<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Jon&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
  
  
    <link rel="alternate" href="/atom.xml" title="Jon's Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="/localshare/css/share.css">

  
  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Jon&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Cease to struggle and you cease to live. - Thomas Carlyle</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/."><i class="fa fa-home"></i> Home</a>
        
          <a class="main-nav-link" href="/archives/"><i class="fa fa-archive"></i> Archive</a>
        
          <a class="main-nav-link" href="/about/"><i class="fa fa-user"></i> About</a>
        
          <a class="main-nav-link" href="/atom.xml"><i class="fa fa-rss"></i> RSS</a>
        
      </nav>
    </div>
    <div id="search-form">
      <div id="result-mask" class="hide"></div>
      <label><input id="search-key" type="text" autocomplete="off" placeholder="search"></label>
      <div id="result-wrap" class="hide">
        <div id="search-result"></div>
      </div>
      <div class="hide">
        <template id="search-tpl">
          <div class="item">
            <a href="/{path}" title="{title}">
              <div class="title">{title}</div>
              <div class="time">{date}</div>
              <div class="tags">{tags}</div>
            </a>
          </div>
        </template>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  <article id="post-Android_interview organize" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/09/04/Android_interview%20organize/">Android_itnerview_organize</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2023-09-04T07:54:57.000Z" itemprop="datePublished">2023年09月04日</time>
</span>
      
      
      
<a href="/2023/09/04/Android_interview%20organize/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>项目的难点，解决</p>
<p>项目中遇到的难题 使用了什么技术来解决</p>
<p>项目中遇到什么困难，应用场景</p>
<ol>
<li>MVP MVVM,现在组件演进成MVVM，最主要的原因是什么。</li>
<li>讲下viewmodel,livedata</li>
<li>ViewModel为什么不会丢失</li>
<li>Livedata版本管理，这块有没有了解.(也就是粘性事件)</li>
<li>kotlin协程有没有了解过。（协程是kotlin     语言对线程的封装）</li>
<li>讲下java匿名内部类,</li>
<li>我说 ，匿名内部类会创建类的对象，lambda不会创建对象，（面试官讲:lambda会怎么样）</li>
<li>Kotlin     内部类的实现方式。</li>
<li>kotlin拓展函数是如何做到的。</li>
<li>为什么https要这么麻烦呢。</li>
<li>Https 服务端公钥客户端认可，如何做到的</li>
<li>中间人怎么攻击怎么做。</li>
<li>反射的原理，为什么能获取方法。</li>
<li>讲下阻塞队列，怎么实现。</li>
<li>对flutter怎么看.</li>
<li>阻塞队列原理</li>
</ol>
<ol>
<li>组件化用过没，组件化用什么通信，arouter底层源码</li>
</ol>
<p>Arouter讲的不清楚</p>
<ol>
<li><p>Android用了哪些第三方库</p>
</li>
<li><p>Retrofit底层实现，在okhttp的基础下做了哪些封装</p>
</li>
<li><p>Okhttp     Resonse之后怎么交给Rxjava处理</p>
</li>
<li><p>自定义view绘制流程</p>
</li>
<li><ol>
<li>构造方法 -      onsizechange - onmeasre - ondraw</li>
<li>说下Onmeasrstate      三个常量 atmost作用</li>
</ol>
</li>
<li><p>为什么onMeasrue     onlayout 绘制的过程执行多遍，ondraw不会</p>
</li>
<li><ol>
<li>自定义view宽高写死，不管什么地方宽高一样的，xml使用</li>
</ol>
</li>
<li><p>Glide使用什么缓存机制</p>
</li>
<li><p>LRUcache底层实现</p>
</li>
<li><p>讲下事件分发机制</p>
</li>
<li><p>事件分发都没拦截，最终被谁消费</p>
</li>
<li><p>hashmap hashtable区别</p>
</li>
<li><p>Hashmap扩容机制 负载因子</p>
</li>
<li><p>Activity启动过程</p>
</li>
<li><p>Aws作用</p>
</li>
<li><p>属性动画和其他动画的区别</p>
</li>
<li><p>为什么不用系统进程通信用Binder</p>
</li>
<li><p>内存泄漏方式</p>
</li>
</ol>
<ol>
<li>kotlin特点有什么不习惯的地方 ， 我说了并发</li>
<li>flutter包为什么那么大</li>
<li>fultter有什么特点</li>
<li>数字签名？</li>
<li>谁通知zygote进程，fork新进程。</li>
<li>点击桌面图标，应用启动流程</li>
<li>屏幕上有个button,为什么button能消费事件</li>
<li>https流程，     签名是什么,怎么知道服务端是谁。</li>
<li>客户端输入一个地址到服务端，中间经历了哪些流程。</li>
<li>路由器是怎么找服务器的。</li>
<li>TCP对包处理做了什么。</li>
</ol>
<ol>
<li>客户投诉，反馈的问题是怎么解决，发版本。</li>
<li>Intent机制什么样的</li>
<li>发起一个Binder请求，中间有一个怎么样的流程。</li>
<li>多线程是怎么改造的。</li>
<li>线程池里面的内部调度机制是怎么样的，什么情况下让出，什么时候抓住锁。或者说线程之间的状态是怎么切换的。</li>
<li>加密平时有了解吗</li>
<li>快速排序。</li>
</ol>
<ol>
<li>MVC MVP     MVVM区别</li>
</ol>
<p>mvvm说得不清楚</p>
<ol>
<li>MVP里面p持有activity引用，怎么持有比较好。</li>
<li>MVP Presenter复用，怎么处理比较好。</li>
<li>项目中用到测量模式，语音项目代码结构怎么样。</li>
<li>Okhttp retrofit     Rxjava有没有看过源码。</li>
<li>OkHttp拦截器有没有用过，拦截器怎么实现整体的拦截的。</li>
<li>讲下Retrofit</li>
<li>动态代理类具体的方法实现。自己在项目里面有没有用过动态代理。</li>
<li>动态代理用到哪些场景。</li>
<li>Retrofit里面用Rxjava返回一个Observable，这个是怎么实现的。</li>
<li>Retrofit还有convert，这个convert和CallAdabter的区别。</li>
<li>有没有自定义convert没</li>
<li>onMeasure的时候，怎么确定view的大小。</li>
<li>Xml layout_width     layout_height对应代码里面怎么对应。</li>
<li>Https怎么防止中间人攻击。Server的公钥一定要和本地一样的是吧。</li>
<li>性能优化你做过哪些方面的。</li>
<li>内存泄漏是怎么发生的。</li>
<li>内存抖动是用什么工具进行检测的。<strong>内存抖动很频繁的话，有没有针对性的做一些优化</strong><strong>.(<strong><strong>这个最好实践下</strong></strong>)</strong></li>
<li>Android还有一个常见的性能问题，ANR你能说一下吗。</li>
<li>线上的ANR有没有排查的经验。怎么处理的。</li>
<li>kotlin在项目中有没有使用过。Kotlin相比java有哪些优势。</li>
<li>Kotlin ? !!都可以让编译通过，实际上有区别吗。it对象是怎么来的</li>
<li>Findviewbyid     kotlin是怎么实现的。findviewbyid通过Map 缓存,在项目里面有使用过缓存吗。</li>
<li>Reprice三个单元测试步骤.</li>
<li>单元测试覆盖率有没有看。</li>
<li>组件化框架，共享数据怎么处理。放公共里面就太多了。用户model需要其他组件使用。这个怎么处理 。</li>
<li>自定义view触摸事件分发，能说一下吗。 </li>
<li>ViewGroup拦截了view的事件，怎么让view不拦截，内部拦截法。</li>
<li>ScrollView     放了 竖的viewpager 怎么处理滑动冲突。</li>
<li>Gradle插件，自动化的任务。</li>
</ol>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>介绍RPC，RPC和其他协议HTTP有什么区别，然后扣项目细节。。。（录像都不敢看，不想写了）</p>
<p>客户端网络安全实现</p>
<p>HTTP1.0、HTTP1.1、HTTP2.0知道吗？他们相比之前的版本有哪些优化？</p>
<p>输入一个URL到网页显示的过程 3 </p>
<p>(输入完了直接弹出一个广告可能是哪个环节出了问题，怎么解决<br>我猜是DNS解析出了问题，不知道怎么解决 面完之后想到清浏览器缓存、加强前端校验之类的)</p>
<p>localhost 与127.0.0.1的区别</p>
<p>HTTP1，HTTP2，HTTP3的协议</p>
<p>get与post区别</p>
<p>HTTPS的加密过程，为什么第一次发送公钥不需要加密<br>HTTP状态码分别代表什么意思</p>
<p>HTTPS是怎么实现的？</p>
<p>HTTPS是怎么保证安全的</p>
<p>https请求流程     3</p>
<p>HTTP3 </p>
<p>http的流程以及和https的区别</p>
<p>HTTP支持长链接吗？什么时候开始支持的？</p>
<p>HTTPS的组成是什么？</p>
<p>http状态码</p>
<p>https请求到响应的过程（加密过程）</p>
<p>怎么加速http连接</p>
<p>http基于tcp还是udp</p>
<p>http协议有哪些跟缓存相关的属性？</p>
<p>http可以用UDP吗</p>
<p>OSI七层模型介绍一下？应用层有什么协议？</p>
<p>OSI七层网络模型</p>
<p>网络传输层的协议</p>
<p>传输层的主要协议有哪些</p>
<p>微信视频是用了tcp还是udp</p>
<p>UDP和TCP的区别，UDP的使用例子，TCP怎么保证连接可靠</p>
<p>TCP三次握手四次挥手，如果中间信息丢失了怎么办，设置超时时间那这个时间具体应该设置多少</p>
<p>OSI七层有哪些  TCP UDP在哪些层  交换器路由器在哪些层</p>
<p>TCP拥塞控制</p>
<p>四次挥手详解</p>
<p>TCP怎么保证可靠传输</p>
<p>DNS解析过程</p>
<p>TCP报文里的字段 </p>
<p>TCP报头</p>
<p>UDP STL  和TCP区别 2</p>
<p>TCP与UDP区别，优缺点</p>
<p>TCP传输中header里的字段</p>
<p>TCP三次握手，如何保证安全传输的</p>
<p>TCP三次握手，TCP三次握手的步骤？两次握手为什么不行？ 3</p>
<p>tcp滑动窗口，TCP三次握手  2</p>
<p>TCP拥塞控制</p>
<p>DNS协议 2</p>
<p>5层结构以及相应的作用</p>
<p>长连接什么时候会释放？</p>
<p>服务端通过timeout还是探测决定是否关闭长连接？</p>
<p>TCP有没有这种关闭连接的方式？</p>
<p>对称加密和非对称加密有哪些算法  什么区别</p>
<h1 id="ANDROID"><a href="#ANDROID" class="headerlink" title="ANDROID"></a>ANDROID</h1><p>handler的作用</p>
<p>深入问handler（比如messagequeue为空时候，looper在做什么）</p>
<p>handle和Activity在链表中的顺序是怎么样的？</p>
<p>Handler为什么会发生内存泄漏</p>
<p>looper阻塞为什么不会造成ANR</p>
<p>looper死循环会不会卡死？为什么？</p>
<p>handler详解，是否会内存泄漏，泄露的原理</p>
<p>handler处理流程，looper和handler是一对一还是一对多，为什么主线程loop不会ANR？</p>
<p>广播的两种启动方式</p>
<p>安卓中的消息机制是什么样的 </p>
<p>消息机制中，如何更新UI </p>
<p>安卓有哪几种页面通讯的方式</p>
<p>自定义view的基本流程 3</p>
<p>提到了滑动冲突怎么解决的</p>
<p>Android事件传递流程和OnTouchListener的关系</p>
<p>touch事件的传递机制</p>
<p>安卓的view事件分发机制 3</p>
<p>介绍一下view渲染流程</p>
<p>Android View绘制流程，当一个TextView的实例调用setText()方法后执行了什么</p>
<p>view绘制流程 2</p>
<p>view怎么确认位置与大小，测量模式</p>
<p>常用的viewgroup，与view区别，在事件处理过程中有什么区别</p>
<p>安卓点击事件的处理</p>
<p>lifecycle介绍</p>
<p>jetpack全家桶用过哪些</p>
<p>livedata有什么能力</p>
<p>双指缩放拖动大图</p>
<p>Android屏幕渲染机制</p>
<p>RecyclerView绘制步骤和复用机制</p>
<p>Recyclerview的复用机制</p>
<p>recyclerview的缓存机制（知道但不懂，我说做项目用list view出现了重复刷显示的问题，所以换了recyclerview解决</p>
<p>retrofit的具体实现，其中接口的作用，注解的作用</p>
<p>怎么在子线程中更新UI？</p>
<p>安卓存储方式</p>
<p>contentprovider介绍，能实现耗时操作吗</p>
<p>service介绍，生命周期与 contentprovider区别</p>
<p>介绍对安卓中intent的理解</p>
<p>service与activity通信</p>
<p>Kotlin有没有static 关键字？那创建静态函数怎么办</p>
<p>协程Flow有哪些应用场景？</p>
<p>内存泄漏的情况有哪些，讲一种检测方法</p>
<p>gradle打包流程</p>
<p>Android签名流程</p>
<p>对AMS的了解</p>
<p>content provider的作用。</p>
<p>sqlite的底层原理(不了解)</p>
<p>索引的原理及实现。</p>
<p>如何定位ANR和崩溃问题的原因。</p>
<p>compose和view写法的优缺点</p>
<p>使用recycleview碰到的问题</p>
<p>compose实现音乐播放栏固定</p>
<p>activity a -&gt; b 的生命周期 （哪个阶段界面不可见）</p>
<p>fragment的构造函数初始化，navigate的跳转。两种方式理解</p>
<p>可以异步加载fragment吗，答案：可以。</p>
<p>serialVersionUID是否了解</p>
<p>handlerMessage什么时候会发生内存泄漏（要怎么预防）</p>
<p>图片有哪些格式，他们的区别</p>
<p>Fragment的replace,hide,add,show的区别</p>
<p>Retrofit中的Call对象如何转换成okhttp的call对象(这个题目是埋坑的)</p>
<p>Retrofit设计模式</p>
<p>加载so有几种方法</p>
<p>Handler工作机制<br>Looper如何识别Handler</p>
<h1 id="LIBRARY"><a href="#LIBRARY" class="headerlink" title="LIBRARY"></a>LIBRARY</h1><p>OkHttp的原理</p>
<p>okhttp的请求机制</p>
<p>okhttp如何处理网络缓存的</p>
<p>okhttp拦截器</p>
<p>okhttp责任链设计模式</p>
<p>okhttp发送请求的拦截方式<br>okhttp的拦截器设计模式</p>
<p>retrofit怎么实现多线程 2</p>
<p>Retrofit的调用过程（我给你点提示，你自己思考一下）</p>
<p>viewmodel的实现原理 2</p>
<p>viewmodel怎么更新数据的</p>
<p>viewmodel实现原理</p>
<p>LeakCanary的使用和实现原理</p>
<p>安卓图片缓存，加载</p>
<p>协程实现原理</p>
<p>Glide的缓存机制 2</p>
<p>安卓glide中与生命周期的关系</p>
<p>glide的缓存加载机制</p>
<p>glide和OkHttp的任务调度是怎么实现的（比如同时发起很多请求）</p>
<p>okhttp、picasso等底层原理如缓存机制等（一个也没答上来，literally</p>
<h1 id="ACTIVITY"><a href="#ACTIVITY" class="headerlink" title="ACTIVITY"></a>ACTIVITY</h1><p>Activity遵循什么设计模式</p>
<p>Activity启动模式，allowReparent的特点和栈亲和性</p>
<p>从点击应用图标到进入应用，Android系统都做了哪些工作，期间涉及到的进程切换有哪些？</p>
<p>写个单例模式 -Activity启动模式</p>
<p> Activity的启动流程,从Launcher到AMS——从AMS到ApplicationThread——从ApplicationThread到Activity</p>
<p>activity生命周期</p>
<p>onStart与onResume解释</p>
<p>activity四大启动模式</p>
<p>说下 Activity 的四种启动模式、应用场景 ？</p>
<p>——standard标准模式；singleTop 栈顶复用模式；singleTask 栈内复用模式；singleInstance 单实例模式</p>
<p>横竖屏切换的 Activity 生命周期变化？</p>
<p>fragment的生命周期</p>
<p>viewmodel设计模式，mvc,mvp,mvvm介绍</p>
<p>广播里怎么执行耗时操作</p>
<p>阻塞多久会出现ANR</p>
<p>Android intent如何传递数据<br>Android广播<br>谈谈Android性能优化</p>
<p>Activity的生命周期，从Activity A启动Activity B生命周期的变化</p>
<p>Activity生命周期，横竖屏切换的 Activity 生命周期变化？</p>
<p>SharedPreference 跨进程使用会怎么样？如何保证跨进程 使用安全？</p>
<p>activity，fragment 传值问题</p>
<p>activity 与 fragment 区别</p>
<p>Fragment 中 add 与 replace 的区别？</p>
<p>FragmentManager的Add和Replace区别</p>
<p>Activity因为内存不足销毁了如何恢复数据</p>
<p>点击锁屏后Activity会执行onPause和onStop吗</p>
<p>Activity的onDestory回调时机</p>
<p>Activity调用finish后是否立即onDestory</p>
<p>Activity调用finish后是否立即onDestory<br>Activity A 启动 Activity B,Activity A 的onDestory和Activity B 的onCreate执行顺序<br>Activity A 启动 Activity B,然后调用finish,Activity A 的onDestory和Activity B 的onCreate执行顺序<br>Activity的singleTop和singleTask的区别</p>
<p>binder原理</p>
<h1 id="KOTLIN"><a href="#KOTLIN" class="headerlink" title="KOTLIN"></a>KOTLIN</h1><p>kotlin的let，apply，also有什么区别。<br>kotlin的inline，nonline关键字有什么作用。</p>
<p>异步调用有几种方式，从简单到复杂。</p>
<p>逆变与协变。</p>
<p>作用域函数（应用场景）</p>
<p>高阶函数（概念）</p>
<p>kotlin和java一块编译碰到啥问题</p>
<p>::funName 双冒号的写法的理解</p>
<p>泛型 out in 与Java泛型中的联系和区别</p>
<p>知道哪些高阶函数</p>
<p>协程的理解<br>协程相对于线程的区别</p>
<p>Kotlin 闭包<br>Kotlin 静态方法</p>
<p>链表逆序<br>Handler的postDelay原理<br>P2P网络</p>
<h1 id="THREAD"><a href="#THREAD" class="headerlink" title="THREAD"></a>THREAD</h1><p>进程、线程、协程的联系与区别 2</p>
<p>Java创建线程的方式</p>
<p>线程并发会遇到哪些问题，怎么解决</p>
<p>线程的 wait 和 block 有什么区别？和 sleep 有什么区别？</p>
<p>sychronized和lock的区别</p>
<p>volatile详解、synchronized详解，两者区别</p>
<p>Java线程间通信， volatile详解、synchronized详解</p>
<p>线程的状态</p>
<p>线程池详解</p>
<p>线程池怎么做到线程复用</p>
<p>安卓中挂起函数怎么实现的</p>
<p>安卓中实现多线程的方法</p>
<p>线程池设计模式，怎么自己设计一个线程池</p>
<p>安卓里解决多线程冲突的方法</p>
<p>Android线程池设计原理</p>
<p>进程线程区别</p>
<p>进程通信方式有哪些<br>线程通信方式有哪些</p>
<p>安卓的线程通信</p>
<p>JAVAGC如何判断是否回收以及僵尸线程</p>
<p>双线程通过线程同步的方式打印12121212…….</p>
<p>为什么安卓用BINDER 有啥优点</p>
<p>安卓中进程间通信方式</p>
<p>线程安全的单例模式（双重检测），为什么要两次判断，volatile作用</p>
<p>多线程如何解决线程冲突？</p>
<p>Java加锁方式</p>
<p>死锁的必要条件 2</p>
<p>死锁怎么造成的</p>
<p>多线程会遇到什么问题</p>
<p>死锁的条件，手写一个死锁代码并运行出来</p>
<p>怎么避免死锁问题</p>
<p>可重入锁</p>
<p>对象、锁、对象监视器相互之间的关系？</p>
<p>乐观锁如何实现？缺点有哪些？</p>
<p>volatile 和 synchronized 有什么区别？</p>
<p>synchronized 和 lock 有什么区别？</p>
<p>synchronized 底层是如何实现加锁操作的？</p>
<p>ThreadLocal 是如何存储的？</p>
<p>ThreadLocal了解么，他有什么问题    </p>
<p>ThreadLocalMap中遇到冲突是如何处理的？</p>
<p>threadlocal，动态代理，这俩我说没用过不了解</p>
<p>synchronized 底层是如何实现的？</p>
<p>ReentrantLock 如何实现公平锁与非公平锁？</p>
<p>公平锁与非公平锁的释放有什么区别？</p>
<p>消费者与生产者模型</p>
<p>实现多线程的几种方式</p>
<p>乐观锁和悲观锁</p>
<p> wait 和 sleep 的区别</p>
<p> Android 线程间通信有哪几种方式</p>
<p>——1. 共享内存（变量）；2.文件，数据库；3.Handler；4.Java 里的 wait()，notify()，notifyAll()</p>
<p> synchronized 原理 锁的升级 </p>
<p> JVM内存模型 </p>
<p>生产者消费者模型，应用（线程池）</p>
<p>用过线程池吗，线程池如何实现</p>
<p>如何全局管理异步任务(不知道)</p>
<p>多线程下如何保证类的线程安全？</p>
<p>CopyOnWriteArrayList底层实现？如何实现线程安全？</p>
<p>线程池核心线程数数量的设计考虑因素</p>
<h1 id="MAP"><a href="#MAP" class="headerlink" title="MAP"></a>MAP</h1><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>HashMap的实现机制，怎么样HashMap线程安全</p>
<p>1.HashMap原理<br> 创建HashMap要放入1000个不同hashCode的键值对,初始最大值多少<br>HashMap如果Hash冲突了怎么解决？ 2</p>
<p>HashMap的扩容机制是什么样的？</p>
<p>concurrenthashmap详解</p>
<p>hashtable,hashmap与 concurrenthashmap详解</p>
<p>ConcurrentHashMap 是如何实现线程安全的？如果让你设计锁的数量你会怎么设计来提高效率？</p>
<p>HashMap的扩容机制，它线程安全吗？</p>
<p>哈希冲突解决方法，</p>
<p>hashmap插入数据的流程？</p>
<p>如何计算hashmap数据插入的位置？</p>
<p>如何解决哈希冲突？</p>
<p>有一千个键值对的数据，如何设计HashMap的初始容量大小？HashMap的实现原理 2</p>
<p>和HashTable区别，线程不安全的原因</p>
<p>哈希表解决冲突的方法</p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>线程安全的队列有哪些</p>
<p>ArrayList的扩容机制？</p>
<p>底层实现？深拷贝还是浅拷贝？</p>
<p>ArrayList的remove方法原理</p>
<p>ArrayList和LinkedList区别 2</p>
<p>面试官给了一段代码，问运行结果：代码是new了个空arraylist（string，integer）问这时候int i=arraylist.get（“key”）然后print会输出啥</p>
<p>如果是Integer i呢，会是啥（好家伙两个全答错）</p>
<h1 id="DESIGN-MODEL"><a href="#DESIGN-MODEL" class="headerlink" title="DESIGN MODEL"></a>DESIGN MODEL</h1><p>mvp是什么？2</p>
<p>MVVM与mvc、mvp架构的区别与联系</p>
<p>MVVM、MVC、MVP的区别与联系，各自优缺点</p>
<p>mvvm用到的设计模式</p>
<p>介绍一下中介者模式吧</p>
<p>问设计模式，要求挑一个深入分析，问你对这些模式的理解</p>
<p>除了中介者模式你还了解哪些设计模式</p>
<p>面向对象的原则有哪些</p>
<p>AOP了解吗</p>
<p>说说你对设计模式的理解，开发过程中主要用到了哪些设计模式？</p>
<p>介绍一下你在开发过程中使用到的设计模式</p>
<p>你都用过哪些设计模式？</p>
<p>Android中的ClassLoader</p>
<p>面向切面编程你知道么，和面向对象的区别和细节    </p>
<p>设计模式作用 </p>
<p>动态代理与静态代理 </p>

        
        
          <blockquote id="copyright">
              <p>Original link: <a href="https://noteforme.github.io/index.html">https://noteforme.github.io/index.html</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-Android-itnerview-algorithm" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/09/03/Android-itnerview-algorithm/">Android_itnerview_algorithm</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2023-09-03T07:54:57.000Z" itemprop="datePublished">2023年09月03日</time>
</span>
      
      
      
<a href="/2023/09/03/Android-itnerview-algorithm/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><p>用过哪些数据结构</p>
<p>常用数据结构</p>
<p>有哪些数据结构   增删改查的复杂度多少</p>
<p>计算二叉树的高度（递归与非递归两种方式）</p>
<p>快排写一下，动态规划了解吗？</p>
<p>冒泡排序的链表实现</p>
<p>写个快排</p>
<p>都用过那些常用的数据结构，说说对树的了解？</p>
<p> 堆排</p>
<p>算法题  判断二叉树深度. 2</p>
<p>算法的五大基本要素有哪些？为什么算法效率不是基本要素</p>
<p>银行家算法</p>
<p>堆排序原理</p>
<p>b树、b+树、红黑树</p>
<p>红黑树怎么增加、删除节点</p>
<p>算法题：随机生成不重复的100个数0-99</p>
<p>写一个泛型方法，实现删除数组中的元素功能</p>
<p>返回二叉树的第k大数</p>
<p>返回第k大的数，先说下你能想到的方法，再选一个最优方法。</p>
<p>二分法查找目标数</p>
<p>使用一个固定长度数组实现队列，包括添加和取数据的功能</p>
<p>时间复杂度、空间复杂度，如何优化</p>
<p>链表如何优化，可以降低查询的时间复杂度？</p>
<p>手撕：手写一个单例模式</p>
<p>手撕：二叉搜索树第 k 小的节点</p>
<p>算法：合并区间</p>
<p>算法：排序数组</p>
<p>算法：序列化和反序列化二叉搜索树</p>
<p>equals和hashCode方法</p>
<p>手撕快速排序</p>
<p>讲一个红黑树和一个排序算法的时间复杂度问题的分析思路</p>
<p>二叉查找树的概念</p>
<p>树退化成链表如何解决？</p>
<p>B树以及B树可以解决什么问题？</p>
<p>图的遍历以及具体代码如何实现？（迭代）</p>
<p>时间复杂度和空间复杂度的概念</p>
<p>常见的排序算法以及时间复杂度</p>
<p>链表的反转怎么实现？</p>
<p>讲一下排序算法的思路</p>
<p>最后是华为经典题，一个桶5L，另一个桶7L，如何得到6L？（答出来了）面试官立马追问，有没有一种数学理论可以给这个问题提供支持来证明，1L，2L，3L，4L，6L是不是都可以得到还是只能得到其中的某几种？（到这里，我是真的麻了，考这种题真的无从准备，面试官是啥问题都能深挖深挖再深挖）（最后一题有知道的同学可以评论区留言</p>
<p>快排的思想    </p>
<p>快排解决topk问题（我哭死啊，我没有想到当前的会使用快排来进行解决topk，我之前都是使用堆排序）    </p>
<p>快排和堆排来进行解决topk问题    </p>
<p>反转链表 </p>
<p>合并两个排序的链表 </p>
<p>算法题：给你一个数组，和一个数字m，问这个数组中存不存在一个子序列（不一定连续），使得它的和为m，输出true或false</p>
<p>两个算法（判断链表是否有环、链表重排/链表折叠）</p>
<p>反转字符串</p>
<p>上楼梯动态规划，如果第M阶梯是不能踩的</p>
<p> 倒水问题，3l和5l桶子要4l水怎么搞<br> 算法思路，链表右移动k位和数组右移动k位怎么搞<br> 左右括号匹配，最少情况要加多少次括号，写在纸上拍照</p>
<p>树、图的存储结构</p>
<p>给出二叉树的前序中序，输出后序</p>
<p>先来了一道算法题:找出最左边的次数最多的字母。</p>
<p>算法题：删除排序链表中的重复元素（力扣82）</p>
<p>快排和反转链表</p>
<p>判断一个树是不是平衡二叉树，</p>
<p>旋转链表 LC61:<br>题意是这样子的：给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。<br>输入：head=[1,2,3] k = 1<br>输出：[3,1,2]</p>
<p>22.算法题：二分法查找目标数</p>
<h1 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h1><p>多实现接口，如果接口里面有入参出参一样的同名方法，会实现几个</p>
<p>说一下final，static</p>
<p>. final的arraylist，往里面add东西会咋样</p>
<p>static方法能调用非静态吗，非静态能调用static吗</p>
<p>面向对象三大特性，多态怎么实现</p>
<p>静态方法与变量是否可以继承，原因</p>
<p>Java内存模块分区和GC机制，</p>
<p>GC算法有哪些</p>
<p>Finalize机制</p>
<p>强引用 弱引用 软引用 虚引用的区别和使用场景</p>
<p>ClassLoader的双亲委托机制 2</p>
<p>.Java代理是否用过，怎么实现</p>
<p>类加载的过程</p>
<p>类加载器，双亲委派模型</p>
<p>对象生命周期</p>
<p>判断对象是否可以回收的方法</p>
<p>有哪些GC roots</p>
<p>Java引用类型</p>
<p>抽象类与接口区别，各自优缺点</p>
<p>Java泛型，泛型擦除机制</p>
<p>匿名内部类，原理是什么</p>
<p>Java引用类型，弱引用的作用，引用队列。</p>
<p>Java内存回收</p>
<p>GC roots</p>
<p><strong>垃圾标记方法(拓展了很多)</strong>   </p>
<p>Java入口函数</p>
<p>Java异常介绍，是否所有异常都需要捕获</p>
<p>类编译过程</p>
<p>JVM 中创建一个对象的过程是什么样的？</p>
<p>JVM 如何判断一个对象需要被回收?</p>
<p>如果电脑内存是4G，已经使用了3G，现在启动一个程序需要超过1G的内存，会发生什么？(内存回收)</p>
<p>类加载过程是什么样的？</p>
<p>双亲委派模型有什么作用？</p>
<p>==和equals的区别</p>
<p>重载和重写的区别</p>
<p>值传递和引用传递</p>
<p>static、final作用</p>
<p>所有类的父类</p>
<p>this()和super()</p>
<p>int和Integer的区别</p>
<p>线程池和线程</p>
<p>锁了解哪些（说了分布式锁，又问我分布式锁是什么）</p>
<p>Java反射原理<br>Java面向对象的理解，封装，继承，多态</p>
<p>Java四次引用</p>
<p>垃圾回收机制</p>
<p>线程安全的集合有哪些（问得比较细）</p>
<p>进程间通信的方式</p>
<p>HashMap的底层实现</p>
<p>View的绘制过程</p>
<p>String、StringBuffer、StringBuidler的区别</p>
<p>注解的类型有哪些？</p>
<p>JVM的内存模型</p>
<p>什么是多态，怎么去实现呢</p>
<p>接口和抽象类的区别，它们各自的使用场景呢</p>
<p>java四种引用<br>JVM内存区域</p>
<p> OOM能捕获吗 </p>
<p>  运行时异常与编译时异常 </p>
<p>了解网络字节序吗</p>
<p>双亲委派(写一个路径名字一样的String，new String（）会创建自己写的还是系统的)</p>
<p>受检异常和非受检异常</p>
<p>抽象类和接口的区别</p>
<p>java里弱引用和强引用分别用在什么场景</p>
<p>深拷贝、浅拷贝</p>
<h1 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h1><p>进程线程在操作系统中的实现</p>
<p>内核态与用户态</p>
<p>linux内存管理机制</p>
<p>虚拟内存与物理内存</p>
<p>进程间能共享内存吗</p>
<p>虚拟内存</p>
<p>跨进程通信的几种方式</p>
<p>线程与进程的使用场景 </p>
<p> 线程安全与不安全的例子 </p>
<p>B站的虚拟人物么，你觉得当前的技术方面是怎么来进行实现的 </p>

        
        
          <blockquote id="copyright">
              <p>Original link: <a href="https://noteforme.github.io/index.html">https://noteforme.github.io/index.html</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/inter/" rel="tag">inter</a></li></ul>

          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-compose-layout" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/20/compose-layout/">compose_layout</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2023-08-20T13:41:06.000Z" itemprop="datePublished">2023年08月20日</time>
</span>
      
      
      
<a href="/2023/08/20/compose-layout/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Scaffold"><a href="#Scaffold" class="headerlink" title="Scaffold"></a>Scaffold</h2>
        
        
          <blockquote id="copyright">
              <p>Original link: <a href="https://noteforme.github.io/index.html">https://noteforme.github.io/index.html</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/compose/" rel="tag">compose</a></li></ul>

          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-compose" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/19/compose/">compose</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2023-08-19T09:16:56.000Z" itemprop="datePublished">2023年08月19日</time>
</span>
      
      
      
<a href="/2023/08/19/compose/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://github.com/android/codelab-android-compose">https://github.com/android/codelab-android-compose</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.android.com/codelabs/jetpack-compose-basics#13">https://developer.android.com/codelabs/jetpack-compose-basics#13</a></p>

        
        
          <blockquote id="copyright">
              <p>Original link: <a href="https://noteforme.github.io/index.html">https://noteforme.github.io/index.html</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/compose/" rel="tag">compose</a></li></ul>

          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-LC-DP-BAG" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/09/LC-DP-BAG/">LC_DP_BAG</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2023-08-09T14:42:49.000Z" itemprop="datePublished">2023年08月09日</time>
</span>
      
      
      
<a href="/2023/08/09/LC-DP-BAG/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>01背包问题，这个视频讲的很好 </p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1pY4y1J7na">https://www.bilibili.com/video/BV1pY4y1J7na</a></p>

        
        
          <blockquote id="copyright">
              <p>Original link: <a href="https://noteforme.github.io/index.html">https://noteforme.github.io/index.html</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-LC-DP" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/02/LC-DP/">LC-DP</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2023-04-02T09:32:31.000Z" itemprop="datePublished">2023年04月02日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/DataStructure/">DataStructure</a>
  </div>

      
      
<a href="/2023/04/02/LC-DP/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Labuladong</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1XV411Y7oE">https://www.bilibili.com/video/BV1XV411Y7oE</a></p>
<ol>
<li>重叠子问题</li>
<li>状态转移方程 (最关键)</li>
<li>最优子结构</li>
</ol>
<ol>
<li>明确状态</li>
<li>明确 选择</li>
<li>明确dp函数/数组的定义</li>
<li>明确base case</li>
</ol>
<p>随想录</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13Q4y197Wg">https://www.bilibili.com/video/BV13Q4y197Wg</a></p>
<h4 id="动规5部曲"><a href="#动规5部曲" class="headerlink" title="动规5部曲"></a>动规5部曲</h4><p><strong>对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 确定dp数组（dp table）以及下标的含义</span><br><span class="line">2. 确定递推公式</span><br><span class="line">3. dp数组如何初始化</span><br><span class="line">4. 确定遍历顺序</span><br><span class="line">5. 举例推导dp数组</span><br></pre></td></tr></table></figure>





<p>动态规划解法代码框架</p>
<p><img src="/2023/04/02/LC-DP/20230701162055.jpg" alt="20230701162055"></p>
<h4 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fibonacci-number/">509. 斐波那契数</a></h4><h5 id="随想录-迭代递推"><a href="#随想录-迭代递推" class="headerlink" title="随想录 迭代递推"></a>随想录 迭代递推</h5><p>自底向上</p>
<p>通过for循环递推出 dp[n]的值，一开始解的时候写成了  dp[n] = dp[n - 1] + dp[n- 2] </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随想录视频思路解法1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fib1</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line"><span class="comment">//        println(n)</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(n+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line"><span class="comment">//            println(&quot; dp[n - 1]= $&#123; dp[n - 1]&#125;  dp[n - 2]= $&#123;dp[n - 2]&#125;&quot;)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h5 id="随想录-视频思路解法2"><a href="#随想录-视频思路解法2" class="headerlink" title="随想录  视频思路解法2"></a>随想录  视频思路解法2</h5><p>这种解法，dp数组空间复杂度减少了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 随想录视频思路解法2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fib</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">val</span> dp = IntArray(<span class="number">2</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">        sum = dp[<span class="number">0</span>] + dp[<span class="number">1</span>]</span><br><span class="line">        println(<span class="string">&quot;sum <span class="variable">$sum</span>  dp[0]= <span class="subst">$&#123;dp[<span class="number">0</span>]&#125;</span> , dp[1]= <span class="subst">$&#123;dp[<span class="number">1</span>]&#125;</span>&quot;</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>]</span><br><span class="line">        dp[<span class="number">1</span>] = sum</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="labuladong"><a href="#labuladong" class="headerlink" title="labuladong"></a>labuladong</h5><p>把所有计算的值先保存起来，后面需要的话先直接返回，避免重复计算.</p>
<p>为什么申请 n+1 数组大小</p>
<p>因为索引从0开始 ，后面要取memory[n]，所有就申请 n+1 大小.</p>
<p>自顶向下</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fib</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> memory = IntArray(n + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> (memory[n] != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> memory[n]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    memory[n] = fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> memory[n]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fib</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>还有一种lablado解法一开始没想出来,双指针应该怎么操作</p>
<p>这个思路和随想录的思路2是一样的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fib</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> pre1 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> pre2 = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">        sum = pre1 + pre2  <span class="comment">// 得到当前n的num</span></span><br><span class="line">        pre1 = pre2     <span class="comment">//移动指针</span></span><br><span class="line">        pre2 = sum</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70 爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">70 爬楼梯</a></h4><p>根据阶梯</p>
<p>0阶                                 1 //  需要返回1，2 = 1 +1,否则2就不正确了,正常理解应该返回0,不过递归解法，需要返回1</p>
<p>1阶                                  1      </p>
<p>2阶    1+1 , 2                   2</p>
<p>3阶  1+1+1, 1+2, 2+1    3</p>
<p>四阶                                 5</p>
<p>根据上面的推导，这个问题也类似于 斐波那契数    ， 看了随想录的视频，这个推导过程还是没看明白</p>
<p>看了这个视频推导明白了</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1G54y1X72H/">https://www.bilibili.com/video/BV1G54y1X72H/</a>        进度条5分钟.</p>
<p>到达 k 只有 两种方式 , k-2过去和k-1过去，所以到k的所有情况就是  (k-2)  + (k-1) ,我们这里讨论的是多少种不同的方法，而不用管k-2,k-1多少步到达k.</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">k</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">k-1</td>
<td align="center"></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center">k-2</td>
<td align="center"></td>
<td align="center"></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h5 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h5><p>超时</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归解法 ， 会超时</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">climbStairs</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span> <span class="comment">// 需要返回1，2 = 1 +1,否则2就不正确了</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">val</span> dp = IntArray(n + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> climbStairs(n - <span class="number">1</span>) + climbStairs(n - <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="迭代解法"><a href="#迭代解法" class="headerlink" title="迭代解法"></a>迭代解法</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">climbStairs1</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">val</span> dp = IntArray(n + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746 使用最小花费爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-cost-climbing-stairs/">746 使用最小花费爬楼梯</a></h4><p>如果要走到dp[i] 的位置， 有两种选择，dp[i-1] + cost[i-1]    ，dp[i-2] + cost[i-2]， cost就是从当前位置跳出消耗的能量值，dp[i-1] 已经包含dp[0]开始的所有 消费值。     </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] &#x3D; min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2]) </span><br></pre></td></tr></table></figure>





<p>可以用这个推导</p>
<p><img src="/2023/04/02/LC-DP/023-07-09-20-24-53.png" alt="023-07-09-20-24-53"></p>
<p>官方题解</p>
<p>这种方式比较好理解</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">minCostClimbingStairs</span><span class="params">(cost: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> dp = IntArray(cost.size + <span class="number">1</span>) <span class="comment">//要走完数组最后一步的下一步</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.cost.size) &#123;</span><br><span class="line">        dp[i] = min(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[cost.size]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他的后面在看吧</p>
<h4 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></h4><p>这题二叉树解法没看懂，给忘了。</p>
<p>递归公式的推导，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">那么很自然，dp[i][j] &#x3D; dp[i - 1][j] + dp[i][j - 1]，因为dp[i][j]只有这两个方向过来。</span><br></pre></td></tr></table></figure>

<ol>
<li>dp数组的初始化</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如何初始化呢，首先dp[i][0]一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，因为只能向右向下走，那么dp[0][j]也同理。</span><br></pre></td></tr></table></figure>

<p>所以初始化代码为：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; m; i++) dp[i][0] = 1;</span><br><span class="line">for (int j = 0; j &lt; n; j++) dp[0][j] = 1;</span><br></pre></td></tr></table></figure>



<p> <img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201209113631392.png" alt="62.不同路径1"></p>
<p>可以根据上图来推导出  <code> dp[i][j]</code></p>
<p>i =1 时  , j 代入进去进行推导。</p>
<p>j = 1 : <code>  dp[i][j] = dp[i-1][j] + dp[i][j-1]</code></p>
<p>j = 2 : <code>  dp[i][j] = dp[i-1][j] + dp[i][j-1]</code></p>
<p>j = 3 : <code>  dp[i][j] = dp[i-1][j] + dp[i][j-1]</code></p>
<p>然后逐步就能推导出所有的值,注意<code>dp[m][n]</code> 要-1,否则会越界。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">uniquePaths</span><span class="params">(m: <span class="type">Int</span>, n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> dp = Array(m) &#123; IntArray(n) &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until m) dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) dp[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths-ii/">63. 不同路径 II</a></h4><p>原理还是一样，从左到右,<code>array[i][0] :  array[0][0],array[1][0],array[2][0] </code>，从上到下 进行推导。</p>
<p>这一题是上一题的拓展版本</p>
<p>通过62题可以看到 m 是竖线，n是横线。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210104114513928.png" alt="63.不同路径II"></p>
<ol>
<li><p><code>[0][0] [m-1][n-1] </code> 那么不可能有有路径往后走了。</p>
</li>
<li><p>有一点不同的是，如果是有障碍，后面就不用初始化了。</p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg" alt="img"></p>
</li>
<li><p>还有一点不同的是，如果要找的位置没有障碍物，才有求出递推值的意义。</p>
</li>
</ol>
<ol start="3">
<li> 递推公式和前面差不多 ，在处理递推公式的时候，看上图，前一步有障碍物的时候，影响的是 <code>dp[i-1]  dp[j-1]</code> 前一步的一个值。</li>
<li>后续递推的时候，碰到obstacles后，obstacles的点就是0，所以下一个点就是障碍物 0 和另一个点相加。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(obstacleGrid: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> m = obstacleGrid.size <span class="comment">// 表示有多少个数组</span></span><br><span class="line">    <span class="keyword">val</span> n = obstacleGrid[<span class="number">0</span>].size <span class="comment">// 其中一个数组的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> || obstacleGrid[m-<span class="number">1</span>][n-<span class="number">1</span>] == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span> <span class="comment">// if there are obstacle in these two points, will no path.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> dp = Array(m) &#123; IntArray(n) &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until m) &#123; <span class="comment">// 里面再加个条件不好加</span></span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>) <span class="keyword">break</span>      <span class="comment">// when init dats, hit path , following init will 0</span></span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// 前面[i][0] i表述多少个数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>) <span class="keyword">break</span></span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">1</span> <span class="comment">// [0][j] 后面表述一个数组的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][j] != <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343. 整数拆分"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/integer-break/">343. 整数拆分</a></h4><p>我们按照动规 5 部曲来分析先</p>
<ol>
<li><p>确定dp数组（dp table）以及下标的含义</p>
<p>拆分i，最大乘积是dp[i]  </p>
</li>
<li><p>确定递推公式</p>
<p>这一步是比较难的， 对 i 进行拆分，看了随想录的视频，有3种可能</p>
<p>第一种:  拆成2个数的情况  i * j  也就是  dp[i] = i * (i-j)</p>
<p>第二种：拆成2个数以上的情况 : dp[i] = i * dp[i-j]</p>
<p> 这种可以用6来测试拆分</p>
<p>1 * 5</p>
<p>2 * 4</p>
<p>3 * 3</p>
<p>4 * 2</p>
<p>5 * 1</p>
<p>上面我们可以只拆分j,  我们有必要拆分i吗，其实是没必要的， 我的理解是2 * 4 中， 2已经被 1 * 5 中的5包含了，</p>
<p>那么5 拆成<code> 2 *1 * 1 * 1</code> 就包括了 2的情况，不知道我的理解对不对。</p>
<p>第三种 : 就是 i本身。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">integerBreak</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>  <span class="comment">// 1+1</span></span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">3.</span>.n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until i) &#123;</span><br><span class="line"><span class="comment">//                println(&quot;i $i    j $j &quot;)</span></span><br><span class="line">                <span class="keyword">val</span> a = j * (i - j)</span><br><span class="line">                <span class="keyword">val</span> b = j * dp[i - j]</span><br><span class="line"><span class="comment">//                maxNum = max(a, b, i)</span></span><br><span class="line">                println(<span class="string">&quot;j * (i - j)  <span class="variable">$j</span> * (<span class="variable">$i</span> - <span class="variable">$j</span>)  a =<span class="variable">$a</span>  dp[i - j] <span class="subst">$&#123;dp[i - j]&#125;</span>  b= <span class="variable">$b</span> &quot;</span>)</span><br><span class="line"><span class="comment">//                maxNum = max(a, b,dp[i])</span></span><br><span class="line"><span class="comment">//                maxNum= max(a,b)</span></span><br><span class="line"><span class="comment">//                val abMax = max(a, b)</span></span><br><span class="line"><span class="comment">//                println(&quot;abMax $abMax dp[$i] $&#123;dp[i]&#125; &quot;)</span></span><br><span class="line">                dp[i] = max(a, b, dp[i]) <span class="comment">// dp[i] 初始值是0，所以得出的值还是从a,b中拿到最大值</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            println(&quot;dp[$i]     $&#123;dp[i]&#125;&quot;)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">max</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>, c: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> max = a</span><br><span class="line">    <span class="keyword">if</span> (b &gt; max) &#123;</span><br><span class="line">        max = b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c &gt; max) &#123;</span><br><span class="line">        max = c</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h4><p>​      </p>
<p>   上面是i==3的情况，</p>
<p>   <img src="https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg"></p>
<p>   root node =1的时候， left tree 0 , right tree 2种情况 , 右子树和 root node =2的树的结构是一样的。</p>
<p>   root node =2的时候， left tree 1 , right tree 1种情况,  左，右子树和 root node =1的树的结构是一样的。</p>
<p>   root node =3的时候， left tree 2 , right tree 0种情况. 左子树和 root node =2的树的结构是一样的。</p>
<p>   所以 dp[3] =  (root node ==1 +dp[2]) +  (root node ==2 +dp[1]) +   (root node ==3 +dp[2]) </p>
<p>   dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量</p>
<p>   元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量</p>
<p>   元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量</p>
<p>   元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量</p>
<p>   有2个元素的搜索树数量就是dp[2]。</p>
<p>   有1个元素的搜索树数量就是dp[1]。</p>
<p>   有0个元素的搜索树数量就是dp[0]。</p>
<p>   所以dp[3] = dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]</p>
<p>   <img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210107093226241.png" alt="96.不同的二叉搜索树2"></p>
<p>   这个图更直观</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义目前可以根据下面推导来，确认dp数组的含义。dp[1] =1dp[2]= 2dp[3] =5</li>
<li>确定递推公式这个没推导出来，i j没搞清楚。把随想录的拿过来<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在上面的分析中，其实已经看出其递推关系， dp[i] +&#x3D; dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]</span><br><span class="line"></span><br><span class="line">j相当于是头结点的元素，从1遍历到i为止。</span><br><span class="line"></span><br><span class="line">所以递推公式：dp[i] +&#x3D; dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量</span><br></pre></td></tr></table></figure></li>
<li>dp数组如何初始化</li>
<li>确定遍历顺序</li>
<li>举例推导dp数组</li>
</ol>
   <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">numTrees</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 确定dp数组（dp table）以及下标的含义</span></span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="comment">//3. dp数组如何初始化</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.确定遍历顺序</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2</span> ..n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> ..i) &#123; <span class="comment">// 注意这里边界，一开始都 没加==</span></span><br><span class="line"><span class="comment">//                println(&quot; dp[$i] $&#123;dp[i]&#125; += (dp[j - 1] $&#123;dp[j - 1]&#125;  * dp[i - j]) $&#123;dp[i - j]&#125;  j = $j&quot;)</span></span><br><span class="line">                dp[i] += (dp[j - <span class="number">1</span>] * dp[i - j]) <span class="comment">//2.确定递推公式</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>












        
        
          <blockquote id="copyright">
              <p>Original link: <a href="https://noteforme.github.io/index.html">https://noteforme.github.io/index.html</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LEETCODE/" rel="tag">LEETCODE</a></li></ul>

          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-RecyclerView-padding" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/10/RecyclerView-padding/">RecyclerView-padding</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2023-01-10T07:16:04.000Z" itemprop="datePublished">2023年01月10日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/ANDROID/">ANDROID</a>
  </div>

      
      
<a href="/2023/01/10/RecyclerView-padding/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>修改Display scaling属性后，即使设置字体是dp也会导致，也会出现Text内容的有变化。</p>
<p>计算转账页面的padding,5个TextView平分屏幕宽度，之前nexus5没问题，因为是刚好2倍，我的手机就是有问题，原来是dp转px有损耗。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@get:JvmName</span>(<span class="string">&quot;dp2px&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> <span class="built_in">Float</span>.dp: <span class="built_in">Float</span></span><br><span class="line">    <span class="keyword">get</span>() = convert(<span class="keyword">this</span>, TypedValue.COMPLEX_UNIT_DIP)</span><br><span class="line"></span><br><span class="line"><span class="meta">@get:JvmName</span>(<span class="string">&quot;dp2px&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> <span class="built_in">Int</span>.dp: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">get</span>() = convert(<span class="keyword">this</span>.toFloat(), TypedValue.COMPLEX_UNIT_DIP).toInt()</span><br></pre></td></tr></table></figure>



<p>然后用 2f.dp这样就能避免dp转px的损耗。</p>
<p>其实选择上面这个方法就能解决这个问题。</p>
<p>字体测量方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getTextLength</span><span class="params">(typeface: <span class="type">Typeface</span>, txt: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> paint = Paint()</span><br><span class="line">    paint.typeface = typeface</span><br><span class="line">    paint.textSize = <span class="number">12f</span>.dp.toFloat()</span><br><span class="line">    <span class="keyword">val</span> textWidth = paint.measureText(txt)</span><br><span class="line">    <span class="keyword">return</span> textWidth.toInt()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>文字宽度</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dasusu/p/6602710.html">https://www.cnblogs.com/dasusu/p/6602710.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9fc07c3311c1">https://www.jianshu.com/p/9fc07c3311c1</a></p>
<p><a target="_blank" rel="noopener" href="https://www.laoyuyu.me/2020/08/03/android/text_measure_wh/">https://www.laoyuyu.me/2020/08/03/android/text_measure_wh/</a></p>

        
        
          <blockquote id="copyright">
              <p>Original link: <a href="https://noteforme.github.io/index.html">https://noteforme.github.io/index.html</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RecyclerView/" rel="tag">RecyclerView</a></li></ul>

          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-LC-GREEDY" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/02/LC-GREEDY/">LC-GREEDY</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2023-01-02T14:42:03.000Z" itemprop="datePublished">2023年01月02日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/DataStructure/">DataStructure</a>
  </div>

      
      
<a href="/2023/01/02/LC-GREEDY/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1sA4y1S7Sp">https://www.bilibili.com/video/BV1sA4y1S7Sp</a></p>
<p>这个视频讲到暴力 对数器可以验证答案，有意思。</p>
<p>有同学问了如何验证可不可以用贪心算法呢？</p>
<p><strong>刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心</strong>。</p>
<p>贪心算法一般分为如下四步：</p>
<ul>
<li>将问题分解为若干个子问题</li>
<li>找出适合的贪心策略</li>
<li>求解每一个子问题的最优解</li>
<li>将局部最优解堆叠成全局最优解</li>
</ul>
<p>这个四步其实过于理论化了，我们平时在做贪心类的题目 很难去按照这四步去思考，真是有点“鸡肋”。</p>
<p>做题的时候，只要想清楚 局部最优 是什么，如果推导出全局最优，其实就够了。</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1XY411A766">https://www.bilibili.com/video/BV1XY411A766</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Hz4y117CP/">https://www.bilibili.com/video/BV1Hz4y117CP/</a></p>
<h4 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455.分发饼干"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/assign-cookies/">455.分发饼干</a></h4><h5 id="分解题目"><a href="#分解题目" class="headerlink" title="分解题目"></a>分解题目</h5><ol>
<li>每个孩子最多只能给一块饼干。</li>
<li>每个孩子 <code>i</code>，都有一个胃口值 <code>g[i]</code>，每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code>。</li>
</ol>
<h5 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g &#x3D; [1,3], s &#x3D; [1,2,4]</span><br></pre></td></tr></table></figure>

<ol>
<li><p>对孩子的胃口值和， 饼干的大小进行排序，得到两行数组。</p>
</li>
<li><p>如上面示例，s中的s[0]=1饼干大小，满足g[0]=1 孩子的胃口值,那么同时向右移动.s[1]=2 不满足g[1],s指针向右移动，s[2]满足g[1].</p>
<p>这样所有孩子都满足了。</p>
</li>
</ol>
<p>上面思路和随想录的不一样，随想录的是大饼干喂 胃口值大的孩子，不过觉得我这个更好理解。</p>
<h5 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findContentChildren</span><span class="params">(g: <span class="type">IntArray</span>, s: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.isEmpty()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    Arrays.sort(g)  <span class="comment">// 写了s.isEmpty()， 一开始忘了加这个排序</span></span><br><span class="line">    Arrays.sort(s)</span><br><span class="line">    <span class="keyword">var</span> pg = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> ps = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (pg &lt; g.size &amp;&amp; ps &lt; s.size) &#123; <span class="comment">// 控制边界</span></span><br><span class="line">        <span class="keyword">if</span> (s[ps] &gt;= g[pg]) &#123;       <span class="comment">//饼干满足孩子的胃口大小.</span></span><br><span class="line">            count++</span><br><span class="line">            pg++</span><br><span class="line">            ps++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ps++    <span class="comment">//饼干不满足孩子的胃口大小，饼干数组指针往右走.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="376摆动序列"><a href="#376摆动序列" class="headerlink" title="376摆动序列"></a>376摆动序列</h4><h5 id="Idea-1"><a href="#Idea-1" class="headerlink" title="Idea"></a>Idea</h5><p>摆动序列，其实求波峰 波谷的个数，所以有一个方向改变就算一个波动。</p>
<ol>
<li><p>根据图1可以看到</p>
<p>preDiff = 17-1 &gt;0 , curveDiff = 5 -10&lt;0 ，这个就是一个摆动序列。还有</p>
<p>preDiff = 5-10 &lt;0 , curveDiff = 16 -5&gt;0 的情况，这又是另一种情况的摆动序列。</p>
</li>
<li><p>根据图2可以看到</p>
<p>preDiff ==0  , curveDiff = 5 -2 &gt; 0,  </p>
<p>preDiff ==0  , curveDiff = 5 -8 &gt; 0,  题目说 两个不等元素的序列也视作摆动序列。所以这种情况也是摆动序列。 但是我感觉这个和前面的 “如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 <strong>摆动序列</strong>”,是有矛盾的。</p>
<p>根据 1.2,所以条件可以合并, preDiff  &gt;=0 , curveDiff &lt;=0 ,preDiff &lt;=0 , curveDiff &gt;=0</p>
</li>
<li><p>图3，只有2个摆动，但是根据根据1，2的总结代码在2,3节点处，红色pre的地方也有1个摆动，这种情况要去掉，因为他是同方向的摆动。所以pre应该停在绿色的地方，只有摆动发生她才需要改变，平波不用管。</p>
</li>
</ol>
<p><img src="/2023/01/02/LC-GREEDY/2023-01-18-9.11.23.png" alt="2023-01-18-9.11.23"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">wiggleMaxLength</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.size &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums.size</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> preDiff = <span class="number">0</span> <span class="comment">//前一对差值</span></span><br><span class="line">    <span class="keyword">var</span> curveDiff = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until nums.size) &#123; <span class="comment">// 第一个数已经计入摆动序列了，所以从1开始</span></span><br><span class="line">        curveDiff = nums[i] - nums[i - <span class="number">1</span>] <span class="comment">// 因为要给值给preDiff，所以从i开始，随想录c++解法是从0开始的。</span></span><br><span class="line">        <span class="keyword">if</span> ((preDiff &gt;= <span class="number">0</span> &amp;&amp; curveDiff &lt; <span class="number">0</span>) || (preDiff &lt;= <span class="number">0</span> &amp;&amp; curveDiff &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">            result++</span><br><span class="line">            preDiff = curveDiff</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53 最大子序和"></a>53 最大子序和</h4><p>  -2,    1,    -3,    4,    -1,    2,    1,    -5,    4</p>
<p>*Q *P </p>
<h5 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h5><ol>
<li>题意是找到最大和的连续子数组， 所以是不能对数组排序。</li>
<li>这题可以考虑用双指针解法，移动*p，从0开始 加上指针对应的计数。如果计数增加则是正数计入，如果减小则重置，移动 *q指针。</li>
</ol>
<p>上面这个思路是不行的，4,    -1,    2,    1这种就有问题。</p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.gif" alt="53.最大子序和"></p>
<p>间隔后新的黄色部分是重置数据。</p>
<p>根据随想录的思路</p>
<p>局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。</p>
<p>这句话看起来有问题，但是也拿不出反例.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">maxSubArray</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> maxResult = <span class="built_in">Int</span>.MIN_VALUE</span><br><span class="line">    <span class="keyword">for</span> (pIndex <span class="keyword">in</span> nums.indices) &#123;</span><br><span class="line">        result += nums[pIndex]</span><br><span class="line">        maxResult = maxResult.coerceAtLeast(result)</span><br><span class="line">        <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            result = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxResult</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122 买卖股票的最佳时机 II"></a>122 买卖股票的最佳时机 II</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7,	1,	5,	3,	6,	4</span><br><span class="line">	-6	4		-2	3		-2</span><br></pre></td></tr></table></figure>



<p>假如第0天买入，第3天卖出，那么利润为：prices[3] - prices[0]。</p>
<p>相当于(prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])。</p>
<p><strong>此时就是把利润分解为每天为单位的维度，而不是从0天到第3天整体去考虑！</strong></p>
<p>那么根据prices可以得到每天的利润序列：(prices[i] - prices[i - 1])…..(prices[1] - prices[0])。</p>
<p><img src="https://img-blog.csdnimg.cn/2020112917480858.png" alt="122.买卖股票的最佳时机II"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">maxProfit</span><span class="params">(prices: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> diffArray = IntArray(prices.size - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until prices.size) &#123;</span><br><span class="line">        println(i)</span><br><span class="line">        diffArray[i - <span class="number">1</span>] = prices[i] - prices[i - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> diffArray.indices) &#123;</span><br><span class="line">        <span class="keyword">if</span> (diffArray[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += diffArray[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55 跳跃游戏"></a>55 跳跃游戏</h4><p>[2,3,1,1,4]</p>
<h5 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h5><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度，比如在2的位置，可以跳一格到3的位置，也可以两格到1的位置。</p>
<p><img src="https://img-blog.csdnimg.cn/20201124154758229.png" alt="55.跳跃游戏"></p>
<p>上面第二幅图，第一条线应该有问题，应该覆盖到2 3 1</p>
<p>遍历每个位置，确定每个位置能覆盖的最大范围。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">canJump</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> coverArea = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span>.coverArea) &#123; <span class="comment">// 注意:这里是coverArea,需要确定能走多少步</span></span><br><span class="line">        coverArea = (i + nums[i]).coerceAtLeast(coverArea) <span class="comment">//新的范围和 之前的范围做比较</span></span><br><span class="line">        <span class="keyword">if</span> (coverArea &gt;= nums.size - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45 跳跃游戏 II"></a>45 跳跃游戏 II</h4><h5 id="Idea-2"><a href="#Idea-2" class="headerlink" title="Idea"></a>Idea</h5><p>题目意思 总是可以到达数组的最后一个位置</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">jump</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> maxCover = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span>.maxCover) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i + nums[i] &gt; maxCover) &#123;</span><br><span class="line">            maxCover = i + nums[i]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count++</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (maxCover &gt;= nums.size) &#123;</span><br><span class="line">            println(<span class="string">&quot;count <span class="variable">$count</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> count</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>找到能覆盖的最远距离，如果移动到了这个地方，那么就计算一次，直到  nums.size - 1- 1个节点，然后再count++就可以了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">jump</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nextCover = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> currentCover = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until nums.size - <span class="number">1</span>) &#123;</span><br><span class="line">        nextCover = Math.max(i + nums[i], nextCover)</span><br><span class="line">        <span class="keyword">if</span> (i == currentCover) &#123;</span><br><span class="line">            currentCover = nextCover</span><br><span class="line">            count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1005-K-次取反后最大化的数组和"><a href="#1005-K-次取反后最大化的数组和" class="headerlink" title="1005. K 次取反后最大化的数组和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/">1005. K 次取反后最大化的数组和</a></h4><ol>
<li>先对数组进行排序，把 &lt; 0的数按位取反 ,直到数组的数据都&gt;0,此时翻转了n次</li>
<li>对翻转后的数组重新进行排序，对最小的数 翻转 k-n 次</li>
</ol>
<p>My Idea</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largestSumAfterKNegations</span><span class="params">(nums: <span class="type">IntArray</span>, k: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    Arrays.sort(nums)</span><br><span class="line">    <span class="keyword">var</span> balanceK = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until k) &#123; <span class="comment">// kotlin用while 应该更好</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= nums.size || nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            balanceK = k - i</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        nums[i] = Math.abs(nums[i])</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(nums)</span><br><span class="line">    <span class="keyword">if</span> (balanceK &gt; <span class="number">0</span> &amp;&amp; (balanceK % <span class="number">2</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        nums[<span class="number">0</span>] = -nums[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (value <span class="keyword">in</span> nums) &#123;</span><br><span class="line">        sum += value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个也可以</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1iY411s7qB">https://www.bilibili.com/video/BV1iY411s7qB</a></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largestSumAfterKNegations</span><span class="params">(nums: <span class="type">IntArray</span>, k: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> typedArray = nums.toTypedArray() <span class="comment">// 转成数组</span></span><br><span class="line">    Arrays.sort(typedArray, Comparator.comparingInt(Math::abs)) <span class="comment">// 按照绝对值排序</span></span><br><span class="line">    <span class="keyword">var</span> k = k</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> typedArray.indices) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; typedArray[i] &lt; <span class="number">0</span>) &#123;  <span class="comment">// 碰到数组中&gt;0的数</span></span><br><span class="line">            typedArray[i] *= -<span class="number">1</span></span><br><span class="line">            k--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(typedArray)</span><br><span class="line">    <span class="keyword">if</span> (k % <span class="number">2</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        typedArray[<span class="number">0</span>] *= -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (value <span class="keyword">in</span> nums) &#123;</span><br><span class="line">        sum += value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 参考随想录，但是编译不通过</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV138411G7LY">https://www.bilibili.com/video/BV138411G7LY</a></p>
<h4 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134 加油站"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/gas-station/">134 加油站</a></h4><h5 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">canCompleteCircuit</span><span class="params">(gas: <span class="type">IntArray</span>, cost: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> gas.indices) &#123;</span><br><span class="line">        <span class="keyword">var</span> balance = gas[i] - cost[i]</span><br><span class="line">        <span class="keyword">var</span> index = (i + <span class="number">1</span>) % gas.size</span><br><span class="line">        <span class="keyword">while</span> (balance &gt; <span class="number">0</span> &amp;&amp; i != index) &#123;  <span class="comment">// 还有油的话，没走完一圈，继续走</span></span><br><span class="line">            balance += (gas[index] - cost[index])</span><br><span class="line">            index = (index + <span class="number">1</span>) % gas.size</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (balance &gt;= <span class="number">0</span> &amp;&amp; (index == i)) &#123;<span class="comment">//走完一圈，返回下标</span></span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="贪心解法"><a href="#贪心解法" class="headerlink" title="贪心解法"></a>贪心解法</h5><p>这里k不用看</p>
<p><img src="/2023/01/02/LC-GREEDY/20230211173204.jpg" alt="20230211173204"></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1DF411L7cz">https://www.bilibili.com/video/BV1DF411L7cz</a></p>
<p>j 到 j+1跑不到 , 从i 到 j +1 油量&lt;0</p>
<ol>
<li>因为 i 能开到j,从 i 出发到 i+1 油量 &gt;=0 ,  那么 i+1 到 j+1 油量一定 &lt;0.</li>
<li>如果起点在 i+1, 因为 i 到j+1&lt;0 ,因此 i 到  i+1&gt;=0 , i+1 到j+1一定&lt;0.</li>
</ol>
<p>总结来看,  i 到 j+1&lt;0 ,中间不用看，直接从 j+1开始即可。</p>
<p>LC134我的解法有问题，看到随想录的解法后感觉很妙</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">canCompleteCircuit</span><span class="params">(gas: <span class="type">IntArray</span>, cost: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> totalSum = <span class="number">0</span> <span class="comment">//  所有路程需要的油量</span></span><br><span class="line">    <span class="keyword">var</span> currentSum = <span class="number">0</span>  <span class="comment">// 当前位置开始所需要的油量</span></span><br><span class="line">    <span class="keyword">var</span> start = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> gas.indices) &#123;</span><br><span class="line">        totalSum += gas[i] - cost[i]</span><br><span class="line">        currentSum += gas[i] - cost[i]</span><br><span class="line">        <span class="keyword">if</span> (currentSum &lt; <span class="number">0</span>) &#123; <span class="comment">// 到i加油站需要油量 &lt;0, 如果接下来 gas[i+1] - cost[i+1]还是&lt;0,那么start ,currentSum 继续更新</span></span><br><span class="line">            start = i + <span class="number">1</span></span><br><span class="line">            currentSum = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (totalSum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li> 到i加油站需要油量 &lt;0, 如果接下来 gas[i+1] - cost[i+1]还是&lt;0,那么start ,currentSum 继续更新.</li>
<li> j ,j+1是负数节点,如果存在这样一个节点,满足条件，那么j+1开始后面一圈的一定都是&gt;0</li>
</ol>
<h4 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135 分发糖果"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/candy/">135 分发糖果</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1,2,2]</span><br><span class="line"> 1 2 1 &#x2F;&#x2F;为什么array[2] 糖果是1，因为题目意思只有评分高才有更多的糖果，相等的情况按照最少的1个糖果了。</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">5</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">左&lt;右</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">左&gt;右</td>
</tr>
</tbody></table>
<h5 id="Idea-3"><a href="#Idea-3" class="headerlink" title="Idea"></a>Idea</h5><p>需要一边一边考虑，否则顾此失彼</p>
<ol>
<li>先考虑  左边孩子粉丝的情况 &lt; 右边孩子分数  ，此时需要从左往右, 得到第三行的分数.</li>
<li>再考虑 左边孩子粉丝 &gt; 右边孩子分数的情况, 此时需要从右向左，因为这种情况需要依赖，右边的孩子。如果从左到右，得到第4行结果，此时  2 3 4 5都是错的。</li>
<li>然后从右往左的过程，还需要考虑之前 左边孩子&lt; 右边的情况，所以取最大值。</li>
</ol>
<h5 id="code"><a href="#code" class="headerlink" title="code"></a>code</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">candy</span><span class="params">(ratings: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> answer = IntArray(ratings.size)</span><br><span class="line">        answer[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        左边孩子粉丝的情况 &lt; 右边孩子分数  ，此时需要从左往右</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until ratings.size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                answer[i] = answer[i - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                answer[i] = <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        println()</span><br><span class="line">        answer.printIntArray()</span><br><span class="line">        <span class="comment">//左边孩子粉丝 &gt; 右边孩子分数的情况, 此时需要从右向左</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> ratings.size - <span class="number">1</span> downTo <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i - <span class="number">1</span>] &gt; ratings[i]) &#123;</span><br><span class="line">                answer[i - <span class="number">1</span>] = answer[i - <span class="number">1</span>].coerceAtLeast(answer[i] + <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        answer.printIntArray()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> answer) &#123;</span><br><span class="line">            sum += i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="860-柠檬水找零"><a href="#860-柠檬水找零" class="headerlink" title="860 柠檬水找零"></a>860 柠檬水找零</h4><h5 id="Idea-4"><a href="#Idea-4" class="headerlink" title="Idea"></a>Idea</h5><ol>
<li>一开始想到的是暴力解法， 用map 存 5 , 10两种金额的个数，20不用考虑</li>
<li>来了5存起来 map5 +1，来了10存起来 map10+1 , map5 -1 ,  来了20， map10-1, map5-1</li>
</ol>
<h5 id="code-暴力解法"><a href="#code-暴力解法" class="headerlink" title="code  暴力解法"></a>code  暴力解法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">fun lemonadeChange(bills: IntArray): Boolean &#123;</span><br><span class="line">    val map &#x3D; HashMap&lt;Int, Int&gt;()</span><br><span class="line">    for ((index, money) in bills.withIndex()) &#123;</span><br><span class="line">        if (money &#x3D;&#x3D; 5) &#123;</span><br><span class="line">            map[5] &#x3D; map.getOrDefault(5, 0).plus(1)</span><br><span class="line">        &#125; else if (money &#x3D;&#x3D; 10) &#123;</span><br><span class="line">            map[5] &#x3D; map.getOrDefault(5, 0) - 1</span><br><span class="line">            map[10] &#x3D; map.getOrDefault(10, 0).plus(1)</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F;for 20 rmb</span><br><span class="line">            if (map.getOrDefault(10, 0) &gt; 0 &amp;&amp; map.getOrDefault(5, 0) &gt; 0) &#123; &#x2F;&#x2F;at lease 10rmb 1  , 5rmb 1</span><br><span class="line">                map[10] &#x3D; map.getOrDefault(10, 0) - 1</span><br><span class="line">                map[5] &#x3D; map.getOrDefault(5, 0) - 1</span><br><span class="line">            &#125; else if (map.getOrDefault(5, 0) &gt; 2) &#123; &#x2F;&#x2F; at least 3 * 5 rmb</span><br><span class="line">                map[5] &#x3D; map.getOrDefault(5, 0) - 3</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        println(&quot; index $index    map5 $&#123;map[5]&#125; map10 $&#123;map[10]&#125; &quot;)</span><br><span class="line">        if (map.getOrDefault(5, 0) &lt; 0 || map.getOrDefault(10, 0) &lt; 0) &#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>看了随想录的解法，和我的解法类似，知识map中的值可以用变量来做.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> five = <span class="number">0</span>, ten = <span class="number">0</span>, twenty = <span class="number">0</span>;</span><br><span class="line">这样++,--更方便.</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0860.%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6.html#%E6%80%9D%E8%B7%AF">https://programmercarl.com/0860.%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6.html#%E6%80%9D%E8%B7%AF</a></p>
<h4 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406 根据身高重建队列"></a>406 根据身高重建队列</h4><h5 id="Idea-随想录"><a href="#Idea-随想录" class="headerlink" title="Idea 随想录"></a>Idea 随想录</h5><p>对于本题相信大家困惑的点是先确定k还是先确定h呢，也就是究竟先按h排序呢，还是先按照k排序呢？</p>
<p>如果按照k来从小到大排序，排完之后，会发现k的排列并不符合条件，身高也不符合条件，两个维度哪一个都没确定下来。</p>
<p>那么按照身高h来排序呢，身高一定是从大到小排（身高相同的话则k小的站前面），让高个子在前面。</p>
<p><strong>此时我们可以确定一个维度了，就是身高，前面的节点一定都比本节点高！</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fun reconstructQueue(people: Array&lt;IntArray&gt;): Array&lt;IntArray&gt; &#123;</span><br><span class="line">    Arrays.sort(people, object : Comparator&lt;IntArray&gt; &#123; </span><br><span class="line">        override fun compare(o1: IntArray, o2: IntArray): Int &#123;</span><br><span class="line">            if (o2[0] &#x3D;&#x3D; o1[0]) &#123;       &#x2F;&#x2F; 如果身高相同，k小的排在前面</span><br><span class="line">                return o1[1] - o2[1]</span><br><span class="line">            &#125;</span><br><span class="line">            return o2[0] - o1[0]        &#x2F;&#x2F; 对数组先按照身高来排序</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    val linkedList &#x3D; LinkedList&lt;IntArray&gt;()</span><br><span class="line"></span><br><span class="line">    for (value in people)&#123;</span><br><span class="line">        val index &#x3D; value[1]</span><br><span class="line">        linkedList.add(index,value) &#x2F;&#x2F; 按照k插入对应的位置, 这里插入时很容易越界。</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return linkedList.toTypedArray()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452. 用最少数量的箭引爆气球"></a>452. 用最少数量的箭引爆气球</h4><p>IDEA</p>
<ol>
<li>先对数组按照左边界大小进行排序。</li>
<li>如果当前i数组右边的值 &gt;  或者前面数组重叠区域的最小右边界， 此时没有重叠（和之前的共有区域），数量+1</li>
<li>否则有重叠，取最小右边界值。</li>
</ol>
<p>一开始看题解，没理解特别是 points[i][1]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">points[i][<span class="number">1</span>] = <span class="built_in">min</span>(points[i - <span class="number">1</span>][<span class="number">1</span>], points[i][<span class="number">1</span>]); <span class="comment">// 更新重叠气球最小右边界</span></span><br></pre></td></tr></table></figure>



<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findMinArrowShots1</span><span class="params">(points: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line"><span class="comment">//        Arrays.sort(points)&#123;o1,o2 -&gt; o1[0] - o2[0]&#125; 这个回报越界错 [[-2147483646,-2147483645],[2147483646,2147483647]]</span></span><br><span class="line">        points.sortBy&#123;it[<span class="number">0</span>]&#125;</span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until points.size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (points[i][<span class="number">0</span>] &gt; points[i - <span class="number">1</span>][<span class="number">1</span>]) &#123; <span class="comment">// 如果当前气球的左边界 &gt; 公共右边界</span></span><br><span class="line">                count++</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有大于公共右边界</span></span><br><span class="line">                <span class="comment">//points[i][1] = points[i][1].minus(points[i - 1][1]) // 用minus是有问题的</span></span><br><span class="line">                points[i][<span class="number">1</span>] = points[i][<span class="number">1</span>].coerceAtMost(points[i - <span class="number">1</span>][<span class="number">1</span>]) <span class="comment">// 更新重叠气球最小右边界</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        points.printDimensionalArray()</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>1       6</p>
<p>​    2            8</p>
<p>​             7                12</p>
<p>​                        10         16</p>
<h5 id="使用chatGPT的算法，更好"><a href="#使用chatGPT的算法，更好" class="headerlink" title="使用chatGPT的算法，更好"></a>使用chatGPT的算法，更好</h5><p>确定右边界, 如果新的左边界&gt;之前的右边界+1 , 使用新的数据，并且确定右边界。</p>
<p>The solution sorts the balloons by their end positions in ascending order, and then uses a greedy algorithm to shoot the balloons. We start with the first balloon and set <code>end</code> to its end position. Then, we iterate through the rest of the balloons and compare their start positions to <code>end</code>. If the start position of a balloon is greater than <code>end</code>, we shoot another arrow and update <code>end</code> to the end position of the current balloon.</p>
<p>At the end, the function returns the number of arrows shot.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findMinArrowShots</span><span class="params">(points: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (points.isEmpty()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    points.sortBy &#123; it[<span class="number">1</span>] &#125;</span><br><span class="line">    <span class="keyword">var</span> arrows = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> end = points[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until points.size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (points[i][<span class="number">0</span>]&gt;end) &#123;</span><br><span class="line">            arrows++</span><br><span class="line">            end = points[i][<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arrows</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/non-overlapping-intervals/">435. 无重叠区间</a></h4><p>[1,2] [3,6] [7,12] [4,8] [10,16]</p>
<p>1     2</p>
<p>​            3       6</p>
<p>​                 4                  8</p>
<p>​                          7                      12</p>
<p>​                                            10                16</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1A14y1c7E1">https://www.bilibili.com/video/BV1A14y1c7E1</a></p>
<h5 id="左边数组进行排序。"><a href="#左边数组进行排序。" class="headerlink" title="左边数组进行排序。"></a>左边数组进行排序。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. if [i][0] &lt; [i-1][1] 说明会有重合，那么求出 [i][1] [i-1][1]中的最小值，作为右边界，更新数量</span><br><span class="line">否则就没重合更新右边界限。</span><br><span class="line">2. 否则，没有重合直接更新  end。</span><br></pre></td></tr></table></figure>



<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">eraseOverlapIntervals</span><span class="params">(intervals: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.isEmpty()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">        Arrays.sort(intervals) &#123; a, b -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>] &#125; <span class="comment">// 按照左边数组进行排序</span></span><br><span class="line">        <span class="keyword">var</span> end = intervals[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until intervals.size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt; end) &#123;    <span class="comment">//重合的情况</span></span><br><span class="line">                count++</span><br><span class="line">                end = end.coerceAtMost(intervals[i][<span class="number">1</span>]) <span class="comment">// 确定最小重合的 右边界, 这里一开始弄错了</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                end = intervals[i][<span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        intervals.printDimensionalArray()</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h5 id="右边数组排序"><a href="#右边数组排序" class="headerlink" title="右边数组排序"></a>右边数组排序</h5><p><strong>这种解法不理解.</strong></p>
<p>根据随想录的思路，总的个数 - 非交叉个数 = 交叉个数。</p>
<p>这里的难点是要知道交叉后的右边界的</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230201164134.png" alt="img"></p>
<p>如果3在 1,2 右边最小值的左边，所以3条线还会有交叉，如果在1，2最小值的右边那么 2去掉就可以了，还是去掉1。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">eraseOverlapIntervals</span><span class="params">(intervals: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.isEmpty()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">1</span> <span class="comment">//非交叉区间个数</span></span><br><span class="line">        Arrays.sort(intervals) &#123; a, b -&gt; a[<span class="number">1</span>] - b[<span class="number">1</span>] &#125; <span class="comment">// 按照左边数组进行排序</span></span><br><span class="line">        <span class="keyword">var</span> end = intervals[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until intervals.size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &gt;= end) &#123;</span><br><span class="line">                count ++</span><br><span class="line">                end = intervals[i][<span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            else&#123;</span></span><br><span class="line"><span class="comment">//                end = intervals[i][1].coerceAtMost(end) // 这个不需要</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        intervals.printDimensionalArray()</span></span><br><span class="line">        <span class="keyword">return</span> intervals.size - count</span><br><span class="line">    &#125;	</span><br></pre></td></tr></table></figure>



<p>12</p>
<h4 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763 划分字母区间"></a>763 划分字母区间</h4><h5 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h5><ol>
<li><p>遍历出每个字母的最远距离，出现的座标。</p>
<p>根据字母的hash值得到当前的座标，后面如果有重复的hash,会覆盖前面的。</p>
</li>
<li><p>遍历后序列找 当前字母hash值 == i , right = i 拿到当前 right + 1 - left, 就是片段的长度。</p>
<p>然后更新left值.</p>
</li>
</ol>
<p>​        </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">partitionLabels</span><span class="params">(s: <span class="type">String</span>)</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> result = arrayListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">val</span> hash = IntArray(<span class="number">26</span>)</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> s.indices) &#123;</span><br><span class="line">            hash[s[i] - <span class="string">&#x27;a&#x27;</span>] = i</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> right = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> s.indices) &#123;</span><br><span class="line">            right = hash[s[i] - <span class="string">&#x27;a&#x27;</span>].coerceAtLeast(right) <span class="comment">// 要找到当前hash值的最大值</span></span><br><span class="line">            <span class="keyword">if</span> (right == i) &#123;   <span class="comment">//如果 hash值的最大值 和座标相等，就用到了分割点</span></span><br><span class="line">                result.add(right + <span class="number">1</span> - left)</span><br><span class="line">                left = i + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        hash.printIntArray()</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56 合并区间"></a>56 合并区间</h4><h5 id="Idea-My"><a href="#Idea-My" class="headerlink" title="Idea My"></a>Idea My</h5><p>初始化 left. right</p>
<ol>
<li>按照左边数组 排序。</li>
<li>如果没重合直接[left,right]把前面数组加入区间 。</li>
<li>如果重合，那么确定 right右边界，判断<code> [i][0]</code>和right,确定右边界，把right放入右边界。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">merge</span><span class="params">(intervals: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: Array&lt;IntArray&gt; &#123;</span><br><span class="line">    Arrays.sort(intervals) &#123; a, b -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>] &#125;</span><br><span class="line">    <span class="keyword">var</span> left = intervals[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> right = intervals[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">val</span> arrayOf = arrayListOf&lt;IntArray&gt;()</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until intervals.size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt;= right) &#123;</span><br><span class="line">            right = right.coerceAtLeast(intervals[i][<span class="number">1</span>])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arrayOf.add(intArrayOf(left, right))</span><br><span class="line">            left = intervals[i][<span class="number">0</span>]</span><br><span class="line">            right = intervals[i][<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arrayOf.add(intArrayOf(left, right))</span><br><span class="line">    <span class="keyword">return</span> arrayOf.toTypedArray()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="Idea-2"><a href="#Idea-2" class="headerlink" title="Idea 2"></a>Idea 2</h5><p>看了随想录的题解，觉得比我上面的更好，只需要更新右边界。</p>
<p>1     3</p>
<p>​    2         6       8     10         15        18</p>
<p>​                    </p>
<ol>
<li>还是按照数组左边界排好序。</li>
<li>把第一组数组放入结果数组中，然后取出来，用它的右边界和第二组数组的左边界比较大小.</li>
<li>如果新的数组的左边界 &lt; 结果数组的右边界，说明有重合，更新结果数组的右边界。</li>
<li>如果新的数组的左边界 &gt; 结果数组的右边界,没有重合，新数组直接添加到结果数组集中。</li>
</ol>
<h4 id="738-单调递增的数字"><a href="#738-单调递增的数字" class="headerlink" title="738 单调递增的数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/monotone-increasing-digits/">738 单调递增的数字</a></h4><h5 id="Idea-5"><a href="#Idea-5" class="headerlink" title="Idea"></a>Idea</h5><p>看了随想录的题解</p>
<p>那么拿一个两位的数字来举例。</p>
<p>例如：98，一旦出现strNum[i - 1] &gt; strNum[i]的情况（非单调递增），首先想让strNum[i - 1]–，然后strNum[i]给为9，这样这个整数就是89，即小于98的最大的单调递增整数。</p>
<p>此时是从前向后遍历还是从后向前遍历呢？</p>
<p>这么说有点抽象，举个例子，数字：332，从前向后遍历的话，那么就把变成了329，此时2又小于了第一位的3了，真正的结果应该是299。</p>
<p>那么从后向前遍历，就可以重复利用上次比较得出的结果了，从后向前遍历332的数值变化为：332 -&gt; 329 -&gt; 299</p>
<p>确定了遍历顺序之后，那么此时局部最优就可以推出全局，找不出反例，试试贪心。</p>
<h5 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h5><p>初始的想法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> arrStr = n.toString().toCharArray()</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> arrStr.size - <span class="number">1</span> downTo <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arrStr[i - <span class="number">1</span>] &gt; arrStr[i]) &#123;</span><br><span class="line">            arrStr[i] = <span class="string">&#x27;9&#x27;</span></span><br><span class="line">            arrStr[i - <span class="number">1</span>] = arrStr[i - <span class="number">1</span>].toInt().minus(<span class="number">1</span>).toChar() </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> String(arrStr).toInt()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>100 跑完后变成90,其实后面所有位都要变成 ‘9’,只有当前位减1</p>
<p>找到 minus 1 的位置，后面的位都变成9</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> arrStr = n.toString().toCharArray()</span><br><span class="line">    <span class="keyword">var</span> position = arrStr.size <span class="comment">//初始位置不能是  arrStr.size - 1 ，否则最后一位都会变成 &#x27;9&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> arrStr.size - <span class="number">1</span> downTo <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arrStr[i - <span class="number">1</span>] &gt; arrStr[i]) &#123;</span><br><span class="line">            arrStr[i - <span class="number">1</span>] = arrStr[i - <span class="number">1</span>].toInt().minus(<span class="number">1</span>).toChar() <span class="comment">// digitToInt leetcode跑不了</span></span><br><span class="line">            position = i <span class="comment">// 找到-1 的位置，后面的位都变成9</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> position until arrStr.size) &#123;</span><br><span class="line">        arrStr[i] = <span class="string">&#x27;9&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> String(arrStr).toInt()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="968-监控二叉树"><a href="#968-监控二叉树" class="headerlink" title="968 监控二叉树"></a>968 监控二叉树</h4><p>这题比较难，暂时没必要写。</p>

        
        
          <blockquote id="copyright">
              <p>Original link: <a href="https://noteforme.github.io/index.html">https://noteforme.github.io/index.html</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LEETCODE/" rel="tag">LEETCODE</a></li></ul>

          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-viewBinding" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/12/27/viewBinding/">viewBinding</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2022-12-27T13:04:33.000Z" itemprop="datePublished">2022年12月27日</time>
</span>
      
      
      
<a href="/2022/12/27/viewBinding/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/pengxurui/p/16669380.html">https://www.cnblogs.com/pengxurui/p/16669380.html</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6958346113552220173">https://juejin.cn/post/6958346113552220173</a></p>
<h5 id="编译生成的目录"><a href="#编译生成的目录" class="headerlink" title="编译生成的目录"></a>编译生成的目录</h5><p>build/generated/data_binding_base_class_source_out/</p>
<p>ActivityCBinding.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityCBinding</span> <span class="keyword">implements</span> <span class="title">ViewBinding</span> </span>&#123;</span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> LinearLayout rootView;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> Button btC;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> Button btD;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">ActivityCBinding</span><span class="params">(<span class="meta">@NonNull</span> LinearLayout rootView, <span class="meta">@NonNull</span> Button btC,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@NonNull</span> Button btD)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.rootView = rootView;</span><br><span class="line">    <span class="keyword">this</span>.btC = btC;</span><br><span class="line">    <span class="keyword">this</span>.btD = btD;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> LinearLayout <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rootView;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ActivityCBinding <span class="title">inflate</span><span class="params">(<span class="meta">@NonNull</span> LayoutInflater inflater)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> inflate(inflater, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ActivityCBinding <span class="title">inflate</span><span class="params">(<span class="meta">@NonNull</span> LayoutInflater inflater,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@Nullable</span> ViewGroup parent, <span class="keyword">boolean</span> attachToParent)</span> </span>&#123;</span><br><span class="line">    View root = inflater.inflate(R.layout.activity_c, parent, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (attachToParent) &#123;</span><br><span class="line">      parent.addView(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bind(root);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ActivityCBinding <span class="title">bind</span><span class="params">(<span class="meta">@NonNull</span> View rootView)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The body of this method is generated in a way you would not otherwise write.</span></span><br><span class="line">    <span class="comment">// This is done to optimize the compiled bytecode for size and performance.</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    missingId: &#123;</span><br><span class="line">      id = R.id.bt_c;</span><br><span class="line">      Button btC = ViewBindings.findChildViewById(rootView, id);</span><br><span class="line">      <span class="keyword">if</span> (btC == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span> missingId;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      id = R.id.bt_D;</span><br><span class="line">      Button btD = ViewBindings.findChildViewById(rootView, id);</span><br><span class="line">      <span class="keyword">if</span> (btD == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span> missingId;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ActivityCBinding((LinearLayout) rootView, btC, btD);</span><br><span class="line">    &#125;</span><br><span class="line">    String missingId = rootView.getResources().getResourceName(id);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;Missing required view with ID: &quot;</span>.concat(missingId));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>从控件  Button btC;  Button btD;可以很容易看到。id都是findbyid生成的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FragmentViewBinding</span>&lt;<span class="type">T : ViewBinding</span>&gt;</span>(classes: Class&lt;T&gt;, fragment: Fragment) :</span><br><span class="line">    FragmentDelegate&lt;T&gt;(fragment) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> TAG = <span class="string">&quot;TAG&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> layoutInflater = classes.inflateMethod()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> bindView = classes.bindMethod()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用getValue属于属性代理,访问viewbiding属性调用getVaule方法</span></span><br><span class="line">    <span class="meta">@Suppress(<span class="meta-string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Fragment</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T = viewBinding ?: let &#123;</span><br><span class="line"></span><br><span class="line">        Log.i(TAG, <span class="string">&quot;getValue: <span class="variable">$layoutInflater</span>  <span class="variable">$bindView</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> bind: T = (<span class="keyword">if</span> (thisRef.view == <span class="literal">null</span>) &#123;</span><br><span class="line">            layoutInflater.invoke(<span class="literal">null</span>, thisRef.layoutInflater) <span class="comment">// 表示 ActivityCBinding.inflate()</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            bindView.invoke(<span class="literal">null</span>, thisRef.view) <span class="comment">//表示 ActivityCBinding.bind()</span></span><br><span class="line">        &#125;) <span class="keyword">as</span> T</span><br><span class="line">        viewBinding = bind</span><br><span class="line">        bind</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
        
          <blockquote id="copyright">
              <p>Original link: <a href="https://noteforme.github.io/index.html">https://noteforme.github.io/index.html</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ANDROID/" rel="tag">ANDROID</a></li></ul>

          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-LC-backtrack-combination" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/10/30/LC-backtrack-combination/">LC-backtrack-combination</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2022-10-30T02:27:10.000Z" itemprop="datePublished">2022年10月30日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/DataStructure/">DataStructure</a>
  </div>

      
      
<a href="/2022/10/30/LC-backtrack-combination/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>组合</p>
<p>组合的元素是无序的[1,2]  , [2,1]是一个组合</p>
<p>组合的元素是不能重复的 </p>
<img src="https://img-blog.csdnimg.cn/20201123195242899.png" alt="77.组合1" style="zoom: 67%;">







<h4 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combinations/">77. 组合</a></h4><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ti4y1L7cv">https://www.bilibili.com/video/BV1ti4y1L7cv</a> </p>
<ol>
<li>拿到第一个元素.</li>
<li>用上面的图很形象,在剩余的元素中取数据，和 二叉树路径很像,递归加回溯的过程.</li>
</ol>
<p>这里一开始用的是 startIndex+1,不理解，这里回溯后,最第一次的for (i in startIndex..n)如果i ==2,或者3，或者4, 递归到底层，再回溯到第一次循环的时候，startIndex都是第一次的2,这样就导致剩余的元素不对</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">combine</span><span class="params">(n: <span class="type">Int</span>, k: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    backTracking(n, k, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTracking</span><span class="params">(n: <span class="type">Int</span>, k: <span class="type">Int</span>, startIndex: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.size == k) &#123;</span><br><span class="line">        result.add(path.toMutableList())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex..n) &#123;</span><br><span class="line">        path.add(i)</span><br><span class="line">        backTracking(n, k, i + <span class="number">1</span>) <span class="comment">// 这里一开始用的是 startIndex+1</span></span><br><span class="line">        path.remove(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="组合剪枝"><a href="#组合剪枝" class="headerlink" title="组合剪枝"></a>组合剪枝</h5><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1wi4y157er/">https://www.bilibili.com/video/BV1wi4y157er/</a></p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html#%E5%89%AA%E6%9E%9D%E4%BC%98%E5%8C%96">https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html#%E5%89%AA%E6%9E%9D%E4%BC%98%E5%8C%96</a></p>
<p>来举一个例子，n = 4，k = 4的话，那么第一层for循环的时候，从元素2开始的遍历都没有意义了。 在第二层for循环，从元素3开始的遍历都没有意义了。</p>
<p><img src="https://img-blog.csdnimg.cn/20210130194335207.png" alt="77.组合4"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> startIndex..n) &#123; <span class="comment">// 这里对应模拟就是,取1,取2 ,取3,取4 ,几个子孩子的操作.</span></span><br><span class="line">         path.add(i)</span><br><span class="line">         backTracking(n, k, i + <span class="number">1</span>) <span class="comment">// 这里一开始用的是 startIndex+1</span></span><br><span class="line">         path.remove(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>剪枝就是 i&lt; n这个范围里面做操作。</p>
<p>接下来看一下优化过程如下：</p>
<ol>
<li>已经选择的元素个数：path.size();</li>
<li>还需要的元素个数为: k - path.size();</li>
<li>在集合n中至多要从该起始位置 : n - (k - path.size()) + 1，开始遍历</li>
</ol>
<p>为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。</p>
<p>举个例子，n = 4，k = 3， 目前已经选取的元素为0（path.size为0），n - (k - 0) + 1 即 4 - ( 3 - 0) + 1 = 2。</p>
<p>从2开始搜索都是合理的，可以是组合[2, 3, 4]。</p>
<p>这里大家想不懂的话，建议也举一个例子，就知道是不是要+1了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> path = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="keyword">val</span> result = ArrayList&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">combine</span><span class="params">(n: <span class="type">Int</span>, k: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    backTracking1(n, k, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//剪枝操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTracking1</span><span class="params">(n: <span class="type">Int</span>, k: <span class="type">Int</span>, startIndex: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.size == k) &#123;</span><br><span class="line">        result.add(path.toMutableList())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex..(n - (k - path.size) + <span class="number">1</span>)) &#123;</span><br><span class="line">        path.add(i)</span><br><span class="line">        backTracking1(n, k, i + <span class="number">1</span>) <span class="comment">// 这里一开始用的是 startIndex+1</span></span><br><span class="line">        path.remove(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III</a></h4><ul>
<li>只使用数字1到9 .</li>
<li>每个数字 <strong>最多使用一次</strong> .</li>
</ul>
<ol>
<li><p>从1开始选取，每次循环往后选取，如果往前选数字入[1,2], [2,1]的情况，就重复了.</p>
</li>
<li><p>选取元素综合==n ,  并且是k个，装入数组。</p>
</li>
</ol>
<p>我的解法if (sum == n &amp;&amp; pathList.size == k)放一起不好 ，pathList.size到了k 个数，后面的就不用加了，达到竖向剪枝的目的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> result = ArrayList&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> sum: <span class="built_in">Int</span> = <span class="number">0</span> <span class="comment">//集合的和</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> pathList = ArrayList&lt;<span class="built_in">Int</span>&gt;() <span class="comment">// 集合</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">combinationSum3</span><span class="params">(k: <span class="type">Int</span>, n: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    blockTracking(k, n, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">blockTracking</span><span class="params">(k: <span class="type">Int</span>, n: <span class="type">Int</span>, startIndex: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sum == n &amp;&amp; pathList.size == k) &#123; <span class="comment">// 相加之和为 n 的 k 个数的组合</span></span><br><span class="line">        result.add(pathList.toMutableList())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex.<span class="number">.9</span>) &#123;</span><br><span class="line">        sum += i</span><br><span class="line">        pathList.add(i)</span><br><span class="line">        blockTracking(k, n, i + <span class="number">1</span>)</span><br><span class="line">        sum -= i</span><br><span class="line">        pathList.remove(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h5><p>还没想好</p>
<p><img src="https://img-blog.csdnimg.cn/2020112319580476.png" alt="216.组合总和III1"></p>
<ol>
<li><p>pathList.size到了k 个数，后面的就不用加了，达到竖向剪枝的目的。</p>
</li>
<li><p>(9 - (k - pathList.size) + 1) 分析 </p>
<p>k - pathList.size :  从1开始选取,还差多少个元素</p>
<p>9 - (k - pathList.size)  : 如果从1…9选取，为了避免重复，一直往大的数选取,第1次选到了8,如果k==2,那么过了8就没意义了，第一次的9就不需要选取了.</p>
<p>(9 - (k - pathList.size) + 1) 处理下标值。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> result = ArrayList&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> sum: <span class="built_in">Int</span> = <span class="number">0</span> <span class="comment">//集合的和</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> pathList = ArrayList&lt;<span class="built_in">Int</span>&gt;() <span class="comment">// 集合</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">combinationSum3</span><span class="params">(k: <span class="type">Int</span>, n: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    blockTracking(k, n, <span class="number">1</span>)</span><br><span class="line">    println(result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">blockTracking</span><span class="params">(k: <span class="type">Int</span>, n: <span class="type">Int</span>, startIndex: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pathList.size == k) &#123; <span class="comment">//shuxiang</span></span><br><span class="line">        <span class="keyword">if</span> (sum == n) &#123;</span><br><span class="line">            result.add(pathList.toMutableList())</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex..(<span class="number">9</span> - (k - pathList.size) + <span class="number">1</span>)) &#123; <span class="comment">// 横向剪枝</span></span><br><span class="line">        <span class="keyword">if</span> (sum &gt; n) &#123; <span class="comment">//剪枝</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        sum += i</span><br><span class="line">        pathList.add(i)</span><br><span class="line">        blockTracking(k, n, i + <span class="number">1</span>)</span><br><span class="line">        sum -= i</span><br><span class="line">        pathList.remove(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">blockTracking</span><span class="params">(k: <span class="type">Int</span>, n: <span class="type">Int</span>, startIndex: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; n) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">//sum &gt; n 直接返回，随想录的解法，这样更好.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pathList.size == k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == n) &#123;</span><br><span class="line">            result.add(pathList.toMutableList())</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex..(<span class="number">9</span> - (k - pathList.size) + <span class="number">1</span>)) &#123;</span><br><span class="line">        sum += i</span><br><span class="line">        pathList.add(i)</span><br><span class="line">        blockTracking(k, n, i + <span class="number">1</span>)</span><br><span class="line">        sum -= i</span><br><span class="line">        pathList.remove(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17.电话号码的字母组合"></a>17.电话号码的字母组合</h4><p>前面的题目都是在一个数组里面取，看到这个问题，这个问题是在数组里面，再取里面的数组。</p>
<p>问题是，如果输入”235”,那么他们内部数组的索引startIndex怎么求出来.</p>
<h5 id="String中的数字转int"><a href="#String中的数字转int" class="headerlink" title="String中的数字转int"></a>String中的数字转int</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> digits = <span class="string">&quot;23&quot;</span></span><br><span class="line"><span class="keyword">val</span> c = digits[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span> <span class="comment">// 50 - 48</span></span><br><span class="line">println(digits[<span class="number">0</span>].code) <span class="comment">// ASCII是 50</span></span><br><span class="line">println(<span class="string">&#x27;0&#x27;</span>.code)       <span class="comment">//ASCII是 48</span></span><br></pre></td></tr></table></figure>



<h4 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39.组合总和"></a>39.组合总和</h4><p>这题目和前面的区别是，可以选取重复的元素.</p>
<p>选了2后，第二列选5这时候不能选2了，否则就会重复了。</p>
<p><img src="/2022/10/30/LC-backtrack-combination/20221120103956.jpg"></p>
<p>看了随想录分析视频，在分析代码前，根据上面的图了解到的思路.</p>
<ol>
<li>整体回溯架构和前面的都是一样的,选了2后，后面还是可以继续253, 选了5后只有53了，否则就有重复的。</li>
<li>一开始我的解法是backTrack(candidates.toList(), target,i),传入for循环中的i，这样会导致有漏掉前面的情况。要知道for循环的部分就是树的宽度。</li>
<li>后面的剪枝应该也是针对这部分。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> path = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> result = ArrayList&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">combinationSum</span><span class="params">(candidates: <span class="type">IntArray</span>, target: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    backTrack(candidates.toList(), target)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(candidates: <span class="type">List</span>&lt;<span class="type">Int</span>&gt;, target: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; target) &#123;  <span class="comment">// 节点和</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum == target) &#123; </span><br><span class="line">        result.add(path.toList())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ((i, item) <span class="keyword">in</span> candidates.withIndex()) &#123;</span><br><span class="line">        path.add(item)</span><br><span class="line">        sum += item</span><br><span class="line">        backTrack(candidates.toMutableList().subList(i, candidates.size), target) <span class="comment">// 只需要传入后面能选取的数组部分</span></span><br><span class="line">        path.remove(item)</span><br><span class="line">        sum -= item</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>看了随想录的部分解法视频后，感觉这种更好，根据startIndex来取数组位置。传入startIndex后，后面的智能从startIndex后面取，和分割数组是一样的道理，感觉效率会更好。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> path = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> result = ArrayList&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">combinationSum</span><span class="params">(candidates: <span class="type">IntArray</span>, target: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    backTrack(candidates.toList(), target, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(candidates: <span class="type">List</span>&lt;<span class="type">Int</span>&gt;, target: <span class="type">Int</span>, startIndex: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">        result.add(path.toList())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex until candidates.size) &#123;</span><br><span class="line">        path.add(candidates[i])</span><br><span class="line">        sum += candidates[i]</span><br><span class="line">        backTrack(candidates, target, i) <span class="comment">// i后分割元素，一开始写的是startIndex，这样for循环后面的就没过滤到了,只有startIndex过滤到了。</span></span><br><span class="line">        path.remove(candidates[i])</span><br><span class="line">        sum -= candidates[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="剪枝-1"><a href="#剪枝-1" class="headerlink" title="剪枝"></a>剪枝</h5><p><img src="/2022/10/30/LC-backtrack-combination/20221120103956.jpg"></p>
<p>如果target ==4</p>
<p>可以看这张图，如果经过排序左边的 235,取了2,3已经 &gt;=4了，那么后面的5就不用去取了.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> path = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> result = ArrayList&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">combinationSum</span><span class="params">(candidates: <span class="type">IntArray</span>, target: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line"><span class="comment">//        backTrack1(candidates.toList(), target)</span></span><br><span class="line">        Arrays.sort(candidates) <span class="comment">//剪枝前需要排序</span></span><br><span class="line">        backTrack(candidates.toList(), target, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(candidates: <span class="type">List</span>&lt;<span class="type">Int</span>&gt;, target: <span class="type">Int</span>, startIndex: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            result.add(path.toList())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex until candidates.size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum + candidates[i] &gt; target) &#123; <span class="comment">//  剪枝操作</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            path.add(candidates[i])</span><br><span class="line">            sum += candidates[i]</span><br><span class="line">            backTrack(candidates, target, i)</span><br><span class="line">            path.remove(candidates[i])</span><br><span class="line">            sum -= candidates[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack1</span><span class="params">(candidates: <span class="type">IntArray</span>, target: <span class="type">Int</span>, startIndex: <span class="type">Int</span>, used: <span class="type">BooleanArray</span>, layer: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">        result.add(path.toList())</span><br><span class="line">        println(path)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex until candidates.size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum + candidates[i] &gt; target) &#123; <span class="comment">// 这样判断更好，因为是生序的数组，右边的枝没必要</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;layer<span class="variable">$layer</span> i: <span class="variable">$i</span> candidates[i]: <span class="subst">$&#123;candidates[i]&#125;</span>   used: <span class="subst">$&#123;used[i]&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            println(<span class="string">&quot;continue <span class="subst">$&#123;candidates[i]&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        path.add(candidates[i])</span><br><span class="line">        sum += candidates[i]</span><br><span class="line">        used[i] = <span class="literal">true</span></span><br><span class="line">        println(<span class="string">&quot;path <span class="variable">$path</span>&quot;</span>)</span><br><span class="line">        backTrack1(candidates, target, i + <span class="number">1</span>, used, layer + <span class="number">1</span>) <span class="comment">// 经过日志排查后, i + 1之前写的是 startIndex +1, 第二层报错</span></span><br><span class="line">        path.remove(candidates[i])</span><br><span class="line">        println(<span class="string">&quot;path backTrack <span class="variable">$path</span>&quot;</span>)</span><br><span class="line">        sum -= candidates[i]</span><br><span class="line">        used[i] = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40.组合总和 II"></a>40.组合总和 II</h4><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV12V4y1V73A/">https://www.bilibili.com/video/BV12V4y1V73A/</a></p>
<p> 这一题的 [10,1,2,7,6,1,5]，有两个1，可能都和7组成了[1,7]就重复了，这里就是要去掉这种重复。</p>
<p>一开始想不到去重的思路 。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20221021163812.png" alt="img"></p>
<ol>
<li>看了视频，对应这个图. 重复的原因在于树宽 第二次取1的地方，因为第1次取1，已经包括了第二次取1的所有树枝。所以把第二次取1的树枝剪掉既可。</li>
<li>剪枝条件1：candidates[i] == candidates[i - 1] </li>
<li>剪枝条件2: 通过设置used数组，只有used[i - 1] 是false才有意义, used[i - 1]= false ,说明数组的第一个1没有取，取的是第二个1，结果是[1,2]，所以可以舍弃掉，否则导致和第一次的取第一个1和下一层取2,结果是[1,2]重复了。这样判断就可以把 第二次取1的这个枝干给剪掉。 也叫 树层去重。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">val</span> path = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="keyword">val</span> result = ArrayList&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">combinationSum2</span><span class="params">(candidates: <span class="type">IntArray</span>, target: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    Arrays.sort(candidates)</span><br><span class="line">    println(candidates.joinToString())</span><br><span class="line">    <span class="keyword">val</span> used = BooleanArray(candidates.size)</span><br><span class="line">    backTrack(candidates, target, <span class="number">0</span>, used, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(candidates: <span class="type">IntArray</span>, target: <span class="type">Int</span>, startIndex: <span class="type">Int</span>, used: <span class="type">BooleanArray</span>, layer: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">        result.add(path.toList())</span><br><span class="line">        println(path)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex until candidates.size) &#123;</span><br><span class="line">        println(<span class="string">&quot;layer<span class="variable">$layer</span> i: <span class="variable">$i</span> candidates[i]: <span class="subst">$&#123;candidates[i]&#125;</span>   used: <span class="subst">$&#123;used[i]&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            println(<span class="string">&quot;continue <span class="subst">$&#123;candidates[i]&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        path.add(candidates[i])</span><br><span class="line">        sum += candidates[i]</span><br><span class="line">        used[i] = <span class="literal">true</span></span><br><span class="line">        println(<span class="string">&quot;path <span class="variable">$path</span>&quot;</span>)</span><br><span class="line">        backTrack(candidates, target, i + <span class="number">1</span>, used, layer + <span class="number">1</span>) <span class="comment">// 经过日志排查后, i + 1之前写的是 startIndex +1, 第二层报错</span></span><br><span class="line">        path.remove(candidates[i])</span><br><span class="line">        println(<span class="string">&quot;path backTrack <span class="variable">$path</span>&quot;</span>)</span><br><span class="line">        sum -= candidates[i]</span><br><span class="line">        used[i] = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131.分割回文串"></a>131.分割回文串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;aab&quot;</span><br><span class="line">输出：[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]</span><br></pre></td></tr></table></figure>

<p>没想明白 [[“a”,”a”,”b”],[“aa”,”b”]] 这个数组是怎么弄出来的。</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1c54y1e7k6">https://www.bilibili.com/video/BV1c54y1e7k6</a></p>
<p>这题是边看答案变做出来的。</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg" alt="131.分割回文串"></p>
<p>根据上图可以这样理解 ，</p>
<ol>
<li>DFS递归是 纵向切割， a|ab 取[a],  a|a|b 取 [a,a] , a|a|b| 最终到叶子节点取 [a,a,b]，到终点。</li>
<li>for循环是横向切割 。</li>
<li>  val str = s.substring(startIndex,i+1) // 这个也很关键，startIndex作为分割的起点</li>
</ol>
<p>这题类似于树中符合条件的所有的路径，一旦纵向路径中，有一个不符合条件[a,ab] ab不符合，就直接回溯去其他路径.所以放if里判断递归会更好。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = ArrayList&lt;List&lt;String&gt;&gt;()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> path = ArrayList&lt;String&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">partition</span><span class="params">(s: <span class="type">String</span>)</span></span>: List&lt;List&lt;String&gt;&gt; &#123;</span><br><span class="line">    backTrack(s, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(s: <span class="type">String</span>, startIndex: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (startIndex &gt;= s.length) &#123; <span class="comment">// 纵向到叶子节点，就网上回溯</span></span><br><span class="line">        result.add(path.toList())</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">//可以用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex until s.length) &#123;  <span class="comment">//for循环是 横向切割</span></span><br><span class="line">        <span class="keyword">if</span> (isPalindromeNum(s,startIndex,i+<span class="number">1</span>))&#123; <span class="comment">// 判断startIndex,到 i+1是否是回文串</span></span><br><span class="line">            <span class="keyword">val</span> str = s.substring(startIndex,i+<span class="number">1</span>) <span class="comment">// 这个也很关键，startIndex作为分割的起点</span></span><br><span class="line">            path.add(str)</span><br><span class="line">          </span><br><span class="line">       <span class="comment">// backTrack(s, i + 1)    //递归是 纵向切割，也没有循环。这个放if里面可能更好.</span></span><br><span class="line">       <span class="comment">// path.removeAt(path.size-1)</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">continue</span> <span class="comment">// 如ab不是回文串，也不用继续了 </span></span><br><span class="line">        &#125;</span><br><span class="line">        backTrack(s, i + <span class="number">1</span>)    <span class="comment">//递归是 纵向切割，也没有循环。这个放if里面可能更好.</span></span><br><span class="line">        path.removeAt(path.size-<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isPalindromeNum</span><span class="params">(str: <span class="type">String</span>,start:<span class="type">Int</span>,end:<span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> charArray = str.substring(start,end)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until charArray.length / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (charArray[i] != charArray[charArray.length - <span class="number">1</span> - i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="优化解法"><a href="#优化解法" class="headerlink" title="优化解法"></a>优化解法</h5><p>对判断是否回文串的优化.</p>
<h4 id="93-复原-IP-地址"><a href="#93-复原-IP-地址" class="headerlink" title="93.复原 IP 地址"></a>93.复原 IP 地址</h4><p>我的分析</p>
<p>这题和上面131类似，可以通过切割方式解决。</p>
<ol>
<li>ip地址都有四位，需要切割4次，所以树的深度是4。也是回溯终止条件之一，startIndex是切割线。(应该是i+1是切割线，否则只能分割一个字母)</li>
<li>选取有效的ip, 前导不为0，只能是数字。</li>
<li>&lt;255 , 可以限制树的宽度。</li>
</ol>
<p>我写完代码后，切割成这样 2.5.5.2， 不是全部的数字，没想到什么方式能切割所有的数字。</p>
<p>s.substring(startIndex, s.length) 先分割前三个，然后判断最后一个字符串，这样就能分割所有的字母。</p>
<p>startIndex解释，下面这张图更清楚，第一层取 元素2.</p>
<p><img src="https://img-blog.csdnimg.cn/202011232041348.png" alt="78.子集"></p>
<p><img src="https://img-blog.csdnimg.cn/20201123203735933.png" alt="93.复原IP地址"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = ArrayList&lt;String&gt;()</span><br><span class="line"><span class="keyword">val</span> path = ArrayList&lt;String&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">restoreIpAddresses</span><span class="params">(s: <span class="type">String</span>)</span></span>: List&lt;String&gt; &#123;</span><br><span class="line">    backTrack(s, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(s: <span class="type">String</span>, startIndex: <span class="type">Int</span>, layer: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 看了随想录解法，这里加上终止条件会更好。</span></span><br><span class="line">    <span class="keyword">if</span> (layer == <span class="number">3</span>) &#123;   <span class="comment">// 第三个分割线</span></span><br><span class="line">        <span class="keyword">val</span> substring = s.substring(startIndex, s.length) <span class="comment">// 这里的方式就解决了，分割所有子串的问题，最后一次分割，直接到字符串的终点。</span></span><br><span class="line">        <span class="keyword">if</span> (isValid(substring)) &#123;</span><br><span class="line">            path.add(substring)</span><br><span class="line">            result.add(path.toList().joinToString(separator = <span class="string">&quot;.&quot;</span>))</span><br><span class="line">            path.removeAt(path.size-<span class="number">1</span>) <span class="comment">// 最后的字符串回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex until s.length) &#123;</span><br><span class="line">        <span class="keyword">val</span> substring = s.substring(startIndex, i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (isValid(substring)) &#123;</span><br><span class="line">            path.add(substring)</span><br><span class="line">            backTrack(s, i + <span class="number">1</span>, layer + <span class="number">1</span>) <span class="comment">// 注意我这里经常传错用 startIndex,如果第一次已经分割到了超过第2个位置，那么就应该传这个位置，</span></span><br><span class="line">            path.removeAt(path.size-<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断字符串s在左闭又闭区间[start, end]所组成的数字是否合法</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isValid</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> start = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> end = s.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s[start] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; start != end) &#123; <span class="comment">// 0开头的数字不合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> start..end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt; <span class="string">&#x27;9&#x27;</span> || s[i] &lt; <span class="string">&#x27;0&#x27;</span>) &#123; <span class="comment">// 遇到非数字字符不合法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num = num * <span class="number">10</span> + (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (num &gt; <span class="number">255</span>) &#123; <span class="comment">// 如果大于255了不合法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/">78. 子集</a></h4><p><img src="https://img-blog.csdnimg.cn/202011232041348.png" alt="78.子集"></p>
<p>这题把上图画出来后，还是比较简单的。只要把所有步数情况添加就可以了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = ArrayList&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line"><span class="keyword">val</span> path = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">subsets</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    backTrack(nums, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(nums: <span class="type">IntArray</span>, startIndex: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    result.add(path.toList()) <span class="comment">// 这棵树所有的步长，都添加</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex until nums.size) &#123;</span><br><span class="line">        path.add(nums[i])</span><br><span class="line">        backTrack(nums, i + <span class="number">1</span>) <span class="comment">// 注意</span></span><br><span class="line">        path.remove(nums[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90.子集 II"></a>90.<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets-ii/description/">子集 II</a></h4><p><img src="https://img-blog.csdnimg.cn/20201124195411977.png" alt="90.子集II"></p>
<p>第一层 第二列取元素2的时候，此时子集就有2了，第三列再取就重复了。</p>
<p>从图中可以看出，同一树层上重复取2 就要过滤掉，同一树枝上就可以重复取2，因为同一树枝上元素的集合才是唯一子集！</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> result = ArrayList&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> path = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">subsetsWithDup</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">        Arrays.sort(nums)</span><br><span class="line">        <span class="keyword">val</span> used = BooleanArray(nums.size)</span><br><span class="line">        backTrack(nums, used, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(nums: <span class="type">IntArray</span>, used: <span class="type">BooleanArray</span>, startIndex: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        result.add(path.toList())</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex until nums.size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            used[i] = <span class="literal">true</span></span><br><span class="line">            path.add(nums[i])</span><br><span class="line">            backTrack(nums,used,i+<span class="number">1</span>)</span><br><span class="line">            path.remove(nums[i])</span><br><span class="line">            used[i] = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>!used[i - 1] 这个条件是判断树层的条件，否则会把树枝给剪掉了。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>本题也可以不使用used数组来去重，因为递归的时候下一个startIndex是i+1而不是0。</p>
<p>随想录这句没理解。</p>
<h4 id="491-递增子序列"><a href="#491-递增子序列" class="headerlink" title="491.递增子序列"></a>491.递增子序列</h4><ol>
<li><p>不能排序,所以子集中used解法不行</p>
</li>
<li><p>树枝中小心判断大小。</p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1EG4y1h78v/">https://www.bilibili.com/video/BV1EG4y1h78v/</a></p>
<p>一开始按照下面子集的解法做的,但是存在问题，子集是经过排序后的，然后nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]这样的条件判断，这题不能排序的，所以情况不一样。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(nums: <span class="type">IntArray</span>, used: <span class="type">BooleanArray</span>, startIndex: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.size &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        result.add(path.toList())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex until nums.size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt; nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        path.add(nums[i])</span><br><span class="line">        used[i] = <span class="literal">true</span></span><br><span class="line">        backTrack(nums,used,i+<span class="number">1</span>)</span><br><span class="line">        path.remove(nums[i])</span><br><span class="line">        used[i] = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://img-blog.csdnimg.cn/20201124200229824.png" alt="491. 递增子序列1"></p>
<p>上图可以看到，树层中是不能重复的，因为签名的 7包含后面7的所有情况。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> result = ArrayList&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> path = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findSubsequences</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">        backTrack(nums, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(nums: <span class="type">IntArray</span>, startIndex: <span class="type">Int</span>, layer: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size &gt; <span class="number">1</span>) &#123;                      <span class="comment">//  至少有两个元素</span></span><br><span class="line">            result.add(path.toList())</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">set</span> = mutableSetOf&lt;<span class="built_in">Int</span>&gt;()             <span class="comment">// 树层中是否包含 相同的元素。</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex until nums.size) &#123;</span><br><span class="line"><span class="comment">//            println(&quot;startIndex $startIndex set $set&quot;)</span></span><br><span class="line">            <span class="keyword">if</span> (layer == <span class="number">0</span>) &#123;</span><br><span class="line">                println(<span class="string">&quot;layer  set <span class="variable">$set</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((path.isNotEmpty() &amp;&amp; nums[i] &lt; path.last()) || <span class="keyword">set</span>.contains(nums[i])) &#123; <span class="comment">// 小于上一个元素，这个分支以下不用走了， set树层中包含相同的与元素。</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">set</span>.add(nums[i])  <span class="comment">//因为是判断树层，而且是每一层都局部会new 一个set，所以这个没有回溯。</span></span><br><span class="line">            path.add(nums[i])</span><br><span class="line">            backTrack(nums, i + <span class="number">1</span>, layer + <span class="number">1</span>)</span><br><span class="line">            path.remove(nums[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(nums: <span class="type">IntArray</span>, startIndex: <span class="type">Int</span>, layer: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.size &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        result.add(path.toList())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> used = IntArray(<span class="number">201</span>) <span class="comment">// -100 &lt;= nums[i] &lt;= 100 ， 包括 0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex until nums.size) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((path.isNotEmpty() &amp;&amp; nums[i] &lt; path.last()) || used[nums[i] + <span class="number">100</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        used[nums[i] + <span class="number">100</span>] = <span class="number">1</span></span><br><span class="line">        path.add(nums[i])</span><br><span class="line">        backTrack(nums, i + <span class="number">1</span>, layer + <span class="number">1</span>)</span><br><span class="line">        path.remove(nums[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="46全排列"><a href="#46全排列" class="headerlink" title="46全排列"></a>46全排列</h4><p>[1,2,3] 选了2之后， 1，3 就不知道从哪里开始了，子集问题有个startIndex</p>
<h5 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> result = ArrayList&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> path = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">permute</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> size = nums.size</span><br><span class="line">    <span class="keyword">val</span> used = BooleanArray(size)</span><br><span class="line">    backTrack(nums, used)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(nums: <span class="type">IntArray</span>, used: <span class="type">BooleanArray</span>)</span></span> &#123;</span><br><span class="line">    println(path)</span><br><span class="line">  <span class="comment">//if (totalUsed(used)) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (totalUsed(used)) &#123;</span><br><span class="line">        result.add(path.toList())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ((index, value) <span class="keyword">in</span> nums.withIndex()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (used[index]) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        path.add(nums[index])</span><br><span class="line">        used[index] = <span class="literal">true</span></span><br><span class="line">        backTrack(nums, used)</span><br><span class="line">        path.remove(nums[index])</span><br><span class="line">        used[index] = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">totalUsed</span><span class="params">(used: <span class="type">BooleanArray</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> used.contains(<span class="literal">false</span>).not()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>先画图分析 </p>
<p><img src="https://img-blog.csdnimg.cn/20201209174225145.png" alt="46.全排列"></p>
<p>单测中把数据打印出来，能大概理清这种思路，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[]</span><br><span class="line">[1]</span><br><span class="line">[1, 2]</span><br><span class="line">[1, 2, 3]</span><br><span class="line">[1, 3]</span><br><span class="line">[1, 3, 2]</span><br><span class="line">[2]</span><br><span class="line">[2, 1]</span><br><span class="line">[2, 1, 3]</span><br><span class="line">[2, 3]</span><br><span class="line">[2, 3, 1]</span><br><span class="line">[3]</span><br><span class="line">[3, 1]</span><br><span class="line">[3, 1, 2]</span><br><span class="line">[3, 2]</span><br><span class="line">[3, 2, 1]</span><br><span class="line">[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]</span><br></pre></td></tr></table></figure>





<h4 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47.全排列 II"></a>47.全排列 II</h4><p>我的解法有一点点问题[2,2,1,1]这个跑步过去,path.removeAt(path.lastIndex),看了随想录的解法和我没区别，才发现这里的。</p>
<p>思路</p>
<ol>
<li>和组合去重没区别 ,(index &gt; 0 &amp;&amp; nums[index] == nums[index - 1] &amp;&amp; !used[index - 1])重复元素，树层去重</li>
<li>全排列使用过的元素。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> path = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> result = ArrayList&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">permuteUnique</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">        Arrays.sort(nums)</span><br><span class="line"><span class="comment">//        nums.printIntArray()</span></span><br><span class="line">        <span class="keyword">val</span> used = BooleanArray(nums.size)</span><br><span class="line">        backTrack(nums, used)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    private fun backTrack(nums: IntArray, used: BooleanArray) &#123;</span></span><br><span class="line"><span class="comment">//        println(path)</span></span><br><span class="line"><span class="comment">//        if (path.size == nums.size) &#123;</span></span><br><span class="line"><span class="comment">//            result.add(path.toList())</span></span><br><span class="line"><span class="comment">//            return</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        for ((index, value) in nums.withIndex()) &#123;</span></span><br><span class="line"><span class="comment">//            if (used[index] || (index &gt; 0 &amp;&amp; nums[index] == nums[index - 1] &amp;&amp; !used[index - 1])) &#123;</span></span><br><span class="line"><span class="comment">//                continue</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            used[index] = true</span></span><br><span class="line"><span class="comment">//            path.add(value)</span></span><br><span class="line"><span class="comment">//            backTrack(nums, used)</span></span><br><span class="line"><span class="comment">//            used[index] = false</span></span><br><span class="line"><span class="comment">//            path.remove(value)</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(nums: <span class="type">IntArray</span>, used: <span class="type">BooleanArray</span>)</span></span> &#123;</span><br><span class="line">        println(path)</span><br><span class="line">        <span class="keyword">if</span> (path.size == nums.size) &#123;</span><br><span class="line">            result.add(path.toList())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (index <span class="keyword">in</span> nums.indices) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((index &gt; <span class="number">0</span> &amp;&amp; nums[index] == nums[index - <span class="number">1</span>] &amp;&amp; !used[index - <span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (used[index]) &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            used[index] = <span class="literal">true</span></span><br><span class="line">            path.add(nums[index])</span><br><span class="line">            backTrack(nums, used)</span><br><span class="line">            path.removeAt(path.lastIndex) <span class="comment">// 用path.remove(value)是有问题的，会把所有的这个元素删除掉，46没问题是因为没有重复元素，leetcode removeLast() cannot build</span></span><br><span class="line">            used[index] = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="332-重新安排行程"><a href="#332-重新安排行程" class="headerlink" title="332.重新安排行程"></a>332.重新安排行程</h4><p>随想录解法那个数组处理没看明白</p>
<p>这里用到的回溯，就是目的地可能有多个。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reconstruct-itinerary/solutions/654811/java-bu-yong-ou-la-zhi-yong-hui-su-si-lu-4v83/">https://leetcode.cn/problems/reconstruct-itinerary/solutions/654811/java-bu-yong-ou-la-zhi-yong-hui-su-si-lu-4v83/</a></p>
<p>看了他的视频</p>
<ol>
<li>给定的tickets转成 from to 的结构,就可以知道出发点对应的，到达点和到达点的线路数。 // 这个数据处理也是有点麻烦的。</li>
<li>根据多个到达点回溯，找到最合适的路径</li>
<li>如果到达点的是线路是0，那么找下一题跳线路。</li>
<li> 遇到的机场个数path ==航班数量+</li>
</ol>
<p>putIfAbsent</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hbtj_1216/article/details/75093428">https://blog.csdn.net/hbtj_1216/article/details/75093428</a></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> path = ArrayList&lt;String&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findItinerary</span><span class="params">(tickets: <span class="type">List</span>&lt;<span class="type">List</span>&lt;<span class="type">String</span>&gt;&gt;)</span></span>: List&lt;String&gt; &#123;</span><br><span class="line">    <span class="comment">//1. list转成 from to 的结构</span></span><br><span class="line">    <span class="comment">//2. 回溯找到最合适的路径</span></span><br><span class="line">    <span class="comment">//3.  遇到的机场个数path ==航班数量+</span></span><br><span class="line">    <span class="keyword">val</span> hashMap = HashMap&lt;String, TreeMap&lt;String, <span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line">    tickets.stream().forEach &#123; ticket -&gt;</span><br><span class="line">        <span class="keyword">val</span> from = ticket[<span class="number">0</span>] <span class="comment">// 出发地</span></span><br><span class="line">        <span class="keyword">val</span> to = ticket[<span class="number">1</span>]  <span class="comment">//目的地</span></span><br><span class="line"></span><br><span class="line">        hashMap.putIfAbsent(from, TreeMap())</span><br><span class="line">        <span class="keyword">val</span> treeMap = hashMap[from] ?: TreeMap()  <span class="comment">//获取出发地对应的容器TreeMap,如果之前没用过的出发地key,那么新建一个容器TreeMap</span></span><br><span class="line">        treeMap[to] = treeMap.getOrDefault(to, <span class="number">0</span>) + <span class="number">1</span> <span class="comment">// 容器内，目的地的个数++,一开始这里写的有问题。</span></span><br><span class="line">    &#125;</span><br><span class="line">    path.add(<span class="string">&quot;JFK&quot;</span>) <span class="comment">// 所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。</span></span><br><span class="line">    backTrack(hashMap, tickets.size)</span><br><span class="line">    <span class="keyword">return</span> path</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(hashMap: <span class="type">HashMap</span>&lt;<span class="type">String</span>, TreeMap&lt;String, <span class="built_in">Int</span>&gt;&gt;, ticketSize: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.size == ticketSize + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.根据path找到出发点,从hashmap根据出发点找到对应的 可能多个到达点</span></span><br><span class="line">    <span class="comment">// 2. 多个可能的目的地进行回溯.</span></span><br><span class="line">    <span class="keyword">val</span> recentTo = path[path.size - <span class="number">1</span>] <span class="comment">//path.last() LeetCode build failed</span></span><br><span class="line">    <span class="keyword">val</span> toDestinations = hashMap[recentTo]</span><br><span class="line">    <span class="keyword">if</span> (toDestinations.isNullOrEmpty()) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> (to <span class="keyword">in</span> toDestinations) &#123;<span class="comment">// forEach也行, for习惯点</span></span><br><span class="line">        <span class="keyword">if</span> (to.value == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        path.add(to.key)</span><br><span class="line">        to.setValue(to.value - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (backTrack(hashMap, ticketSize)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        path.removeAt(path.size - <span class="number">1</span>)</span><br><span class="line">        to.setValue(to.value + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="51-N-皇后"><a href="#51-N-皇后" class="headerlink" title="51.N 皇后"></a>51.N 皇后</h4><img src="https://img-blog.csdnimg.cn/20210130182532303.jpg" alt="51.N皇后" style="zoom:50%;">



<p>这题思路不难，实现还是有难度，主要是皇后冲突代码不好理解，<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1bK4y1n7iq">https://www.bilibili.com/video/BV1bK4y1n7iq</a></p>
<p>大概11分钟，判断 皇后位置的冲突情况。</p>
<ol>
<li>这一题思路就是主要 首先行，然后列摆放皇后问题，然后回溯。</li>
<li>还一个就是将要放下皇后的位置之前，8个方向只用考虑3个,确定左上，正上方，右上方的皇后是否存在。当前行不用考了，因为每行一个，后面的更不看了，因为还没放皇后.</li>
<li>最后就是要注意边界的问题，二刷的时候尤其注意这个。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="comment">//1. 初始化棋盘放上.</span></span><br><span class="line">    <span class="keyword">char</span>[][] chessBoard = <span class="keyword">new</span> <span class="keyword">char</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span>[] c : chessBoard) &#123;</span><br><span class="line">        Arrays.fill(c, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 开始放Queue,首先从行开始，一行一行回溯的放， 然后每一行开始从第1列开始。</span></span><br><span class="line">    <span class="comment">// 3. 每次新的一行开始放Queue时，要考虑当前位置列的 前面的列有没有Queue,</span></span><br><span class="line">    <span class="comment">// 当前位置的左边45度和135度有没有Queue,对于当前行和后面的行和斜对角不用考虑，因为每一行只有一个Queue,后面的行更是没有。</span></span><br><span class="line">    <span class="comment">//4 。只有能放下，才会放后续的，然后进行回溯.</span></span><br><span class="line">    <span class="comment">//5. 当放下的Queue时最后一行n时，递归结束，开始收集结果。</span></span><br><span class="line">    backTrack(n, <span class="number">0</span>, chessBoard);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> row, <span class="keyword">char</span>[][] chessBoard)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == row) &#123;</span><br><span class="line">        result.add(Array2List(chessBoard));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; n; ++column) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isValid(row, column, chessBoard, n)) &#123; <span class="comment">// row,column待放入Queue的位置</span></span><br><span class="line">            chessBoard[row][column] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            backTrack(n, row + <span class="number">1</span>, chessBoard);</span><br><span class="line">            chessBoard[row][column] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> pRow, <span class="keyword">int</span> pColumn, <span class="keyword">char</span>[][] chessBoard, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pRow; ++i) &#123; <span class="comment">//列</span></span><br><span class="line">        <span class="keyword">if</span> (chessBoard[i][pColumn] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = pRow - <span class="number">1</span>, y = pColumn - <span class="number">1</span>; x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span>; x--, y--) &#123; <span class="comment">//左上角 首次==边界错了</span></span><br><span class="line">        <span class="keyword">if</span> (chessBoard[x][y] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = pRow - <span class="number">1</span>, y = pColumn + <span class="number">1</span>; x &gt;= <span class="number">0</span> &amp;&amp; y &lt;= n - <span class="number">1</span>; x--, y++) &#123;<span class="comment">//右上角  首次==,n-1边界错了 ,y &lt; n - 1一开始写成这样，找了半天</span></span><br><span class="line">        <span class="keyword">if</span> (chessBoard[x][y] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List <span class="title">Array2List</span><span class="params">(<span class="keyword">char</span>[][] chessboard)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span>[] c : chessboard) &#123;</span><br><span class="line">        list.add(String.copyValueOf(c));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这题for里面有x,y两个变量，kotlin不好弄，就用java了。</p>
<h4 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37.解数独"></a>37.解数独</h4><p>随想录讲解.</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1TW4y1471V/">https://www.bilibili.com/video/BV1TW4y1471V/</a></p>
<p><img src="/2022/10/30/LC-backtrack-combination/20230102104449.jpg" alt="20230102104449"></p>
<p><a target="_blank" rel="noopener" href="https://xiaochen1024.com/video?id=6285f1b6ede03c002e46b218">https://xiaochen1024.com/video?id=6285f1b6ede03c002e46b218</a></p>
<p>根据下面公式可以找到 3 *3的开始位置。</p>
<pre><code>val startRow = (row / 3) * 3    
val startColumn = (column / 3) * 3
</code></pre>
<p>把红方框代入进去， val 3 = (4 / 3) * 3    就是红色箭头的位置。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.先行 后列的顺序，找到字符位 &#x27;.&#x27;的空格，填入 1 - 9 的数字</span></span><br><span class="line"><span class="comment">// 2.填入后，开始回溯</span></span><br><span class="line"><span class="comment">// 3.填入空格的时候，如果没有返回true,if就返回false</span></span><br><span class="line"><span class="comment">// 4. 如果全部填满了都没返回true,此时说明已经到了叶子节点，直接返回true.</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">solveSudoku</span><span class="params">(board: <span class="type">Array</span>&lt;<span class="type">CharArray</span>&gt;)</span></span>: <span class="built_in">Unit</span> &#123;</span><br><span class="line">    backTrack(board)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(board: <span class="type">Array</span>&lt;<span class="type">CharArray</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> board.indices) &#123;   <span class="comment">// 遍历行</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> board[<span class="number">0</span>].indices) &#123;<span class="comment">// 遍历列</span></span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (k <span class="keyword">in</span> <span class="string">&#x27;1&#x27;</span>..<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isValid(i, j, k, board)) &#123;</span><br><span class="line">                        board[i][j] = k</span><br><span class="line">                        <span class="keyword">if</span> (backTrack(board)) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        board[i][j] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">//放上面一层，循环后直接返回false了,// 9个数都试完了，都不行，那么就返回false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isValid</span><span class="params">(row: <span class="type">Int</span>, column: <span class="type">Int</span>, k: <span class="type">Char</span>, board: <span class="type">Array</span>&lt;<span class="type">CharArray</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> board[<span class="number">0</span>].indices) &#123; <span class="comment">// 判断行里是否重复,一开始不理解很多解法包括，随想录用的是9,这样如果不是9*9就有问题了,原来题目给的就是9*9的方格</span></span><br><span class="line">        <span class="keyword">if</span> (board[row][i] == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> board.indices) &#123;  <span class="comment">// 判断列里是否重复</span></span><br><span class="line">        <span class="keyword">if</span> (board[i][column] == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> startRow = (row / <span class="number">3</span>) * <span class="number">3</span>    </span><br><span class="line">    <span class="keyword">val</span> startColumn = (column / <span class="number">3</span>) * <span class="number">3</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> startRow until (startRow + <span class="number">3</span>)) &#123;  <span class="comment">// 判断9方格里是否重复</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> startColumn until startColumn + <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == k) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
        
          <blockquote id="copyright">
              <p>Original link: <a href="https://noteforme.github.io/index.html">https://noteforme.github.io/index.html</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LEETCODE/" rel="tag">LEETCODE</a></li></ul>

          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>



    <nav id="page-nav">

<span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/2/">Next</a>
</nav>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-posts"></i> Recent</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/09/04/Android_interview%20organize/">Android_itnerview_organize</a>
          </li>
        
          <li>
            <a href="/2023/09/03/Android-itnerview-algorithm/">Android_itnerview_algorithm</a>
          </li>
        
          <li>
            <a href="/2023/08/20/compose-layout/">compose_layout</a>
          </li>
        
          <li>
            <a href="/2023/08/19/compose/">compose</a>
          </li>
        
          <li>
            <a href="/2023/08/09/LC-DP-BAG/">LC_DP_BAG</a>
          </li>
        
      </ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-tag"></i> Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ANDROID/" style="font-size: 13.33px;">ANDROID</a> <a href="/tags/AOSP/" style="font-size: 16.67px;">AOSP</a> <a href="/tags/Activity/" style="font-size: 10px;">Activity</a> <a href="/tags/AndroidNewFeatures/" style="font-size: 10px;">AndroidNewFeatures</a> <a href="/tags/Assembly/" style="font-size: 10px;">Assembly</a> <a href="/tags/BLOG/" style="font-size: 10px;">BLOG</a> <a href="/tags/ConstraintLayout/" style="font-size: 10px;">ConstraintLayout</a> <a href="/tags/DB/" style="font-size: 11.67px;">DB</a> <a href="/tags/Drawer/" style="font-size: 10px;">Drawer</a> <a href="/tags/Fragment/" style="font-size: 11.67px;">Fragment</a> <a href="/tags/Git/" style="font-size: 11.67px;">Git</a> <a href="/tags/JVM/" style="font-size: 18.33px;">JVM</a> <a href="/tags/LEETCODE/" style="font-size: 20px;">LEETCODE</a> <a href="/tags/Operators/" style="font-size: 10px;">Operators</a> <a href="/tags/Performance/" style="font-size: 15px;">Performance</a> <a href="/tags/RecyclerView/" style="font-size: 11.67px;">RecyclerView</a> <a href="/tags/RxJava/" style="font-size: 15px;">RxJava</a> <a href="/tags/THINK/" style="font-size: 10px;">THINK</a> <a href="/tags/TOOL/" style="font-size: 11.67px;">TOOL</a> <a href="/tags/TabLayout/" style="font-size: 10px;">TabLayout</a> <a href="/tags/Test/" style="font-size: 15px;">Test</a> <a href="/tags/TouchEvent/" style="font-size: 13.33px;">TouchEvent</a> <a href="/tags/VIEW/" style="font-size: 11.67px;">VIEW</a> <a href="/tags/XML/" style="font-size: 10px;">XML</a> <a href="/tags/anim/" style="font-size: 10px;">anim</a> <a href="/tags/compose/" style="font-size: 11.67px;">compose</a> <a href="/tags/concurrency/" style="font-size: 15px;">concurrency</a> <a href="/tags/coroutie/" style="font-size: 16.67px;">coroutie</a> <a href="/tags/inter/" style="font-size: 18.33px;">inter</a> <a href="/tags/keyboard/" style="font-size: 10px;">keyboard</a> <a href="/tags/proguard/" style="font-size: 10px;">proguard</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-classify"></i> Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ANDROID/">ANDROID</a><span class="category-list-count">59</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/BLE/">BLE</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/DataStructure/">DataStructure</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/DesignPatterns/">DesignPatterns</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ENGLISH/">ENGLISH</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/">JAVA</a><span class="category-list-count">27</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Jetpack/">Jetpack</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kotlin/">Kotlin</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/LINUX/">LINUX</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mathematics/">Mathematics</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS/">OS</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Organization/">Organization</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SOURCE/">SOURCE</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/TEST/">TEST</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/TOOL/">TOOL</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/VIEW/">VIEW</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/anim/">anim</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/flutter/">flutter</a><span class="category-list-count">5</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-archive"></i> Archive</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/">2023年09月</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022年12月</a><span class="archive-list-count">33</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021年12月</a><span class="archive-list-count">23</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020年12月</a><span class="archive-list-count">46</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019年12月</a><span class="archive-list-count">21</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/">2018年11月</a><span class="archive-list-count">32</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">2017年12月</a><span class="archive-list-count">57</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-tag"></i> Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ANDROID/" rel="tag">ANDROID</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AOSP/" rel="tag">AOSP</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Activity/" rel="tag">Activity</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AndroidNewFeatures/" rel="tag">AndroidNewFeatures</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Assembly/" rel="tag">Assembly</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BLOG/" rel="tag">BLOG</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ConstraintLayout/" rel="tag">ConstraintLayout</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DB/" rel="tag">DB</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Drawer/" rel="tag">Drawer</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fragment/" rel="tag">Fragment</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LEETCODE/" rel="tag">LEETCODE</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Operators/" rel="tag">Operators</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Performance/" rel="tag">Performance</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RecyclerView/" rel="tag">RecyclerView</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RxJava/" rel="tag">RxJava</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/THINK/" rel="tag">THINK</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TOOL/" rel="tag">TOOL</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TabLayout/" rel="tag">TabLayout</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Test/" rel="tag">Test</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TouchEvent/" rel="tag">TouchEvent</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VIEW/" rel="tag">VIEW</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XML/" rel="tag">XML</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/anim/" rel="tag">anim</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/compose/" rel="tag">compose</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/concurrency/" rel="tag">concurrency</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/coroutie/" rel="tag">coroutie</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/inter/" rel="tag">inter</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/keyboard/" rel="tag">keyboard</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/proguard/" rel="tag">proguard</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-link"></i> Blogroll</h3>
    <div class="widget">
      <ul>
      
        <li>
          <a target="_blank" rel="noopener" href="http://www.example1.com/">site-name1</a>
        </li>
      
        <li>
          <a target="_blank" rel="noopener" href="http://www.example2.com/">site-name2</a>
        </li>
      
        <li>
          <a target="_blank" rel="noopener" href="http://www.example3.com/">site-name3</a>
        </li>
      
      </ul>
    </div>
  </div>


  
</aside>
        
      </div>
      <a id="totop" href="#top"></a>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      <p>
        <a href="/sitemap.xml">Site Map</a>
        <span> | </span><a href="/atom.xml">Subscribe to this site</a>
        <span> | </span><a href="/about/">Contact the blogger</a>
      </p>
      
        <p>
          <i class="fa fa-visitors"></i>
          <i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>
          ，
          <i class="fa fa-views"></i>
          <i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>
        </p>
      
      <p>
        <span>Copyright &copy; 2023 Jon.</span>
        <span>Theme by <a href="https://github.com/chaooo/hexo-theme-BlueLake/" target="_blank">BlueLake.</a></span>
        
            <span>Count by <a href="http://busuanzi.ibruce.info/" target="_blank">busuanzi.</a></span>
        
        <span>Powered by <a href="https://hexo.io/" target="_blank">Hexo.</a></span>
      </p>
    </div>
  </div>
</footer>

    </div>
    
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/search.json.js"></script>


  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>






  
<script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



  
<script src="/localshare/js/social-share.js"></script>

  
<script src="/localshare/js/qrcode.js"></script>




















  </div>
</body>
</html>