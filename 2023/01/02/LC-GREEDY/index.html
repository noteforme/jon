

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Jon">
  <meta name="keywords" content="">
  
    <meta name="description" content="https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1sA4y1S7Sp 这个视频讲到暴力 对数器可以验证答案，有意思。 有同学问了如何验证可不可以用贪心算法呢？ 刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心。 贪心算法一般分为如下四步：  将问题分解为若干个子问题 找出适合的贪心策略 求解每一个子问题的最优解 将局部最优解堆叠成全局">
<meta property="og:type" content="article">
<meta property="og:title" content="LC-GREEDY">
<meta property="og:url" content="https://noteforme.github.io/2023/01/02/LC-GREEDY/index.html">
<meta property="og:site_name" content="Jon&#39;s Blog">
<meta property="og:description" content="https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1sA4y1S7Sp 这个视频讲到暴力 对数器可以验证答案，有意思。 有同学问了如何验证可不可以用贪心算法呢？ 刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心。 贪心算法一般分为如下四步：  将问题分解为若干个子问题 找出适合的贪心策略 求解每一个子问题的最优解 将局部最优解堆叠成全局">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://noteforme.github.io/2023/01/02/LC-GREEDY/2023-01-18-9.11.23.png">
<meta property="og:image" content="https://code-thinking.cdn.bcebos.com/gifs/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020112917480858.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201124154758229.png">
<meta property="og:image" content="https://noteforme.github.io/2023/01/02/LC-GREEDY/20230211173204.jpg">
<meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20230201164134.png">
<meta property="article:published_time" content="2023-01-02T14:42:03.000Z">
<meta property="article:modified_time" content="2023-04-02T11:24:38.736Z">
<meta property="article:author" content="Jon">
<meta property="article:tag" content="LEETCODE">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://noteforme.github.io/2023/01/02/LC-GREEDY/2023-01-18-9.11.23.png">
  
  
  
  <title>LC-GREEDY - Jon&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"noteforme.github.io","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="LC-GREEDY"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-01-02 22:42" pubdate>
          January 2, 2023 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          4.8k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          40 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">LC-GREEDY</h1>
            
            
              <div class="markdown-body">
                
                <p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1sA4y1S7Sp">https://www.bilibili.com/video/BV1sA4y1S7Sp</a></p>
<p>这个视频讲到暴力 对数器可以验证答案，有意思。</p>
<p>有同学问了如何验证可不可以用贪心算法呢？</p>
<p><strong>刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心</strong>。</p>
<p>贪心算法一般分为如下四步：</p>
<ul>
<li>将问题分解为若干个子问题</li>
<li>找出适合的贪心策略</li>
<li>求解每一个子问题的最优解</li>
<li>将局部最优解堆叠成全局最优解</li>
</ul>
<p>这个四步其实过于理论化了，我们平时在做贪心类的题目 很难去按照这四步去思考，真是有点“鸡肋”。</p>
<p>做题的时候，只要想清楚 局部最优 是什么，如果推导出全局最优，其实就够了。</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1XY411A766">https://www.bilibili.com/video/BV1XY411A766</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Hz4y117CP/">https://www.bilibili.com/video/BV1Hz4y117CP/</a></p>
<h4 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455.分发饼干"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/assign-cookies/">455.分发饼干</a></h4><h5 id="分解题目"><a href="#分解题目" class="headerlink" title="分解题目"></a>分解题目</h5><ol>
<li>每个孩子最多只能给一块饼干。</li>
<li>每个孩子 <code>i</code>，都有一个胃口值 <code>g[i]</code>，每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code>。</li>
</ol>
<h5 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g &#x3D; [1,3], s &#x3D; [1,2,4]</span><br></pre></td></tr></table></figure>

<ol>
<li><p>对孩子的胃口值和， 饼干的大小进行排序，得到两行数组。</p>
</li>
<li><p>如上面示例，s中的s[0]=1饼干大小，满足g[0]=1 孩子的胃口值,那么同时向右移动.s[1]=2 不满足g[1],s指针向右移动，s[2]满足g[1].</p>
<p>这样所有孩子都满足了。</p>
</li>
</ol>
<p>上面思路和随想录的不一样，随想录的是大饼干喂 胃口值大的孩子，不过觉得我这个更好理解。</p>
<h5 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findContentChildren</span><span class="params">(g: <span class="type">IntArray</span>, s: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.isEmpty()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    Arrays.sort(g)  <span class="comment">// 写了s.isEmpty()， 一开始忘了加这个排序</span></span><br><span class="line">    Arrays.sort(s)</span><br><span class="line">    <span class="keyword">var</span> pg = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> ps = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (pg &lt; g.size &amp;&amp; ps &lt; s.size) &#123; <span class="comment">// 控制边界</span></span><br><span class="line">        <span class="keyword">if</span> (s[ps] &gt;= g[pg]) &#123;       <span class="comment">//饼干满足孩子的胃口大小.</span></span><br><span class="line">            count++</span><br><span class="line">            pg++</span><br><span class="line">            ps++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ps++    <span class="comment">//饼干不满足孩子的胃口大小，饼干数组指针往右走.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="376摆动序列"><a href="#376摆动序列" class="headerlink" title="376摆动序列"></a>376摆动序列</h4><h5 id="Idea-1"><a href="#Idea-1" class="headerlink" title="Idea"></a>Idea</h5><p>摆动序列，其实求波峰 波谷的个数，所以有一个方向改变就算一个波动。</p>
<ol>
<li><p>根据图1可以看到</p>
<p>preDiff = 17-1 &gt;0 , curveDiff = 5 -10&lt;0 ，这个就是一个摆动序列。还有</p>
<p>preDiff = 5-10 &lt;0 , curveDiff = 16 -5&gt;0 的情况，这又是另一种情况的摆动序列。</p>
</li>
<li><p>根据图2可以看到</p>
<p>preDiff ==0  , curveDiff = 5 -2 &gt; 0,  </p>
<p>preDiff ==0  , curveDiff = 5 -8 &gt; 0,  题目说 两个不等元素的序列也视作摆动序列。所以这种情况也是摆动序列。 但是我感觉这个和前面的 “如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 <strong>摆动序列</strong>”,是有矛盾的。</p>
<p>根据 1.2,所以条件可以合并, preDiff  &gt;=0 , curveDiff &lt;=0 ,preDiff &lt;=0 , curveDiff &gt;=0</p>
</li>
<li><p>图3，只有2个摆动，但是根据根据1，2的总结代码在2,3节点处，红色pre的地方也有1个摆动，这种情况要去掉，因为他是同方向的摆动。所以pre应该停在绿色的地方，只有摆动发生她才需要改变，平波不用管。</p>
</li>
</ol>
<p><img src="/2023/01/02/LC-GREEDY/2023-01-18-9.11.23.png" srcset="/img/loading.gif" lazyload alt="2023-01-18-9.11.23"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">wiggleMaxLength</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.size &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums.size</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> preDiff = <span class="number">0</span> <span class="comment">//前一对差值</span></span><br><span class="line">    <span class="keyword">var</span> curveDiff = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until nums.size) &#123; <span class="comment">// 第一个数已经计入摆动序列了，所以从1开始</span></span><br><span class="line">        curveDiff = nums[i] - nums[i - <span class="number">1</span>] <span class="comment">// 因为要给值给preDiff，所以从i开始，随想录c++解法是从0开始的。</span></span><br><span class="line">        <span class="keyword">if</span> ((preDiff &gt;= <span class="number">0</span> &amp;&amp; curveDiff &lt; <span class="number">0</span>) || (preDiff &lt;= <span class="number">0</span> &amp;&amp; curveDiff &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">            result++</span><br><span class="line">            preDiff = curveDiff</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53 最大子序和"></a>53 最大子序和</h4><p>  -2,    1,    -3,    4,    -1,    2,    1,    -5,    4</p>
<p>*Q *P </p>
<h5 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h5><ol>
<li>题意是找到最大和的连续子数组， 所以是不能对数组排序。</li>
<li>这题可以考虑用双指针解法，移动*p，从0开始 加上指针对应的计数。如果计数增加则是正数计入，如果减小则重置，移动 *q指针。</li>
</ol>
<p>上面这个思路是不行的，4,    -1,    2,    1这种就有问题。</p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.gif" srcset="/img/loading.gif" lazyload alt="53.最大子序和"></p>
<p>间隔后新的黄色部分是重置数据。</p>
<p>根据随想录的思路</p>
<p>局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。</p>
<p>这句话看起来有问题，但是也拿不出反例.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">maxSubArray</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> maxResult = <span class="built_in">Int</span>.MIN_VALUE</span><br><span class="line">    <span class="keyword">for</span> (pIndex <span class="keyword">in</span> nums.indices) &#123;</span><br><span class="line">        result += nums[pIndex]</span><br><span class="line">        maxResult = maxResult.coerceAtLeast(result)</span><br><span class="line">        <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            result = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxResult</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122 买卖股票的最佳时机 II"></a>122 买卖股票的最佳时机 II</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7,	1,	5,	3,	6,	4</span><br><span class="line">	-6	4		-2	3		-2</span><br></pre></td></tr></table></figure>



<p>假如第0天买入，第3天卖出，那么利润为：prices[3] - prices[0]。</p>
<p>相当于(prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])。</p>
<p><strong>此时就是把利润分解为每天为单位的维度，而不是从0天到第3天整体去考虑！</strong></p>
<p>那么根据prices可以得到每天的利润序列：(prices[i] - prices[i - 1])…..(prices[1] - prices[0])。</p>
<p><img src="https://img-blog.csdnimg.cn/2020112917480858.png" srcset="/img/loading.gif" lazyload alt="122.买卖股票的最佳时机II"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">maxProfit</span><span class="params">(prices: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> diffArray = IntArray(prices.size - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until prices.size) &#123;</span><br><span class="line">        println(i)</span><br><span class="line">        diffArray[i - <span class="number">1</span>] = prices[i] - prices[i - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> diffArray.indices) &#123;</span><br><span class="line">        <span class="keyword">if</span> (diffArray[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += diffArray[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55 跳跃游戏"></a>55 跳跃游戏</h4><p>[2,3,1,1,4]</p>
<h5 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h5><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度，比如在2的位置，可以跳一格到3的位置，也可以两格到1的位置。</p>
<p><img src="https://img-blog.csdnimg.cn/20201124154758229.png" srcset="/img/loading.gif" lazyload alt="55.跳跃游戏"></p>
<p>上面第二幅图，第一条线应该有问题，应该覆盖到2 3 1</p>
<p>遍历每个位置，确定每个位置能覆盖的最大范围。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">canJump</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> coverArea = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span>.coverArea) &#123; <span class="comment">// 注意:这里是coverArea,需要确定能走多少步</span></span><br><span class="line">        coverArea = (i + nums[i]).coerceAtLeast(coverArea) <span class="comment">//新的范围和 之前的范围做比较</span></span><br><span class="line">        <span class="keyword">if</span> (coverArea &gt;= nums.size - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45 跳跃游戏 II"></a>45 跳跃游戏 II</h4><h5 id="Idea-2"><a href="#Idea-2" class="headerlink" title="Idea"></a>Idea</h5><p>题目意思 总是可以到达数组的最后一个位置</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">jump</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> maxCover = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span>.maxCover) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i + nums[i] &gt; maxCover) &#123;</span><br><span class="line">            maxCover = i + nums[i]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count++</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (maxCover &gt;= nums.size) &#123;</span><br><span class="line">            println(<span class="string">&quot;count <span class="variable">$count</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> count</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>找到能覆盖的最远距离，如果移动到了这个地方，那么就计算一次，直到  nums.size - 1- 1个节点，然后再count++就可以了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">jump</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nextCover = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> currentCover = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until nums.size - <span class="number">1</span>) &#123;</span><br><span class="line">        nextCover = Math.max(i + nums[i], nextCover)</span><br><span class="line">        <span class="keyword">if</span> (i == currentCover) &#123;</span><br><span class="line">            currentCover = nextCover</span><br><span class="line">            count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1005-K-次取反后最大化的数组和"><a href="#1005-K-次取反后最大化的数组和" class="headerlink" title="1005. K 次取反后最大化的数组和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/">1005. K 次取反后最大化的数组和</a></h4><ol>
<li>先对数组进行排序，把 &lt; 0的数按位取反 ,直到数组的数据都&gt;0,此时翻转了n次</li>
<li>对翻转后的数组重新进行排序，对最小的数 翻转 k-n 次</li>
</ol>
<p>My Idea</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largestSumAfterKNegations</span><span class="params">(nums: <span class="type">IntArray</span>, k: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    Arrays.sort(nums)</span><br><span class="line">    <span class="keyword">var</span> balanceK = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until k) &#123; <span class="comment">// kotlin用while 应该更好</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= nums.size || nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            balanceK = k - i</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        nums[i] = Math.abs(nums[i])</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(nums)</span><br><span class="line">    <span class="keyword">if</span> (balanceK &gt; <span class="number">0</span> &amp;&amp; (balanceK % <span class="number">2</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        nums[<span class="number">0</span>] = -nums[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (value <span class="keyword">in</span> nums) &#123;</span><br><span class="line">        sum += value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个也可以</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1iY411s7qB">https://www.bilibili.com/video/BV1iY411s7qB</a></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largestSumAfterKNegations</span><span class="params">(nums: <span class="type">IntArray</span>, k: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> typedArray = nums.toTypedArray() <span class="comment">// 转成数组</span></span><br><span class="line">    Arrays.sort(typedArray, Comparator.comparingInt(Math::abs)) <span class="comment">// 按照绝对值排序</span></span><br><span class="line">    <span class="keyword">var</span> k = k</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> typedArray.indices) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; typedArray[i] &lt; <span class="number">0</span>) &#123;  <span class="comment">// 碰到数组中&gt;0的数</span></span><br><span class="line">            typedArray[i] *= -<span class="number">1</span></span><br><span class="line">            k--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(typedArray)</span><br><span class="line">    <span class="keyword">if</span> (k % <span class="number">2</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        typedArray[<span class="number">0</span>] *= -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (value <span class="keyword">in</span> nums) &#123;</span><br><span class="line">        sum += value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 参考随想录，但是编译不通过</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV138411G7LY">https://www.bilibili.com/video/BV138411G7LY</a></p>
<h4 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134 加油站"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/gas-station/">134 加油站</a></h4><h5 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">canCompleteCircuit</span><span class="params">(gas: <span class="type">IntArray</span>, cost: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> gas.indices) &#123;</span><br><span class="line">        <span class="keyword">var</span> balance = gas[i] - cost[i]</span><br><span class="line">        <span class="keyword">var</span> index = (i + <span class="number">1</span>) % gas.size</span><br><span class="line">        <span class="keyword">while</span> (balance &gt; <span class="number">0</span> &amp;&amp; i != index) &#123;  <span class="comment">// 还有油的话，没走完一圈，继续走</span></span><br><span class="line">            balance += (gas[index] - cost[index])</span><br><span class="line">            index = (index + <span class="number">1</span>) % gas.size</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (balance &gt;= <span class="number">0</span> &amp;&amp; (index == i)) &#123;<span class="comment">//走完一圈，返回下标</span></span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="贪心解法"><a href="#贪心解法" class="headerlink" title="贪心解法"></a>贪心解法</h5><p>这里k不用看</p>
<p><img src="/2023/01/02/LC-GREEDY/20230211173204.jpg" srcset="/img/loading.gif" lazyload alt="20230211173204"></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1DF411L7cz">https://www.bilibili.com/video/BV1DF411L7cz</a></p>
<p>j 到 j+1跑不到 , 从i 到 j +1 油量&lt;0</p>
<ol>
<li>因为 i 能开到j,从 i 出发到 i+1 油量 &gt;=0 ,  那么 i+1 到 j+1 油量一定 &lt;0.</li>
<li>如果起点在 i+1, 因为 i 到j+1&lt;0 ,因此 i 到  i+1&gt;=0 , i+1 到j+1一定&lt;0.</li>
</ol>
<p>总结来看,  i 到 j+1&lt;0 ,中间不用看，直接从 j+1开始即可。</p>
<p>LC134我的解法有问题，看到随想录的解法后感觉很妙</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">canCompleteCircuit</span><span class="params">(gas: <span class="type">IntArray</span>, cost: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> totalSum = <span class="number">0</span> <span class="comment">//  所有路程需要的油量</span></span><br><span class="line">    <span class="keyword">var</span> currentSum = <span class="number">0</span>  <span class="comment">// 当前位置开始所需要的油量</span></span><br><span class="line">    <span class="keyword">var</span> start = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> gas.indices) &#123;</span><br><span class="line">        totalSum += gas[i] - cost[i]</span><br><span class="line">        currentSum += gas[i] - cost[i]</span><br><span class="line">        <span class="keyword">if</span> (currentSum &lt; <span class="number">0</span>) &#123; <span class="comment">// 到i加油站需要油量 &lt;0, 如果接下来 gas[i+1] - cost[i+1]还是&lt;0,那么start ,currentSum 继续更新</span></span><br><span class="line">            start = i + <span class="number">1</span></span><br><span class="line">            currentSum = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (totalSum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li> 到i加油站需要油量 &lt;0, 如果接下来 gas[i+1] - cost[i+1]还是&lt;0,那么start ,currentSum 继续更新.</li>
<li> j ,j+1是负数节点,如果存在这样一个节点,满足条件，那么j+1开始后面一圈的一定都是&gt;0</li>
</ol>
<h4 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135 分发糖果"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/candy/">135 分发糖果</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1,2,2]</span><br><span class="line"> 1 2 1 &#x2F;&#x2F;为什么array[2] 糖果是1，因为题目意思只有评分高才有更多的糖果，相等的情况按照最少的1个糖果了。</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">5</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">左&lt;右</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">左&gt;右</td>
</tr>
</tbody></table>
<h5 id="Idea-3"><a href="#Idea-3" class="headerlink" title="Idea"></a>Idea</h5><p>需要一边一边考虑，否则顾此失彼</p>
<ol>
<li>先考虑  左边孩子粉丝的情况 &lt; 右边孩子分数  ，此时需要从左往右, 得到第三行的分数.</li>
<li>再考虑 左边孩子粉丝 &gt; 右边孩子分数的情况, 此时需要从右向左，因为这种情况需要依赖，右边的孩子。如果从左到右，得到第4行结果，此时  2 3 4 5都是错的。</li>
<li>然后从右往左的过程，还需要考虑之前 左边孩子&lt; 右边的情况，所以取最大值。</li>
</ol>
<h5 id="code"><a href="#code" class="headerlink" title="code"></a>code</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">candy</span><span class="params">(ratings: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> answer = IntArray(ratings.size)</span><br><span class="line">        answer[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        左边孩子粉丝的情况 &lt; 右边孩子分数  ，此时需要从左往右</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until ratings.size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                answer[i] = answer[i - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                answer[i] = <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        println()</span><br><span class="line">        answer.printIntArray()</span><br><span class="line">        <span class="comment">//左边孩子粉丝 &gt; 右边孩子分数的情况, 此时需要从右向左</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> ratings.size - <span class="number">1</span> downTo <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i - <span class="number">1</span>] &gt; ratings[i]) &#123;</span><br><span class="line">                answer[i - <span class="number">1</span>] = answer[i - <span class="number">1</span>].coerceAtLeast(answer[i] + <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        answer.printIntArray()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> answer) &#123;</span><br><span class="line">            sum += i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="860-柠檬水找零"><a href="#860-柠檬水找零" class="headerlink" title="860 柠檬水找零"></a>860 柠檬水找零</h4><h5 id="Idea-4"><a href="#Idea-4" class="headerlink" title="Idea"></a>Idea</h5><ol>
<li>一开始想到的是暴力解法， 用map 存 5 , 10两种金额的个数，20不用考虑</li>
<li>来了5存起来 map5 +1，来了10存起来 map10+1 , map5 -1 ,  来了20， map10-1, map5-1</li>
</ol>
<h5 id="code-暴力解法"><a href="#code-暴力解法" class="headerlink" title="code  暴力解法"></a>code  暴力解法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">fun lemonadeChange(bills: IntArray): Boolean &#123;</span><br><span class="line">    val map &#x3D; HashMap&lt;Int, Int&gt;()</span><br><span class="line">    for ((index, money) in bills.withIndex()) &#123;</span><br><span class="line">        if (money &#x3D;&#x3D; 5) &#123;</span><br><span class="line">            map[5] &#x3D; map.getOrDefault(5, 0).plus(1)</span><br><span class="line">        &#125; else if (money &#x3D;&#x3D; 10) &#123;</span><br><span class="line">            map[5] &#x3D; map.getOrDefault(5, 0) - 1</span><br><span class="line">            map[10] &#x3D; map.getOrDefault(10, 0).plus(1)</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F;for 20 rmb</span><br><span class="line">            if (map.getOrDefault(10, 0) &gt; 0 &amp;&amp; map.getOrDefault(5, 0) &gt; 0) &#123; &#x2F;&#x2F;at lease 10rmb 1  , 5rmb 1</span><br><span class="line">                map[10] &#x3D; map.getOrDefault(10, 0) - 1</span><br><span class="line">                map[5] &#x3D; map.getOrDefault(5, 0) - 1</span><br><span class="line">            &#125; else if (map.getOrDefault(5, 0) &gt; 2) &#123; &#x2F;&#x2F; at least 3 * 5 rmb</span><br><span class="line">                map[5] &#x3D; map.getOrDefault(5, 0) - 3</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        println(&quot; index $index    map5 $&#123;map[5]&#125; map10 $&#123;map[10]&#125; &quot;)</span><br><span class="line">        if (map.getOrDefault(5, 0) &lt; 0 || map.getOrDefault(10, 0) &lt; 0) &#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>看了随想录的解法，和我的解法类似，知识map中的值可以用变量来做.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> five = <span class="number">0</span>, ten = <span class="number">0</span>, twenty = <span class="number">0</span>;</span><br><span class="line">这样++,--更方便.</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0860.%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6.html#%E6%80%9D%E8%B7%AF">https://programmercarl.com/0860.%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6.html#%E6%80%9D%E8%B7%AF</a></p>
<h4 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406 根据身高重建队列"></a>406 根据身高重建队列</h4><h5 id="Idea-随想录"><a href="#Idea-随想录" class="headerlink" title="Idea 随想录"></a>Idea 随想录</h5><p>对于本题相信大家困惑的点是先确定k还是先确定h呢，也就是究竟先按h排序呢，还是先按照k排序呢？</p>
<p>如果按照k来从小到大排序，排完之后，会发现k的排列并不符合条件，身高也不符合条件，两个维度哪一个都没确定下来。</p>
<p>那么按照身高h来排序呢，身高一定是从大到小排（身高相同的话则k小的站前面），让高个子在前面。</p>
<p><strong>此时我们可以确定一个维度了，就是身高，前面的节点一定都比本节点高！</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fun reconstructQueue(people: Array&lt;IntArray&gt;): Array&lt;IntArray&gt; &#123;</span><br><span class="line">    Arrays.sort(people, object : Comparator&lt;IntArray&gt; &#123; </span><br><span class="line">        override fun compare(o1: IntArray, o2: IntArray): Int &#123;</span><br><span class="line">            if (o2[0] &#x3D;&#x3D; o1[0]) &#123;       &#x2F;&#x2F; 如果身高相同，k小的排在前面</span><br><span class="line">                return o1[1] - o2[1]</span><br><span class="line">            &#125;</span><br><span class="line">            return o2[0] - o1[0]        &#x2F;&#x2F; 对数组先按照身高来排序</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    val linkedList &#x3D; LinkedList&lt;IntArray&gt;()</span><br><span class="line"></span><br><span class="line">    for (value in people)&#123;</span><br><span class="line">        val index &#x3D; value[1]</span><br><span class="line">        linkedList.add(index,value) &#x2F;&#x2F; 按照k插入对应的位置, 这里插入时很容易越界。</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return linkedList.toTypedArray()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452. 用最少数量的箭引爆气球"></a>452. 用最少数量的箭引爆气球</h4><p>IDEA</p>
<ol>
<li>先对数组按照左边界大小进行排序。</li>
<li>如果当前i数组右边的值 &gt;  或者前面数组重叠区域的最小右边界， 此时没有重叠（和之前的共有区域），数量+1</li>
<li>否则有重叠，取最小右边界值。</li>
</ol>
<p>一开始看题解，没理解特别是 points[i][1]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">points[i][<span class="number">1</span>] = <span class="built_in">min</span>(points[i - <span class="number">1</span>][<span class="number">1</span>], points[i][<span class="number">1</span>]); <span class="comment">// 更新重叠气球最小右边界</span></span><br></pre></td></tr></table></figure>



<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findMinArrowShots1</span><span class="params">(points: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line"><span class="comment">//        Arrays.sort(points)&#123;o1,o2 -&gt; o1[0] - o2[0]&#125; 这个回报越界错 [[-2147483646,-2147483645],[2147483646,2147483647]]</span></span><br><span class="line">        points.sortBy&#123;it[<span class="number">0</span>]&#125;</span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until points.size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (points[i][<span class="number">0</span>] &gt; points[i - <span class="number">1</span>][<span class="number">1</span>]) &#123; <span class="comment">// 如果当前气球的左边界 &gt; 公共右边界</span></span><br><span class="line">                count++</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有大于公共右边界</span></span><br><span class="line">                <span class="comment">//points[i][1] = points[i][1].minus(points[i - 1][1]) // 用minus是有问题的</span></span><br><span class="line">                points[i][<span class="number">1</span>] = points[i][<span class="number">1</span>].coerceAtMost(points[i - <span class="number">1</span>][<span class="number">1</span>]) <span class="comment">// 更新重叠气球最小右边界</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        points.printDimensionalArray()</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>1       6</p>
<p>​    2            8</p>
<p>​             7                12</p>
<p>​                        10         16</p>
<h5 id="使用chatGPT的算法，更好"><a href="#使用chatGPT的算法，更好" class="headerlink" title="使用chatGPT的算法，更好"></a>使用chatGPT的算法，更好</h5><p>确定右边界, 如果新的左边界&gt;之前的右边界+1 , 使用新的数据，并且确定右边界。</p>
<p>The solution sorts the balloons by their end positions in ascending order, and then uses a greedy algorithm to shoot the balloons. We start with the first balloon and set <code>end</code> to its end position. Then, we iterate through the rest of the balloons and compare their start positions to <code>end</code>. If the start position of a balloon is greater than <code>end</code>, we shoot another arrow and update <code>end</code> to the end position of the current balloon.</p>
<p>At the end, the function returns the number of arrows shot.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findMinArrowShots</span><span class="params">(points: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (points.isEmpty()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    points.sortBy &#123; it[<span class="number">1</span>] &#125;</span><br><span class="line">    <span class="keyword">var</span> arrows = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> end = points[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until points.size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (points[i][<span class="number">0</span>]&gt;end) &#123;</span><br><span class="line">            arrows++</span><br><span class="line">            end = points[i][<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arrows</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/non-overlapping-intervals/">435. 无重叠区间</a></h4><p>[1,2] [3,6] [7,12] [4,8] [10,16]</p>
<p>1     2</p>
<p>​            3       6</p>
<p>​                 4                  8</p>
<p>​                          7                      12</p>
<p>​                                            10                16</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1A14y1c7E1">https://www.bilibili.com/video/BV1A14y1c7E1</a></p>
<h5 id="左边数组进行排序。"><a href="#左边数组进行排序。" class="headerlink" title="左边数组进行排序。"></a>左边数组进行排序。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. if [i][0] &lt; [i-1][1] 说明会有重合，那么求出 [i][1] [i-1][1]中的最小值，作为右边界，更新数量</span><br><span class="line">否则就没重合更新右边界限。</span><br><span class="line">2. 否则，没有重合直接更新  end。</span><br></pre></td></tr></table></figure>



<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">eraseOverlapIntervals</span><span class="params">(intervals: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.isEmpty()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">        Arrays.sort(intervals) &#123; a, b -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>] &#125; <span class="comment">// 按照左边数组进行排序</span></span><br><span class="line">        <span class="keyword">var</span> end = intervals[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until intervals.size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt; end) &#123;    <span class="comment">//重合的情况</span></span><br><span class="line">                count++</span><br><span class="line">                end = end.coerceAtMost(intervals[i][<span class="number">1</span>]) <span class="comment">// 确定最小重合的 右边界, 这里一开始弄错了</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                end = intervals[i][<span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        intervals.printDimensionalArray()</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h5 id="右边数组排序"><a href="#右边数组排序" class="headerlink" title="右边数组排序"></a>右边数组排序</h5><p><strong>这种解法不理解.</strong></p>
<p>根据随想录的思路，总的个数 - 非交叉个数 = 交叉个数。</p>
<p>这里的难点是要知道交叉后的右边界的</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230201164134.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>如果3在 1,2 右边最小值的左边，所以3条线还会有交叉，如果在1，2最小值的右边那么 2去掉就可以了，还是去掉1。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">eraseOverlapIntervals</span><span class="params">(intervals: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.isEmpty()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">1</span> <span class="comment">//非交叉区间个数</span></span><br><span class="line">        Arrays.sort(intervals) &#123; a, b -&gt; a[<span class="number">1</span>] - b[<span class="number">1</span>] &#125; <span class="comment">// 按照左边数组进行排序</span></span><br><span class="line">        <span class="keyword">var</span> end = intervals[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until intervals.size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &gt;= end) &#123;</span><br><span class="line">                count ++</span><br><span class="line">                end = intervals[i][<span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            else&#123;</span></span><br><span class="line"><span class="comment">//                end = intervals[i][1].coerceAtMost(end) // 这个不需要</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        intervals.printDimensionalArray()</span></span><br><span class="line">        <span class="keyword">return</span> intervals.size - count</span><br><span class="line">    &#125;	</span><br></pre></td></tr></table></figure>



<p>12</p>
<h4 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763 划分字母区间"></a>763 划分字母区间</h4><h5 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h5><ol>
<li><p>遍历出每个字母的最远距离，出现的座标。</p>
<p>根据字母的hash值得到当前的座标，后面如果有重复的hash,会覆盖前面的。</p>
</li>
<li><p>遍历后序列找 当前字母hash值 == i , right = i 拿到当前 right + 1 - left, 就是片段的长度。</p>
<p>然后更新left值.</p>
</li>
</ol>
<p>​        </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">partitionLabels</span><span class="params">(s: <span class="type">String</span>)</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> result = arrayListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">val</span> hash = IntArray(<span class="number">26</span>)</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> s.indices) &#123;</span><br><span class="line">            hash[s[i] - <span class="string">&#x27;a&#x27;</span>] = i</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> right = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> s.indices) &#123;</span><br><span class="line">            right = hash[s[i] - <span class="string">&#x27;a&#x27;</span>].coerceAtLeast(right) <span class="comment">// 要找到当前hash值的最大值</span></span><br><span class="line">            <span class="keyword">if</span> (right == i) &#123;   <span class="comment">//如果 hash值的最大值 和座标相等，就用到了分割点</span></span><br><span class="line">                result.add(right + <span class="number">1</span> - left)</span><br><span class="line">                left = i + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        hash.printIntArray()</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56 合并区间"></a>56 合并区间</h4><h5 id="Idea-My"><a href="#Idea-My" class="headerlink" title="Idea My"></a>Idea My</h5><p>初始化 left. right</p>
<ol>
<li>按照左边数组 排序。</li>
<li>如果没重合直接[left,right]把前面数组加入区间 。</li>
<li>如果重合，那么确定 right右边界，判断<code> [i][0]</code>和right,确定右边界，把right放入右边界。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">merge</span><span class="params">(intervals: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: Array&lt;IntArray&gt; &#123;</span><br><span class="line">    Arrays.sort(intervals) &#123; a, b -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>] &#125;</span><br><span class="line">    <span class="keyword">var</span> left = intervals[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> right = intervals[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">val</span> arrayOf = arrayListOf&lt;IntArray&gt;()</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until intervals.size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt;= right) &#123;</span><br><span class="line">            right = right.coerceAtLeast(intervals[i][<span class="number">1</span>])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arrayOf.add(intArrayOf(left, right))</span><br><span class="line">            left = intervals[i][<span class="number">0</span>]</span><br><span class="line">            right = intervals[i][<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arrayOf.add(intArrayOf(left, right))</span><br><span class="line">    <span class="keyword">return</span> arrayOf.toTypedArray()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="Idea-2"><a href="#Idea-2" class="headerlink" title="Idea 2"></a>Idea 2</h5><p>看了随想录的题解，觉得比我上面的更好，只需要更新右边界。</p>
<p>1     3</p>
<p>​    2         6       8     10         15        18</p>
<p>​                    </p>
<ol>
<li>还是按照数组左边界排好序。</li>
<li>把第一组数组放入结果数组中，然后取出来，用它的右边界和第二组数组的左边界比较大小.</li>
<li>如果新的数组的左边界 &lt; 结果数组的右边界，说明有重合，更新结果数组的右边界。</li>
<li>如果新的数组的左边界 &gt; 结果数组的右边界,没有重合，新数组直接添加到结果数组集中。</li>
</ol>
<h4 id="738-单调递增的数字"><a href="#738-单调递增的数字" class="headerlink" title="738 单调递增的数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/monotone-increasing-digits/">738 单调递增的数字</a></h4><h5 id="Idea-5"><a href="#Idea-5" class="headerlink" title="Idea"></a>Idea</h5><p>看了随想录的题解</p>
<p>那么拿一个两位的数字来举例。</p>
<p>例如：98，一旦出现strNum[i - 1] &gt; strNum[i]的情况（非单调递增），首先想让strNum[i - 1]–，然后strNum[i]给为9，这样这个整数就是89，即小于98的最大的单调递增整数。</p>
<p>此时是从前向后遍历还是从后向前遍历呢？</p>
<p>这么说有点抽象，举个例子，数字：332，从前向后遍历的话，那么就把变成了329，此时2又小于了第一位的3了，真正的结果应该是299。</p>
<p>那么从后向前遍历，就可以重复利用上次比较得出的结果了，从后向前遍历332的数值变化为：332 -&gt; 329 -&gt; 299</p>
<p>确定了遍历顺序之后，那么此时局部最优就可以推出全局，找不出反例，试试贪心。</p>
<h5 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h5><p>初始的想法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> arrStr = n.toString().toCharArray()</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> arrStr.size - <span class="number">1</span> downTo <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arrStr[i - <span class="number">1</span>] &gt; arrStr[i]) &#123;</span><br><span class="line">            arrStr[i] = <span class="string">&#x27;9&#x27;</span></span><br><span class="line">            arrStr[i - <span class="number">1</span>] = arrStr[i - <span class="number">1</span>].toInt().minus(<span class="number">1</span>).toChar() </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> String(arrStr).toInt()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>100 跑完后变成90,其实后面所有位都要变成 ‘9’,只有当前位减1</p>
<p>找到 minus 1 的位置，后面的位都变成9</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> arrStr = n.toString().toCharArray()</span><br><span class="line">    <span class="keyword">var</span> position = arrStr.size <span class="comment">//初始位置不能是  arrStr.size - 1 ，否则最后一位都会变成 &#x27;9&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> arrStr.size - <span class="number">1</span> downTo <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arrStr[i - <span class="number">1</span>] &gt; arrStr[i]) &#123;</span><br><span class="line">            arrStr[i - <span class="number">1</span>] = arrStr[i - <span class="number">1</span>].toInt().minus(<span class="number">1</span>).toChar() <span class="comment">// digitToInt leetcode跑不了</span></span><br><span class="line">            position = i <span class="comment">// 找到-1 的位置，后面的位都变成9</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> position until arrStr.size) &#123;</span><br><span class="line">        arrStr[i] = <span class="string">&#x27;9&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> String(arrStr).toInt()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="968-监控二叉树"><a href="#968-监控二叉树" class="headerlink" title="968 监控二叉树"></a>968 监控二叉树</h4><p>这题比较难，暂时没必要写。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/DataStructure/" class="category-chain-item">DataStructure</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/LEETCODE/" class="print-no-link">#LEETCODE</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>LC-GREEDY</div>
      <div>https://noteforme.github.io/2023/01/02/LC-GREEDY/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Jon</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>January 2, 2023</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/01/10/RecyclerView-padding/" title="RecyclerView-padding">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">RecyclerView-padding</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/12/27/viewBinding/" title="viewBinding">
                        <span class="hidden-mobile">viewBinding</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
