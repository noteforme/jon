<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>Tag: inter - Hexo</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Hexo"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Hexo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Hexo"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="Hexo"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="John Doe"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"Hexo","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"John Doe"},"publisher":{"@type":"Organization","name":"Hexo","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Hexo" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">Tags</a></li><li class="is-active"><a href="#" aria-current="page">inter</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-09-03T07:54:57.000Z" title="9/3/2023, 3:54:57 PM">2023-09-03</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-09-03T13:54:03.565Z" title="9/3/2023, 9:54:03 PM">2023-09-03</time></span><span class="level-item">12 minutes read (About 1864 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/09/03/Android-itnerview-algorithm/">Android_itnerview_algorithm</a></p><div class="content"><h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><p>用过哪些数据结构</p>
<p>常用数据结构</p>
<p>有哪些数据结构   增删改查的复杂度多少</p>
<p>计算二叉树的高度（递归与非递归两种方式）</p>
<p>快排写一下，动态规划了解吗？</p>
<p>冒泡排序的链表实现</p>
<p>写个快排</p>
<p>都用过那些常用的数据结构，说说对树的了解？</p>
<p> 堆排</p>
<p>算法题  判断二叉树深度. 2</p>
<p>算法的五大基本要素有哪些？为什么算法效率不是基本要素</p>
<p>银行家算法</p>
<p>堆排序原理</p>
<p>b树、b+树、红黑树</p>
<p>红黑树怎么增加、删除节点</p>
<p>算法题：随机生成不重复的100个数0-99</p>
<p>写一个泛型方法，实现删除数组中的元素功能</p>
<p>返回二叉树的第k大数</p>
<p>返回第k大的数，先说下你能想到的方法，再选一个最优方法。</p>
<p>二分法查找目标数</p>
<p>使用一个固定长度数组实现队列，包括添加和取数据的功能</p>
<p>时间复杂度、空间复杂度，如何优化</p>
<p>链表如何优化，可以降低查询的时间复杂度？</p>
<p>手撕：手写一个单例模式</p>
<p>手撕：二叉搜索树第 k 小的节点</p>
<p>算法：合并区间</p>
<p>算法：排序数组</p>
<p>算法：序列化和反序列化二叉搜索树</p>
<p>equals和hashCode方法</p>
<p>手撕快速排序</p>
<p>讲一个红黑树和一个排序算法的时间复杂度问题的分析思路</p>
<p>二叉查找树的概念</p>
<p>树退化成链表如何解决？</p>
<p>B树以及B树可以解决什么问题？</p>
<p>图的遍历以及具体代码如何实现？（迭代）</p>
<p>时间复杂度和空间复杂度的概念</p>
<p>常见的排序算法以及时间复杂度</p>
<p>链表的反转怎么实现？</p>
<p>讲一下排序算法的思路</p>
<p>最后是华为经典题，一个桶5L，另一个桶7L，如何得到6L？（答出来了）面试官立马追问，有没有一种数学理论可以给这个问题提供支持来证明，1L，2L，3L，4L，6L是不是都可以得到还是只能得到其中的某几种？（到这里，我是真的麻了，考这种题真的无从准备，面试官是啥问题都能深挖深挖再深挖）（最后一题有知道的同学可以评论区留言</p>
<p>快排的思想    </p>
<p>快排解决topk问题（我哭死啊，我没有想到当前的会使用快排来进行解决topk，我之前都是使用堆排序）    </p>
<p>快排和堆排来进行解决topk问题    </p>
<p>反转链表 </p>
<p>合并两个排序的链表 </p>
<p>算法题：给你一个数组，和一个数字m，问这个数组中存不存在一个子序列（不一定连续），使得它的和为m，输出true或false</p>
<p>两个算法（判断链表是否有环、链表重排/链表折叠）</p>
<p>反转字符串</p>
<p>上楼梯动态规划，如果第M阶梯是不能踩的</p>
<p> 倒水问题，3l和5l桶子要4l水怎么搞<br> 算法思路，链表右移动k位和数组右移动k位怎么搞<br> 左右括号匹配，最少情况要加多少次括号，写在纸上拍照</p>
<p>树、图的存储结构</p>
<p>给出二叉树的前序中序，输出后序</p>
<p>先来了一道算法题:找出最左边的次数最多的字母。</p>
<p>算法题：删除排序链表中的重复元素（力扣82）</p>
<p>快排和反转链表</p>
<p>判断一个树是不是平衡二叉树，</p>
<p>旋转链表 LC61:<br>题意是这样子的：给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。<br>输入：head=[1,2,3] k = 1<br>输出：[3,1,2]</p>
<p>22.算法题：二分法查找目标数</p>
<h1 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h1><p>多实现接口，如果接口里面有入参出参一样的同名方法，会实现几个</p>
<p>说一下final，static</p>
<p>. final的arraylist，往里面add东西会咋样</p>
<p>static方法能调用非静态吗，非静态能调用static吗</p>
<p>面向对象三大特性，多态怎么实现</p>
<p>静态方法与变量是否可以继承，原因</p>
<p>Java内存模块分区和GC机制，</p>
<p>GC算法有哪些</p>
<p>Finalize机制</p>
<p>强引用 弱引用 软引用 虚引用的区别和使用场景</p>
<p>ClassLoader的双亲委托机制 2</p>
<p>.Java代理是否用过，怎么实现</p>
<p>类加载的过程</p>
<p>类加载器，双亲委派模型</p>
<p>对象生命周期</p>
<p>判断对象是否可以回收的方法</p>
<p>有哪些GC roots</p>
<p>Java引用类型</p>
<p>抽象类与接口区别，各自优缺点</p>
<p>Java泛型，泛型擦除机制</p>
<p>匿名内部类，原理是什么</p>
<p>Java引用类型，弱引用的作用，引用队列。</p>
<p>Java内存回收</p>
<p>GC roots</p>
<p><strong>垃圾标记方法(拓展了很多)</strong>   </p>
<p>Java入口函数</p>
<p>Java异常介绍，是否所有异常都需要捕获</p>
<p>类编译过程</p>
<p>JVM 中创建一个对象的过程是什么样的？</p>
<p>JVM 如何判断一个对象需要被回收?</p>
<p>如果电脑内存是4G，已经使用了3G，现在启动一个程序需要超过1G的内存，会发生什么？(内存回收)</p>
<p>类加载过程是什么样的？</p>
<p>双亲委派模型有什么作用？</p>
<p>==和equals的区别</p>
<p>重载和重写的区别</p>
<p>值传递和引用传递</p>
<p>static、final作用</p>
<p>所有类的父类</p>
<p>this()和super()</p>
<p>int和Integer的区别</p>
<p>线程池和线程</p>
<p>锁了解哪些（说了分布式锁，又问我分布式锁是什么）</p>
<p>Java反射原理<br>Java面向对象的理解，封装，继承，多态</p>
<p>Java四次引用</p>
<p>垃圾回收机制</p>
<p>线程安全的集合有哪些（问得比较细）</p>
<p>进程间通信的方式</p>
<p>HashMap的底层实现</p>
<p>View的绘制过程</p>
<p>String、StringBuffer、StringBuidler的区别</p>
<p>注解的类型有哪些？</p>
<p>JVM的内存模型</p>
<p>什么是多态，怎么去实现呢</p>
<p>接口和抽象类的区别，它们各自的使用场景呢</p>
<p>java四种引用<br>JVM内存区域</p>
<p> OOM能捕获吗 </p>
<p>  运行时异常与编译时异常 </p>
<p>了解网络字节序吗</p>
<p>双亲委派(写一个路径名字一样的String，new String（）会创建自己写的还是系统的)</p>
<p>受检异常和非受检异常</p>
<p>抽象类和接口的区别</p>
<p>java里弱引用和强引用分别用在什么场景</p>
<p>深拷贝、浅拷贝</p>
<h1 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h1><p>进程线程在操作系统中的实现</p>
<p>内核态与用户态</p>
<p>linux内存管理机制</p>
<p>虚拟内存与物理内存</p>
<p>进程间能共享内存吗</p>
<p>虚拟内存</p>
<p>跨进程通信的几种方式</p>
<p>线程与进程的使用场景 </p>
<p> 线程安全与不安全的例子 </p>
<p>B站的虚拟人物么，你觉得当前的技术方面是怎么来进行实现的 </p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-07-15T02:29:39.000Z" title="7/15/2020, 10:29:39 AM">2020-07-15</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-08-20T03:06:20.543Z" title="8/20/2021, 11:06:20 AM">2021-08-20</time></span><span class="level-item">10 minutes read (About 1501 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/07/15/resume/">resume</a></p><div class="content"><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5e801a49e51d45470e2bc8bf">https://juejin.im/post/5e801a49e51d45470e2bc8bf</a></p>
<p><a target="_blank" rel="noopener" href="https://wanandroid.com/blog/show/2754">https://wanandroid.com/blog/show/2754</a></p>
<p> <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/AJ4QUqdYMeQWgWEQAFPsww">https://mp.weixin.qq.com/s/AJ4QUqdYMeQWgWEQAFPsww</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/6876968255597051917">https://juejin.im/post/6876968255597051917</a></p>
<h4 id="APP模式-MVC-MVP-MVVM"><a href="#APP模式-MVC-MVP-MVVM" class="headerlink" title="APP模式 MVC MVP. MVVM:"></a>APP模式 MVC MVP. MVVM:</h4><p>面试题</p>
<ul>
<li><p>mvp与mvvm的区别，mvvm怎么更新UI</p>
</li>
<li><p>讲讲mvc,mvp模式，presenter内存泄漏的问题</p>
</li>
<li><p>代理模式与装饰模式的区别，手写一个静态代理，一个动态代理</p>
</li>
<li><p>MVP怎么处理内存泄漏</p>
</li>
<li><p><strong>Mvp与Mvvm有什么区别?</strong></p>
</li>
<li><p>mvvm双向数据绑定的原理是怎样的？ViewModel</p>
</li>
<li><p>你在项目中有用到什么设计模式吗？</p>
</li>
<li><p>单例模式有什么缺点？</p>
</li>
<li><p>动画里面用到了什么设计模式？</p>
</li>
<li><p>OkHttp里面用到了什么设计模式？</p>
</li>
<li><p>谈谈设计模式，你了解多少，运用了多少？</p>
</li>
<li><p>MVP</p>
<p>Presenter 的作用类似于MVC中的Controller,但是其会反作用与View层，Model层的数据更新会被首先反馈到</p>
<p>Presenter,由Presenter优先处理并决定是否刷新以及刷新哪个View,也就是说Presenter完全将View层与Model层</p>
<p>隔离开，充当一个名副其实的中间人角色.</p>
</li>
<li><p>MVVM</p>
<p>MVVM则是思想的完全变革。它是将“数据模型数据双向绑定”的思想作为核心，因此在View和Model之间没有联系，通过ViewModel进行交互，而且Model和ViewModel之间的交互是双向的，因此视图的数据的变化会同时修改数据源，而数据源数据的变化也会立即反应到View上</p>
<p>缺点</p>
<p>1、过于简单的图形界面不适用，或说牛刀杀鸡。<br>2、对于大型的图形应用程序，视图状态较多，ViewModel的构建和维护的成本都会比较高。<br>3、数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的。</p>
</li>
</ul>
<h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><h5 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h5><ol>
<li><p>设计模式六大原则1-单一职责原则</p>
</li>
<li><p>设计模式六大原则2-里氏替换原则</p>
<blockquote>
<p>子类必须实现父类的抽象方法，但不得重写（覆盖）父类的非抽象（已实现）方法，里氏替换原则规定，子类不能覆写父类已实现的方法。父类中已实现的方法其实是一种已定好的规范和契约，如果我们随意的修改了它，那么可能会带来意想不到的错误。</p>
<p>子类完美继承父类的设计初衷，并做了增强</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/cf9f3c7c0df5">https://www.jianshu.com/p/cf9f3c7c0df5</a></p>
</li>
<li><p>设计模式六大原则3-依赖倒置原则</p>
<blockquote>
<p>高层模块不应该依赖于底层模块，两者都应该依赖于抽象，抽象不应该依赖于细节，细节应该依赖于抽象</p>
</blockquote>
</li>
<li><p>设计模式六大原则4-接口隔离原则</p>
<p>接口隔离原则:Clients should not be forced to depend upon interfaces that they do not use.与外部关系上只依赖需要的抽象</p>
<blockquote>
<p>接口隔离原则的关键是接口以及这个接口要小，如何小呢，也就是我们要为专门的类创建专门的接口，这个接口只对它有效，不要试图让一个接口包罗万象，要建立最小的依赖关系</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/dingshuo168/article/details/103531805">https://blog.csdn.net/dingshuo168/article/details/103531805</a></p>
</li>
<li><p>设计模式六大原则5-迪米特法则</p>
<p>减少依赖 Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers</p>
<blockquote>
<p>一个类应该应该对其他类尽可能了解得最少；类只与直接的朋友通信等等。但是其最终目的只有一个，就是让类间解耦。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://tianweili.github.io/2015/02/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/">https://tianweili.github.io/2015/02/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/</a></p>
</li>
<li><p>设计模式六大原则6-开闭原则</p>
</li>
<li><p>控制反转</p>
<p>在使用框架之后，整个程序的执行流程通过框架来控制。流程的控制权从程序员“反转”给了框架。</p>
</li>
</ol>
<p>谈一谈自己对依赖、关联、聚合和组合之间区别的理解</p>
<p><a target="_blank" rel="noopener" href="http://blog.itpub.net/69952849/viewspace-2672009/">http://blog.itpub.net/69952849/viewspace-2672009/</a></p>
<h5 id="设计模式之美"><a href="#设计模式之美" class="headerlink" title="设计模式之美"></a>设计模式之美</h5><p>迪米特法则的描述为：不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/35f76e87ac45">https://www.jianshu.com/p/35f76e87ac45</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903591686176776">https://juejin.im/post/6844903591686176776</a></p>
<p> <a target="_blank" rel="noopener" href="https://github.com/Meng997998/AndroidJX">https://github.com/Meng997998/AndroidJX</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/6864252499466354701">https://juejin.im/post/6864252499466354701</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/JsonChao/Awesome-Android-Interview">https://github.com/JsonChao/Awesome-Android-Interview</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/6878902981400625160">https://juejin.im/post/6878902981400625160</a></p>
<h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>单例为什么使用volatile修饰 </p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903605292498958">https://juejin.im/post/6844903605292498958</a></p>
<p><a target="_blank" rel="noopener" href="http://static.kancloud.cn/alex_wsc/mianshi/1811436">http://static.kancloud.cn/alex_wsc/mianshi/1811436</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/eCotdGOWvSMki062eLjS8g">https://mp.weixin.qq.com/s/eCotdGOWvSMki062eLjS8g</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/7DvReHYugl1KClKFGBwSfg">https://mp.weixin.qq.com/s/7DvReHYugl1KClKFGBwSfg</a></p>
<ul>
<li>平常有用到什么锁，synchronized底层原理是什么</li>
<li>锁之间的区别</li>
<li>线程间同步的方法</li>
<li>阿里编程规范不建议使用线程池，为什么？</li>
<li>RXJava怎么切换线程</li>
<li>平常有用到什么锁，synchronized底层原理是什么</li>
<li>简单描述下Handler,Handler是怎么切换线程的,Handler同步屏障</li>
<li>synchronized是公平锁还是非公平锁,ReteranLock是公平锁吗？是怎么实现的</li>
<li>线程间同步的方法</li>
<li>锁之间的区别</li>
<li>OkHttp怎么实现连接池</li>
<li>如果让你来实现一个网络框架，你会考虑什么</li>
<li>说说你对volatile字段有什么用途？</li>
<li>四种线程池原理？</li>
<li>怎么中止一个线程，Thread.Interupt一定有效吗？</li>
<li>如何让两个线程循环交替打印</li>
<li>线程池了解多少？拒绝策略有几种,为什么有newSingleThread</li>
<li></li>
</ul>
<p>okhttp线程使用方式</p>
<h4 id="RXJava"><a href="#RXJava" class="headerlink" title="RXJava"></a>RXJava</h4><ul>
<li>RXJava怎么切换线程</li>
<li>Rxjava自定义操作符</li>
</ul>
<h5 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h5><p><a target="_blank" rel="noopener" href="https://juejin.im/post/6875638406165037063">https://juejin.im/post/6875638406165037063</a></p>
<p>设计模式之美</p>
<p>25 26 39. 40代码没什么了解</p>
<p>Hashmap </p>
<h4 id="注解作用"><a href="#注解作用" class="headerlink" title="注解作用"></a>注解作用</h4><p>路线图 </p>
<p>注解</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-01-15T02:24:37.000Z" title="1/15/2019, 10:24:37 AM">2019-01-15</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-08-19T14:17:45.846Z" title="8/19/2021, 10:17:45 PM">2021-08-19</time></span><span class="level-item">38 minutes read (About 5667 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/01/15/INTERVIEW-ANDROID/">INTERVIEW_ANDROID</a></p><div class="content"><p><a target="_blank" rel="noopener" href="https://www.1point3acres.com/bbs/interview/airbnb(%E5%8C%97%E4%BA%AC)%E3%80%81%E5%BF%AB%E6%89%8B%E3%80%81%E5%B0%8F%E7%BA%A2%E4%B9%A6%E3%80%81%E7%8C%BF%E9%A2%98%E5%BA%93%E7%AD%8915%E5%AE%B6%E9%9D%A2%E7%BB%8F-mobile-ios-android-530393.html">大佬面试经验</a></p>
<p><a target="_blank" rel="noopener" href="https://interview-q-a-1gdnkgkla15afdbe-1258598664.tcloudbaseapp.com/Android/">https://interview-q-a-1gdnkgkla15afdbe-1258598664.tcloudbaseapp.com/Android/</a></p>
<h3 id="Android基础知识点"><a href="#Android基础知识点" class="headerlink" title="Android基础知识点"></a>Android基础知识点</h3><h5 id="四大组件是什么"><a href="#四大组件是什么" class="headerlink" title="四大组件是什么"></a>四大组件是什么</h5><p>Activity ,Service ,BroadCastReceiver,ContentProvider</p>
<h4 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h4><h5 id="Activity各种情况下的生命周期"><a href="#Activity各种情况下的生命周期" class="headerlink" title="Activity各种情况下的生命周期?"></a>Activity各种情况下的生命周期?</h5><ul>
<li><p>先启动A 再跳转B</p>
<p>A_onCreate()-&gt; A_onStart()-&gt;A_onResume-&gt; A_onPause()-&gt; B_onCreate() -&gt; B_onStart() -&gt; B_resume -&gt; A_onSaveInstanceState()-&gt;A_onStop()</p>
</li>
<li><p>弹出Dialog</p>
<p>不调用任何生命周期,所以Activity上有Dialog的时候按Home键时的生命周期,有没有Dialog都一样的。</p>
</li>
<li><p>横竖屏切换的时候，Activity 各种情况下的生命周期</p>
<ol>
<li><p>Activity状态保存于恢复 (什么都不设置)</p>
<p>![](INTERVIEW-ANDROID/Screen Shot 2021-01-24 at 3.37.01 PM.png)</p>
</li>
<li><p>设置<code>android:screenOrientation=&quot;portrait&quot;</code> 不会旋转</p>
</li>
<li><p>Android 8.0 设置<code>android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot;</code> </p>
<p>会发生旋转，生命周期不发生变化，只是会调用 <code>onConfigurationChanged()</code> </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36713816/article/details/80538467">https://blog.csdn.net/qq_36713816/article/details/80538467</a></p>
</li>
</ol>
</li>
<li><p>前台切换到后台，然后再回到前台，Activity生命周期回调方法。</p>
<p>前台切换到后台: A_onCreate()-&gt; A_onStart()-&gt;A_onResume-&gt; A_onPause()-&gt;A_onSaveInstanceState()-&gt; A_onStop()</p>
<p>再回到前台: A_onRestart() -&gt;A_onStart()-&gt; A_onResume()</p>
</li>
</ul>
<h5 id="Activity之间的通信方式"><a href="#Activity之间的通信方式" class="headerlink" title="Activity之间的通信方式"></a>Activity之间的通信方式</h5><ul>
<li><p>Intent</p>
<p>startActivity()或startActivityForResult(),通过Intent传递信息,需要注意，Intent对携带信息大小有限制。</p>
</li>
</ul>
<ul>
<li><p>BroadcastReceiver</p>
</li>
<li><p>数据存取传递，sharePreference/sql/File</p>
</li>
<li><p>Application 静态变量</p>
</li>
</ul>
<h5 id="Activity的四种启动模式对比"><a href="#Activity的四种启动模式对比" class="headerlink" title="Activity的四种启动模式对比"></a>Activity的四种启动模式对比</h5><ul>
<li><p>Standard </p>
<p>默认启动模式，每次都重新创建一个新的Activity 。</p>
</li>
<li><p>SingleStop</p>
<p>当前Activity如果在栈顶，那么就不会创建新的Activity，会原先调用Activity的onNewIntent()</p>
</li>
<li><p>SingleTask</p>
<p>当前任务栈已经有Activity实例，就不会再创建了，会调用 onNewIntent().</p>
</li>
<li><p>SingleInstance</p>
<p>单一实例模式，整个手机操作系统里面只有一个实例存在。不同的应用去打开这个activity  共享公用的同一个activity。他会运行在自己单独，独立的任务栈里面，并且任务栈里面只有他一个实例存在。应用场景：呼叫来电界面。这种模式的使用情况比较罕见，在Launcher中可能使用。或者你确定你需要使Activity只有一个实例。<br> 可以得出以下结论：<br> \1. 以singleInstance模式启动的Activity具有全局唯一性，即整个系统中只会存在一个这样的实例。<br> \2. 以singleInstance模式启动的Activity在整个系统中是单例的，如果在启动这样的Activiyt时，已经存在了一个实例，那么会把它所在的任务调度到前台，重用这个实例。<br> \3. 以singleInstance模式启动的Activity具有独占性，即它会独自占用一个任务，被他开启的任何activity都会运行在其他任务中。<br> \4. 被singleInstance模式的Activity开启的其他activity，能够在新的任务中启动，但不一定开启新的任务，也可能在已有的一个任务中开启。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zivensonice/article/details/51569502">https://blog.csdn.net/zivensonice/article/details/51569502</a></p>
<p><a target="_blank" rel="noopener" href="https://ayusch.com/android-launch-modes-explained/">https://ayusch.com/android-launch-modes-explained/</a></p>
<p><a target="_blank" rel="noopener" href="https://noteforme.github.io/2021/01/16/Activity/">https://noteforme.github.io/2021/01/16/Activity/</a></p>
</li>
<li><p>为什么 application.startActivity 要设置NEW_TASK</p>
<p>如果Activity是由一个已经启动的Activity发起的，那么把它放在这个已经启动的任务栈是合理的，Application本来没有任务栈，那么就新创建一个放起来.</p>
<p><a target="_blank" rel="noopener" href="https://www.wanandroid.com/wenda/show/8697">https://www.wanandroid.com/wenda/show/8697</a></p>
</li>
</ul>
<p>任务栈的底层原理</p>
<h5 id="Android-APK编译打包流程"><a href="#Android-APK编译打包流程" class="headerlink" title="Android APK编译打包流程"></a>Android APK编译打包流程</h5><p><img src="https://camo.githubusercontent.com/9f62ff22761b5a960fc9547be84cd05ddec48fe4b28fbb1bd17877fb88b43ed0/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d636462613331396461623332643063372e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"></p>
<ol>
<li>AAPT（Android Asset Packaging  Tools）工具会打包应用中的资源文件，如AndroidManifest.xml、layout布局中的xml等，并将xml文件编译成二进制形式，当然assets文件夹中的文件不会被编译，图片以及raw文件夹中的资源也会保持原有的形态，需要注意的是raw文件夹中的资源也会生成资源ID。AAPT编译完成后会生成R.java文件。</li>
<li>AIDL工会将所有的aidl接口转换为java接口。</li>
<li>所有的Java源代码、R文件、接口都会编译器编译成.class文件。</li>
<li>Dex工具会将上述产生的.class文件以及第三方库和其他class文件转化为dex（Dalvik虚拟机可执行文件）文件，dex文件最终会被打包进APK文件。</li>
<li>apkbuilder会把编译后的资源和其他资源文件同dex文件一起打入APK中。</li>
<li>生成APK文件之后，，需要对其签名才能安装到设备上，平时测试都会使用debug keystore，当发布应用时必须使用release版的keystore对应用进行签名。</li>
<li>如果对APK正式签名，还需要使用zipalign工具对APK进行对齐操作，这样做的好处是当应用运行时能提高速度，但是会相应的增加内存开销。</li>
</ol>
<p><strong>总结：编译 –&gt; DEX –&gt; 打包 –&gt; 签名和对齐</strong></p>
<h5 id="ART虚拟机与Dalvik虚拟机的区别"><a href="#ART虚拟机与Dalvik虚拟机的区别" class="headerlink" title="ART虚拟机与Dalvik虚拟机的区别"></a>ART虚拟机与Dalvik虚拟机的区别</h5><ul>
<li><p>什么是ART？</p>
<p>ART代表Android  Runtime，其处理应用程序执行的方式完全不同于Dalvik，Dalvik是依靠一个Just-In-Time（<strong>JIT）编译器去解释字节码</strong>。开发者编译后的应用代码需要通过一个解释器在用户的设备上运行，这一机制并不高效，但让应用能更容易在不同硬件和架构上运行。ART则完全改变了这套做法，<strong>在应用安装时就预编译字节码到机器语言</strong>，这一机制叫Ahead-Of-Time（AOT）编译。在移除解释代码这一过程后，应用程序执行将更加效率。启动更快。</p>
</li>
<li><p>ART优点：</p>
<ol>
<li>系统性能的显著提升。</li>
<li>应用启动更快、运行更快、体验更流畅、触摸反馈更及时。</li>
<li>更长的电池续航能力</li>
<li>支持更低的硬件。</li>
</ol>
</li>
<li><p>ART缺点</p>
<ol>
<li>更大的存储空间占用，可能会增加10%-20%</li>
<li>更长的应用安装时间</li>
</ol>
</li>
</ul>
<h5 id="LaunchMode应用场景"><a href="#LaunchMode应用场景" class="headerlink" title="LaunchMode应用场景"></a>LaunchMode应用场景</h5><h4 id="Fragmment"><a href="#Fragmment" class="headerlink" title="Fragmment"></a>Fragmment</h4><h5 id="Fragment生命周期管理过程遇到的坑和解决办法"><a href="#Fragment生命周期管理过程遇到的坑和解决办法" class="headerlink" title="Fragment生命周期管理过程遇到的坑和解决办法"></a>Fragment生命周期管理过程遇到的坑和解决办法</h5><h5 id="fragment各种情况下的生命周期-Activity与Fragment之间生命周期比较"><a href="#fragment各种情况下的生命周期-Activity与Fragment之间生命周期比较" class="headerlink" title="fragment各种情况下的生命周期 Activity与Fragment之间生命周期比较"></a>fragment各种情况下的生命周期 Activity与Fragment之间生命周期比较</h5><p>​        <u>onAttach() -&gt; onCreate() -</u>&gt; onCreateView() -&gt; onActivityCreate() -&gt; onStart() -&gt;  onResume() -&gt; onPause() -&gt; onStop() -&gt;      </p>
<p>​        onDestroyView() -&gt; onDestroy() -&gt; onDetach() </p>
<h5 id="Fragment状态保存startActivityForResult是哪个类的方法，在什么情况下使用？"><a href="#Fragment状态保存startActivityForResult是哪个类的方法，在什么情况下使用？" class="headerlink" title="Fragment状态保存startActivityForResult是哪个类的方法，在什么情况下使用？"></a>Fragment状态保存startActivityForResult是哪个类的方法，在什么情况下使用？</h5><ul>
<li><p>Fragment发起</p>
<p> Fragment onActivityResult能接收。Activity onActivityResult能接收,但是requestCode不正确。</p>
</li>
<li><p>Activity发起</p>
<p> Fragment不能接收。 Activity onActivityResult能接收。</p>
</li>
</ul>
<h5 id="fragment之间传递数据的方式？"><a href="#fragment之间传递数据的方式？" class="headerlink" title="fragment之间传递数据的方式？"></a>fragment之间传递数据的方式？</h5><ol>
<li><p>Fragment.setArguments()方法传递bundle</p>
</li>
<li><p>findFragmentById()找到tag,然后直接操作Framgent</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onArticleSelected</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">      ArticleFragment articleFrag = (ArticleFragment)</span><br><span class="line">      getSupportFragmentManager().findFragmentById(R.id.article_fragment);</span><br><span class="line">   </span><br><span class="line">      <span class="keyword">if</span> (articleFrag != <span class="keyword">null</span>) &#123;</span><br><span class="line">          articleFrag.updateArticleView(position);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          ArticleFragment newFragment = <span class="keyword">new</span> ArticleFragment();</span><br><span class="line">          Bundle args = <span class="keyword">new</span> Bundle();</span><br><span class="line">          args.putInt(ArticleFragment.ARG_POSITION, position);</span><br><span class="line">          newFragment.setArguments(args);</span><br><span class="line">   </span><br><span class="line">          FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();</span><br><span class="line">          transaction.replace(R.id.fragment_container, newFragment);</span><br><span class="line">          transaction.addToBackStack(<span class="keyword">null</span>);</span><br><span class="line">          transaction.commit();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>接口回调</p>
</li>
</ol>
<h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><h5 id="请描述一下Service-的生命周期"><a href="#请描述一下Service-的生命周期" class="headerlink" title="请描述一下Service 的生命周期"></a>请描述一下Service 的生命周期</h5><ul>
<li>startService()</li>
</ul>
<p>​    启动:  onCreate() - onCommandStart()  - onDestory()</p>
<p>​    继续startService : 只会执行 onCommandStart()      </p>
<ul>
<li>bindService()</li>
</ul>
<p>​    onCreate() -   onBind() - onUnbind()-onDestory()</p>
<h5 id="service和activity怎么进行数据交互？"><a href="#service和activity怎么进行数据交互？" class="headerlink" title="service和activity怎么进行数据交互？"></a>service和activity怎么进行数据交互？</h5><ol>
<li><p>bindService()</p>
<p>Service中定义接口，ServiceConnection中获取Service实例，调用响应接口</p>
</li>
<li><p>注册广播传递数据说说ContentProvider、ContentResolver、ContentObserver 之间的关系</p>
<pre><code> 把自己的程序数据提供给其他应用程序调用，提供相关的uri接口,没用过ntentObserver 之间的关系
    把自己的程序数据提供给其他应用程序调用，提供香港的uri接口,没用过
</code></pre>
<p><a target="_blank" rel="noopener" href="http://wangbufan.cn/2019/09/17/Service%E5%8F%8AService%E4%B8%8EActivity%E9%80%9A%E4%BF%A1/">http://wangbufan.cn/2019/09/17/Service%E5%8F%8AService%E4%B8%8EActivity%E9%80%9A%E4%BF%A1/</a></p>
</li>
</ol>
<h5 id="请描述一下广播BroadcastReceiver的理解"><a href="#请描述一下广播BroadcastReceiver的理解" class="headerlink" title="请描述一下广播BroadcastReceiver的理解"></a>请描述一下广播BroadcastReceiver的理解</h5><ul>
<li> 广播是可以作为应用全局监听器，可以实现应用中不同组件少量数据的通信！！！，更深研究后可以多说点.</li>
</ul>
<p>  基于消息的发布/订阅事件模型.</p>
<ul>
<li><p>广播的分类</p>
<ol>
<li><p>无序广播</p>
</li>
<li><p>有序广播</p>
<p><strong>接收者按照优先级顺序</strong>接收,每个接收者都<strong>有权终止广播</strong>,下一个就得不到.</p>
</li>
</ol>
</li>
<li><p>广播使用的方式和场景</p>
<p>app全局监听</p>
<p>binder机制 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5a983578418e">https://www.jianshu.com/p/5a983578418e</a></p>
<h5 id="BroadcastReceiver，LocalBroadcastReceiver-本地广播-区别"><a href="#BroadcastReceiver，LocalBroadcastReceiver-本地广播-区别" class="headerlink" title="BroadcastReceiver，LocalBroadcastReceiver(本地广播) 区别"></a>BroadcastReceiver，LocalBroadcastReceiver(本地广播) 区别</h5><p>BroadcastReceiver：针对应用间，系统和应用间通信。</p>
<p>LocalBroadcastReceiver： 只有自己应用内部才能收到,效率更高.</p>
</li>
</ul>
<h4 id="Dialog"><a href="#Dialog" class="headerlink" title="Dialog"></a>Dialog</h4><h5 id="AlertDialog-popupWindow-Toast区别-？"><a href="#AlertDialog-popupWindow-Toast区别-？" class="headerlink" title="AlertDialog,popupWindow,Toast区别 ？"></a>AlertDialog,popupWindow,Toast区别 ？</h5><p>Android是不允许Activity或Dialog凭空出现的,而Dialog则必须在一个Activity上面弹出</p>
<ul>
<li><p>AlertDialog </p>
<p>   拦截了屏幕上所有的TouchK/key</p>
</li>
<li><p>PopupWindow </p>
<p>  仅仅拦截自身区域touch/key</p>
<p>  需要Activity类型的Context启动</p>
</li>
<li><p>Toast</p>
<p>  可以研究下 两者最根本的区别在于有没有新建一个 window，PopupWindow 没有新建，而是通过 WMS 将 View 加到 DecorView；Dialog 是新建了一个 window (PhoneWindow)，相当于走了一遍 Activity 中创建 window 的流程</p>
<p>  <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/aed496937bd2">https://www.jianshu.com/p/aed496937bd2</a></p>
</li>
</ul>
<h5 id="Application-和-Activity-的-Context-对象的区别"><a href="#Application-和-Activity-的-Context-对象的区别" class="headerlink" title="Application 和 Activity 的 Context 对象的区别"></a>Application 和 Activity 的 Context 对象的区别</h5><p>ApplicatioContext ：</p>
<p>​    应用生命周期一样长,长生命周期对象就用ApplicationContext</p>
<p>Activity的Context：</p>
<p>​     当前Activity的生命周期,和UI相关的都用Activity为Context来处理</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e215c90a460e">https://www.jianshu.com/p/e215c90a460e</a></p>
<h5 id="Context的理解？"><a href="#Context的理解？" class="headerlink" title="Context的理解？"></a>Context的理解？</h5><p>​    Context是维持Android程序中各组件能够正常工作的一个核心功能类</p>
<h4 id="Anim"><a href="#Anim" class="headerlink" title="Anim"></a>Anim</h4><h5 id="Android属性动画特性"><a href="#Android属性动画特性" class="headerlink" title="Android属性动画特性"></a>Android属性动画特性</h5><p>Android动画框架实现原理</p>
<p>可以改变对象的属性。还需要说说什么吗?</p>
<h5 id="如何导入外部数据库"><a href="#如何导入外部数据库" class="headerlink" title="如何导入外部数据库?"></a>如何导入外部数据库?</h5><p>把数据库文件防盗asserts目录下，然后写入databases目录下面, 然后通过数据库容器装载里面数据库里面的数据。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/chaoyu168/article/details/50467913">https://blog.csdn.net/chaoyu168/article/details/50467913</a></p>
<h5 id="插值器-估值器区别"><a href="#插值器-估值器区别" class="headerlink" title="插值器 估值器区别"></a>插值器 估值器区别</h5><p>​     插值器: （<code>Interpolator</code>）决定 值 的变化模式（匀速、加速）</p>
<p>​     估值器 :     (<code>TypeEvaluator</code>)决定 值 的具体变化数值</p>
<h5 id="谈谈对接口与回调的理解"><a href="#谈谈对接口与回调的理解" class="headerlink" title="谈谈对接口与回调的理解"></a>谈谈对接口与回调的理解</h5><ul>
<li><p>理解: A发送消息给B,B处理完后高速A处理结果.</p>
</li>
<li><p>实现: 一般而言，处理消息的类是唯一的，发送消息的类却是各种各样的，将回调方法做成一个接口，不同的发送者实现该接口，并且把自己的接口实现类的对象在发送消息时，传递给消息处理者。</p>
</li>
</ul>
<p>注册之后不马上执行，而是某个时机再触发执行。</p>
<h5 id="回调的原理-写一个回调demo"><a href="#回调的原理-写一个回调demo" class="headerlink" title="回调的原理 写一个回调demo"></a>回调的原理 写一个回调demo</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProcessClick process = <span class="keyword">new</span> ProcessClick(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;已经点击&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        process.click();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OnClickListener</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span>  <span class="title">onClick</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">ProcessClick</span> </span>&#123;</span><br><span class="line">    OnClickListener listener;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProcessClick</span><span class="params">(OnClickListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.listener = listener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">click</span><span class="params">()</span></span>&#123;</span><br><span class="line">        listener.onClick();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/614769">https://developer.aliyun.com/article/614769</a></p>
<h4 id="VIEW相关"><a href="#VIEW相关" class="headerlink" title="VIEW相关"></a>VIEW相关</h4><h5 id="如何优化自定义View"><a href="#如何优化自定义View" class="headerlink" title="如何优化自定义View"></a>如何优化自定义View</h5><h5 id="android-view绘制机制和加载过程，请详细说下整个流程"><a href="#android-view绘制机制和加载过程，请详细说下整个流程" class="headerlink" title="android view绘制机制和加载过程，请详细说下整个流程"></a>android view绘制机制和加载过程，请详细说下整个流程</h5><p>每个Activity包含一个Window对象，Android中window对象由PhoneWindow实现，PhoneWindow将一个DecorView设置为整个应用窗口的根View,DecorView作为窗口界面的顶层视图，封装了窗口操作的通用方法，DecorView将要显示的具体内容显示在PhoneWindow上，这里所有的View监听事件通过WindowMangerService来接收,通过Activity对象来回调相应的onCLicklistener.显示是将屏幕分成两部分，一个TitleView，另一个是ContentView.</p>
<p> Measure</p>
<p>如果是原始的 View,通过measure方法就完成了测量过程,如果是ViewGroup,除了完成自己的测量外，还需要遍历所有的子View,各个子元素再去递归执行这个流程.</p>
<p>Layout </p>
<p>Draw</p>
<h5 id="MeasureSpeck的意义，怎么计算MeasureSpec"><a href="#MeasureSpeck的意义，怎么计算MeasureSpec" class="headerlink" title="MeasureSpeck的意义，怎么计算MeasureSpec"></a>MeasureSpeck的意义，怎么计算MeasureSpec</h5><h5 id="wrap-content-和MATCH-PARENT的测量方式"><a href="#wrap-content-和MATCH-PARENT的测量方式" class="headerlink" title="wrap content 和MATCH_PARENT的测量方式"></a>wrap content 和MATCH_PARENT的测量方式</h5><p>WRAP_CONTENT : 最大模式，大小不定，但是不能超过窗口的大小. specMode是AT_MOST模式,这种模式下，它的宽，高等于specSize,                                 这种情况下specSize是parentSize,而parentSize是父容器目前可以使用的大小,也就是父容器剩余的空间大小.</p>
<p>MATCH_PARENT: 精确模式，大小就是窗口大小.</p>
<p><a target="_blank" rel="noopener" href="https://noteforme.github.io/2017/11/12/View_OVER/">https://noteforme.github.io/2017/11/12/View_OVER/</a></p>
<h5 id="LayoutParams是是什么"><a href="#LayoutParams是是什么" class="headerlink" title="LayoutParams是是什么"></a>LayoutParams是是什么</h5><h5 id="介绍下SurfaceView"><a href="#介绍下SurfaceView" class="headerlink" title="介绍下SurfaceView"></a>介绍下SurfaceView</h5><ul>
<li><p>SurfaceView使用双缓冲技术缓解，页面绘制频繁引起的卡顿。</p>
</li>
<li><p>SurfaceView可以在子线程更新 UI,不会阻塞主线程，提高响应速度。</p>
<p><a target="_blank" rel="noopener" href="https://noteforme.github.io/2019/11/05/SurfaceView/">https://noteforme.github.io/2019/11/05/SurfaceView/</a></p>
<p>SurfaceView在更新视图时用到了两张 Canvas，可以先创建一个临时的Canvas对象，将图像都绘制到这个临时的Canvas对象中，绘制完成之后再将这个临时Canvas对象中的内容(也就是一个Bitmap)，通过drawBitmap()方法绘制到onDraw()方法中的canvas对象中。</p>
</li>
</ul>
<h5 id="RecycleView的使用"><a href="#RecycleView的使用" class="headerlink" title="RecycleView的使用"></a>RecycleView的使用</h5><p>​    <a target="_blank" rel="noopener" href="https://noteforme.github.io/2017/07/17/RecyclerView/">https://noteforme.github.io/2017/07/17/RecyclerView/</a></p>
<h5 id="webview安全问题"><a href="#webview安全问题" class="headerlink" title="webview安全问题"></a>webview安全问题</h5><p>WebView漏洞的根源在于强制其访问攻击者控制的网页。网页中含有攻击者可以控制的JS,因此可能钓鱼，窃取私有文件，甚至是 RCE,带来比较大的危害。</p>
<p>下面主要是4.4系统以上的机型</p>
<h5 id="Webview密码明文存储漏洞"><a href="#Webview密码明文存储漏洞" class="headerlink" title="Webview密码明文存储漏洞"></a>Webview密码明文存储漏洞</h5><p>WebView默认开启密码保存功能mWebView.setSavePassword(true),如果未关闭，用户输入密码时，会弹出提示框，询问用户是否保存密码，如果选是，密码会明文保存到 /data/data/com.package.name/databases/webview.db</p>
<h5 id="WebView域控制不严格漏洞"><a href="#WebView域控制不严格漏洞" class="headerlink" title="WebView域控制不严格漏洞"></a>WebView域控制不严格漏洞</h5><p>setAllowFileAccess(true) : 窃取APP任意目录下的私有文件</p>
<p>​    setAllowUniversalAccessFromFileURLs : 允许通过file域url中的 javascript访问其他的源。</p>
<p><a target="_blank" rel="noopener" href="https://noteforme.github.io/2017/09/01/WebView/">https://noteforme.github.io/2017/09/01/WebView/</a></p>
<h5 id="webview内存泄漏-Leakcanary-验证"><a href="#webview内存泄漏-Leakcanary-验证" class="headerlink" title="webview内存泄漏 Leakcanary 验证?"></a>webview内存泄漏 Leakcanary 验证?</h5><p>​    android 5.0以下有内存泄漏问题</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6901487965562732551">https://juejin.cn/post/6901487965562732551</a></p>
<p>viewstub延迟加载原理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 设置 ViewStub 不进行绘制</span></span><br><span class="line">     setWillNotDraw(<span class="keyword">true</span>);</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceSelfWithView</span><span class="params">(View view, ViewGroup parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> index = parent.indexOfChild(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 把 ViewStub 从控件层级中移除。</span></span><br><span class="line">    parent.removeViewInLayout(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把新创建的 View 对象加入控件层级结构中，并且位于 ViewStub 的位置，</span></span><br><span class="line">    <span class="comment">// 并且在这个过程中，会使用 ViewStub 的布局参数，例如宽高等。</span></span><br><span class="line">    <span class="keyword">final</span> ViewGroup.LayoutParams layoutParams = getLayoutParams();</span><br><span class="line">    <span class="keyword">if</span> (layoutParams != <span class="keyword">null</span>) &#123;</span><br><span class="line">        parent.addView(view, index, layoutParams);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent.addView(view, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    <a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903799337779214">https://juejin.cn/post/6844903799337779214</a></p>
<h5 id="overdraw过度绘制优化方法"><a href="#overdraw过度绘制优化方法" class="headerlink" title="overdraw过度绘制优化方法"></a>overdraw过度绘制优化方法</h5><p>​    移除默认和不必要背景</p>
<p>​    <a target="_blank" rel="noopener" href="https://jaeger.itscoder.com/android/2016/09/29/android-performance-overdraw.html">https://jaeger.itscoder.com/android/2016/09/29/android-performance-overdraw.html</a></p>
<p>​    <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9e095bacf44a">https://www.jianshu.com/p/9e095bacf44a</a></p>
<ul>
<li>View刷新机制</li>
<li>View绘制流程</li>
<li>自定义控件原理</li>
<li>如何取消AsyncTask？</li>
<li>为什么不能在子线程更新UI？</li>
<li>Requestlayout，onlayout，onDraw，DrawChild区别与联系</li>
<li>invalidate和postInvalidate的区别及使用</li>
<li>Activity-Window-View三者的差别</li>
<li>自定义View如何考虑机型适配</li>
<li>自定义View的事件</li>
<li>封装View的时候怎么知道view的大小</li>
</ul>
<h4 id="事件分发机制"><a href="#事件分发机制" class="headerlink" title="事件分发机制"></a>事件分发机制</h4><p>是否解决过事件冲突问题，怎么解决的。</p>
<p>问题: <a target="_blank" rel="noopener" href="https://juejin.cn/post/6922300686638153736">https://juejin.cn/post/6922300686638153736</a></p>
<p><a target="_blank" rel="noopener" href="https://noteforme.github.io/categories/VIEW/">https://noteforme.github.io/categories/VIEW/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1754y1H7jT">https://www.bilibili.com/video/BV1754y1H7jT</a></p>
<p>请描述一下View事件传递分发机制</p>
<ul>
<li>Touch事件传递流程</li>
<li>事件分发中的onTouch 和onTouchEvent 有什么区别，又该如何使用？</li>
<li>View和ViewGroup分别有哪些事件分发相关的回调方法</li>
</ul>
<h4 id="我的面试问题"><a href="#我的面试问题" class="headerlink" title="我的面试问题"></a>我的面试问题</h4><h5 id="activity被销毁后重建，怎么获取fragment"><a href="#activity被销毁后重建，怎么获取fragment" class="headerlink" title="activity被销毁后重建，怎么获取fragment"></a>activity被销毁后重建，怎么获取fragment</h5><p>​    findFragmentByTag</p>
<p>​    <a target="_blank" rel="noopener" href="https://www.wanandroid.com/wenda/show/11077">https://www.wanandroid.com/wenda/show/11077</a></p>
<h5 id="activity和service通信"><a href="#activity和service通信" class="headerlink" title="activity和service通信"></a>activity和service通信</h5><ol>
<li><p>通过bindService</p>
</li>
<li><p>通过广播</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6040dfa83594">https://www.jianshu.com/p/6040dfa83594</a></p>
</li>
</ol>
<h5 id="activity销毁线程会不会消失"><a href="#activity销毁线程会不会消失" class="headerlink" title="activity销毁线程会不会消失"></a>activity销毁线程会不会消失</h5><p>不会,  可以这样处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 静态内部类将不会再隐式的持有外部类的引用，所以在配置改变时，你的Activity的实例在也不会</span></span><br><span class="line"><span class="comment">  * 出现内存泄露</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">boolean</span> mRunning = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     mRunning = <span class="keyword">true</span>;</span><br><span class="line">     <span class="keyword">while</span> (mRunning) &#123;</span><br><span class="line">       SystemClock.sleep(<span class="number">1000</span>);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     mRunning = <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="activity每个方法处理的区别"><a href="#activity每个方法处理的区别" class="headerlink" title="activity每个方法处理的区别"></a>activity每个方法处理的区别</h5><ol>
<li><p>onCreate():  Activity创建的时候调用，绑定数据。</p>
</li>
<li><p>onStart() : 当Activity对用户变得可见的时候调用.</p>
</li>
<li><p>onResume() : activity开始和用户交互的时候调用，这时候activity处于栈顶，伴随着用户的输入.</p>
</li>
<li><p>onPause() : 当activity失去前台状态，开始进入stopped/hidden or destroyed状态，不能再获取焦点，此时activity对用户可见，但是更新的UI的操作要快。</p>
</li>
<li><p>onStop()  :  当activity不再可见，可能是新的activity来到栈顶，或者当前activity正在被destroy.</p>
</li>
<li><p>onDestory(): 当前activity正在离开。</p>
</li>
</ol>
<h5 id="activity-fragment传递数据方式"><a href="#activity-fragment传递数据方式" class="headerlink" title="activity fragment传递数据方式"></a>activity fragment传递数据方式</h5><ul>
<li><p> ViewModel</p>
</li>
<li><p>onTach() 回调</p>
</li>
</ul>
<h5 id="单例模式怎么理解的"><a href="#单例模式怎么理解的" class="headerlink" title="单例模式怎么理解的"></a>单例模式怎么理解的</h5><p>  创建唯一的对象 </p>
<ul>
<li>res/raw和assets 三者目录下的文件在打包后原封不动的保存在apk包中，不会被编译成二进制。</li>
<li>Res/raw文件会被映射到R.java文件中，访问的时候直接使用资源 R.id.filename;</li>
<li>res/raw不可以有目录结构，而asserts则可以有目录结构，也就是asserts目录下可以建立文件夹.</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4c8bcb8c3717">https://www.jianshu.com/p/4c8bcb8c3717</a></p>
<h5 id="截获通知"><a href="#截获通知" class="headerlink" title="截获通知"></a>截获通知</h5><p>新建一个服务MessageNotificationService实现 NotificationListenerService</p>
<h5 id="final特性"><a href="#final特性" class="headerlink" title="final特性"></a>final特性</h5><ol>
<li>final类不能被继承，没有子类</li>
<li>方法不能被子类的方法重写，但可以被继承</li>
<li>表示常量，只能被赋值一次，赋值后不再改变。</li>
</ol>
<h5 id="android多线程怎么处理的-，两个子线程间怎么通讯"><a href="#android多线程怎么处理的-，两个子线程间怎么通讯" class="headerlink" title="android多线程怎么处理的 ，两个子线程间怎么通讯"></a>android多线程怎么处理的 ，两个子线程间怎么通讯</h5><p>​    Android主线程和子线程之间的通信是通过消息循环机制，主线程中的handler把子线程的 message发送给主线程的Looper，那么子线程是如何通信的， 可以把looper绑定到子线程中，调用Looper.prepare()为改子线程生成Looper,然后调用Looper.loop()启动消息队列，并且在该子线程中创建一个Handler,在另一个子线程调用handler发送消息。这样实现通信.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> threadA = ThreadA()</span><br><span class="line"><span class="keyword">val</span> threadB = ThreadB()</span><br><span class="line">Thread(threadA).start()</span><br><span class="line"><span class="keyword">if</span> (threadA.getHandler() == <span class="literal">null</span>) &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">    handler = threadA.getHandler()</span><br><span class="line">&#125;</span><br><span class="line">Thread(threadB).start()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> : <span class="type">Runnable &#123;</span></span></span><br><span class="line">        <span class="keyword">var</span> mHandler: Handler? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getHandler</span><span class="params">()</span></span>: Handler? &#123;</span><br><span class="line">            <span class="keyword">return</span> mHandler</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">            Looper.prepare()</span><br><span class="line">            mHandler = <span class="keyword">object</span> : Handler(Looper.myLooper()!!) &#123;</span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>)</span></span> &#123;</span><br><span class="line">                    <span class="keyword">super</span>.handleMessage(msg)</span><br><span class="line">                    Timber.d(<span class="string">&quot;线程A: 线程B发过来消息了-- <span class="subst">$&#123;msg.obj&#125;</span> &quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Looper.loop()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> : <span class="type">Runnable &#123;</span></span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">val</span> message = Message.obtain()</span><br><span class="line">            message.what = <span class="number">1</span></span><br><span class="line">            message.obj = <span class="string">&quot;线程B 发送消息&quot;</span> + System.currentTimeMillis()</span><br><span class="line">            handler?.sendMessage(message)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/pbm863521/article/details/103493708">https://blog.csdn.net/pbm863521/article/details/103493708</a></p>
<h5 id="防止应用被被杀死-怎么保证service不被杀死"><a href="#防止应用被被杀死-怎么保证service不被杀死" class="headerlink" title="防止应用被被杀死,怎么保证service不被杀死"></a>防止应用被被杀死,怎么保证service不被杀死</h5><p><a target="_blank" rel="noopener" href="http://www.52im.net/thread-2881-1-1.html">http://www.52im.net/thread-2881-1-1.html</a></p>
<p><a target="_blank" rel="noopener" href="http://www.52im.net/thread-2893-1-1.html">http://www.52im.net/thread-2893-1-1.html</a></p>
<h5 id="怎么让线程有序"><a href="#怎么让线程有序" class="headerlink" title="怎么让线程有序"></a>怎么让线程有序</h5><h5 id="两个线程，想让来的一个插队怎么弄"><a href="#两个线程，想让来的一个插队怎么弄" class="headerlink" title="两个线程，想让来的一个插队怎么弄"></a>两个线程，想让来的一个插队怎么弄</h5><p>​    Join</p>
<p>批量网络请求</p>
<p>子线程创建Handler</p>
<p>context对象互相引用，对象回收 Android界面怎么回收的 生命周期 </p>
<p>内存溢出和内存泄露的区别，oom是怎么处理的 ， ANR怎么避免</p>
<p>java内存回收机制 android管理机制 怎么处理内存泄露</p>
<p>怎么做性能优化</p>
<p>反射机制</p>
<p>broadcastReciever和 handler区别</p>
<p>后台图片更改，前台怎么处理</p>
<p>图片加载库,图片加载方法</p>
<p>图片加载框架怎么处理oom问题</p>
<p>java Android加载机制</p>
<p>Android加载动态库</p>
<p>AndroidManifest权限是怎么获取的，封装权限管理，为什么需要权限分组.</p>
<p>listview图片 缓存，listview怎么优化</p>
<p>viewpager listview处理滑动冲突 </p>
<p>list遍历删除</p>
<p>fragment tag</p>
<p>sercice ALDL (后面再弄)</p>
<p>Hashmap实现原理  实现有序</p>
<p>android事件分发机制，请详细说下整个流程</p>
<p>android四大组件的加载过程</p>
<p>提高sqlite的查询效率</p>
<p>冒泡排序，插入排序 </p>
<h3 id="Android源码相关分析"><a href="#Android源码相关分析" class="headerlink" title="Android源码相关分析"></a>Android源码相关分析</h3><h5 id="Handler机制和底层实现"><a href="#Handler机制和底层实现" class="headerlink" title="Handler机制和底层实现"></a>Handler机制和底层实现</h5><p>​    <a target="_blank" rel="noopener" href="https://noteforme.github.io/2017/08/21/Handler/">https://noteforme.github.io/2017/08/21/Handler/</a></p>
<h5 id="RecycleView"><a href="#RecycleView" class="headerlink" title="RecycleView"></a>RecycleView</h5><p>​    <a target="_blank" rel="noopener" href="https://noteforme.github.io/2017/07/17/RecyclerView/">https://noteforme.github.io/2017/07/17/RecyclerView/</a></p>
<h5 id="Binder通信原理与机制"><a href="#Binder通信原理与机制" class="headerlink" title="Binder通信原理与机制"></a>Binder通信原理与机制</h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Android_SE/article/details/103898581">https://blog.csdn.net/Android_SE/article/details/103898581</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Ko4y117Ca?p=74">https://www.bilibili.com/video/BV1Ko4y117Ca?p=74</a></p>
<h5 id="JetPack"><a href="#JetPack" class="headerlink" title="JetPack"></a>JetPack</h5><p><a target="_blank" rel="noopener" href="https://noteforme.github.io/categories/Jetpack/">https://noteforme.github.io/categories/Jetpack/</a></p>
<ul>
<li><p>Android各个版本API的区别</p>
</li>
<li><p>描述一次网络请求的流程</p>
</li>
<li><p>Bitmap对象的理解</p>
</li>
<li><p>ActivityThread，AMS，WMS的工作原理</p>
</li>
<li><p>SpareArray原理</p>
</li>
<li><p>AndroidService与Activity之间通信的几种方式</p>
</li>
<li><p>IntentService原理及作用是什么？</p>
</li>
<li><p>说说Activity、Intent、Service 是什么关系</p>
</li>
<li><p>ApplicationContext和ActivityContext的区别</p>
</li>
<li><p>SP是进程同步的吗?有什么方法做到同步？</p>
</li>
<li><p>谈谈多线程在Android中的使用</p>
</li>
<li><p>进程和 Application 的生命周期</p>
</li>
<li><p>AsyncTask机制</p>
</li>
<li><p>AsyncTask原理及不足</p>
</li>
<li><p>AndroidManifest的作用与理解</p>
</li>
</ul>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p><a target="_blank" rel="noopener" href="https://noteforme.github.io/2017/08/16/PerformancePatterns/">https://noteforme.github.io/2017/08/16/PerformancePatterns/</a></p>
<p><a target="_blank" rel="noopener" href="https://noteforme.github.io/2018/02/09/LeakMemory/">https://noteforme.github.io/2018/02/09/LeakMemory/</a></p>
<ul>
<li>ANR产生的原因是什么？</li>
<li>ANR定位和修正</li>
<li>oom是什么？</li>
<li>什么情况导致oom？</li>
<li>有什么解决方法可以避免OOM？</li>
<li>Oom 是否可以try catch？为什么？</li>
<li>内存泄漏是什么？</li>
<li>什么情况导致内存泄漏？</li>
<li>如何防止线程的内存泄漏？</li>
<li>内存泄露场的解决方法</li>
<li>内存泄漏和内存溢出区别？</li>
<li>LruCache默认缓存大小</li>
<li>如何通过广播拦截和abort一条短信？</li>
<li>广播引起anr的时间限制是多少？</li>
<li>计算一个view的嵌套层级</li>
<li>Activity栈</li>
<li>Android线程有没有上限？</li>
<li>线程池有没有上限？</li>
<li>Android为什么引入Parcelable？</li>
<li>有没有尝试简化Parcelable的使用？</li>
</ul>
<p>（四）开发中常见的一些问题</p>
<ul>
<li><p>屏幕适配的处理技巧都有哪些?</p>
</li>
<li><p>服务器只提供数据接收接口，在多线程或多进程条件下，如何保证数据的有序到达？</p>
</li>
<li><p>动态布局的理解</p>
</li>
<li><p>怎么去除重复代码？</p>
</li>
<li><p>画出 Android 的大体架构图</p>
</li>
<li><p>Recycleview和ListView的区别</p>
</li>
<li><p>ListView图片加载错乱的原理和解决方案</p>
</li>
<li><p>动态权限适配方案，权限组的概念</p>
</li>
<li><p>Android系统为什么会设计ContentProvider？</p>
</li>
<li><p>下拉状态栏是不是影响activity的生命周期</p>
</li>
<li><p>如果在onStop的时候做了网络请求，onResume的时候怎么恢复？</p>
</li>
<li><p>Bitmap 使用时候注意什么？</p>
</li>
<li><p>Bitmap的recycler()</p>
</li>
<li><p>ViewPager使用细节，如何设置成每次只初始化当前的Fragment，其他的不初始化？</p>
</li>
<li><p>点击事件被拦截，但是想传到下面的View，如何操作？</p>
</li>
<li><p>微信上消息小红点的原理</p>
</li>
<li><p>CAS介绍（这是阿里巴巴的面试题，我不是很了解，可以参考博客: <a target="_blank" rel="noopener" href="http://blog.csdn.net/jly4758/article/details/46673835">CAS简介</a>）</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/android-exchange/Android-Interview">https://github.com/android-exchange/Android-Interview</a></p>
<p>Kotin面试题</p>
<p><a target="_blank" rel="noopener" href="http://www.youkmi.cn/2019/10/27/kotlin-ti-mu-zheng-li/">http://www.youkmi.cn/2019/10/27/kotlin-ti-mu-zheng-li/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/45866c8415c8">https://www.jianshu.com/p/45866c8415c8</a></p>
<p>怎么看源码 </p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1d54y1h768">https://www.bilibili.com/video/BV1d54y1h768</a></p>
<p>面经</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sjy0118/article/details/112759112">https://blog.csdn.net/sjy0118/article/details/112759112</a></p>
<p><a target="_blank" rel="noopener" href="https://www.kaelli.com/43.html">https://www.kaelli.com/43.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/058c54948ca5">https://www.jianshu.com/p/058c54948ca5</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6888222422760488974#heading-51">https://juejin.cn/post/6888222422760488974#heading-51</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Omooo/Android_QA">https://github.com/Omooo/Android_QA</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-01-15T02:24:37.000Z" title="1/15/2019, 10:24:37 AM">2019-01-15</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-09-03T12:02:04.234Z" title="9/3/2023, 8:02:04 PM">2023-09-03</time></span><span class="level-item">25 minutes read (About 3749 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/01/15/Android_interview/">Android_interview</a></p><div class="content"><p><a target="_blank" rel="noopener" href="https://github.com/Moosphan/Android-Daily-Interview/">https://github.com/Moosphan/Android-Daily-Interview/</a></p>
<p><a target="_blank" rel="noopener" href="https://lrh1993.gitbooks.io/android_interview_guide/content/">https://lrh1993.gitbooks.io/android_interview_guide/content/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/396383934924292096">https://www.nowcoder.com/discuss/396383934924292096</a></p>
<p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/456922214454091776">https://www.nowcoder.com/discuss/456922214454091776</a></p>
<p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/462666906584043520">https://www.nowcoder.com/discuss/462666906584043520</a></p>
<p>我是21年入坑，一年晋升一次，第一次靠业务配合技术，第二次靠数据监控搭建配合数据挖掘找业务优化点，下一步打算挖掘端智能配合动态化加上数据挖掘来继续晋升，另外我是iOS和Android都做，希望对你有帮助 … 展开  </p>
<p>作者：吐泡泡的咸鱼<br>链接：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/?type=11023_0">https://www.nowcoder.com/?type=11023_0</a><br>来源：牛客网</p>
<h1 id="怎么在短时间打牢基础？"><a href="#怎么在短时间打牢基础？" class="headerlink" title="怎么在短时间打牢基础？"></a>怎么在短时间打牢基础？</h1><p>你就搜搜大多数的面试题经常问那些问题，提起多看几遍，不至于问到的时候，根本不知道说什么，至少你能说出个大概也比什么都说不出来好。当然，这不是教你诈，是你找到工作后，要赶紧把自己薄弱的地方补上来。</p>
<p>我11月顺利拿到了OPPO公司Android工程师offer，我有三年多的工作经验，这次面试历经两轮，终于是拿到了offer，一面是以项目来展开的，简历上的东西一定要熟悉，面试官就是通过简历去问，然后会针对项目中遇到的问题，让你现场给你解决方案。 二面是由部门的主管负责面试，主要也是询问工作上的一些事，大头当然还是项目上的经历，遇到的难点和解决办法，还针对团队合作问题上提了一些问题，类似于结构化面试中的人际关系题，考察的应该是沟通协调能力了吧。</p>
<p>作者：juncos<br>链接：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/?type=11023_0">https://www.nowcoder.com/?type=11023_0</a><br>来源：牛客网</p>
<p>OSI七层网络模型<br>UDP和TCP的区别，UDP的使用例子，TCP怎么保证连接可靠<br>HTTP1，HTTP2，HTTP3的协议<br>TCP三次握手四次挥手，如果中间信息丢失了怎么办，设置超时时间那这个时间具体应该设置多少<br>HTTPS的加密过程，为什么第一次发送公钥不需要加密<br>HTTP状态码分别代表什么意思<br>数据库TABLE和VIEW的区别（我回答不太懂数据库后面就没问了）<br>死锁产生条件<br>FragmentManager的Add和Replace区别<br>Activity因为内存不足销毁了如何恢复数据<br>点击锁屏后Activity会执行onPause和onStop吗<br>Recyclerview的复用机制</p>
<p>作者：牛客784018930号</p>
<p>\3. 介绍一下七层模型，每一层的作用</p>
<p>\4. 生产者消费者模型，应用（线程池）</p>
<p>\5. 用过线程池吗，线程池如何实现</p>
<p>\6. 进程间通信方式</p>
<p>\7. http请求的过程</p>
<p>\8. 什么是多态，应用场景</p>
<p>\9. 了解过设计模式吗？单例模式，应用场景</p>
<p>\10. epoll的优势</p>
<p>\11. 手撕简单题</p>
<p>\12. 项目中遇到什么困难，应用场景</p>
<p>作者：已run的小学生很爱看电影<br>链接：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/?type=11023_0">https://www.nowcoder.com/?type=11023_0</a><br>来源：牛客网</p>
<p>\1. kotlin的let，apply，also有什么区别。<br>\2. kotlin的inline，nonline关键字有什么作用。<br>\3. 异步调用有几种方式，从简单到复杂。<br>\4. 如何全局管理异步任务(不知道)<br>\5. mvvm与mvp的区别。<br>\6. 逆变与协变。<br>\7. content provider的作用。<br>\8. sqlite的底层原理(不了解)<br>\9. 索引的原理及实现。<br>\10. 跨端框架的核心实现要点(开放题)<br>\11. 如何定位ANR和崩溃问题的原因。</p>
<p>作者：摸不着头发</p>
<p>·对面向对象的理解<br>·ArrayList扩容等<br>·垃圾回收<br>·网络七层协议<br>·TCP三次握手 四次挥手<br>·https加密的算法</p>
<h1 id="快手客户端一面（40min）"><a href="#快手客户端一面（40min）" class="headerlink" title="快手客户端一面（40min）"></a>快手客户端一面（40min）</h1><p>自我介绍</p>
<p>1.ArrayList的扩容机制？</p>
<p>2.底层实现？深拷贝还是浅拷贝？</p>
<p>3.单例模式</p>
<p>4.懒汉线程安全？</p>
<p>5.多线程下如何保证类的线程安全？</p>
<p>6.CopyOnWriteArrayList底层实现？如何实现线程安全？</p>
<p>7.HTTP支持长链接吗？什么时候开始支持的？</p>
<p>8.长连接什么时候会释放？</p>
<p>9.服务端通过timeout还是探测决定是否关闭长连接？</p>
<p>10.TCP有没有这种关闭连接的方式？</p>
<p>11.算法题：给你一个数组，和一个数字m，问这个数组中存不存在一个子序列（不一定连续），使得它的和为m，输出true或false</p>
<p>12.反问</p>
<p>作者：Namcoo</p>
<h1 id="影石：客户端iOS开发，一面面经"><a href="#影石：客户端iOS开发，一面面经" class="headerlink" title="影石：客户端iOS开发，一面面经"></a>影石：客户端iOS开发，一面面经</h1><p>\4. 八股：计网和数据结构与算法<br>4.1 你知道哪些常见的数据结构？<br>4.2 链表有哪些类型？<br>4.3 什么是哈希冲突？<br>4.4 说一下排序算法中冒泡排序如何实现？<br>4.5 快速排序如何实现？<br>4.6 堆排序知道吗？如何实现？（麻了已经）<br>4.7 TCP协议与UDP协议的区别<br>4.8 TCP三次握手和四次挥手的过程<br>4.9 TCP滑动窗口、拥塞控制如何实现？<br>4.10 HTTP1.0、HTTP1.1、HTTP2.0知道吗？他们相比之前的版本有哪些优化？</p>
<p>作者：勤奋的鼠鼠</p>
<h1 id="2023-5-9-美团-移动端-一面（1小时）"><a href="#2023-5-9-美团-移动端-一面（1小时）" class="headerlink" title="2023.5.9 美团 移动端 一面（1小时）"></a>2023.5.9 美团 移动端 一面（1小时）</h1><p>了解网络字节序吗</p>
<p>你对移动端客户端开发感兴趣吗</p>
<p>介绍一下中介者模式吧</p>
<p>除了中介者模式你还了解哪些设计模式</p>
<p>面向对象的原则有哪些</p>
<p>C语言源文件编译过程</p>
<p>知道编译器前端和后端吗</p>
<p>死锁是什么，怎么避免死锁</p>
<p>关于前端你学过什么，了解前端的框架吗</p>
<p>你平时都通过什么方式学习</p>
<p>两个算法（判断链表是否有环、链表重排/链表折叠）</p>
<p>反问</p>
<p>作者：genius1008</p>
<h1 id="快手客户端2面"><a href="#快手客户端2面" class="headerlink" title="快手客户端2面"></a>快手客户端2面</h1><p>项目</p>
<ul>
<li>compose和view写法的优缺点</li>
<li>使用recycleview碰到的问题</li>
<li>glide的缓存加载机制</li>
<li>compose实现音乐播放栏固定</li>
<li>安卓glide中与生命周期的关系</li>
</ul>
<p>java</p>
<ul>
<li>双亲委派(写一个路径名字一样的String，new String（）会创建自己写的还是系统的)</li>
<li>受检异常和非受检异常</li>
<li>抽象类和接口的区别</li>
</ul>
<p>koltin</p>
<ul>
<li>作用域函数（应用场景）</li>
<li>高阶函数（概念）</li>
<li>kotlin和java一块编译碰到啥问题</li>
<li>::funName 双冒号的写法的理解</li>
<li>泛型 out in 与Java泛型中的联系和区别</li>
</ul>
<p>安卓</p>
<ul>
<li>activity a -&gt; b 的生命周期 （哪个阶段界面不可见）</li>
<li>fragment的构造函数初始化，navigate的跳转。两种方式理解</li>
<li>可以异步加载fragment吗，答案：可以。</li>
<li>serialVersionUID是否了解</li>
</ul>
<p>算法</p>
<ul>
<li>反转字符串</li>
<li>上楼梯动态规划，如果第M阶梯是不能踩的</li>
</ul>
<p>作者：偷偷look痛苦面具</p>
<h1 id="安卓开发货拉拉日常实习-寄"><a href="#安卓开发货拉拉日常实习-寄" class="headerlink" title="安卓开发货拉拉日常实习(寄)"></a>安卓开发货拉拉日常实习(寄)</h1><p>\1. 先问项目(提到了滑动冲突怎么解决的)<br>\2. 安卓有哪几种页面通讯的方式<br>\3. 用过什么开源框架（消息总线<a href="">#%￥#</a>？）<br>\4. jetpack全家桶用过哪些<br>\5. livedata有什么能力<br>\6. java里弱引用和强引用分别用在什么场景<br>\7. 用到什么布局（为什么不用constraintLayout)<br>\8. glide和OkHttp的任务调度是怎么实现的（比如同时发起很多请求）<br>\9. handlerMessage什么时候会发生内存泄漏（要怎么预防）<br>\10. handler和Activity两者是怎么相互引用的？（这里没听懂，面试官语速太快太模糊了）<br>\11. handle和Activity在链表中的顺序是怎么样的？<br>\12. http协议有哪些跟缓存相关的属性？<br>\13. kotlin比java新的地方在哪<br>\14. 知道哪些高阶函数</p>
<p>作者：JojoYo<br>链接：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/?type=11023_0">https://www.nowcoder.com/?type=11023_0</a><br>来源：牛客网</p>
<h1 id="东方财富校招安卓二面50min（已过）"><a href="#东方财富校招安卓二面50min（已过）" class="headerlink" title="东方财富校招安卓二面50min（已过）"></a>东方财富校招安卓二面50min（已过）</h1><p>2.为什么选择东财<br>3.介绍项目，具体的一些功能会问怎么实现的<br>4.问第三方库如okhttp、picasso等底层原理如缓存机制等（一个也没答上来，literally<br>5.穿插问面向对象、安卓、java、计网的常规知识，网上面经可以概括者不加赘述<br>6.深入问handler（比如messagequeue为空时候，looper在做什么）<br>7.问设计模式，要求挑一个深入分析，问你对这些模式的理解<br>8.安卓怎么判断activity发生内存泄漏（其实我没答上来，面试官问有简易方法么？我说as内置的资源监视工具里面看是否在使用的时候内存占用不停增加，面试官说嗯应该可以。。<br>9.threadlocal，动态代理，这俩我说没用过不了解<br>10.recyclerview的缓存机制（知道但不懂，我说做项目用list view出现了重复刷显示的问题，所以换了recyclerview解决<br>11.图片有哪些格式，他们的区别？（报菜名，并且一问三不知</p>
<p>过于基础的不贴了，这位面试官感觉技术特扎实，但是他对技术的考量应该有一定阈值，大部分是在给你施加压力考察在压力中应变的能力。比如问了很多源码我一概不知，他这时候说那你对什么比较了解？我把handler整套流程憋出来了，并且说我是在xx项目遇到xx问题所以深入了解了handler</p>
<p>作者：歇息必取</p>
<h1 id="东方财富校招Android一面（春招）"><a href="#东方财富校招Android一面（春招）" class="headerlink" title="东方财富校招Android一面（春招）"></a>东方财富校招Android一面（春招）</h1><p>\2. 多实现接口，如果接口里面有入参出参一样的同名方法，会实现几个<br>\3. 说一下final，static<br>\4. static方法能调用非静态吗，非静态能调用static吗<br>\5. final的arraylist，往里面add东西会咋样（摸黑了，完全不确定，当时瞎蒙了个答案<br>\6. 面试官给了一段代码，问运行结果：代码是new了个空arraylist（string，integer）问这时候int i=arraylist.get（“key”）然后print会输出啥<br>\7. 如果是Integer i呢，会是啥（好家伙两个全答错）<br>\8. 安卓问得不多且比较基础，忘了<br>\9. 倒水问题，3l和5l桶子要4l水怎么搞<br>\10. 算法思路，链表右移动k位和数组右移动k位怎么搞<br>\11. 左右括号匹配，最少情况要加多少次括号，写在纸上拍照<br>三、大概说说项目，反问</p>
<p>作者：歇息必取</p>
<h1 id="百度安卓春招二面凉经"><a href="#百度安卓春招二面凉经" class="headerlink" title="百度安卓春招二面凉经"></a>百度安卓春招二面凉经</h1><p>java内存分配   方法区：方法没有运行的时候，实在这里存储的<br>栈区：方法如果进行运行，在没有进行新生成数据的时候，代码就是在栈中存储。<br>堆区：new出来的东西会在这块内存中开辟空间并产生地址</p>
<p>GC算法：<br>app启动流程<br>recyclerView<br>kotlin基础<br>安卓内存泄露<br>Retrofit 图片缓存<br>树、图的存储结构<br>http可以用UDP吗<br>线程进程区别</p>
<p>作者：想去广西嗦粉的小黄鸭在学习</p>
<h1 id="B站安卓客户端实习面经"><a href="#B站安卓客户端实习面经" class="headerlink" title="B站安卓客户端实习面经"></a>B站安卓客户端实习面经</h1><p>## 一面<br>1.自我介绍<br>2.项目<br>3.介绍一下多线程 问题很宽泛讲了一大堆<br>4.输入bilibili.com之后发生了什么<br>5.扩展：输入完了直接弹出一个广告可能是哪个环节出了问题，怎么解决<br>我猜是DNS解析出了问题，不知道怎么解决 面完之后想到清浏览器缓存、加强前端校验之类的<br>6.http协议1.0 2.0xx 版本之间的区别 有了解吗 （没了解）<br>7.TCP和UDP的区别<br>8.TCP为什么是可靠的<br>9.死锁了解吗 （没复习 但扯一点）<br>10.深拷贝、浅拷贝<br>11.你学习过安卓的哪些东西<br>12.介绍一下view渲染流程<br>13.写题 括号匹配<br>面完10分钟 hr约第二天下午二面</p>
<p>作者：FANIII__<br>链接：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/?type=11023_0">https://www.nowcoder.com/?type=11023_0</a><br>来源：牛客网</p>
<h1 id="火币"><a href="#火币" class="headerlink" title="火币"></a>火币</h1><h4 id="Global部门"><a href="#Global部门" class="headerlink" title="Global部门"></a>Global部门</h4><h5 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h5><p>1.HashMap原理<br> 2.创建HashMap要放入1000个不同hashCode的键值对,初始最大值多少<br> 3.ArrayList的remove方法原理<br> 4.对线程池的理解<br> 5.使用线程池的考虑因素<br> 6.线程池核心线程数数量的设计考虑因素<br> 7.CPU密集型和IO密集型<br> 8.DCL单例模式原理<br> 9.Fragment的replace,hide,add,show的区别<br> 10.多渠道打包<br> 11.APK瘦身<br> 12.Kotlin相比较java的好处<br> 13.Retrofit中的Call对象如何转换成okhttp的call对象(这个题目是埋坑的)<br> 14.Retrofit设计模式<br> 15.项目中的组件化架构方案<br> 16.对Arouter的理解<br> 17.在Google Play上架过吗<br> 18.对国外机型的适配方案<br> 19.对低端机型和弱网的适配方案<br> 20.线上问题排查方案<br> 21.Room有什么问题<br> 22.EditText的监控方法</p>
<h5 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h5><p>1.Android art 和 dalvik的区别<br> 2.协程的理解<br> 3.协程相对于线程的区别<br> 4.内存优化<br> 5.内存检测工具<br> 6.优化方面可以做的内容<br> 7.启动优化<br> 8.单例能否继承(对象初始化过程)<br> 9.APK体积优化<br> 10.加载so有几种方法<br> 11.okhttp责任链设计模式<br> 12.Activity的onDestory回调时机<br> 13.Activity调用finish后是否立即onDestory<br> 14.Activity A 启动 Activity B,Activity A 的onDestory和Activity B 的onCreate执行顺序<br> 15.Activity A 启动 Activity B,然后调用finish,Activity A 的onDestory和Activity B 的onCreate执行顺序<br> 16.Activity的singleTop和singleTask的区别<br> 17.Handler工作机制<br> 18.Looper如何识别Handler<br> 19.K线图的绘制和优化(非金融相关不用考虑这个问题)</p>
<h4 id="钱包部门"><a href="#钱包部门" class="headerlink" title="钱包部门"></a>钱包部门</h4><p>1.Kotlin 闭包<br> 2.Kotlin 静态方法<br> 3.链表逆序<br> 4.Handler的postDelay原理<br> 5.P2P网络<br> 6.okhttp发送请求的拦截方式<br> 7.okhttp的拦截器设计模式<br> 8.线上ANR监控策略<br> 9.线上卡顿监控策略<br> 10.区块链钱包的签名和交易原理</p>
<p>作者：天大地大我最大<br>链接：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/?type=11023_0">https://www.nowcoder.com/?type=11023_0</a><br>来源：牛客网</p>
<h1 id="View绘制前的流程"><a href="#View绘制前的流程" class="headerlink" title="View绘制前的流程"></a>View绘制前的流程</h1><p>算法题<br>给出二叉树的前序中序，输出后序</p>
<p>先来了一道算法题:找出最左边的次数最多的字母。</p>
<p>算法题：删除排序链表中的重复元素（力扣82）</p>
<p>快排和反转链表</p>
<p>判断一个树是不是平衡二叉树，</p>
<p>算法：旋转链表 LC61<br>题意是这样子的：给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。<br>输入：head=[1,2,3] k = 1<br>输出：[3,1,2]</p>
<p>22.算法题：二分法查找目标数</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2018-07-02T08:15:24.000Z" title="7/2/2018, 4:15:24 PM">2018-07-02</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-08-19T11:11:43.977Z" title="8/19/2021, 7:11:43 PM">2021-08-19</time></span><span class="level-item">32 minutes read (About 4826 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2018/07/02/INTERVIEW-CONCURRENCY/">INTERVIEW_CONCURRENCY</a></p><div class="content"><p><a target="_blank" rel="noopener" href="https://noteforme.github.io/tags/concurrency/">https://noteforme.github.io/tags/concurrency/</a></p>
<h3 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h3><h5 id="Java线程模型"><a href="#Java线程模型" class="headerlink" title="Java线程模型"></a>Java线程模型</h5><ol>
<li>用户线程与内核级线程</li>
<li>并发与并行</li>
<li>多线程模型</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://crazyfzw.github.io/2018/06/19/thred-model/">https://crazyfzw.github.io/2018/06/19/thred-model/</a></p>
<p>谈谈对多线程的理解</p>
<ol>
<li>在Android中一个应用程序就是一个单独的进程，一般来说，当我们运行一个应用，系统就会自动创建一个进程，并且为这个进程创建一个主线程–UI线程，这样就可以运行MainActivity。</li>
<li>线程是操作系统能够进行运算调度的最小单位，线程是进程的子集，线程可以并行的执行不同任务，所有的线程共享同一片内存空间，这就为线程间通信提供了基础，线程有五种状态：创建，就绪，运行，阻塞，死亡。</li>
</ol>
<h5 id="多线程有什么要注意的问题？"><a href="#多线程有什么要注意的问题？" class="headerlink" title="多线程有什么要注意的问题？"></a>多线程有什么要注意的问题？</h5><p>并发问题，安全问题，效率问题。</p>
<p>谈谈你对并发编程的理解并举例说明</p>
<p>谈谈你对多线程同步机制的理解？</p>
<h5 id="进程和线程的区别-协程呢"><a href="#进程和线程的区别-协程呢" class="headerlink" title="? 进程和线程的区别 协程呢"></a>? 进程和线程的区别 协程呢</h5><ul>
<li>进程  </li>
</ul>
<p>​    是系统给程序分配资源的基本单位，每个进程都有唯一的地址空间，一个程序至少有一个进程，一个进程至少有一个线程.</p>
<ul>
<li><p>线程</p>
<p>线程是执行操作的基本单位，JVM结构中共享 Method Area ,Heap Area</p>
</li>
</ul>
<p>​    <a target="_blank" rel="noopener" href="https://blog.csdn.net/mxsgoden/article/details/8821936">https://blog.csdn.net/mxsgoden/article/details/8821936</a></p>
<p>​    <a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html">https://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html</a></p>
<p>进程 : 有很大的独立性</p>
<p>线程 :  所有线程都有完全一样的地址空间,意味着它们也共享同样的全局变量。由于线程可以访问进程地址空间的每一个内存地址，所以一个线程可以读、写甚至清除另一个线程的堆栈。</p>
<p>每个进程中的内容 : 地址空间  全局变量 打开文件 子进程    即将发生的定时器    信号与信号处理程序</p>
<p>每个线程中的内容：程序计数器、寄存器、堆栈、状态.</p>
<p>协程?</p>
<p>​        协程拥有自己的寄存器上下文和栈，协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的    时候，恢复先前保存的寄存器上下文和栈，即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。</p>
<p>协程的好处:</p>
<ol>
<li>无需线程上下文切换的开销 </li>
<li>无需原子操作锁定及同步的开销</li>
<li>方便切换控制流，简化编程模型</li>
</ol>
<p>​    为什么要有线程，而不是仅仅用进程？</p>
<h5 id="怎么创建一个线程"><a href="#怎么创建一个线程" class="headerlink" title="怎么创建一个线程"></a>怎么创建一个线程</h5><ol>
<li><p>继承Thread类创建线程类.</p>
</li>
<li><p>通过Runnable接口创建线程类</p>
</li>
<li><p>通过Callable和FutureTask创建线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableThreadTest</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CallableThreadTest ctt = <span class="keyword">new</span> CallableThreadTest();</span><br><span class="line">        FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(ctt);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 的循环变量i的值&quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">20</span>) &#123;</span><br><span class="line">                <span class="keyword">new</span> Thread(ft, <span class="string">&quot;有返回值的线程&quot;</span>).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程的返回值：&quot;</span> + ft.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="线程如何关闭？"><a href="#线程如何关闭？" class="headerlink" title="线程如何关闭？"></a>线程如何关闭？</h5><p>​    最正确的停止线程的方式是使用 interrupt,和条件满足.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!Thread.currentThread().isInterrupted() &amp;&amp; cout&lt;<span class="number">1000</span>) &#123;</span><br><span class="line">    <span class="keyword">do</span> more work</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="在Java中wait和sleep方法的不同"><a href="#在Java中wait和sleep方法的不同" class="headerlink" title="在Java中wait和sleep方法的不同"></a>在Java中wait和sleep方法的不同</h5><pre><code>1. sleep作用Thread上，wait作用object上
2. sleep不会释放锁
3. sleep可以在任何代码块。wait必须在同步方法，持有锁中运行。
</code></pre>
<p>​    </p>
<p>谈谈wait/notify关键字的理解</p>
<ol>
<li>调用之前持有对象锁</li>
<li>wait ,线程进入 waiting状态，释放对象锁</li>
<li>notify,唤醒处于waiting状态的线程。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://howtodoinjava.com/java/multi-threading/wait-notify-and-notifyall-methods/">https://howtodoinjava.com/java/multi-threading/wait-notify-and-notifyall-methods/</a></p>
<h5 id="如何控制某个方法允许并发访问线程的个数？"><a href="#如何控制某个方法允许并发访问线程的个数？" class="headerlink" title="如何控制某个方法允许并发访问线程的个数？"></a>如何控制某个方法允许并发访问线程的个数？</h5><p>​    信号量</p>
<h5 id="什么导致线程阻塞？"><a href="#什么导致线程阻塞？" class="headerlink" title="什么导致线程阻塞？"></a>什么导致线程阻塞？</h5><ol>
<li> 阻塞指的是暂停一个线程的执行以等待某个条件发生。 Thread.sleep t.join 等待输入</li>
<li>线程执行了一个对象的<code>wait()</code>方法，直接进入阻塞状态，等待其他线程执行<code>notify()</code>或者<code>notifyAll()</code>方法。</li>
</ol>
<h5 id="如何保证线程安全？"><a href="#如何保证线程安全？" class="headerlink" title="如何保证线程安全？"></a>如何保证线程安全？</h5><pre><code>1. 使用线程安全的类。
2. 使用synchronized同步代码块，或者用Lock锁。
</code></pre>
<h5 id="如何实现线程同步？"><a href="#如何实现线程同步？" class="headerlink" title="如何实现线程同步？"></a>如何实现线程同步？</h5><pre><code> 1. Synchronized修饰整个方法或代码块。
 2. Lock
</code></pre>
<h5 id="两个进程同时要求写或者读，能不能实现？如何防止进程的同步？"><a href="#两个进程同时要求写或者读，能不能实现？如何防止进程的同步？" class="headerlink" title="两个进程同时要求写或者读，能不能实现？如何防止进程的同步？"></a>两个进程同时要求写或者读，能不能实现？如何防止进程的同步？</h5><p>​    可以进行同时读写，但为了保证数据的正确，必须要针对进程访问的共享临界区进行处理；两个进程不能同时进入临界区，否则会导致数据错乱。常见的处理方式有：<strong>信号量、管程、会合、分布式系统</strong></p>
<ul>
<li><p><strong>信号量</strong><br> 信号量是一个计数器，它只支持2种操作：P操作（进入临界区）和V操作（退出临界区）。假设有信号量SV，则对它的P、V操作含义如下：<br>   P(SV)，如果SV的值大于0，意味着可以进入临界区，就将它减1；如果SV的值为0，意味着别的进程正在访问临界区，则挂起当前进程的执行；<br>   V(SV)，当前进程退出临界区时，如果有其他进程因为等待SV而挂起，则唤醒之；如果没有，则将SV加1，之后再退出临界区。</p>
</li>
<li><p><strong>管程</strong><br>   提出原因：信号量机制不足，程序编写困难、易出错</p>
<pre><code>   方案：在程序设计语言中引入一种高级维护机制
   定义：是一个特殊的模块；有一个名字；由关于共享资源的数据结构及在其上操作上的一组过程组成。进程只能通过调用管程中的过程间接访问管程中的数据结构
</code></pre>
<p>  1）互斥：管程是互斥进入的 为了保证数据结构的数据完整性<br> 管程的互斥由编译器负责保证的，是一种语言机制<br>  2）同步：设置条件变量及等待唤醒操作以解决同步问题<br> 可以让一个进程或者线程在条件变量上等待（先释放管程的管理权），也可以通过发送信号将等待在条件变量上的进程线程唤醒</p>
</li>
</ul>
<p>  链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/72f5017c6649">https://www.jianshu.com/p/72f5017c6649</a></p>
<h5 id="线程间操作List"><a href="#线程间操作List" class="headerlink" title="线程间操作List"></a>线程间操作List</h5><p>​    </p>
<h5 id="怎么中止一个线程，Thread-Interupt一定有效吗？"><a href="#怎么中止一个线程，Thread-Interupt一定有效吗？" class="headerlink" title="怎么中止一个线程，Thread.Interupt一定有效吗？"></a>怎么中止一个线程，Thread.Interupt一定有效吗？</h5><p>不一定 </p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903896339447815#heading-6">https://juejin.cn/post/6844903896339447815#heading-6</a></p>
<h3 id="线程安全-锁"><a href="#线程安全-锁" class="headerlink" title="线程安全 锁"></a>线程安全 锁</h3><h5 id="讲一下java中的同步的方法-结果锁一起"><a href="#讲一下java中的同步的方法-结果锁一起" class="headerlink" title="讲一下java中的同步的方法 结果锁一起"></a>讲一下java中的同步的方法 结果锁一起</h5><ol>
<li><p>synchronized  </p>
</li>
<li><p>wait和notify</p>
</li>
<li><p>volatile</p>
<p>  a. volatile关键字为域变量的访问提供了一种免锁机制<br>  b.使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新<br>  c.因此每次使用该域就要重新计算，而不是使用寄存器中的值<br>  d.volatile不会提供任何原子操作，它也不能用来修饰final类型的变量 </p>
</li>
</ol>
<h5 id="synchronize的原理"><a href="#synchronize的原理" class="headerlink" title="synchronize的原理"></a>synchronize的原理</h5><blockquote>
<ol>
<li>原子性：确保线程互斥的访问同步代码；</li>
<li>可见性：保证共享变量的修改能够及时可见，其实是通过Java内存模型中的 “<strong>对一个变量unlock操作之前，必须要同步到主内存中；如果对一个变量进行lock操作，则将会清空工作内存中此变量的值，在执行引擎使用此变量前，需要重新从主内存中load操作或assign操作初始化变量值</strong>” 来保证的；</li>
<li>有序性：有效解决重排序问题，即 “一个unlock操作先行发生(happen-before)于后面对同一个锁的lock操作”；</li>
</ol>
</blockquote>
<h5 id="谈谈对Synchronized关键字，类锁，方法锁，重入锁的理解"><a href="#谈谈对Synchronized关键字，类锁，方法锁，重入锁的理解" class="headerlink" title="谈谈对Synchronized关键字，类锁，方法锁，重入锁的理解"></a>谈谈对Synchronized关键字，类锁，方法锁，重入锁的理解</h5><ol>
<li>当synchronized作用于普通方法是，锁对象是this；</li>
<li>当synchronized作用于静态方法是，锁对象是当前类的Class对象；</li>
<li>当synchronized作用于代码块时，锁对象是synchronized(obj)中的这个obj。</li>
</ol>
<h5 id="static-synchronized-方法的多线程访问和作用"><a href="#static-synchronized-方法的多线程访问和作用" class="headerlink" title="static synchronized 方法的多线程访问和作用"></a>static synchronized 方法的多线程访问和作用</h5><p>也就是两个的区别了,也就是synchronized相当于this.synchronized，而static synchronized相当于Something.synchronized，它可以对类的所有对象实例起作用</p>
<h5 id="synchronized与Lock的区别"><a href="#synchronized与Lock的区别" class="headerlink" title="synchronized与Lock的区别"></a>synchronized与Lock的区别</h5><p>Lock支持的功能:</p>
<p>公平锁：Synchronized是非公平锁，ReentrantLock支持公平锁，默认非公平锁</p>
<p>可中断锁：ReentrantLock提供了lockInterruptibly（）的功能，可以中断争夺锁的操作，抢锁的时候会check是否被中断，中断直接抛出异常，退出抢锁。而Synchronized只有抢锁的过程，不可干预，直到抢到锁以后，才可以编码控制锁的释放。</p>
<p>快速反馈锁：ReentrantLock提供了trylock（）  和 trylock（tryTimes）的功能，不等待或者限定时间等待获取锁，更灵活。可以避免死锁的发生。</p>
<p>读写锁：ReentrantReadWriteLock类实现了读写锁的功能，类似于Mysql，锁自身维护一个计数器，读锁可以并发的获取，写锁只能独占。而synchronized全是独占锁</p>
<p>Condition：ReentrantLock提供了比Sync更精准的线程调度工具，Condition，一个lock可以有多个Condition，比如在生产消费的业务下，一个锁通过控制生产Condition和消费Condition精准控制。</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/09d5ba4bfb7a">https://www.jianshu.com/p/09d5ba4bfb7a</a></p>
<h5 id="ReentrantLock的内部实现"><a href="#ReentrantLock的内部实现" class="headerlink" title="ReentrantLock的内部实现"></a>ReentrantLock的内部实现</h5><p>显式锁ReentrantLock和同步工具类的实现基础都是AQS (AbstractQueuedSynchronizer).AQS内部有一条双向的队列存放等待线程，节点是Node对象。每个Node维护了线程、前后Node的指针和等待状态等参数。</p>
<p>ReentrantLock是可重入锁，也就是同一个线程可以多次获取锁，每获取一次就会进行一次计数，解锁的时候就会递减这个计数，直到计数变为0。</p>
<p>它有两种实现，一种是公平锁，一种是非公平锁，</p>
<h5 id="lock原理"><a href="#lock原理" class="headerlink" title="lock原理"></a>lock原理</h5><p>整体来看Lock主要是通过两个东西来实现的分别是<strong>CAS和AQS(AbstractQueuedSynchronizer)。</strong>通过加锁和解锁的过程来分析锁的实现。</p>
<p>一、整体概述流程</p>
<ol>
<li><p>读取表示锁状态的变量</p>
</li>
<li><p>如果表示状态的变量的值为0，那么当前线程尝试将变量值设置为1（通过CAS操作完成），当多个线程同时将表示状态的变量值由0设置成1时，仅一个线程能成功，其它线程都会失败。失败后进入队列自旋转并阻塞当前线程。</p>
<p>  2.1 若成功，表示获取了锁，</p>
<blockquote>
<p>2.1.1 如果该线程（或者说节点）已位于在队列中，则将其出列（并将下一个节点则变成了队列的头节点）</p>
</blockquote>
<blockquote>
<p>2.1.2 如果该线程未入列，则不用对队列进行维护</p>
</blockquote>
<blockquote>
<p>2.1.3 然后当前线程从lock方法中返回，对共享资源进行访问。           </p>
</blockquote>
<p>   2.2 若失败，则当前线程将自身放入等待（锁的）队列中并阻塞自身，此时线程一直被阻塞在lock方法中，没有从该方法中返回（被唤醒后仍然在lock方法中，并从下一条语句继续执行，这里又会回到第1步重新开始）。</p>
</li>
<li><p>如果表示状态的变量的值为1，那么将当前线程放入等待队列中，然后将自身阻塞<br> <a target="_blank" rel="noopener" href="https://blog.csdn.net/liyantianmin/article/details/54673109">https://blog.csdn.net/liyantianmin/article/details/54673109</a></p>
</li>
</ol>
<h5 id="死锁的四个必要条件？"><a href="#死锁的四个必要条件？" class="headerlink" title="死锁的四个必要条件？"></a>死锁的四个必要条件？</h5><ol>
<li>互斥条件: 指线程对己经获取到的资源进行排它性使用 ，即该资源同时只由 一个线<br>程占用。如果 此时 还有其 他 线程请求获取该资源 ，则 请求者只能等待，直至占有资<br>源 的 线程释放该资源。</li>
<li>请求并持有条件 : 指一个线程己经持有了至少一个资源，但又提出了新的资源请求，<br>而新资源己被其 他 线程占有，所 以 当前线程会被阻塞 ，但 阻塞 的同时 并不释放自 己<br>己经获取的资源。</li>
<li>不可剥夺条件 : 指线程获取到的资源在自己使用完之前不能被其他线程抢占 ， 只有在自己使用完 毕后才 由 自 己释放该资源。</li>
<li>环路等待条件 : 指在发生死锁时 ，必然存在一个线程→资源的环形链 ，即线程集合</li>
</ol>
<h5 id="怎么避免死锁？"><a href="#怎么避免死锁？" class="headerlink" title="怎么避免死锁？"></a>怎么避免死锁？</h5><p>请求并持有和环路等待条件是可 以被破坏.</p>
<h5 id="synchronized是公平锁还是非公平锁-ReteranLock是公平锁吗？是怎么实现的"><a href="#synchronized是公平锁还是非公平锁-ReteranLock是公平锁吗？是怎么实现的" class="headerlink" title="synchronized是公平锁还是非公平锁,ReteranLock是公平锁吗？是怎么实现的"></a>synchronized是公平锁还是非公平锁,ReteranLock是公平锁吗？是怎么实现的</h5><ol>
<li>synchronized只能是非公平锁。</li>
<li>而ReentrantLock可以实现公平锁和非公平锁两种。</li>
<li>公平锁的公平的含义在于如果线程现在拿不到这把锁，那么线程就都会进入等待，开始排队，在等待队列里等待时间长的线程会优先拿到这把锁，有先来先得的意思。而非公平锁就不那么“完美”了，它会在一定情况下，忽略掉已经在排队的线程，发生插队现象</li>
</ol>
<h5 id="synchronized跟ReentranLock有什么区别？"><a href="#synchronized跟ReentranLock有什么区别？" class="headerlink" title="synchronized跟ReentranLock有什么区别？"></a>synchronized跟ReentranLock有什么区别？</h5><p>都是加锁方式同步，而且都是阻塞式的同步，也就是说当如果一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等待</p>
<ul>
<li><p>synchronized</p>
<p><strong>自动释放锁</strong>,只有非公平锁。都是可重入的</p>
</li>
<li><p>ReentrantLock</p>
<p> <strong>手动释放锁</strong></p>
</li>
</ul>
<h5 id="对象锁和类锁是否会互相影响？"><a href="#对象锁和类锁是否会互相影响？" class="headerlink" title="对象锁和类锁是否会互相影响？"></a>对象锁和类锁是否会互相影响？</h5><p>不会相互影响</p>
<ul>
<li><p>类锁</p>
<p>在代码中的方法上加了static和synchronized的锁，或者synchronized(xxx.class）的代码段</p>
</li>
<li><p>对象锁</p>
<p>在代码中的方法上加了synchronized的锁，或者synchronized(this）的代码段</p>
</li>
<li><p>私有锁</p>
<p>在类内部声明一个私有属性如private Object lock，在需要加锁的代码段synchronized(lock）</p>
</li>
</ul>
<h5 id="管理线程-提高效率"><a href="#管理线程-提高效率" class="headerlink" title="管理线程 提高效率"></a>管理线程 提高效率</h5><h5 id="volatile的原理"><a href="#volatile的原理" class="headerlink" title="volatile的原理"></a>volatile的原理</h5><p> 有序性.</p>
<p> 可见性 :</p>
<p>　    （1）修改volatile变量时会强制将修改后的值刷新的主内存中。</p>
<p>　　（2）修改volatile变量后会导致其他线程工作内存中对应的变量值失效。因此，再读取该变量值的时候就需要重新从读取主内存中的值。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/paddix/p/5428507.html">https://www.cnblogs.com/paddix/p/5428507.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1NT4y1G7WE?p=8">https://www.bilibili.com/video/BV1NT4y1G7WE?p=8</a></p>
<h5 id="synchronized-和volatile-关键字的区别"><a href="#synchronized-和volatile-关键字的区别" class="headerlink" title="synchronized 和volatile 关键字的区别"></a>synchronized 和volatile 关键字的区别</h5><ol>
<li>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性</li>
<li>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化.</li>
</ol>
<p>多线程断点续传原理</p>
<p>其实原理很简单，只需要保证每个子任务的下载进度能够被即时地记录即可。这样继续下载时只需要读取这些下载记录，从上次下载结束的位置开始下载即可。</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904013440221198">https://juejin.cn/post/6844904013440221198</a></p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h5 id="JavaAPI线程池有哪些参数"><a href="#JavaAPI线程池有哪些参数" class="headerlink" title="JavaAPI线程池有哪些参数"></a>JavaAPI线程池有哪些参数</h5><p><img src="https://s0.lgstatic.com/i/image2/M01/AD/A3/CgoB5l3eH8mAAoJCAACEOKMHtpw036.png"></p>
<p><img src="https://s0.lgstatic.com/i/image2/M01/AD/A3/CgoB5l3eH-KAAHpkAAC4vEMOXQ4797.png"></p>
<h5 id="为什么要用线程池"><a href="#为什么要用线程池" class="headerlink" title="为什么要用线程池"></a>为什么要用线程池</h5><ol>
<li>降低资源消耗2. 提高响应速度3. 提高线程的可管理性</li>
</ol>
<h5 id="什么是线程池，如何使用"><a href="#什么是线程池，如何使用" class="headerlink" title="什么是线程池，如何使用?"></a>什么是线程池，如何使用?</h5><p>很多小任务让一组线程来执行，而不是一个任务对应一个新线程。这种能接收大量小任务并进行分发处理的就是线程池</p>
<h5 id="什么是核心线程"><a href="#什么是核心线程" class="headerlink" title="什么是核心线程"></a>什么是核心线程</h5><p>​    常驻线程池的线程数量</p>
<h5 id="怎么销毁核心线程"><a href="#怎么销毁核心线程" class="headerlink" title="怎么销毁核心线程"></a>怎么销毁核心线程</h5><p>​    allowCoreThreadTimeOut</p>
<p>​    <a target="_blank" rel="noopener" href="https://objcoding.com/2019/04/14/threadpool-some-settings/">https://objcoding.com/2019/04/14/threadpool-some-settings/</a></p>
<h5 id="为什么DCL-DOUBLE-CHECK-LOCK要那么写，直接在方法前加synchronized不行吗"><a href="#为什么DCL-DOUBLE-CHECK-LOCK要那么写，直接在方法前加synchronized不行吗" class="headerlink" title="为什么DCL DOUBLE CHECK LOCK要那么写，直接在方法前加synchronized不行吗"></a>为什么DCL DOUBLE CHECK LOCK要那么写，直接在方法前加synchronized不行吗</h5><p>​    不DCL 这样写，就会创建多个实例</p>
<p>​    synchronized可以，这样粒度太大了.</p>
<p>​    <a target="_blank" rel="noopener" href="https://blog.csdn.net/zhaoyajie1011/article/details/106812327">https://blog.csdn.net/zhaoyajie1011/article/details/106812327</a></p>
<h5 id="如何让两个线程循环交替打印"><a href="#如何让两个线程循环交替打印" class="headerlink" title="如何让两个线程循环交替打印"></a>如何让两个线程循环交替打印</h5><p>LockSupport_1A2B.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">char</span>[] aI = <span class="string">&quot;1234567&quot;</span>.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] aC = <span class="string">&quot;ABCDEFG&quot;</span>.toCharArray();</span><br><span class="line"></span><br><span class="line">        t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : aI) &#123;</span><br><span class="line">                System.out.print(c);</span><br><span class="line">                LockSupport.unpark(t2);</span><br><span class="line">                LockSupport.park();</span><br><span class="line">            &#125;</span><br><span class="line">            LockSupport.unpark(t2);</span><br><span class="line">        &#125;);</span><br><span class="line">        t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : aC) &#123;</span><br><span class="line">                System.out.print(c);</span><br><span class="line">                LockSupport.unpark(t1);</span><br><span class="line">                LockSupport.park();</span><br><span class="line">            &#125;</span><br><span class="line">            LockSupport.unpark(t1);</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"><span class="comment">//        System.out.println(&quot;t1  &quot; + t1.getState());</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;t2  &quot; + t2.getState());</span></span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br></pre></td></tr></table></figure>



<p>Notify_1A2B.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Notify_1A2B o = <span class="keyword">new</span> Notify_1A2B();</span><br><span class="line"><span class="keyword">char</span>[] aI = <span class="string">&quot;1234567&quot;</span>.toCharArray();</span><br><span class="line"><span class="keyword">char</span>[] aC = <span class="string">&quot;ABCDEFG&quot;</span>.toCharArray();</span><br><span class="line">t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : aI) &#123;</span><br><span class="line">            System.out.print(c);</span><br><span class="line">            o.notify();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                o.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : aC) &#123;</span><br><span class="line">                System.out.print(c);</span><br><span class="line">                o.notify();</span><br><span class="line">                o.wait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t1.join();</span><br><span class="line">t2.join();</span><br></pre></td></tr></table></figure>



<p>协程可以在Java项目中使用吗？</p>
<p>线程池了解多少？拒绝策略有几种,为什么有newSingleThread</p>
<h5 id="跨进程通信了解多少？管道了解吗？"><a href="#跨进程通信了解多少？管道了解吗？" class="headerlink" title="跨进程通信了解多少？管道了解吗？"></a>跨进程通信了解多少？管道了解吗？</h5><pre><code>文件
AIDL （基于 Binder）
    Android 进阶：进程通信之 AIDL 的使用
    Android 进阶：进程通信之 AIDL 解析
Binder
    Android 进阶：进程通信之 Binder 机制浅析
Messenger （基于 Binder）
    Android 进阶：进程通信之 Messenger 使用与解析 
ContentProvider （基于 Binder）
    Android 进阶：进程通信之 ContentProvider 内容提供者 
Socket
    Android 进阶：进程通信之 Socket （顺便回顾 TCP UDP）
</code></pre>
<p><img src="https://img-blog.csdn.net/20170605011532312?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTI0MDg3Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"><br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u011240877/article/details/72863432">https://blog.csdn.net/u011240877/article/details/72863432</a></p>
<h5 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h5><ul>
<li>RXJava怎么切换线程</li>
<li>binder进程间通信可以调用原进程方法吗？</li>
<li>SharedPreference原理？读取xml是在哪个线程?</li>
<li>AQS了解吗？</li>
<li>ConcurrentHashMap，线程安全，为何安全。底层实现是怎么样的。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/63859501">https://www.zhihu.com/question/63859501</a></p>
<h5 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h5><p><a target="_blank" rel="noopener" href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf">http://gee.cs.oswego.edu/dl/papers/aqs.pdf</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV11Q4y1M7K2?from=search&amp;seid=12598203519866117819">https://www.bilibili.com/video/BV11Q4y1M7K2?from=search&amp;seid=12598203519866117819</a></p>
<p><a target="_blank" rel="noopener" href="https://javadoop.com/post/AbstractQueuedSynchronizer">https://javadoop.com/post/AbstractQueuedSynchronizer</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1yJ411v7er?from=search&amp;seid=12598203519866117819">https://www.bilibili.com/video/BV1yJ411v7er?from=search&amp;seid=12598203519866117819</a></p>
<h5 id="阻塞队列原理"><a href="#阻塞队列原理" class="headerlink" title="阻塞队列原理"></a>阻塞队列原理</h5><p><img src="https://s0.lgstatic.com/i/image3/M01/62/7D/Cgq2xl4le9SAL6enAAGpXZi8Wcg079.jpg"></p>
<p>阻塞功能:阻塞功能使得生产者和消费者两端的能力得以平衡，当有任何一端速度过快时，阻塞队列便会把过快的速度给降下来</p>
<p>是否有界</p>
<ul>
<li> LinkedBlockingQueue 的上限是 Integer.MAX_VALUE，约为 2 的 31 次方,</li>
<li>ArrayBlockingQueue 如果容量满了，也不会扩容，所以一旦满了就无法再往里放数据了。</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2018-06-22T10:56:44.000Z" title="6/22/2018, 6:56:44 PM">2018-06-22</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-01-02T03:31:39.079Z" title="1/2/2023, 11:31:39 AM">2023-01-02</time></span><span class="level-item">30 minutes read (About 4441 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2018/06/22/INTERVIEW-SENIOR/">INTERVIEW_SENIOR</a></p><div class="content"><hr>
<h3 id="高端技术面试题"><a href="#高端技术面试题" class="headerlink" title="高端技术面试题"></a>高端技术面试题</h3><p><strong>这里讲的是大公司需要用到的一些高端Android技术，这里专门整理了一个文档，希望大家都可以看看。这些题目有点技术含量，需要好点时间去研究一下的。</strong></p>
<h5 id="（一）图片"><a href="#（一）图片" class="headerlink" title="（一）图片"></a>（一）图片</h5><ul>
<li><p>图片库对比</p>
</li>
<li><p>图片库的源码分析</p>
</li>
<li><p>图片框架缓存实现</p>
</li>
<li><p>LRUCache原理</p>
</li>
<li><p>图片加载原理</p>
</li>
<li><p>自己去实现图片库，怎么做？</p>
</li>
<li><p>Glide源码解析</p>
</li>
<li><p>Glide使用什么缓存？</p>
</li>
<li><p>Glide内存缓存如何控制大小？</p>
</li>
</ul>
<h3 id="框架学习"><a href="#框架学习" class="headerlink" title="框架学习"></a>框架学习</h3><p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=pUV3qZh481k">https://www.youtube.com/watch?v=pUV3qZh481k</a></p>
<h4 id="okhttp"><a href="#okhttp" class="headerlink" title="okhttp"></a>okhttp</h4><p>​    <a target="_blank" rel="noopener" href="https://noteforme.github.io/2017/08/07/OKHTTP/">https://noteforme.github.io/2017/08/07/OKHTTP/</a></p>
<h6 id="okhttp怎么支持http2-0"><a href="#okhttp怎么支持http2-0" class="headerlink" title="okhttp怎么支持http2.0"></a>okhttp怎么支持http2.0</h6><p>​    Handshake则会把服务端支持的Tls版本，加密方式等都带回来，然后会把这个没有验证过的HandShake用X509Certificate去验证证书的有效性。然后会通过Platform去从SSLSocket去获取ALPN的协议支持信息，当后端支持的协议内包含Http2.0时，则就会把请求升级到Http2.0阶段。</p>
<p>​    配置合适的适配器，解析json数据。</p>
<p>​    Android 如何编写基于编译时注解的项目</p>
<p>​    编译时注解与运行时注解，为什么retrofit要使用运行时注解？什么时候用运行时注解？</p>
<p>​    在项目中有直接使用tcp,socket来发送消息吗</p>
<p>​    <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ib4y1f7S1">https://www.bilibili.com/video/BV1ib4y1f7S1</a></p>
<p>Okhttp缓存机制</p>
<h6 id="网络请求缓存处理，okhttp如何处理网络缓存的"><a href="#网络请求缓存处理，okhttp如何处理网络缓存的" class="headerlink" title="网络请求缓存处理，okhttp如何处理网络缓存的"></a>网络请求缓存处理，okhttp如何处理网络缓存的</h6><p>自己去设计网络请求框架，怎么做？</p>
<ul>
<li>从网络加载一个10M的图片，说下注意事项</li>
<li>TCP的3次握手和四次挥手</li>
<li>TCP与UDP的区别</li>
<li>TCP与UDP的应用</li>
<li>HTTP协议</li>
<li>HTTP1.0与2.0的区别</li>
<li>HTTP报文结构</li>
<li>HTTP与HTTPS的区别以及如何实现安全性</li>
<li>如何验证证书的合法性?</li>
<li>https中哪里用了对称加密，哪里用了非对称加密，对加密算法（如RSA）等是否有了解?</li>
<li>client如何确定自己发送的消息被server收到?</li>
<li>谈谈你对安卓签名的理解。</li>
<li>请解释安卓为啥要加签名机制?</li>
<li>视频加密传输</li>
<li>App 是如何沙箱化，为什么要这么做？</li>
<li>权限管理系统（底层的权限是如何进行 grant 的）？</li>
</ul>
<h4 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h4><p>在retrofit中的泛型是怎么解析的</p>
<p><a target="_blank" rel="noopener" href="https://noteforme.github.io/2017/09/23/Retrofit/">https://noteforme.github.io/2017/09/23/Retrofit/</a></p>
<h4 id="RxJava"><a href="#RxJava" class="headerlink" title="RxJava"></a>RxJava</h4><p><a target="_blank" rel="noopener" href="https://noteforme.github.io/2020/08/04/RxJava/">https://noteforme.github.io/2020/08/04/RxJava/</a></p>
<p>在 RxJava 中， 会遇到被观察者发送消息太快以至于它的操作符或者订阅者不能及时处理相关的消息，这就是典型的背压（ Back Pressure ）场景。</p>
<p>RxJava 是基于 Push 模型 。对于 Pull 模型而言，当消费者请求数据的时候，如果生产者比较慢  ，则消费者会阻塞等待。如果生产者比较快，生产者会等待消费者处理完后再生产新的数据，所以不会出现背压的情况。然而在 RxJava  中，只要生产者数据准备好了就会发射出去。如果生产者比较慢，则消费者会等待新的数据到来。如果生产者比较快，则会有很多数据发射给消费者，而不管消费者当前有没有能力处理数据，这样就会导致背压。</p>
<p>在 RxJava 2.x 中， Observable 不再支持背压，而是改用 Flowable 来专门支持背压。默认队列大小为 128 ，并且要求所有的操作符强制支持背压。</p>
<h5 id="RxJava原理及如何封装使用"><a href="#RxJava原理及如何封装使用" class="headerlink" title="RxJava原理及如何封装使用"></a>RxJava原理及如何封装使用</h5><p>​            使用观察者模式，和装饰器模式。</p>
<p>​            先用Observablex向右构建流，然后向左创建订阅流，最后时间通过观察者回调流发送。</p>
<p>​    </p>
<p>​    你了解协程吗？协程有什么作用？可以完全取代rxjava吗？</p>
<h5 id="rxjava里面用了大量的-lt-super-T-gt-这些，是什么意思。"><a href="#rxjava里面用了大量的-lt-super-T-gt-这些，是什么意思。" class="headerlink" title="rxjava里面用了大量的&lt;? super T&gt;这些，是什么意思。"></a>rxjava里面用了大量的<code>&lt;? super T&gt;</code>这些，是什么意思。</h5><ul>
<li><p>如果要从集合中读取类型T的数据，并且不能写入，可以使用 ? extends 通配符；(Producer Extends)</p>
</li>
<li><p>如果要从集合中写入类型T的数据，并且不需要读取，可以使用 ? super 通配符；(Consumer Super),只能用Object接收。</p>
</li>
<li><p>如果既要存又要取，那么就不要使用任何通配符。</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/86cf908afcb6">https://www.jianshu.com/p/86cf908afcb6</a></p>
</li>
</ul>
<h5 id="RxJava怎么通过被订阅者传给订阅者的过程是什么样的"><a href="#RxJava怎么通过被订阅者传给订阅者的过程是什么样的" class="headerlink" title="RxJava怎么通过被订阅者传给订阅者的过程是什么样的?"></a>RxJava怎么通过被订阅者传给订阅者的过程是什么样的?</h5><h5 id="Observer处理完onComplete后会还能onNext吗"><a href="#Observer处理完onComplete后会还能onNext吗" class="headerlink" title="Observer处理完onComplete后会还能onNext吗?"></a>Observer处理完onComplete后会还能onNext吗?</h5><p>​    onComplete是用来控制不能发送数据的，也就是不能onNext了，包括onError也是不能再发送onNext数据了，该方法中也是调用了     dispose方法。    </p>
<h5 id="RxJava中map、flatMap的区别，你还用过其他哪些操作符"><a href="#RxJava中map、flatMap的区别，你还用过其他哪些操作符" class="headerlink" title="RxJava中map、flatMap的区别，你还用过其他哪些操作符?"></a>RxJava中map、flatMap的区别，你还用过其他哪些操作符?</h5><p>​    map是通过原始数据类型返回另外一种数据类型，而flatMap是通过原始数据类型返回另外一种被观察者。</p>
<h5 id="Maybe、Single、Flowable、Completable几种观察者的区别，以及他们在什么场景用？"><a href="#Maybe、Single、Flowable、Completable几种观察者的区别，以及他们在什么场景用？" class="headerlink" title="Maybe、Single、Flowable、Completable几种观察者的区别，以及他们在什么场景用？"></a>Maybe、Single、Flowable、Completable几种观察者的区别，以及他们在什么场景用？</h5><p>​    如果只想发一条数据，或者不发数据就用Maybe，如果想发多条数据或者不发数据就用Observable，如果只发一条数据或者失败就用Single，如果想用背压策略使用Flowable，如果不发数据就用Completable</p>
<p>也就是说Maybe可能不发送数据，如果发送数据只会发送单条数据。</p>
<p>single也是发送单条数据，但是它要么成功要么失败。</p>
<h5 id="RxJava切换线程是怎么回事"><a href="#RxJava切换线程是怎么回事" class="headerlink" title="RxJava切换线程是怎么回事?"></a>RxJava切换线程是怎么回事?</h5><p>subscribeOn实际是创建了ObservableSubscribeOn的Observable，它的订阅方法里面创建了<code>SubscribeOnObserver</code>，通过线程池执行Runnable，使上游Observable的订阅在子线程中执行，这就是为什么subscribeOn能控制observable在哪个线程中执行的原因 </p>
<h5 id="RxJava的subscribeOn只有第一次生效"><a href="#RxJava的subscribeOn只有第一次生效" class="headerlink" title="RxJava的subscribeOn只有第一次生效?"></a>RxJava的subscribeOn只有第一次生效?</h5><p>subscribeOn对subscribe订阅进行处理，针对是订阅流，从后向前流动，所以最前面的一次生效。</p>
<p>subscribeOn是规定上游的observable在哪个线程中执行，如果我们执行多次的subscribeOn的话，从下游的observer到上游的observable的订阅过程，<strong>最开始调用的subscribeOn返回的observable会把后面执行的subscribeOn返回的observable给覆盖了，因此我们感官的是只有第一次的subscribeOn能生效。</strong></p>
<h5 id="RxJava的observeOn多次调用哪个有效"><a href="#RxJava的observeOn多次调用哪个有效" class="headerlink" title="RxJava的observeOn多次调用哪个有效?"></a>RxJava的observeOn多次调用哪个有效?</h5><p>observeOn在事件发送的 onNext(T t)进行处理，针对的是观察者流，从前向后流动，所以最后一次生效。</p>
<p>observeOn是指定下游的observer在哪个线程中执行，所以这个更好理解，看observeOn下一个observer是哪一个，<strong>所以多次调用observeOn肯定是最后一个observeOn控制有效。</strong></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6900870262062120967">https://juejin.cn/post/6900870262062120967</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/339620311">https://zhuanlan.zhihu.com/p/339620311</a></p>
<p>RxJava中背压是怎么回事？</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c3965e82b164">https://www.jianshu.com/p/c3965e82b164</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/322405376">https://zhuanlan.zhihu.com/p/322405376</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Af4y187b8">https://www.bilibili.com/video/BV1Af4y187b8</a></p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul>
<li>sqlite升级，增加字段的语句</li>
<li>数据库框架对比和源码分析</li>
<li>数据库的优化</li>
<li>数据库数据迁移问题</li>
</ul>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h6 id="排序算法有哪些？"><a href="#排序算法有哪些？" class="headerlink" title="排序算法有哪些？"></a>排序算法有哪些？</h6><p>冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/42586566">https://zhuanlan.zhihu.com/p/42586566</a></p>
<p><img src="https://img-blog.csdn.net/20180912224019565?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzcwNjQx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p>
<h6 id="最快的排序算法是哪个？"><a href="#最快的排序算法是哪个？" class="headerlink" title="最快的排序算法是哪个？"></a>最快的排序算法是哪个？</h6><p>快速排序  最好情况O(nlogn)  最坏情况 O(n^2)</p>
<p>为什么不是堆排序  ?</p>
<p> 在堆排序（小根堆）的时候，每次总是将最小的元素移除，然后将最后的元素放到堆顶，再让其自我调整。这样一来，有很多比较将是被浪费的，因为被拿到堆顶的那个元素几乎肯定是很大的，而靠近堆顶的元素又几乎肯定是很小的，最后一个元素能留在堆顶的可能性微乎其微，最后一个元素很有可能最终再被移动到底部。在堆排序里面有大量这种近乎无效的比较。随着数据规模的增长，比较的开销最差情况应该在（线性*对数）级别，如果数据量是原来的10倍，那么用于比较的时间开销可能是原来的10log10倍<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36770641/article/details/82669788">https://blog.csdn.net/qq_36770641/article/details/82669788</a></p>
<ul>
<li>手写一个冒泡排序</li>
</ul>
<ul>
<li>手写快速排序代码</li>
<li>快速排序的过程、时间复杂度、空间复杂度</li>
<li>手写堆排序</li>
<li>堆排序过程、时间复杂度及空间复杂度</li>
<li>写出你所知道的排序算法及时空复杂度，稳定性</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://noteforme.github.io/2021/03/21/Data-Sort/">https://noteforme.github.io/2021/03/21/Data-Sort/</a></p>
<ul>
<li>二叉树给出根节点和目标节点，找出从根节点到目标节点的路径</li>
<li>给阿里2万多名员工按年龄排序应该选择哪个算法？</li>
<li>GC算法(各种算法的优缺点以及应用场景)</li>
<li>蚁群算法与蒙特卡洛算法</li>
<li>子串包含问题(KMP 算法)写代码实现</li>
<li>一个无序，不重复数组，输出N个元素，使得N个元素的和相加为M，给出时间复杂度、空间复杂度。手写算法</li>
<li>万亿级别的两个URL文件A和B，如何求出A和B的差集C(提示：Bit映射-&gt;hash分组-&gt;多文件读写效率-&gt;磁盘寻址以及应用层面对寻址的优化)</li>
<li>百度POI中如何试下查找最近的商家功能(提示：坐标镜像+R树)。</li>
<li>两个不重复的数组集合中，求共同的元素。</li>
<li>两个不重复的数组集合中，这两个集合都是海量数据，内存中放不下，怎么求共同的元素？</li>
<li>一个文件中有100万个整数，由空格分开，在程序中判断用户输入的整数是否在此文件中。说出最优的方法</li>
<li>一张Bitmap所占内存以及内存占用的计算</li>
<li>2000万个整数，找出第五十大的数字？</li>
<li>烧一根不均匀的绳，从头烧到尾总共需要1个小时。现在有若干条材质相同的绳子，问如何用烧绳的方法来计时一个小时十五分钟呢？</li>
<li>求1000以内的水仙花数以及40亿以内的水仙花数</li>
<li>5枚硬币，2正3反如何划分为两堆然后通过翻转让两堆中正面向上的硬8币和反面向上的硬币个数相同</li>
<li>时针走一圈，时针分针重合几次</li>
<li>N*N的方格纸,里面有多少个正方形</li>
<li>x个苹果，一天只能吃一个、两个、或者三个，问多少天可以吃完？</li>
</ul>
<h5 id="插件化、模块化、组件化、热修复、增量更新、Gradle"><a href="#插件化、模块化、组件化、热修复、增量更新、Gradle" class="headerlink" title="插件化、模块化、组件化、热修复、增量更新、Gradle"></a>插件化、模块化、组件化、热修复、增量更新、Gradle</h5><ul>
<li>对热修复和插件化的理解</li>
<li>插件化原理分析</li>
<li>模块化实现（好处，原因）</li>
<li>热修复,插件化</li>
<li>项目组件化的理解</li>
<li>描述清点击 Android Studio 的 build 按钮后发生了什么</li>
</ul>
<h3 id="架构设计和设计模式"><a href="#架构设计和设计模式" class="headerlink" title="架构设计和设计模式"></a>架构设计和设计模式</h3><p>​    <a target="_blank" rel="noopener" href="https://noteforme.github.io/categories/DesignPatterns/">https://noteforme.github.io/categories/DesignPatterns/</a></p>
<h4 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h4><p>​    单一职责</p>
<p>​    一个类应该只负责一项职责。</p>
<p>接口隔离</p>
<p>​    客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。</p>
<p>依赖倒置</p>
<ul>
<li>高层模块不应该依赖低层模块，二者都应该依赖其抽象。</li>
<li>抽象不应该依赖细节，细节应该依赖抽象。</li>
<li>依赖倒置的中心思想是<strong>面向接口编程</strong>。</li>
</ul>
<p>里氏替换</p>
<ul>
<li>所有使用基类的地方必须能透明的使用其子类。</li>
<li>使用继承时，遵循里氏替换原则，<strong>子类尽量不要重写父类的方法</strong>。继承实际上让两个类耦合性增强了，适当情况下可以通过 聚合 组合 依赖来解决问题。</li>
</ul>
<p>​    通用做法是： 原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖，聚合，组合等关系代替。</p>
<p>开闭原则 ocp</p>
<p>迪米特法则</p>
<p>​    一个对象应该对其他对象保持最少的了解</p>
<h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><ul>
<li>谈谈你对Android设计模式的理解</li>
<li>MVC MVP MVVM原理和区别</li>
<li>你所知道的设计模式有哪些？</li>
<li>项目中常用的设计模式</li>
<li>手写生产者/消费者模式</li>
<li>写出观察者模式的代码</li>
<li>适配器模式，装饰者模式，外观模式的异同？</li>
<li>用到的一些开源框架，介绍一个看过源码的，内部实现过程。</li>
<li>谈谈对RxJava的理解</li>
<li>RxJava的功能与原理实现</li>
<li>RxJava的作用，与平时使用的异步操作来比的优缺点</li>
<li>说说EventBus作用，实现方式，代替EventBus的方式</li>
<li>从0设计一款App整体架构，如何去做？</li>
<li>说一款你认为当前比较火的应用并设计(比如：直播APP，P2P金融，小视频等)</li>
<li>谈谈对java状态机理解</li>
<li>Fragment如果在Adapter中使用应该如何解耦？</li>
<li>Binder机制及底层实现</li>
<li>对于应用更新这块是如何做的？(解答：灰度，强制更新，分区域更新)？</li>
<li>实现一个Json解析器(可以通过正则提高速度)</li>
<li>统计启动时长,标准</li>
</ul>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ul>
<li>如何对Android 应用进行性能分析以及优化?</li>
<li>ddms 和 traceView</li>
<li>性能优化如何分析systrace？</li>
<li>用IDE如何分析内存泄漏？</li>
<li>Java多线程引发的性能问题，怎么解决？</li>
<li>启动页白屏及黑屏解决？</li>
<li>启动太慢怎么解决？</li>
<li>怎么保证应用启动不卡顿？</li>
<li>App启动崩溃异常捕捉</li>
<li>自定义View注意事项</li>
<li>现在下载速度很慢,试从网络协议的角度分析原因,并优化(提示：网络的5层都可以涉及)。</li>
<li>Https请求慢的解决办法（提示：DNS，携带数据，直接访问IP）</li>
<li>如何保持应用的稳定性</li>
<li>RecyclerView和ListView的性能对比</li>
<li>ListView的优化</li>
<li>RecycleView优化</li>
<li>View渲染</li>
<li>Bitmap如何处理大图，如一张30M的大图，如何预防OOM</li>
<li>java中的四种引用的区别以及使用场景</li>
<li>强引用置为null，会不会被回收？</li>
</ul>
<h4 id="NDK、jni、Binder、AIDL、进程通信有关"><a href="#NDK、jni、Binder、AIDL、进程通信有关" class="headerlink" title="NDK、jni、Binder、AIDL、进程通信有关"></a>NDK、jni、Binder、AIDL、进程通信有关</h4><ul>
<li>请介绍一下NDK</li>
<li>什么是NDK库?</li>
<li>jni用过吗？</li>
<li>如何在jni中注册native函数，有几种注册方式?</li>
<li>Java如何调用c、c++语言？</li>
<li>jni如何调用java层代码？</li>
<li>进程间通信的方式？</li>
<li>Binder机制</li>
<li>简述IPC？</li>
<li>什么是AIDL？</li>
<li>AIDL解决了什么问题？</li>
<li>AIDL如何使用？</li>
<li>Android 上的 Inter-Process-Communication 跨进程通信时如何工作的？</li>
<li>多进程场景遇见过么？</li>
<li>Android进程分类？</li>
<li>进程和 Application 的生命周期？</li>
<li>进程调度</li>
<li>谈谈对进程共享和线程安全的认识</li>
<li>谈谈对多进程开发的理解以及多进程应用场景</li>
<li>什么是协程？</li>
</ul>
<h4 id="framework层、ROM定制、Ubuntu、Linux之类的问题"><a href="#framework层、ROM定制、Ubuntu、Linux之类的问题" class="headerlink" title="framework层、ROM定制、Ubuntu、Linux之类的问题"></a>framework层、ROM定制、Ubuntu、Linux之类的问题</h4><ul>
<li>java虚拟机的特性</li>
<li>谈谈对jvm的理解</li>
<li>JVM内存区域，开线程影响哪块内存</li>
<li>对Dalvik、ART虚拟机有什么了解？</li>
<li>Art和Dalvik对比</li>
<li>虚拟机原理，如何自己设计一个虚拟机(内存管理，类加载，双亲委派)</li>
<li>谈谈你对双亲委派模型理解</li>
<li>JVM内存模型，内存区域</li>
<li>类加载机制</li>
<li>谈谈对ClassLoader(类加载器)的理解</li>
<li>谈谈对动态加载（OSGI）的理解</li>
<li>内存对象的循环引用及避免</li>
<li>内存回收机制、GC回收策略、GC原理时机以及GC对象</li>
<li>垃圾回收机制与调用System.gc()区别</li>
<li>系统启动流程是什么？（提示：Zygote进程 –&gt; SystemServer进程 –&gt; 各种系统服务 –&gt; 应用进程）</li>
<li>大体说清一个应用程序安装到手机上时发生了什么</li>
<li>简述Activity启动全部过程</li>
<li>App启动流程，从点击桌面开始</li>
<li>Android中进程内存的分配，能不能自己分配定额内存？</li>
<li>如何保证一个后台服务不被杀死？（相同问题：如何保证service在后台不被kill？）比较省电的方式是什么？</li>
<li>App中唤醒其他进程的实现方式</li>
</ul>
<p>​    <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c3965e82b164">https://www.jianshu.com/p/c3965e82b164</a></p>
<p>​    <a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label29">https://www.cnblogs.com/deman/p/5860976.html#_label29</a></p>
<ul>
<li><strong>AMS是如何启动的？</strong></li>
<li><strong>AMS在Android起到什么作用？</strong></li>
<li><strong>AMS有哪些应用场景？我们是如何应用AMS核心原理的？</strong></li>
<li><strong>WMS的工作原理说说？</strong></li>
<li><strong>JVM的核心原理你懂多少？</strong></li>
<li><strong>我们的代码是如何在栈区中运行的？</strong></li>
<li><strong>如何使用字节码研究系统级原理？</strong></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2018-05-24T14:31:57.000Z" title="5/24/2018, 10:31:57 PM">2018-05-24</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-01-02T03:31:39.079Z" title="1/2/2023, 11:31:39 AM">2023-01-02</time></span><span class="level-item">37 minutes read (About 5519 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2018/05/24/INTERVIEW-JAVA/">INTERVIEW-JAVA</a></p><div class="content"><p><a target="_blank" rel="noopener" href="https://interview-q-a-1gdnkgkla15afdbe-1258598664.tcloudbaseapp.com/Java/HashMap%E5%8E%9F%E7%90%86-%E7%BE%8E%E5%9B%A2.html">https://interview-q-a-1gdnkgkla15afdbe-1258598664.tcloudbaseapp.com/Java/HashMap%E5%8E%9F%E7%90%86-%E7%BE%8E%E5%9B%A2.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/huangjialin/p/12411842.html">面试题含答案</a></p>
<h3 id="java基础面试知识点"><a href="#java基础面试知识点" class="headerlink" title="java基础面试知识点"></a>java基础面试知识点</h3><h5 id="java中-和equals和hashCode的区别"><a href="#java中-和equals和hashCode的区别" class="headerlink" title="java中==和equals和hashCode的区别"></a>java中==和equals和hashCode的区别</h5><p>类型</p>
<ul>
<li>基本类型：比较的是值是否相同；</li>
<li>引用类型：如果是 类、接口、数组的话,当他们用双等号（==）进行比较的时候，比较的是他们的引用，如果要比较堆中对象是否相同，那么就要重写equals方法了；</li>
<li>默认情况下（没有覆写equals方法）的equals方法都是调用Object类的equals方法，而Object的equals方法主要是用于判断<strong>对象的内存地址引用是不是同一个地址</strong>（是不是同一个对象）。</li>
</ul>
<h5 id="int、char、long各占多少字节数"><a href="#int、char、long各占多少字节数" class="headerlink" title="int、char、long各占多少字节数"></a>int、char、long各占多少字节数</h5><p>   byte   1字节       short   2字节         int    4字节           long   8字节          </p>
<p>   char   2字节       float   4字节         double  8字节      boolean  false/true(理论上占用1bit,1/8字节，实际处理按1byte处理) </p>
<h5 id="int与integer的区别"><a href="#int与integer的区别" class="headerlink" title="int与integer的区别"></a>int与integer的区别</h5><p>​    Integer 是int的包装类；int是基本数据类型;</p>
<p>​    Integer实际是对象的引用，int是直接存储数据值</p>
<h5 id="谈谈对java多态-polymorphism-的理解-Java中实现多态的机制是什么"><a href="#谈谈对java多态-polymorphism-的理解-Java中实现多态的机制是什么" class="headerlink" title="谈谈对java多态(polymorphism)的理解,Java中实现多态的机制是什么"></a>谈谈对java多态(polymorphism)的理解,Java中实现多态的机制是什么</h5><p> 实现的机制是，父类或者接口定义的引用变量指向子类或者子类的实现， 执行期间判断所引用对象的实际类型，根据其实际的类型调用相应的方法。</p>
<ol>
<li><p>编译时多态(静态多态)==重载</p>
</li>
<li><p>运行时多态（动态多态）</p>
<p>无论哪种方法，核心之处在对父类方法的改写或对接口方法的实现，以取得运行时不同的执行效果.</p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/IandI/polymorphism.html">https://docs.oracle.com/javase/tutorial/java/IandI/polymorphism.html</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1447574">https://cloud.tencent.com/developer/article/1447574</a></p>
<h5 id="String、StringBuffer、StringBuilder区别"><a href="#String、StringBuffer、StringBuilder区别" class="headerlink" title="String、StringBuffer、StringBuilder区别"></a>String、StringBuffer、StringBuilder区别</h5><ul>
<li>都是fianl类，不能被继承,底层都是 char[] value实现</li>
<li>String类长度是不可变的，substring()、  concat(),最终实现都是通过  new String(buf, true)实现的,StringBuffer,StringBuilder是通过操作本类的value实现的</li>
<li>StringBuffer类是线程安全的，StringBuilder不是线程安全的</li>
<li>String：字符串常量。</li>
</ul>
<p>​    </p>
<h5 id="什么是内部类？内部类的作用"><a href="#什么是内部类？内部类的作用" class="headerlink" title="什么是内部类？内部类的作用"></a>什么是内部类？内部类的作用</h5><p>​    内部类:    一个类定义在另一个类的内部，就叫内部类</p>
<p>​    作用: </p>
<ul>
<li><p>内部类  拥有外部类的所有访问权限，包括被private修饰的私有数据</p>
</li>
<li><p>内部类可以很好的隐藏实现</p>
</li>
<li><p>内部类可以实现多重继承</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类一</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;liutao&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">doSomeThing</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// doSomeThing</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类二</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">age</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">25</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类三</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainExample</span></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> <span class="keyword">extends</span> <span class="title">ClassA</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">super</span>.name();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> <span class="keyword">extends</span> <span class="title">ClassB</span></span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">age</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">super</span>.age();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Test1().name();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">age</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Test2().age();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">       MainExample mi=<span class="keyword">new</span> MainExample();</span><br><span class="line">       System.out.println(<span class="string">&quot;姓名:&quot;</span>+mi.name());</span><br><span class="line">       System.out.println(<span class="string">&quot;年龄:&quot;</span>+mi.age());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> MainExample 类通过内部类拥有了 ClassA 和 ClassB 的两个类的继承关系。 而无需关注 ClassA 中的 doSomeThing 方法的实现。这就是比接口实现更有戏的地方</p>
<p> <a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903566293860366">https://juejin.cn/post/6844903566293860366</a></p>
</li>
</ul>
<h5 id="抽象类和接口区别"><a href="#抽象类和接口区别" class="headerlink" title="抽象类和接口区别"></a>抽象类和接口区别</h5><table>
<thead>
<tr>
<th>Abstract class</th>
<th>Interface</th>
</tr>
</thead>
<tbody><tr>
<td>1) Abstract class can <strong>have abstract and non-abstract</strong> methods.</td>
<td>Interface can have <strong>only abstract</strong> methods. Since Java 8, it can have <strong>default and static methods</strong> also.</td>
</tr>
<tr>
<td>2) Abstract class <strong>doesn’t support multiple inheritance</strong>.</td>
<td>Interface <strong>supports multiple inheritance</strong>.</td>
</tr>
<tr>
<td>3) Abstract class <strong>can have final, non-final, static and non-static variables</strong>.</td>
<td>Interface has <strong>only static and final variables</strong>.</td>
</tr>
<tr>
<td>4) Abstract class <strong>can provide the implementation of interface</strong>.</td>
<td>Interface <strong>can’t provide the implementation of abstract class</strong>.</td>
</tr>
<tr>
<td>5) The <strong>abstract keyword</strong> is used to declare abstract class.</td>
<td>The <strong>interface keyword</strong> is used to declare interface.</td>
</tr>
<tr>
<td>6) An <strong>abstract class</strong> can extend another Java class and implement multiple Java interfaces.</td>
<td>An <strong>interface</strong> can extend another Java interface only.</td>
</tr>
<tr>
<td>7) An <strong>abstract class</strong> can be extended using keyword “extends”.</td>
<td>An <strong>interface</strong> can be implemented using keyword “implements”.</td>
</tr>
<tr>
<td>8) A Java <strong>abstract class</strong> can have class members like private, protected, etc.</td>
<td>Members of a Java interface are public by default.</td>
</tr>
<tr>
<td>9)<strong>Example:</strong>  public abstract class Shape{ public abstract void draw(); }</td>
<td><strong>Example:</strong>  public interface Drawable{ void draw(); }</td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://www.javatpoint.com/difference-between-abstract-class-and-interface">https://www.javatpoint.com/difference-between-abstract-class-and-interface</a></p>
<h5 id="泛型中extends和super的区别"><a href="#泛型中extends和super的区别" class="headerlink" title="? 泛型中extends和super的区别"></a>? 泛型中extends和super的区别</h5><ul>
<li><p>上界&lt;? extends T&gt;不能往里存，只能往外取，适合频繁往外面读取内容的场景。</p>
</li>
<li><p>下界&lt;? super T&gt;不影响往里存，但往外取只能放在Object对象里，适合经常往里面插入数据的场景</p>
<p><a target="_blank" rel="noopener" href="https://noteforme.github.io/2018/04/16/Generics/">https://noteforme.github.io/2018/04/16/Generics/</a></p>
</li>
</ul>
<h5 id="string-转换成-integer的方式及原理"><a href="#string-转换成-integer的方式及原理" class="headerlink" title="string 转换成 integer的方式及原理"></a>string 转换成 integer的方式及原理</h5><ol>
<li>判断是否null或””</li>
<li>判断第一位正负数，逐位获取值 ?</li>
</ol>
<p>  <a target="_blank" rel="noopener" href="https://blog.csdn.net/nobody_1/article/details/91488686">https://blog.csdn.net/nobody_1/article/details/91488686</a></p>
<h5 id="静态内部类的设计意图"><a href="#静态内部类的设计意图" class="headerlink" title="静态内部类的设计意图"></a>静态内部类的设计意图</h5><p>​    非静态内部类编译后会隐含的保存着一个引用，改引用指向创建它的外围类，静态内部类没有，</p>
<p>​    它不能使用任何外围类的非static成员变量和方法.</p>
<h5 id="final，finally，finalize的区别"><a href="#final，finally，finalize的区别" class="headerlink" title="final，finally，finalize的区别"></a>final，finally，finalize的区别</h5><p>  Final : 用于申明属性，方法，类，表示属性不可变，方法不可以覆盖，类不能继承</p>
<ol>
<li><p>final数组</p>
<p><strong>Java 中数组也是对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;  <span class="comment">//  注意，数组 arr 是 final 的</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">         arr[i] = arr[i]*<span class="number">10</span>;</span><br><span class="line">         System.out.println(arr[i]);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>数组是对象的一种，现在数组是被 final 修饰的，所以它的意思是一旦被赋值之后，变量的引用不能修改。但是我们现在想证明的是，数组对象里面的内容可以修改</p>
</li>
<li><p>非数组对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">20</span>; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123; </span><br><span class="line">       <span class="keyword">final</span> Test t = <span class="keyword">new</span> Test();</span><br><span class="line">       t.p = <span class="number">30</span>; </span><br><span class="line">       System.out.println(t.p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把它用 final 修饰，然后去尝试改它里面成员变量 p 的值，并打印出结果，程序会打印出“30”。一开始 p 的值是 20，但是最后修改完毕变成了 30，说明这次修改是成功的。</p>
<p>以上我们就得出了一个结论，<strong>final 修饰一个指向对象的变量的时候，对象本身的内容依然是可以变化的</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=16#/detail/pc?id=311">https://kaiwu.lagou.com/course/courseInfo.htm?courseId=16#/detail/pc?id=311</a></p>
</li>
</ol>
<ul>
<li><p>Finally: 异常语句处理机构中，与try{}进行配合使用，不论try中的代码是否执行完，表示总是执行的部分</p>
</li>
<li><p>Finalize: Object类的一个方法，用于对象”消失”时，由JVM进行调用用于对对象进行垃圾回收，释放对象占用的资源.</p>
</li>
</ul>
<h5 id="Serializable-和Parcelable-的区别，如何将一个Java对象序列化到文件里？"><a href="#Serializable-和Parcelable-的区别，如何将一个Java对象序列化到文件里？" class="headerlink" title="Serializable 和Parcelable 的区别，如何将一个Java对象序列化到文件里？"></a>Serializable 和Parcelable 的区别，如何将一个Java对象序列化到文件里？</h5><ol>
<li><p>两者最大的区别在于 <strong>存储媒介的不同</strong>，<code>Serializable</code> 使用 <strong>I/O 读写存储在硬盘上</strong>，而 <code>Parcelable</code> 是直接 <strong>在内存中读写</strong>。很明显，内存的读写速度通常大于 IO 读写，所以在 Android 中传递数据优先选择 <code>Parcelable</code>。</p>
</li>
<li><p><code>Serializable</code> 会使用反射，序列化和反序列化过程需要大量 I/O 操作，也会创建很多临时对象， <code>Parcelable</code> 自已实现封送和解封（marshalled &amp;unmarshalled）操作不需要用反射，数据也存放在 Native 内存中，效率要快很多。</p>
<p> <a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903518826921991">https://juejin.cn/post/6844903518826921991</a></p>
</li>
</ol>
<p>父类的静态方法能否被子类重写</p>
<p> 不能，静态方法只和类有关,JVM加载后先初始化static相关属性方法,重写依赖于类的实例.</p>
<h5 id="成员内部类、局部内部类以及项目中的应用"><a href="#成员内部类、局部内部类以及项目中的应用" class="headerlink" title="成员内部类、局部内部类以及项目中的应用"></a>成员内部类、局部内部类以及项目中的应用</h5><p>成员内部类 : 普通的内部类，不存在任何static的变量和方法；</p>
<p>局部内部类： 嵌套于方法和作用域内</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destionation <span class="title">destionation</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">PDestionation</span> <span class="keyword">implements</span> <span class="title">Destionation</span></span>&#123;</span><br><span class="line">            <span class="keyword">private</span> String label;</span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="title">PDestionation</span><span class="params">(String whereTo)</span></span>&#123;</span><br><span class="line">                label = whereTo;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> label;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PDestionation(str);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Parcel5 parcel5 = <span class="keyword">new</span> Parcel5();</span><br><span class="line">      Destionation d = parcel5.destionation(<span class="string">&quot;chenssy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>闭包和局部内部类的区别</p>
<h5 id="Java中对象的生命周期"><a href="#Java中对象的生命周期" class="headerlink" title="Java中对象的生命周期"></a>Java中对象的生命周期</h5><p>​    <strong>1、创建阶段(Created)</strong><br>  <code>检测类是否被加载没有加载的先加载</code>→<code>为新生对象分配内存</code>→<code>将分配到的内存空间都初始化为零值</code>→<code>对对象进行必要的设置</code>→<code>执行&lt;init&gt;方法把对象进行初始化</code><br> 对象的加载大小是类加载中就已经确定好了的，类加载过程就相当复杂了，如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4345692-846543b5bed56265.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/452" alt="img"></p>
<p>类加载过程.png</p>
<p><strong>2、应用阶段(In Use)</strong><br>  至少有一个强引用使用着</p>
<p><strong>3、不可见阶段(Invisible)</strong><br>  程序的执行已经超出了该对象的作用域了</p>
<p><strong>4、不可达阶段(Unreachable)</strong><br>  程序不再持有该对象的任何强引用，这种情况下，该对象仍可能被JVM等系统下的某些已装载的静态变量或线程或JNI等强引用持有着，这些特殊的强引用被称为”GC root”</p>
<p><strong>5、收集阶段(Collected)</strong><br>  垃圾回收器发现该对象已经处于“不可达阶段”并且垃圾回收器已经对该对象的内存空间重新分配做好准备时，则对象进入了“收集阶段”。如果该对象已经重写了finalize()方法，则会去执行该方法的终端操作。</p>
<p><strong>6、终结阶段(Finalized)</strong><br>  当对象执行完finalize()方法后仍然处于不可达状态时，则该对象进入终结阶段。在该阶段是等待垃圾回收器对该对象空间进行回收。</p>
<p><strong>7、对象空间重分配阶段(De-allocated)</strong><br>  垃圾回收器对该对象的所占用的内存空间进行回收或者再分配了，则该对象彻底消失了，称之为“对象空间重新分配阶段”。</p>
<p>链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/72f5017c6649">https://www.jianshu.com/p/72f5017c6649</a></p>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><h5 id="String特性"><a href="#String特性" class="headerlink" title="String特性"></a>String特性</h5><p>Java虚拟机在内存中开辟出一块单独的区域</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/60643031">https://zhuanlan.zhihu.com/p/60643031</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1PJ411n7xZ?p=118">https://www.bilibili.com/video/BV1PJ411n7xZ?p=118</a>   几个视频讲到用法，最好能用图画出来</p>
<p><a target="_blank" rel="noopener" href="https://www.iteye.com/blog/rednaxelafx-774673">https://www.iteye.com/blog/rednaxelafx-774673</a></p>
<h5 id="哪些情况下的对象会被垃圾回收机制处理掉？"><a href="#哪些情况下的对象会被垃圾回收机制处理掉？" class="headerlink" title="哪些情况下的对象会被垃圾回收机制处理掉？"></a>哪些情况下的对象会被垃圾回收机制处理掉？</h5><ol>
<li>可达性分析,GC Root向下搜索，产生一个reference chain 。当一个对象不能和任何GC Root产生关系时就被回收.</li>
<li><ul>
<li>强引用 ：那<strong>垃圾回收器</strong>绝不会回收</li>
<li>软引用: 内存溢出时候对象回收</li>
<li>弱引用:下一次GC时候对象回收</li>
<li>虚引用：随时可能被回收</li>
</ul>
</li>
<li>当前商业虚拟机的垃圾回收都采用分代收集算法，这种算法并没有什么新的思想，只是根据对象的存活周期将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾回收都有大批对象死去，只有少量存活，那就选用复制算法，只要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高，没有额外的空间对它进行分配担保，那就使用标记清理或者标记整理算法来进行回收。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://noteforme.github.io/2021/01/05/JVM-GC/">https://noteforme.github.io/2021/01/05/JVM-GC/</a></p>
<p><a target="_blank" rel="noopener" href="https://noteforme.github.io/2020/04/18/JVM/">https://noteforme.github.io/2020/04/18/JVM/</a></p>
<h5 id="String为什么要设计成不可变的？"><a href="#String为什么要设计成不可变的？" class="headerlink" title="String为什么要设计成不可变的？"></a>String为什么要设计成不可变的？</h5><ol>
<li><p>便于实现字符串池</p>
<p>由于会大量的使用String常量，如果每一次声明一个String都创建一个String对象，那将会造成极大的空间资源的浪费。Java提出了String pool的概念，在堆中开辟一块存储空间String  pool，当初始化一个String变量时，如果该字符串已经存在了，就不会去创建一个新的字符串变量，而是会返回已经存在了的字符串的引用。</p>
<p>如果字符串是可变的，某一个字符串变量改变了其值，那么其指向的变量的值也会改变，String pool将不能够实现！</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wkfvawl/p/11693260.html">https://www.cnblogs.com/wkfvawl/p/11693260.html</a></p>
</li>
</ol>
<h3 id="java深入源码级的面试题"><a href="#java深入源码级的面试题" class="headerlink" title="java深入源码级的面试题"></a>java深入源码级的面试题</h3><h5 id="讲一下常见编码方式？"><a href="#讲一下常见编码方式？" class="headerlink" title="讲一下常见编码方式？"></a>讲一下常见编码方式？</h5><ol>
<li><p>ASCII码:  用一个字节的低7位表示，总共128个,0<del>31 是控制字符如换行回车删除等；32</del>126 是打印字符，可以通过键盘输入并且能够显示出来</p>
</li>
<li><p>UTF-16:  固定两个字节表示一个字符：说到 UTF 必须要提到 Unicode（Universal Code 统一码），ISO  试图想创建一个全新的超语言字典，世界上所有的语言都可以通过这本字典来相互翻译。可想而知这个字典是多么的复杂，关于 Unicode  的详细规范可以参考相应文档。Unicode 是 Java 和 XML 的基础，下面详细介绍 Unicode 在计算机中的存储形式。<br>UTF-16 具体定义了 Unicode 字符在计算机中存取方法。UTF-16 用两个字节来表示 Unicode  转化格式，这个是定长的表示方法，不论什么字符都可以用两个字节表示，两个字节是 16 个 bit，所以叫 UTF-16。UTF-16  表示字符非常方便，每两个字节表示一个字符，这个在字符串操作时就大大简化了操作，这也是 Java 以 UTF-16  作为内存的字符存储格式的一个很重要的原因。</p>
</li>
<li><p>UTF-8:  优化UTF-16,UTF-16  统一采用两个字节表示一个字符，虽然在表示上非常简单方便，但是也有其缺点，有很大一部分字符用一个字节就可以表示的现在要两个字节表示，存储空间放大了一倍，在现在的网络带宽还非常有限的今天，这样会增大网络传输的流量，而且也没必要。而 UTF-8 采用了一种变长技术，每个编码区域有不同的字码长度。不同类型的字符可以是由 1~6 个字节组成。<br>UTF-8 有以下编码规则：<br>如果一个字节，最高位（第 8 位）为 0，表示这是一个 ASCII 字符（00 - 7F）。可见，所有 ASCII 编码已经是 UTF-8 了。<br>如果一个字节，以 11 开头，连续的 1 的个数暗示这个字符的字节数，例如：110xxxxx 代表它是双字节 UTF-8 字符的首字节。<br>如果一个字节，以 10 开始，表示它不是首字节，需要向前查找才能得到当前字符的首字节 </p>
</li>
<li><p>GBK 、ISO-8859-1、GB2312</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mlan/p/7823375.html">https://www.cnblogs.com/mlan/p/7823375.html</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mlan/p/7823375.html">https://www.cnblogs.com/mlan/p/7823375.html</a></p>
</li>
</ol>
<h5 id="utf-8编码中的中文占几个字节；int型几个字节？"><a href="#utf-8编码中的中文占几个字节；int型几个字节？" class="headerlink" title="utf-8编码中的中文占几个字节；int型几个字节？"></a>utf-8编码中的中文占几个字节；int型几个字节？</h5><p>​    少数是汉字每个占用3个字节，多数占用4个字节。</p>
<p>​    <a target="_blank" rel="noopener" href="https://blog.csdn.net/hellokatewj/article/details/24325653">https://blog.csdn.net/hellokatewj/article/details/24325653</a></p>
<p>​    int类型 4个字节</p>
<h5 id="静态代理和动态代理的区别，什么场景使用？"><a href="#静态代理和动态代理的区别，什么场景使用？" class="headerlink" title="静态代理和动态代理的区别，什么场景使用？"></a>静态代理和动态代理的区别，什么场景使用？</h5><p>​    静态代理 :  编译的时候就已经存在，</p>
<p>​    动态代理 ： 通过反射机制生成的代理对象</p>
<p>​    <a target="_blank" rel="noopener" href="https://noteforme.github.io/2021/01/14/DesignPattern-Proxy/">https://noteforme.github.io/2021/01/14/DesignPattern-Proxy/</a></p>
<p>​    <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2f518a4a4c2b">https://www.jianshu.com/p/2f518a4a4c2b</a></p>
<h5 id="Java的异常体系"><a href="#Java的异常体系" class="headerlink" title="Java的异常体系"></a>Java的异常体系</h5><p>非运行时异常 :编译期间可以检查到的异常, 像IoException,DataFormatException,CertificateException</p>
<p>运行时异常 : NullPointerException, ClassCastException,IndexOutOfBoundsException</p>
<h5 id="谈谈你对解析与分派的认识。"><a href="#谈谈你对解析与分派的认识。" class="headerlink" title="? 谈谈你对解析与分派的认识。"></a>? 谈谈你对解析与分派的认识。</h5><h5 id="说说你对Java反射的理解"><a href="#说说你对Java反射的理解" class="headerlink" title="说说你对Java反射的理解"></a>说说你对Java反射的理解</h5><p>​    对于任何一个类都可以通过反射知道的它的属性和方法。</p>
<h5 id="说说你对Java注解的理解"><a href="#说说你对Java注解的理解" class="headerlink" title="说说你对Java注解的理解"></a>说说你对Java注解的理解</h5><p>​    注解，对代码进行注明。使得程序在编译或者运行时，读取到注解并加以处理，以间接的改变程序的运行。</p>
<h5 id="为什么Java里的匿名内部类只能访问final修饰的外部变量？"><a href="#为什么Java里的匿名内部类只能访问final修饰的外部变量？" class="headerlink" title="为什么Java里的匿名内部类只能访问final修饰的外部变量？"></a>为什么Java里的匿名内部类只能访问final修饰的外部变量？</h5><p>​    因为匿名内部类最终会被编译成一个单独的类，而被该类使用的变量会以构造函数参数的形式传递给该类。如果变量不定义为final的，参数在匿名内部类中可以被修改，进而造成和外部的变量不一致的问题，为了避免这种不一致的情况，规定匿名内部类只能访问final修饰的外部变量。</p>
<h5 id="说说你对依赖注入的理解"><a href="#说说你对依赖注入的理解" class="headerlink" title="说说你对依赖注入的理解?"></a>说说你对依赖注入的理解?</h5><p>​    给予调用方它所需要的对象</p>
<h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><h5 id="说一下泛型原理，并举例说明"><a href="#说一下泛型原理，并举例说明" class="headerlink" title="说一下泛型原理，并举例说明"></a>说一下泛型原理，并举例说明</h5><p>​    泛型实现了参数化类型的概念，使代码可以应用于多种类型。</p>
<p>​    在泛型代码内部，无法获得任何有关泛型参数类型的信息。    </p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><h5 id="常用数据结构简介"><a href="#常用数据结构简介" class="headerlink" title="常用数据结构简介"></a>常用数据结构简介</h5><p>数组 栈 队列  链表 图 树 哈希表</p>
<h5 id="并发集合了解哪些？"><a href="#并发集合了解哪些？" class="headerlink" title="并发集合了解哪些？"></a>并发集合了解哪些？</h5><p>ConcurrentHashMap  CopyOnWriteArrayList  CopyOnWriteArraySet  ArrayBlockingQueue  LinkedBlockingQueue</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010942020/article/details/73610121">https://blog.csdn.net/u010942020/article/details/73610121</a></p>
<h5 id="列举java的集合以及集合之间的继承关系"><a href="#列举java的集合以及集合之间的继承关系" class="headerlink" title="列举java的集合以及集合之间的继承关系"></a>列举java的集合以及集合之间的继承关系</h5><img src="/2018/05/24/INTERVIEW-JAVA/colltetcion_map.png">



<p><img src="https://images4.pianshen.com/887/c1/c1abbb330519fa244799ae0923a2f3cf.png"></p>
<h5 id="List-Set-Map的区别"><a href="#List-Set-Map的区别" class="headerlink" title="List,Set,Map的区别"></a>List,Set,Map的区别</h5><p>容器类介绍以及之间的区别（容器类估计很多人没听这个词，Java容器主要可以划分为4个部分：List列表、Set集合、Map映射、工具类（Iterator迭代器、Enumeration枚举类、Arrays和Collections），具体的可以看看这篇博文 <a target="_blank" rel="noopener" href="http://alexyyek.github.io/2015/04/06/Collection/">Java容器类</a>）</p>
<ol>
<li>List是一个有序的队列，每一个元素都有它的索引。Set是一个不允许有重复元素的集合。</li>
<li>Map是一个映射接口，即key-value键值对。</li>
</ol>
<h5 id="List和Map的实现方式以及存储方式"><a href="#List和Map的实现方式以及存储方式" class="headerlink" title="List和Map的实现方式以及存储方式"></a>List和Map的实现方式以及存储方式</h5><ol>
<li><p>list</p>
<p>ArrayList    查询快 .  LinkedList  插入删除快</p>
</li>
</ol>
<p>修改对象A的equals方法的签名，那么使用HashMap存放这个对象实例的时候，会调用哪个equals方法？</p>
<h5 id="集合Set实现Hash怎么防止碰撞"><a href="#集合Set实现Hash怎么防止碰撞" class="headerlink" title="集合Set实现Hash怎么防止碰撞"></a>集合Set实现Hash怎么防止碰撞</h5><p>1，如果hash码值不相同，说明是一个新元素，存储；</p>
<p>如果没有元素和传入对象（也就是add的元素）的hash值相等，那么就认为这个元素在table中不存在，将其添加进table；</p>
<p>2.1，如果hash码值相同，且equles判断相等，说明元素已经存在，不存；</p>
<p>2.2，如果hash码值相同，且equles判断不相等，说明元素不存在，存；</p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/github_37130188/article/details/96508272">https://blog.csdn.net/github_37130188/article/details/96508272</a></p>
<p>​                    <a target="_blank" rel="noopener" href="https://noteforme.github.io/2018/05/31/HashMap/">https://noteforme.github.io/2018/05/31/HashMap/</a></p>
<h5 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h5><ol>
<li>对key的Dashcode()做hash运算，计算index.</li>
<li>如果没碰撞直接放到bucket⾥</li>
<li>如果碰撞了，以链表的形式存在buckets后</li>
<li>如果节点已经存在就替换old value(保证key的唯⼀性)</li>
<li>如果bucket满了(超过load factor*current capacity)，就要resize</li>
</ol>
<p>get数据</p>
<ol>
<li><p>对key的hashCode()做hash运算，计算index;</p>
</li>
<li><p>如果在bucket⾥的第⼀个节点⾥直接命中，则直接返回；</p>
</li>
<li><p>如果有冲突，则通过key.equals(k)去查找对应的Entry;分为下面两种方式.</p>
</li>
<li><p>若为树，则在树中通过key.equals(k)查找，O(logn)；</p>
</li>
<li><p>若为链表，则在链表中通过key.equals(k)查找，O(n)。</p>
</li>
</ol>
<h5 id="ArrayMap"><a href="#ArrayMap" class="headerlink" title="ArrayMap"></a>ArrayMap</h5><p>ArrayMap相比传统的HashMap速度更慢，因为其查找方法是二分法，并且当删除或添加数据时，会对空间重新调整，可以说ArrayMap是牺牲了时间来换空间，ArrayMap与HashMap的区别主要在：</p>
<p>存储方式不同：HashMap内部有一个HashMapEntry&lt;K,V&gt;[ ]对象，而ArrayMap是一个&lt;key,value&gt;映射的数据结构，内部使用两个数组进行数据存储，一个数组记录key的hash值，另一个数组记录value值。</p>
<p>添加数据时扩容的处理不一样：HashMap进行了new操作，重新创建对象，开销很大，而ArrayMap用的是copy数据，效率相对高很多。</p>
<p>ArrayMap提供了数组收缩的功能，在clear或remove之后，会重新收缩数组，释放空间。</p>
<p>ArrayMap采用的是二分法查找。</p>
<h5 id="hashmap-hashtable区别"><a href="#hashmap-hashtable区别" class="headerlink" title="hashmap hashtable区别"></a>hashmap hashtable区别</h5><p>堆的结构</p>
<p>​    堆分为两种：<em>最大堆</em>和<em>最小堆</em>，两者的差别在于节点的排序方式。</p>
<p>在最大堆中，父节点的值比每一个子节点的值都要大。在最小堆中，父节点的值比每一个子节点的值都要小。这就是所谓的“堆属性”，并且这个属性对堆中的每一个节点都成立。<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6b526aa481b1">https://www.jianshu.com/p/6b526aa481b1</a></p>
<h5 id="堆和树的区别"><a href="#堆和树的区别" class="headerlink" title="堆和树的区别"></a>堆和树的区别</h5><p>​    左子节点必须比父节点小，右子节点必须必比父节点大。但是在堆中并非如此。在最大堆中两个子节点都必须比父节点小，而在最小堆中，它们都必须比父节点大。</p>
<p>堆和栈在内存中的区别是什么(解答提示：可以从数据结构方面以及实际实现方面两个方面去回答)？</p>
<h5 id="什么是深拷贝和浅拷贝"><a href="#什么是深拷贝和浅拷贝" class="headerlink" title="什么是深拷贝和浅拷贝"></a>什么是深拷贝和浅拷贝</h5><ul>
<li><p>浅拷贝</p>
<p>是一个传址,也就是把a的值赋给b的时候同时也把a的地址赋给了b，当b（a）的值改变的时候，a（b）的值同时也会改变</p>
</li>
<li><p>深拷贝</p>
<p>​    深拷贝是指，拷贝对象的具体内容，二内存地址是自主分配的，拷贝结束之后俩个对象虽然存的值是一样的，但是内存地址不一样，俩个对象页互相不影响，互不干涉</p>
</li>
</ul>
<p>手写链表逆序代码</p>
<p>讲一下对树，B+树的理解</p>
<p>讲一下对图的理解</p>
<p>判断单链表成环与否？</p>
<p>链表翻转（即：翻转一个单项链表）</p>
<p>合并多个单有序链表（假设都是递增的）</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2018-03-12T04:44:01.000Z" title="3/12/2018, 12:44:01 PM">2018-03-12</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-09-03T07:02:13.535Z" title="9/3/2023, 3:02:13 PM">2023-09-03</time></span><span class="level-item">2 hours read (About 18914 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2018/03/12/INTERVIEW-ANSWER/">INTERVIEW-ANSWER</a></p><div class="content"><h2 id="阿里面试题"><a href="#阿里面试题" class="headerlink" title="阿里面试题"></a><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/cf5092fa2694">阿里面试题</a></h2><h2 id="1-android事件分发机制，请详细说下整个流程"><a href="#1-android事件分发机制，请详细说下整个流程" class="headerlink" title="1.android事件分发机制，请详细说下整个流程"></a>1.android事件分发机制，请详细说下整个流程</h2><p><img src="https://upload-images.jianshu.io/upload_images/2911038-5349d6ebb32372da?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>事件分发（面试）.png</p>
<h2 id="2-android-view绘制机制和加载过程，请详细说下整个流程"><a href="#2-android-view绘制机制和加载过程，请详细说下整个流程" class="headerlink" title="2.android view绘制机制和加载过程，请详细说下整个流程"></a>2.android view绘制机制和加载过程，请详细说下整个流程</h2><ul>
<li><p>1.ViewRootImpl会调用performTraversals(),其内部会调用performMeasure()、performLayout、performDraw()。</p>
</li>
<li><p>2.performMeasure()会调用最外层的ViewGroup的measure()–&gt;onMeasure(),ViewGroup的onMeasure()是抽象方法，但其提供了measureChildren()，这之中会遍历子View然后循环调用measureChild()这之中会用getChildMeasureSpec()+父View的MeasureSpec+子View的LayoutParam一起获取本View的MeasureSpec，然后调用子View的measure()到View的onMeasure()–&gt;setMeasureDimension(getDefaultSize(),getDefaultSize()),getDefaultSize()默认返回measureSpec的测量数值，所以继承View进行自定义的wrap_content需要重写。</p>
</li>
<li><p>3.performLayout()会调用最外层的ViewGroup的layout(l,t,r,b),本View在其中使用setFrame()设置本View的四个顶点位置。在onLayout(抽象方法)中确定子View的位置，如LinearLayout会遍历子View，循环调用setChildFrame()–&gt;子View.layout()。</p>
</li>
<li><p>4.performDraw()会调用最外层ViewGroup的draw():其中会先后调用background.draw()(绘制背景)、onDraw()(绘制自己)、dispatchDraw()(绘制子View)、onDrawScrollBars()(绘制装饰)。</p>
</li>
<li><p>5.MeasureSpec由2位SpecMode(UNSPECIFIED、EXACTLY(对应精确值和match_parent)、AT_MOST(对应warp_content))和30位SpecSize组成一个int,DecorView的MeasureSpec由窗口大小和其LayoutParams决定，其他View由父View的MeasureSpec和本View的LayoutParams决定。ViewGroup中有getChildMeasureSpec()来获取子View的MeasureSpec。</p>
</li>
<li><p>6.三种方式获取measure()后的宽高：</p>
<ul>
<li>1.Activity#onWindowFocusChange()中调用获取</li>
<li>2.view.post(Runnable)将获取的代码投递到消息队列的尾部。</li>
<li>3.ViewTreeObservable.</li>
</ul>
<p>自定义 View 的绘制顺序</p>
</li>
</ul>
<h2 id="3-android四大组件的加载过程，请详细介绍下"><a href="#3-android四大组件的加载过程，请详细介绍下" class="headerlink" title="3.android四大组件的加载过程，请详细介绍下"></a>3.android四大组件的加载过程，请详细介绍下</h2><ul>
<li>1.<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f499afd8d0ab">android四大组件的加载过程</a>:这是我总结的一篇博客</li>
</ul>
<h2 id="4-Activity的启动模式"><a href="#4-Activity的启动模式" class="headerlink" title="4.Activity的启动模式"></a>4.Activity的启动模式</h2><ul>
<li>1.standard:默认标准模式，每启动一个都会创建一个实例，</li>
<li>2.singleTop：栈顶复用，如果在栈顶就调用onNewIntent复用，从onResume()开始</li>
<li>3.singleTask：栈内复用，本栈内只要用该类型Activity就会将其顶部的activity出栈</li>
<li>4.singleInstance：单例模式，除了3中特性，系统会单独给该Activity创建一个栈，</li>
</ul>
<h2 id="5-A、B、C、D分别是四种Activity的启动模式，那么A-gt-B-gt-C-gt-D-gt-A-gt-B-gt-C-gt-D分别启动，最后的activity栈是怎么样的"><a href="#5-A、B、C、D分别是四种Activity的启动模式，那么A-gt-B-gt-C-gt-D-gt-A-gt-B-gt-C-gt-D分别启动，最后的activity栈是怎么样的" class="headerlink" title="5.A、B、C、D分别是四种Activity的启动模式，那么A-&gt;B-&gt;C-&gt;D-&gt;A-&gt;B-&gt;C-&gt;D分别启动，最后的activity栈是怎么样的"></a>5.A、B、C、D分别是四种Activity的启动模式，那么A-&gt;B-&gt;C-&gt;D-&gt;A-&gt;B-&gt;C-&gt;D分别启动，最后的activity栈是怎么样的</h2><ul>
<li>1.这个题目需要深入了解activity的启动模式</li>
<li>2.最后的答案是：两个栈，前台栈是只有D，后台栈从底至上是A、B、C</li>
</ul>
<h2 id="6-Activity缓存方法"><a href="#6-Activity缓存方法" class="headerlink" title="6.Activity缓存方法"></a>6.Activity缓存方法</h2><ul>
<li>1.配置改变导致Activity被杀死，横屏变竖屏：在onStop之前会调用onSaveInstanceState()保存数据在重建Activity之后，会在onStart()之后调用onRestoreInstanceState(),并把保存下来的Bundle传给onCreate()和它会默认重建Activity当前的视图，我们可以在onCreate()中，回复自己的数据。</li>
<li>2.内存不足杀掉Activity，优先级分别是：前台可见，可见非前台，后台。</li>
</ul>
<h2 id="7-Service的生命周期，两种启动方法，有什么区别"><a href="#7-Service的生命周期，两种启动方法，有什么区别" class="headerlink" title="7.Service的生命周期，两种启动方法，有什么区别"></a>7.Service的生命周期，两种启动方法，有什么区别</h2><ul>
<li>1.context.startService() -&gt;onCreate()- &gt;onStart()-&gt;Service running–&gt;(如果调用context.stopService() )-&gt;onDestroy() -&gt;Service shut down<ul>
<li>1.如果Service还没有运行，则调用onCreate()然后调用onStart()；</li>
<li>2.如果Service已经运行，则只调用onStart()，所以一个Service的onStart方法可能会重复调用多次。</li>
<li>3.调用stopService的时候直接onDestroy，</li>
<li>4.如果是调用者自己直接退出而没有调用stopService的话，Service会一直在后台运行。该Service的调用者再启动起来后可以通过stopService关闭Service。</li>
</ul>
</li>
<li>2.context.bindService()-&gt;onCreate()-&gt;onBind()-&gt;Service running–&gt;onUnbind() -&gt; onDestroy() -&gt;Service stop<ul>
<li>1.onBind将返回给客户端一个IBind接口实例，IBind允许客户端回调服务的方法，比如得到Service运行的状态或其他操作。</li>
<li>2.这个时候会把调用者和Service绑定在一起，Context退出了,Service就会调用onUnbind-&gt;onDestroy相应退出。</li>
<li>3.所以调用bindService的生命周期为：onCreate –&gt; onBind(只一次，不可多次绑定) –&gt; onUnbind –&gt; onDestory。</li>
</ul>
</li>
</ul>
<h2 id="8-怎么保证service不被杀死"><a href="#8-怎么保证service不被杀死" class="headerlink" title="8.怎么保证service不被杀死"></a>8.怎么保证service不被杀死</h2><ul>
<li>1.提升service优先级</li>
<li>2.提升service进程优先级</li>
<li>3.onDestroy方法里重启service</li>
</ul>
<h2 id="9-静态的Broadcast-和动态的有什么区别"><a href="#9-静态的Broadcast-和动态的有什么区别" class="headerlink" title="9.静态的Broadcast 和动态的有什么区别"></a>9.静态的Broadcast 和动态的有什么区别</h2><ul>
<li>1.动态的比静态的安全</li>
<li>2.静态在app启动的时候就初始化了 动态使用代码初始化</li>
<li>3.静态需要配置 动态不需要</li>
<li>4.生存期，静态广播的生存期可以比动态广播的长很多</li>
<li>5.优先级动态广播的优先级比静态广播高</li>
</ul>
<h2 id="10-Intent可以传递哪些数据类型"><a href="#10-Intent可以传递哪些数据类型" class="headerlink" title="10.Intent可以传递哪些数据类型"></a>10.Intent可以传递哪些数据类型</h2><ul>
<li>1.Serializable</li>
<li>2.charsequence: 主要用来传递String，char等</li>
<li>3.parcelable</li>
<li>4.Bundle</li>
</ul>
<h2 id="11-Json有什么优劣势、解析的原理"><a href="#11-Json有什么优劣势、解析的原理" class="headerlink" title="11.Json有什么优劣势、解析的原理"></a>11.Json有什么优劣势、解析的原理</h2><ul>
<li>1.JSON的速度要远远快于XML</li>
<li>2.JSON相对于XML来讲，数据的体积小</li>
<li>3.JSON对数据的描述性比XML较差</li>
<li>4.解析的基本原理是：词法分析</li>
</ul>
<h2 id="12-一个语言的编译过程"><a href="#12-一个语言的编译过程" class="headerlink" title="12.一个语言的编译过程"></a>12.一个语言的编译过程</h2><ul>
<li>1.词法分析：将一串文本按规则分割成最小的结构，关键字、标识符、运算符、界符和常量等。一般实现方法是自动机和正则表达式</li>
<li>2.语法分析：将一系列单词组合成语法树。一般实现方法有自顶向下和自底向上</li>
<li>3.语义分析：对结构上正确的源程序进行上下文有关性质的审查</li>
<li>4.目标代码生成</li>
<li>5.代码优化：优化生成的目标代码，</li>
</ul>
<h2 id="13-动画有哪几类，各有什么特点"><a href="#13-动画有哪几类，各有什么特点" class="headerlink" title="13.动画有哪几类，各有什么特点"></a>13.动画有哪几类，各有什么特点</h2><ul>
<li>1.动画的基本原理：其实就是利用插值器和估值器，来计算出各个时刻View的属性，然后通过改变View的属性来，实现View的动画效果。</li>
<li>2.View动画:只是影像变化，view的实际位置还在原来的地方。</li>
<li>3.帧动画是在xml中定义好一系列图片之后，使用AnimationDrawable来播放的动画。</li>
<li>4.View的属性动画：<ul>
<li>1.插值器：作用是根据时间的流逝的百分比来计算属性改变的百分比</li>
<li>2.估值器：在1的基础上由这个东西来计算出属性到底变化了多少数值的类</li>
</ul>
</li>
</ul>
<h2 id="14-Handler、Looper消息队列模型，各部分的作用"><a href="#14-Handler、Looper消息队列模型，各部分的作用" class="headerlink" title="14.Handler、Looper消息队列模型，各部分的作用"></a>14.Handler、Looper消息队列模型，各部分的作用</h2><ul>
<li>1.MessageQueue：读取会自动删除消息，单链表维护，在插入和删除上有优势。在其next()中会无限循环，不断判断是否有消息，有就返回这条消息并移除。</li>
<li>2.Looper：Looper创建的时候会创建一个MessageQueue，调用loop()方法的时候消息循环开始，loop()也是一个死循环，会不断调用messageQueue的next()，当有消息就处理，否则阻塞在messageQueue的next()中。当Looper的quit()被调用的时候会调用messageQueue的quit(),此时next()会返回null，然后loop()方法也跟着退出。</li>
<li>3.Handler：在主线程构造一个Handler，然后在其他线程调用sendMessage(),此时主线程的MessageQueue中会插入一条message，然后被Looper使用。</li>
<li>4.系统的主线程在ActivityThread的main()为入口开启主线程，其中定义了内部类Activity.H定义了一系列消息类型，包含四大组件的启动停止。</li>
<li>5.MessageQueue和Looper是一对一关系，Handler和Looper是多对一</li>
</ul>
<h2 id="15-怎样退出终止App"><a href="#15-怎样退出终止App" class="headerlink" title="15.怎样退出终止App"></a>15.怎样退出终止App</h2><ul>
<li>1.自己设置一个Activity的栈，然后一个个finish()</li>
</ul>
<h2 id="16-Android-IPC-Binder原理"><a href="#16-Android-IPC-Binder原理" class="headerlink" title="16.Android IPC:Binder原理"></a>16.Android IPC:Binder原理</h2><ul>
<li>1.在Activity和Service进行通讯的时候，用到了Binder。<ul>
<li>1.当属于同个进程我们可以继承Binder然后在Activity中对Service进行操作</li>
<li>2.当不属于同个进程，那么要用到AIDL让系统给我们创建一个Binder，然后在Activity中对远端的Service进行操作。</li>
</ul>
</li>
<li>2.系统给我们生成的Binder：<ul>
<li>1.Stub类中有:接口方法的id，有该Binder的标识，有asInterface(IBinder)(让我们在Activity中获取实现了Binder的接口，接口的实现在Service里，同进程时候返回Stub否则返回Proxy)，有onTransact()这个方法是在不同进程的时候让Proxy在Activity进行远端调用实现Activity操作Service</li>
<li>2.Proxy类是代理，在Activity端，其中有:IBinder mRemote(这就是远端的Binder)，两个接口的实现方法不过是代理最终还是要在远端的onTransact()中进行实际操作。</li>
</ul>
</li>
<li>3.哪一端的Binder是副本，该端就可以被另一端进行操作，因为Binder本体在定义的时候可以操作本端的东西。所以可以在Activity端传入本端的Binder，让Service端对其进行操作称为Listener，可以用RemoteCallbackList这个容器来装Listener，防止Listener因为经历过序列化而产生的问题。</li>
<li>4.当Activity端向远端进行调用的时候，当前线程会挂起，当方法处理完毕才会唤醒。</li>
<li>5.如果一个AIDL就用一个Service太奢侈，所以可以使用Binder池的方式，建立一个AIDL其中的方法是返回IBinder，然后根据方法中传入的参数返回具体的AIDL。</li>
<li>6.IPC的方式有：Bundle（在Intent启动的时候传入，不过是一次性的），文件共享(对于SharedPreference是特例，因为其在内存中会有缓存)，使用Messenger(其底层用的也是AIDL，同理要操作哪端，就在哪端定义Messenger)，AIDL，ContentProvider(在本进程中继承实现一个ContentProvider，在增删改查方法中调用本进程的SQLite，在其他进程中查询)，Socket</li>
</ul>
<h2 id="17-描述一次跨进程通讯"><a href="#17-描述一次跨进程通讯" class="headerlink" title="17.描述一次跨进程通讯"></a>17.描述一次跨进程通讯</h2><ul>
<li>1.client、proxy、serviceManager、BinderDriver、impl、service</li>
<li>2.client发起一个请求service信息的Binder请求到BinderDriver中，serviceManager发现BinderDiriver中有自己的请求 然后将clinet请求的service的数据返回给client这样完成了一次Binder通讯</li>
<li>3.clinet获取的service信息就是该service的proxy，此时调用proxy的方法，proxy将请求发送到BinderDriver中，此时service的 Binder线程池循环发现有自己的请求，然后用impl就处理这个请求最后返回，这样完成了第二次Binder通讯<br>4.中间client可挂起，也可以不挂起，有一个关键字oneway可以解决这个</li>
</ul>
<h2 id="18-android重要术语解释"><a href="#18-android重要术语解释" class="headerlink" title="18.android重要术语解释"></a>18.android重要术语解释</h2><ul>
<li>1.ActivityManagerServices，简称AMS，服务端对象，负责系统中所有Activity的生命周期</li>
<li>2.ActivityThread，App的真正入口。当开启App之后，会调用main()开始运行，开启消息循环队列，这就是传说中的UI线程或者叫主线程。与ActivityManagerServices配合，一起完成Activity的管理工作</li>
<li>3.ApplicationThread，用来实现ActivityManagerService与ActivityThread之间的交互。在ActivityManagerService需要管理相关Application中的Activity的生命周期时，通过ApplicationThread的代理对象与ActivityThread通讯。</li>
<li>4.ApplicationThreadProxy，是ApplicationThread在服务器端的代理，负责和客户端的ApplicationThread通讯。AMS就是通过该代理与ActivityThread进行通信的。</li>
<li>5.Instrumentation，每一个应用程序只有一个Instrumentation对象，每个Activity内都有一个对该对象的引用。Instrumentation可以理解为应用进程的管家，ActivityThread要创建或暂停某个Activity时，都需要通过Instrumentation来进行具体的操作。</li>
<li>6.ActivityStack，Activity在AMS的栈管理，用来记录已经启动的Activity的先后关系，状态信息等。通过ActivityStack决定是否需要启动新的进程。</li>
<li>7.ActivityRecord，ActivityStack的管理对象，每个Activity在AMS对应一个ActivityRecord，来记录Activity的状态以及其他的管理信息。其实就是服务器端的Activity对象的映像。</li>
<li>8.TaskRecord，AMS抽象出来的一个“任务”的概念，是记录ActivityRecord的栈，一个“Task”包含若干个ActivityRecord。AMS用TaskRecord确保Activity启动和退出的顺序。如果你清楚Activity的4种launchMode，那么对这个概念应该不陌生。</li>
</ul>
<h2 id="19-理解Window和WindowManager"><a href="#19-理解Window和WindowManager" class="headerlink" title="19.理解Window和WindowManager"></a>19.理解Window和WindowManager</h2><ul>
<li>1.Window用于显示View和接收各种事件，Window有三种类型：应用Window(每个Activity对应一个Window)、子Window(不能单独存在，附属于特定Window)、系统window(Toast和状态栏)</li>
<li>2.Window分层级，应用Window在1-99、子Window在1000-1999、系统Window在2000-2999.WindowManager提供了增删改View三个功能。</li>
<li>3.Window是个抽象概念：每一个Window对应着一个View和ViewRootImpl，Window通过ViewRootImpl来和View建立联系，View是Window存在的实体，只能通过WindowManager来访问Window。</li>
<li>4.WindowManager的实现是WindowManagerImpl其再委托给WindowManagerGlobal来对Window进行操作，其中有四个List分别储存对应的View、ViewRootImpl、WindowManger.LayoutParams和正在被删除的View</li>
<li>5.Window的实体是存在于远端的WindowMangerService中，所以增删改Window在本端是修改上面的几个List然后通过ViewRootImpl重绘View，通过WindowSession(每个应用一个)在远端修改Window。</li>
<li>6.Activity创建Window：Activity会在attach()中创建Window并设置其回调(onAttachedToWindow()、dispatchTouchEvent()),Activity的Window是由Policy类创建PhoneWindow实现的。然后通过Activity#setContentView()调用PhoneWindow的setContentView。</li>
</ul>
<h2 id="20-Bitmap的处理"><a href="#20-Bitmap的处理" class="headerlink" title="20.Bitmap的处理"></a>20.Bitmap的处理</h2><ul>
<li>1.当使用ImageView的时候，可能图片的像素大于ImageView，此时就可以通过BitmapFactory.Option来对图片进行压缩，inSampleSize表示缩小2^(inSampleSize-1)倍。</li>
<li>2.BitMap的缓存：<ul>
<li>1.使用LruCache进行内存缓存。</li>
<li>2.使用DiskLruCache进行硬盘缓存。</li>
<li>3.实现一个ImageLoader的流程：同步异步加载、图片压缩、内存硬盘缓存、网络拉取<ul>
<li>1.同步加载只创建一个线程然后按照顺序进行图片加载</li>
<li>2.异步加载使用线程池，让存在的加载任务都处于不同线程</li>
<li>3.为了不开启过多的异步任务，只在列表静止的时候开启图片加载</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="21-如何实现一个网络框架-参考Volley"><a href="#21-如何实现一个网络框架-参考Volley" class="headerlink" title="21.如何实现一个网络框架(参考Volley)"></a>21.如何实现一个网络框架(参考Volley)</h2><ul>
<li>1.缓存队列,以url为key缓存内容可以参考Bitmap的处理方式，这里单独开启一个线程。</li>
<li>2.网络请求队列，使用线程池进行请求。</li>
<li>3.提供各种不同类型的返回值的解析如String，Json，图片等等。</li>
</ul>
<h2 id="22-ClassLoader的基础知识"><a href="#22-ClassLoader的基础知识" class="headerlink" title="22.ClassLoader的基础知识"></a>22.ClassLoader的基础知识</h2><ul>
<li>1.双亲委托：一个ClassLoader类负责加载这个类所涉及的所有类，在加载的时候会判断该类是否已经被加载过，然后会递归去他父ClassLoader中找。</li>
<li>2.可以动态加载Jar通过URLClassLoader</li>
<li>3.ClassLoader 隔离问题 JVM识别一个类是由：ClassLoader id+PackageName+ClassName。</li>
<li>4.加载不同Jar包中的公共类：<ul>
<li>1.让父ClassLoader加载公共的Jar，子ClassLoader加载包含公共Jar的Jar，此时子ClassLoader在加载公共Jar的时候会先去父ClassLoader中找。(只适用Java)</li>
<li>2.重写加载包含公共Jar的Jar的ClassLoader，在loadClass中找到已经加载过公共Jar的ClassLoader，也就是把父ClassLoader替换掉。(只适用Java)</li>
<li>3.在生成包含公共Jar的Jar时候把公共Jar去掉。</li>
</ul>
</li>
</ul>
<h2 id="23-插件化框架描述：dynamicLoadApk为例子"><a href="#23-插件化框架描述：dynamicLoadApk为例子" class="headerlink" title="23.插件化框架描述：dynamicLoadApk为例子"></a>23.插件化框架描述：dynamicLoadApk为例子</h2><ul>
<li>1.可以通过DexClassLoader来对apk中的dex包进行加载访问</li>
<li>2.如何加载资源是个很大的问题，因为宿主程序中并没有apk中的资源，所以调用R资源会报错，所以这里使用了Activity中的实现ContextImpl的getAssets()和getResources()再加上反射来实现。</li>
<li>3.由于系统启动Activity有很多初始化动作要做，而我们手动反射很难完成，所以可以采用接口机制，将Activity的大部分生命周期提取成接口，然后通过代理Activity去调用插件Activity的生命周期。同时如果像增加一个新生命周期方法的时候，只需要在接口中和代理中声明一下就行。</li>
<li>4.缺点：<ul>
<li>1.慎用this，因为在apk中使用this并不代表宿主中的activity，当然如果this只是表示自己的接口还是可以的。除此之外可以使用that代替this。</li>
<li>2.不支持Service和静态注册的Broadcast</li>
<li>3.不支持LaunchMode和Apk中Activity的隐式调用。</li>
</ul>
</li>
</ul>
<h2 id="24-热修复：Andfix为例子"><a href="#24-热修复：Andfix为例子" class="headerlink" title="24.热修复：Andfix为例子"></a>24.热修复：Andfix为例子</h2><ul>
<li>1.大致原理：apkpatch将两个apk做一次对比，然后找出不同的部分。可以看到生成的apatch了文件，后缀改成zip再解压开，里面有一个dex文件。通过jadx查看一下源码，里面就是被修复的代码所在的类文件,这些更改过的类都加上了一个_CF的后缀，并且变动的方法都被加上了一个叫@MethodReplace的annotation，通过clazz和method指定了需要替换的方法。然后客户端sdk得到补丁文件后就会根据annotation来寻找需要替换的方法。最后由JNI层完成方法的替换。</li>
<li>2.无法添加新类和新的字段、补丁文件很容易被反编译、加固平台可能会使热补丁功能失效</li>
</ul>
<h2 id="25-线程同步的问题，常用的线程同步"><a href="#25-线程同步的问题，常用的线程同步" class="headerlink" title="25.线程同步的问题，常用的线程同步"></a>25.线程同步的问题，常用的线程同步</h2><ul>
<li>1.sycn：保证了原子性、可见性、有序性</li>
<li>2.锁：保证了原子性、可见性、有序性<ul>
<li>1.自旋锁:可以使线程在没有取得锁的时候，不被挂起，而转去执行一个空循环。<ul>
<li>1.优点:线程被挂起的几率减少，线程执行的连贯性加强。用于对于锁竞争不是很激烈，锁占用时间很短的并发线程。</li>
<li>2.缺点:过多浪费CPU时间，有一个线程连续两次试图获得自旋锁引起死锁</li>
</ul>
</li>
<li>2.阻塞锁:没得到锁的线程等待或者挂起，Sycn、Lock</li>
<li>3.可重入锁:一个线程可多次获取该锁，Sycn、Lock</li>
<li>4.悲观锁:每次去拿数据的时候都认为别人会修改，所以会阻塞全部其他线程 Sycn、Lock</li>
<li>5.乐观锁:每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。cas</li>
<li>6.显示锁和内置锁:显示锁用Lock来定义、内置锁用synchronized。</li>
<li>7.读-写锁:为了提高性能，Java提供了读</li>
</ul>
</li>
<li>3.volatile<ul>
<li>1.只能保证可见性，不能保证原子性</li>
<li>2.自增操作有三步，此时多线程写会出现问题</li>
</ul>
</li>
<li>4.cas<ul>
<li>1.操作:内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做并返回false。</li>
<li>2.解释:本地副本为A，共享内存为V，线程A要把V修改成B。某个时刻线程A要把V修改成B，如果A和V不同那么就表示有其他线程在修改V，此时就表示修改失败，否则表示没有其他线程修改，那么把V改成B。</li>
<li>3.局限:如果V被修改成V1然后又被改成V，此时cas识别不出变化，还是认为没有其他线程在修改V，此时就会有问题</li>
<li>4.局限解决:将V带上版本。</li>
</ul>
</li>
<li>5.线程不安全到底是怎么回事：<ul>
<li>1.一个线程写，多个线程读的时候，会造成写了一半就去读</li>
<li>2.多线程写，会造成脏数据</li>
</ul>
</li>
</ul>
<h2 id="26-Asynctask和线程池，GC相关（怎么判断哪些内存该GC，GC算法）"><a href="#26-Asynctask和线程池，GC相关（怎么判断哪些内存该GC，GC算法）" class="headerlink" title="26.Asynctask和线程池，GC相关（怎么判断哪些内存该GC，GC算法）"></a>26.Asynctask和线程池，GC相关（怎么判断哪些内存该GC，GC算法）</h2><ul>
<li>1.Asynctask：异步任务类，单线程线程池+Handler</li>
<li>2.线程池：<ul>
<li>1.ThreadPoolExecutor：通过Executors可以构造单线程池、固定数目线程池、不固定数目线程池。</li>
<li>2.ScheduledThreadPoolExecutor：可以延时调用线程或者延时重复调度线程。</li>
</ul>
</li>
<li>3.GC相关：重要<ul>
<li>1.搜索算法：<ul>
<li>1.引用计数</li>
<li>2.图搜索，可达性分析</li>
</ul>
</li>
<li>2.回收算法：<ul>
<li>1.标记清除复制：用于青年代</li>
<li>2.标记整理：用于老年代</li>
</ul>
</li>
<li>3.堆分区：<ul>
<li>1.青年区eden 80%、survivor1 10%、survivor2 10%</li>
<li>2.老年区</li>
</ul>
</li>
<li>4.虚拟机栈分区：<ul>
<li>1.局部变量表</li>
<li>2.操作数栈</li>
<li>3.动态链接</li>
<li>4.方法返回地址</li>
</ul>
</li>
<li>5.GC Roots:<ul>
<li>1.虚拟机栈(栈桢中的本地变量表)中的引用的对象</li>
<li>2.方法区中的类静态属性引用的对象</li>
<li>3.方法区中的常量引用的对象</li>
<li>4.本地方法栈中JNI的引用的对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="27-网络"><a href="#27-网络" class="headerlink" title="27.网络"></a>27.网络</h2><ul>
<li>1.ARP协议:在IP以太网中，当一个上层协议要发包时，有了该节点的IP地址，ARP就能提供该节点的MAC地址。</li>
<li>2.HTTP HTTPS的区别:<ul>
<li>1.HTTPS使用TLS(SSL)进行加密</li>
<li>2.HTTPS缺省工作在TCP协议443端口</li>
<li>3.它的工作流程一般如以下方式:<ul>
<li>1.完成TCP三次同步握手</li>
<li>2.客户端验证服务器数字证书，通过，进入步骤3</li>
<li>3.DH算法协商对称加密算法的密钥、hash算法的密钥</li>
<li>4.SSL安全加密隧道协商完成</li>
<li>5.网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改</li>
</ul>
</li>
<li>3.http请求包结构，http返回码的分类，400和500的区别<ul>
<li>1.包结构：<ul>
<li>1.请求：请求行、头部、数据</li>
<li>2.返回：状态行、头部、数据</li>
</ul>
</li>
<li>2.http返回码分类：1到5分别是，消息、成功、重定向、客户端错误、服务端错误</li>
</ul>
</li>
<li>4.Tcp<ul>
<li>1.可靠连接，三次握手，四次挥手<ul>
<li>1.三次握手：防止了服务器端的一直等待而浪费资源，例如只是两次握手，如果s确认之后c就掉线了，那么s就会浪费资源<ul>
<li>1.syn-c = x，表示这消息是x序号</li>
<li>2.ack-s = x + 1，表示syn-c这个消息接收成功。syn-s = y，表示这消息是y序号。</li>
<li>3.ack-c = y + 1，表示syn-s这条消息接收成功</li>
</ul>
</li>
</ul>
</li>
<li>2.四次挥手：TCP是全双工模式<ul>
<li>1.fin-c = x , 表示现在需要关闭c到s了。ack-c = y,表示上一条s的消息已经接收完毕</li>
<li>2.ack-s = x + 1，表示需要关闭的fin-c消息已经接收到了，同意关闭</li>
<li>3.fin-s = y + 1，表示s已经准备好关闭了，就等c的最后一条命令</li>
<li>4.ack-c = y + 1，表示c已经关闭，让s也关闭</li>
</ul>
</li>
<li>3.滑动窗口，停止等待、后退N、选择重传</li>
<li>4.拥塞控制，慢启动、拥塞避免、加速递减、快重传快恢复</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="28-数据库性能优化：索引和事务，需要找本专门的书大概了解一下"><a href="#28-数据库性能优化：索引和事务，需要找本专门的书大概了解一下" class="headerlink" title="28.数据库性能优化：索引和事务，需要找本专门的书大概了解一下"></a>28.数据库性能优化：索引和事务，需要找本专门的书大概了解一下</h2><h2 id="29-13-APK打包流程和其内容"><a href="#29-13-APK打包流程和其内容" class="headerlink" title="29.13.APK打包流程和其内容"></a>29.13.APK打包流程和其内容</h2><ul>
<li>1.流程<ul>
<li>1.aapt生成R文件<ul>
<li>2.aidl生成java文件</li>
<li>3.将全部java文件编译成class文件</li>
<li>4.将全部class文件和第三方包合并成dex文件</li>
<li>5.将资源、so文件、dex文件整合成apk</li>
<li>6.apk签名</li>
<li>7.apk字节对齐</li>
</ul>
</li>
</ul>
</li>
<li>2.内容：so、dex、asset、资源文件</li>
</ul>
<h2 id="30-网络劫持的类型原理：可以百度一下了解一下具体概念"><a href="#30-网络劫持的类型原理：可以百度一下了解一下具体概念" class="headerlink" title="30.网络劫持的类型原理：可以百度一下了解一下具体概念"></a>30.网络劫持的类型原理：可以百度一下了解一下具体概念</h2><ul>
<li>1.DNS劫持、欺骗、污染</li>
<li>2.http劫持：重定向、注入js，http注入、报文扩展</li>
</ul>
<h2 id="31-java类加载过程："><a href="#31-java类加载过程：" class="headerlink" title="31.java类加载过程："></a>31.java类加载过程：</h2><ul>
<li>1.加载时机：创建实例、访问静态变量或方法、反射、加载子类之前</li>
<li>2.验证：验证文件格式、元数据、字节码、符号引用的正确性</li>
<li>3.加载：根据全类名获取文件字节流、将字节流转化为静态储存结构放入方法区、生成class对象</li>
<li>4.准备：在堆上为静态变量划分内存</li>
<li>5.解析：将常量池中的符号引用转换为直接引用</li>
<li>6.初始化：初始化静态变量</li>
<li>7.书籍推荐：<strong>深入理解java虚拟机</strong>，博客推荐：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/bc6d1770d92c">Java/Android阿里面试JVM部分理解</a></li>
</ul>
<h2 id="32-retrofit的了解"><a href="#32-retrofit的了解" class="headerlink" title="32.retrofit的了解"></a>32.retrofit的了解</h2><ul>
<li>1.动态代理创建一个接口的代理类</li>
<li>2.通过反射解析每个接口的注解、入参构造http请求</li>
<li>3.获取到返回的http请求，使用Adapter解析成需要的返回值。</li>
</ul>
<h2 id="33-bundle的数据结构，如何存储"><a href="#33-bundle的数据结构，如何存储" class="headerlink" title="33.bundle的数据结构，如何存储"></a>33.bundle的数据结构，如何存储</h2><ul>
<li>1.键值对储存</li>
<li>2.传递的数据可以是boolean、byte、int、long、float、double、string等基本类型或它们对应的数组，也可以是对象或对象数组。</li>
<li>3.当Bundle传递的是对象或对象数组时，必须实现Serializable 或Parcelable接口</li>
</ul>
<h2 id="34-listview内点击buttom并移动的事件流完整拦截过程："><a href="#34-listview内点击buttom并移动的事件流完整拦截过程：" class="headerlink" title="34.listview内点击buttom并移动的事件流完整拦截过程："></a>34.listview内点击buttom并移动的事件流完整拦截过程：</h2><ul>
<li>1.点下按钮的时候：<ul>
<li>1.产生了一个down事件，activity–&gt;phoneWindow–&gt;ViewGroup–&gt;ListView–&gt;botton,中间如果有重写了拦截方法，则事件被该view拦截可能消耗。</li>
<li>2.没拦截，事件到达了button，这个过程中建立了一条事件传递的view链表</li>
<li>3.到button的dispatch方法–&gt;onTouch–&gt;view是否可用–&gt;Touch代理</li>
</ul>
</li>
<li>2.移动点击按钮的时候:<ul>
<li>1.产生move事件，listView中会对move事件做拦截</li>
<li>2.此时listView会将该滑动事件消费掉</li>
<li>3.后续的滑动事件都会被listView消费掉</li>
</ul>
</li>
<li>3.手指抬起来时候：前面建立了一个view链表，listView的父view在获取事件的时候，会直接取链表中的listView让其进行事件消耗。</li>
</ul>
<h2 id="35-service的意义：不需要界面，在后台执行的程序"><a href="#35-service的意义：不需要界面，在后台执行的程序" class="headerlink" title="35.service的意义：不需要界面，在后台执行的程序"></a>35.service的意义：不需要界面，在后台执行的程序</h2><h2 id="36-android的IPC通信方式，线程（进程间）通信机制有哪些"><a href="#36-android的IPC通信方式，线程（进程间）通信机制有哪些" class="headerlink" title="36.android的IPC通信方式，线程（进程间）通信机制有哪些"></a>36.android的IPC通信方式，线程（进程间）通信机制有哪些</h2><ul>
<li>1.ipc通信方式：binder、contentprovider、socket</li>
<li>2.操作系统进程通讯方式：共享内存、socket、管道</li>
</ul>
<h2 id="37-操作系统进程和线程的区别"><a href="#37-操作系统进程和线程的区别" class="headerlink" title="37.操作系统进程和线程的区别"></a>37.操作系统进程和线程的区别</h2><ul>
<li>1.简而言之,一个程序至少有一个进程,一个进程至少有一个线程.</li>
<li>2.线程的划分尺度小于进程，使得多线程程序的并发性高。</li>
<li>3.另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</li>
<li>4.多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配</li>
</ul>
<h2 id="38-HashMap的实现过程：Capacity就是buckets的数目，Load-factor就是buckets填满程度的最大比例。如果对迭代性能要求很高的话不要把capacity设置过大，也不要把load-factor设置过小。"><a href="#38-HashMap的实现过程：Capacity就是buckets的数目，Load-factor就是buckets填满程度的最大比例。如果对迭代性能要求很高的话不要把capacity设置过大，也不要把load-factor设置过小。" class="headerlink" title="38.HashMap的实现过程：Capacity就是buckets的数目，Load factor就是buckets填满程度的最大比例。如果对迭代性能要求很高的话不要把capacity设置过大，也不要把load factor设置过小。"></a>38.HashMap的实现过程：Capacity就是buckets的数目，Load factor就是buckets填满程度的最大比例。如果对迭代性能要求很高的话不要把capacity设置过大，也不要把load factor设置过小。</h2><ul>
<li>1.简单来说HashMap就是一个会自动扩容的<strong>数组链表</strong></li>
<li>2.put过程<ul>
<li>1.对key的hashCode()做hash，然后再计算index;</li>
<li>2.如果没碰撞直接放到bucket里；</li>
<li>3.如果碰撞了，以链表的形式存在buckets后；</li>
<li>4.如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树；</li>
<li>5.如果节点已经存在就替换old value(保证key的唯一性)</li>
<li>6.如果bucket满了(超过load factor*current capacity)，就要resize。</li>
</ul>
</li>
<li>3.resize：当put时，如果发现目前的bucket占用程度已经超过了Load Factor所希望的比例，那么就会发生resize。在resize的过程，简单的说就是把bucket扩充为2倍，之后重新计算index，把节点再放到新的bucket中</li>
<li>4.get过程<ul>
<li>1.根据key的hash算出数组下表</li>
<li>2.使用equals遍历链表进行比较</li>
</ul>
</li>
</ul>
<h2 id="39-mvc、mvp、mvvm："><a href="#39-mvc、mvp、mvvm：" class="headerlink" title="39.mvc、mvp、mvvm："></a>39.mvc、mvp、mvvm：</h2><ul>
<li>1.mvc:数据、View、Activity，View将操作反馈给Activity，Activitiy去获取数据，数据通过观察者模式刷新给View。循环依赖<ul>
<li>1.Activity重，很难单元测试</li>
<li>2.View和Model耦合严重</li>
</ul>
</li>
<li>2.mvp:数据、View、Presenter，View将操作给Presenter，Presenter去获取数据，数据获取好了返回给Presenter，Presenter去刷新View。PV，PM双向依赖<ul>
<li>1.接口爆炸</li>
<li>2.Presenter很重</li>
</ul>
</li>
<li>3.mvvm:数据、View、ViewModel，View将操作给ViewModel，ViewModel去获取数据，数据和界面绑定了，数据更新界面更新。<ul>
<li>1.viewModel的业务逻辑可以单独拿来测试</li>
<li>2.一个view 对应一个 viewModel 业务逻辑可以分离，不会出现全能类</li>
<li>3.数据和界面绑定了，不用写垃圾代码，但是复用起来不舒服</li>
</ul>
</li>
</ul>
<h2 id="40-java的线程如何实现"><a href="#40-java的线程如何实现" class="headerlink" title="40.java的线程如何实现"></a>40.java的线程如何实现</h2><ul>
<li>1.Thread继承</li>
<li>2.Runnale</li>
<li>3.Future</li>
<li>4.线程池</li>
</ul>
<h2 id="41-ArrayList-如何删除重复的元素或者指定的元素；"><a href="#41-ArrayList-如何删除重复的元素或者指定的元素；" class="headerlink" title="41.ArrayList 如何删除重复的元素或者指定的元素；"></a>41.ArrayList 如何删除重复的元素或者指定的元素；</h2><ul>
<li>1.删除重复：Set</li>
<li>2.删除指定：迭代器</li>
</ul>
<h2 id="42-如何设计在-UDP-上层保证-UDP-的可靠性传输；"><a href="#42-如何设计在-UDP-上层保证-UDP-的可靠性传输；" class="headerlink" title="42.如何设计在 UDP 上层保证 UDP 的可靠性传输；"></a>42.如何设计在 UDP 上层保证 UDP 的可靠性传输；</h2><ul>
<li>1.简单来讲，要使用UDP来构建可靠的面向连接的数据传输，就要实现类似于TCP协议的超时重传，有序接受，应答确认，滑动窗口流量控制等机制,等于说要在传输层的上一层（或者直接在应用层）实现TCP协议的可靠数据传输机制。</li>
<li>2.比如使用UDP数据包+序列号，UDP数据包+时间戳等方法，在服务器端进行应答确认机制，这样就会保证不可靠的UDP协议进行可靠的数据传输。</li>
<li>3.基于udp的可靠传输协议有：RUDP、RTP、UDT</li>
</ul>
<h2 id="43-Java-中内部类为什么可以访问外部类"><a href="#43-Java-中内部类为什么可以访问外部类" class="headerlink" title="43.Java 中内部类为什么可以访问外部类"></a>43.Java 中内部类为什么可以访问外部类</h2><ul>
<li>1.因为内部类创建的时候，需要外部类的对象，在内部类对象创建的时候会把外部类的引用传递进去</li>
</ul>
<h2 id="44-设计移动端的联系人存储与查询的功能，要求快速搜索联系人，可以用到哪些数据结构？数据库索引，平衡二叉树-B树、红黑树"><a href="#44-设计移动端的联系人存储与查询的功能，要求快速搜索联系人，可以用到哪些数据结构？数据库索引，平衡二叉树-B树、红黑树" class="headerlink" title="44.设计移动端的联系人存储与查询的功能，要求快速搜索联系人，可以用到哪些数据结构？数据库索引，平衡二叉树(B树、红黑树)"></a>44.设计移动端的联系人存储与查询的功能，要求快速搜索联系人，可以用到哪些数据结构？数据库索引，平衡二叉树(B树、红黑树)</h2><h2 id="45-红黑树特点"><a href="#45-红黑树特点" class="headerlink" title="45.红黑树特点"></a>45.红黑树特点</h2><ul>
<li>1.root节点和叶子节点是黑色</li>
<li>2.红色节点后必须为黑色节点</li>
<li>3.从root到叶子每条路径的黑节点数量相同</li>
</ul>
<h2 id="46-linux异步和同步i-o"><a href="#46-linux异步和同步i-o" class="headerlink" title="46.linux异步和同步i/o:"></a>46.linux异步和同步i/o:</h2><ul>
<li>1.同步：对于client，client一直等待，但是client不挂起：主线程调用</li>
<li>2.异步：对于client，client发起请求，service好了再回调client：其他线程调用，调用完成之后进行回调</li>
<li>3.阻塞：对于service，在准备io的时候会将service端挂起，直至准备完成然后唤醒service：bio</li>
<li>3.非阻塞：对于service，在准备io的时候不会将service端挂起，而是service一直去轮询判断io是否准备完成，准备完成了就进行操作：nio、linux的select、poll、epoll</li>
<li>4.多路复用io：非阻塞io的一种优化，java nio，用一个线程去轮询多个 io端口是否可用，如果一个可用就通知对应的io请求，这使用一个线程轮询可以大大增强性能。<ul>
<li>1.我可以采用 多线程+ 阻塞IO 达到类似的效果，但是由于在多线程 + 阻塞IO 中，每个socket对应一个线程，这样会造成很大的资源占用。</li>
<li>2.而在多路复用IO中，轮询每个socket状态是内核在进行的，这个效率要比用户线程要高的多。</li>
</ul>
</li>
<li>5.异步io：aio，用户线程完全不感知io的进行，所有操作都交给内核，io完成之后内核通知用户线程。<ul>
<li>1.这种io才是异步的，2、3、4都是同步io，因为内核进行数据拷贝的过程都会让用户线程阻塞。</li>
<li>2.异步IO是需要操作系统的底层支持，也就是内核支持，Java 7中，提供了Asynchronous IO</li>
</ul>
</li>
</ul>
<h2 id="47-ConcurrentHashMap内部实现，HashTable的实现被废弃的原因"><a href="#47-ConcurrentHashMap内部实现，HashTable的实现被废弃的原因" class="headerlink" title="47.ConcurrentHashMap内部实现，HashTable的实现被废弃的原因:"></a>47.ConcurrentHashMap内部实现，HashTable的实现被废弃的原因:</h2><ul>
<li>1.HashTable容器在竞争激烈的并发环境下表现出效率低下的原因，是因为所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</li>
<li>2.ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。</li>
</ul>
<h2 id="48-HandlerThread是什么"><a href="#48-HandlerThread是什么" class="headerlink" title="48.HandlerThread是什么"></a>48.HandlerThread是什么</h2><ul>
<li>1.MessageQueue + Looper + Handler</li>
</ul>
<h2 id="49-IntentService是什么"><a href="#49-IntentService是什么" class="headerlink" title="49.IntentService是什么"></a>49.IntentService是什么</h2><ul>
<li>1.含有HandlerThread的Service，可以多次startService()来多次在子线程中进行 onHandlerIntent()的调用。</li>
</ul>
<h2 id="50-class和dex"><a href="#50-class和dex" class="headerlink" title="50.class和dex"></a>50.class和dex</h2><ul>
<li>1.dvm执行的是dex格式文件，jvm执行的是class文件，android程序编译完之后生产class文件。然后dex工具会把class文件处理成dex文件，然后把资源文件和.dex文件等打包成apk文件。</li>
<li>2.dvm是基于寄存器的虚拟机，而jvm执行是基于虚拟栈的虚拟机。寄存器存取速度比栈快的多，dvm可以根据硬件实现最大的优化，比较适合移动设备。</li>
<li>3.class文件存在很多的冗余信息，dex工具会去除冗余信息，并把所有的class文件整合到dex文件中。减少了I/O操作，提高了类的查找速度</li>
</ul>
<h2 id="51-内存泄漏"><a href="#51-内存泄漏" class="headerlink" title="51.内存泄漏"></a>51.内存泄漏</h2><ul>
<li>1.其他线程持有一个Listener，Listener操作activity。那么在线程么有完毕的时候，activity关闭了，原本是要被回收的但是，不能被回收。</li>
<li>2.例如Handler导致的内存泄漏，Handler就相当于Listener。</li>
<li>3.在activity关闭的时候注意停止线程，或者将Listener的注册取消</li>
<li>3.使用弱引用，这样即使Listener持有了activity，在GC的时候还是会被回收</li>
<li>4.工具:LeakCanary</li>
</ul>
<h2 id="52-过度绘制、卡顿优化"><a href="#52-过度绘制、卡顿优化" class="headerlink" title="52.过度绘制、卡顿优化:"></a>52.过度绘制、卡顿优化:</h2><ul>
<li>1.过度绘制：<ul>
<li>1.移除Window默认的Background：getWidow.setBackgroundDrawable(null);</li>
<li>2.移除XML布局文件中非必需的Background</li>
<li>3.减少布局嵌套(扁平化的一个体现，减少View数的深度，也就减少了View树的遍历时间，渲染的时候，前后期的工作，总是按View树结点来)</li>
<li>4.在引入布局文件里面，最外层可以用merge替代LinearLayout,RelativeLayout，这样把子UI元素直接衔接在include位置</li>
<li>5.工具：HierarchyViewer 查看视图层级</li>
</ul>
</li>
<li>2.卡顿优化：16ms数据更新</li>
</ul>
<h2 id="53-apk瘦身"><a href="#53-apk瘦身" class="headerlink" title="53.apk瘦身:"></a>53.apk瘦身:</h2><ul>
<li>1.classes.dex：通过代码混淆，删掉不必要的jar包和代码实现该文件的优化</li>
<li>2.资源文件：通过Lint工具扫描代码中没有使用到的静态资源</li>
<li>3.图片资源：使用tinypng和webP，下面详细介绍图片资源优化的方案,矢量图</li>
<li>4.SO文件将不用的去掉，目前主流app一般只放一个arm的so包</li>
</ul>
<h2 id="54-ANR的形成，各个组件上出现ARN的时间限制是多少"><a href="#54-ANR的形成，各个组件上出现ARN的时间限制是多少" class="headerlink" title="54.ANR的形成，各个组件上出现ARN的时间限制是多少"></a>54.ANR的形成，各个组件上出现ARN的时间限制是多少</h2><ul>
<li>1.只要是主线程耗时的操作就会ARN  如io</li>
<li>2.broadcast超时时间为10秒  按键无响应的超时时间为5秒 前台service无响应的超时时间为20秒，后台service为200秒</li>
</ul>
<h2 id="55-Serializable和Parcelable-的区别"><a href="#55-Serializable和Parcelable-的区别" class="headerlink" title="55.Serializable和Parcelable 的区别"></a>55.Serializable和Parcelable 的区别</h2><ul>
<li>1.P 消耗内存小</li>
<li>2.网络传输用S  程序内使用P</li>
<li>3.S将数据持久化方便</li>
<li>4.S使用了反射 容易触发垃圾回收 比较慢</li>
</ul>
<h2 id="56-Sharedpreferences源码简述"><a href="#56-Sharedpreferences源码简述" class="headerlink" title="56.Sharedpreferences源码简述"></a>56.Sharedpreferences源码简述</h2><ul>
<li>1.储存于硬盘上的xml键值对，数据多了会有性能问题</li>
<li>2.ContextImpl记录着SharedPreferences的重要数据，文件路径和实例的键值对</li>
<li>3.在xml文件全部内加载到内存中之前，读取操作是阻塞的，在xml文件全部内加载到内存中之后，是直接读取内存中的数据</li>
<li>4.apply因为是异步的没有返回值, commit是同步的有返回值能知道修改是否提交成功</li>
<li>5.多并发的提交commit时，需等待正在处理的commit数据更新到磁盘文件后才会继续往下执行，从而降低效率; 而apply只是原子更新到内存，后调用apply函数会直接覆盖前面内存数据，从一定程度上提高很多效率。 3.edit()每次都是创建新的EditorImpl对象.</li>
<li>6.博客推荐：**<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/102f25cf64e3">全面剖析SharedPreferences</a>**</li>
</ul>
<h2 id="57-操作系统如何管理内存的："><a href="#57-操作系统如何管理内存的：" class="headerlink" title="57.操作系统如何管理内存的："></a>57.操作系统如何管理内存的：</h2><ul>
<li>1.使用寄存器进行将进程地址和物理内存进行映射</li>
<li>2.虚拟内存进行内存映射到硬盘上增大内存</li>
<li>3.虚拟内存是进行内存分页管理</li>
<li>4.页表实现分页，就是 页+地址偏移。</li>
<li>5.如果程序的内存在硬盘上，那么就需要用页置换算法来将其调入内存中：先进先出、最近未使用最少等等</li>
<li>6.博客推荐：**<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/aecff59430fa">现代操作系统部分章节笔记</a>**</li>
</ul>
<h2 id="58-浏览器输入地址到返回结果发生了什么"><a href="#58-浏览器输入地址到返回结果发生了什么" class="headerlink" title="58.浏览器输入地址到返回结果发生了什么"></a>58.浏览器输入地址到返回结果发生了什么</h2><ul>
<li>1.DNS解析</li>
<li>2.TCP连接</li>
<li>3.发送HTTP请求</li>
<li>4.服务器处理请求并返回HTTP报文</li>
<li>5.浏览器解析渲染页面</li>
<li>6.连接结束</li>
</ul>
<h2 id="59-java泛型类型擦除发生在什么时候，通配符有什么需要注意的。"><a href="#59-java泛型类型擦除发生在什么时候，通配符有什么需要注意的。" class="headerlink" title="59.java泛型类型擦除发生在什么时候，通配符有什么需要注意的。"></a>59.java泛型类型擦除发生在什么时候，通配符有什么需要注意的。</h2><ul>
<li>1.发生在编译的时候</li>
<li>2.PECS，extends善于提供精确的对象 A是B的子集，Super善于插入精确的对象 A是B的超集</li>
<li>3.博客推荐：**<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4e4751b5bbbb">Effective Java笔记（不含反序列化、并发、注解和枚举）</a><strong>、</strong><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6006a3284f55">android阿里面试java基础锦集</a>**</li>
</ul>
<h2 id="60-activity的生命周期"><a href="#60-activity的生命周期" class="headerlink" title="60.activity的生命周期"></a>60.activity的生命周期</h2><ul>
<li>1.a启动b，后退键再到a的生命周期流程：a.create–&gt;a.start–&gt;a.resume–&gt;a.pause–&gt;b.create–&gt;b.start–&gt;b.resume–&gt;b界面绘制–&gt;a.stop–&gt;b.pause–&gt;b.stop–&gt;b.destroy–&gt;a.restart–&gt;a.start–&gt;a.resume</li>
<li>2.意外销毁会调用saveInstance，重新恢复的时候回调用restoreInstance。储存数据的时候使用了委托机制，从activity–&gt;window–&gt;viewGroup–&gt;view 会递归调用save来保持本view的数据，restore则是递归恢复本view数据。我们可以在里面做一些自己需要的数据操作。</li>
</ul>
<h2 id="61-面试常考的算法"><a href="#61-面试常考的算法" class="headerlink" title="61.面试常考的算法"></a>61.面试常考的算法</h2><ul>
<li>1.快排、堆排序为首的各种排序算法</li>
<li>2.链表的各种操作：判断成环、判断相交、合并链表、倒数K个节点、寻找成环节点</li>
<li>3.二叉树、红黑树、B树定义以及时间复杂度计算方式</li>
<li>4.动态规划、贪心算法、简单的图论</li>
<li>5.推荐书籍：<strong>算法导论</strong>，将图论之前的例子写一遍</li>
</ul>
<h2 id="62-Launcher进程启动另外一个进程的过程：启动一个app"><a href="#62-Launcher进程启动另外一个进程的过程：启动一个app" class="headerlink" title="62.Launcher进程启动另外一个进程的过程：启动一个app"></a>62.Launcher进程启动另外一个进程的过程：<a target="_blank" rel="noopener" href="http://www.cnblogs.com/tiantianbyconan/p/5017056.html">启动一个app</a></h2><h2 id="63-开源框架源码"><a href="#63-开源框架源码" class="headerlink" title="63.开源框架源码"></a>63.开源框架源码</h2><ul>
<li>1.Fresco<ul>
<li>1.mvc框架：<ul>
<li>1.Controller控制数据显示在Hierarchy中的Drawable的显隐</li>
<li>2.ImagePipeline在Controller中负责进行数据获取，返回的数据是CloseableImage</li>
<li>3.Drawee把除了初始化之外的操作全部交给Holder去做，Holder持有Controller和Hierarchy</li>
</ul>
</li>
<li>2.Drawable层次以及绘制：<ul>
<li>1.如果要绘制一次Drawable就调用invalidateSelf()来触发onDraw()</li>
<li>2.Drawable分为：容器类(保存一些Drawable)、自我绘制类(进度条)、图形变换类(scale、rotate、矩阵变换)、动画类(内部不断刷新，进行webp和gif的帧绘制)</li>
<li>3.ImagePipeline返回的CloseableImage是由一个个DrawableFactory解析成Drawable的</li>
<li>4.webp和gif动画是由jni代码解析的，然后其他静态图片是根据不同的android平台使用BitmapFactory来解析的</li>
</ul>
</li>
<li>3.职责链模式：producer不做操作标n，表示只是提供一个consumer。获取图片–》解码图片缓存Producer–》后台线程Producer–》client图片处理producer(n)–》解码producer(n)–》旋转或剪裁producer(n)–》编码图片内存缓存producer–》读硬盘缓存producer–》写硬盘缓存producer(n)–》网络producer提供CloseableImage《–解码图片缓存consumer《–client图片处理consumer《–解码consumer《–旋转或剪裁consumer《–编码图片内存缓存consumer《–写硬盘缓存consumer《–图片数据</li>
<li>4.内存缓存：<ul>
<li>1.一个CountingLruMap保存已经没有被引用的缓存条目，一个CountingLruMap保存所有的条目包括没有引用的条目。每当缓存策略改变和一定时间缓存配置的更新的时候，就会将 待销毁条目Map中的条目一个个移除，直到缓存大小符合配置。</li>
<li>2.这里的引用计数是用Fresco组件实现的引用计数器。</li>
<li>3.缓存有一个代理类，用来追踪缓存的存取。</li>
<li>4.CountingLruMap是使用LinkedHashMap来储存数据的。</li>
</ul>
</li>
<li>5.硬盘缓存：<ul>
<li>1.DefaultDiskStorage使用Lru策略。</li>
<li>2.为了不让所有的文件集中在一个文件中，创建很多命名不同的文件夹，然后使用hash算法把缓存文件分散</li>
<li>3.DiskStorageCache封装了DefaultDiskStorage，不仅进行缓存存取追踪，并且其在内存里面维持着一个 &lt;key,value&gt; 的键值对，因为文件修改频繁，所有只是定时刷新，因此如果在内存中找不到，还要去硬盘中找一次。</li>
<li>4.删除硬盘的缓存只出现在硬盘数据大小超限的时候，此时同时也会删除缓存中的key，所以不会出现内存中有key，但是硬盘上没有的情况。</li>
<li>5.在插入硬盘数据的时候，采用的是插入器的形式。返回一个Inserter，在Inserter.writeData()中传入一个CallBack(里面封装了客户端插入数据的逻辑和文件引用)，让内部实现调用CallBack的逻辑来插入文件数据，前面写的文件后缀是.temp,只有调用commit()之后才会修改后缀，让文件对客户端可见。</li>
<li>6.使用了java提供的FileTreeVisitor来遍历文件</li>
</ul>
</li>
<li>6.对象池：<ul>
<li>1.使用数组来存储一个桶，桶内部是一个Queue。数组下标是数据申请内存的byte大小，桶内部的Queue存的是内存块的。所以数组使用的是稀疏数组</li>
<li>2.申请内存的方式有两种 1.java堆上开辟的内存 2.ashme 的本地内存中开辟的内存</li>
</ul>
</li>
<li>7.设计模式：Builder、职责链、观察者、代理、组合、享元、适配器、装饰者、策略、生产者消费者、提供者</li>
<li>8.自定义计数引用：类似c++智能指针<ul>
<li>1.使用一个静态IdentityHashMap &lt;储存需要被计数引用的对象,其被引用的次数&gt;</li>
<li>2.用SharedReference分装需要被计数引用的对象，提供一个销毁资源的销毁器，提供一个静态工厂方法来复制自己，复制一个引用计数加一。提供一个方法销毁自己，表示自己需要变成无人引用的对象了，此时引用计数减一。</li>
<li>3.引用计数归零，销毁器将销毁资源，如bitmap的recycle或者是jni内存调用jni方法归还内存。</li>
</ul>
</li>
<li>9.博客推荐：**<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/dbe01f9994d0">Android Fresco源码文档翻译</a><strong>、</strong><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ab2124764438">从零开始撸一个Fresco之硬盘缓存</a><strong>、</strong><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/36663090b140">从零开始撸一个Fresco之gif和Webp动画</a><strong>、</strong><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ba0de15ce667">从零开始撸一个Fresco之内存缓存</a><strong>、</strong><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2dff47ae7666">从零开始撸一个Fresco之总结</a>**</li>
</ul>
</li>
<li>2.oKhttp：<ul>
<li>1.同步和异步：<ul>
<li>1.异步使用了Dispatcher来将存储在 Deque 中的请求分派给线程池中各个线程执行。</li>
<li>2.当任务执行完成后，无论是否有异常，finally代码段总会被执行，也就是会调用Dispatcher的finished函数，它将正在运行的任务Call从队列runningAsyncCalls中移除后，主动的把缓存队列向前走了一步。</li>
</ul>
</li>
<li>2.连接池：<ul>
<li>1.一个Connection封装了一个socket，ConnectionPool中储存s着所有的Connection，StreamAllocation是引用计数的一个单位</li>
<li>2.当一个请求获取一个Connection的时候要传入一个StreamAllocation，Connection中存着一个弱引用的StreamAllocation列表，每当上层应用引用一次Connection，StreamAllocation就会加一个。反之如果上层应用不使用了，就会删除一个。</li>
<li>3.ConnectionPool中会有一个后台任务定时清理StreamAllocation列表为空的Connection。5分钟时间，维持5个socket</li>
</ul>
</li>
<li>3.选择路线与建立连接<ul>
<li>1.选择路线有两种方式：<ul>
<li>1.无代理，那么在本地使用DNS查找到ip，注意结果是数组，即一个域名有多个IP，这就是自动重连的来源</li>
<li>2.有代理HTTP：设置socket的ip为代理地址的ip，设置socket的端口为代理地址的端口</li>
<li>3.代理好处：HTTP代理会帮你在远程服务器进行DNS查询，可以减少DNS劫持。</li>
</ul>
</li>
<li>2.建立连接<ul>
<li>1.连接池中已经存在连接，就从中取出(get)RealConnection，如果没有命中就进入下一步</li>
<li>2.根据选择的路线(Route)，调用Platform.get().connectSocket选择当前平台Runtime下最好的socket库进行握手</li>
<li>3.将建立成功的RealConnection放入(put)连接池缓存</li>
<li>4.如果存在TLS，就根据SSL版本与证书进行安全握手</li>
<li>5.构造HttpStream并维护刚刚的socket连接，管道建立完成</li>
</ul>
</li>
</ul>
</li>
<li>4.职责链模式：缓存、重试、建立连接等功能存在于拦截器中网络请求相关，主要是网络请求优化。网络请求的时候遇到的问题</li>
<li>5.博客推荐：**<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/60e5ebf0096a">Android数据层架构的实现 上篇</a><strong>、</strong><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5def7b42d223">Android数据层架构的实现 下篇</a>**</li>
</ul>
</li>
<li>3.okio<ul>
<li>1.简介；<ul>
<li>1.sink：自己–》别人</li>
<li>2.source：别人–》自己</li>
<li>3.BufferSink：有缓存区域的sink</li>
<li>4.BufferSource：有缓存区域的source</li>
<li>5.Buffer：实现了3、4的缓存区域，内部有Segment的双向链表，在在转移数据的时候，只需要将指针转移指向就行</li>
</ul>
</li>
<li>2.比java io的好处：<ul>
<li>1.减少内存申请和数据拷贝</li>
<li>2.类少，功能齐全，开发效率高</li>
</ul>
</li>
<li>3.内部实现：<ul>
<li>1.Buffer的Segment双向链表，减少数据拷贝</li>
<li>2.Segment的内部byte数组的共享，减少数据拷贝</li>
<li>3.SegmentPool的共享和回收Segment</li>
<li>4.sink和source中被实际操作的其实是Buffer，Buffer可以充当sink和source</li>
<li>5.最终okio只是对java io的封装，所有操作都是基于java io 的</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>写在最后:能看到这里的人,我挺佩服你的.这篇文章是我在<strong>头条</strong>面试之前整理的,最后**80%**的题目都命中了,所以祝你好运.</p>
</blockquote>
<p>不贩卖焦虑，也不标题党。分享一些这个世界上有意思的事情。题材包括且不限于：科幻、科学、科技、互联网、程序员、计算机编程。下面是我的微信公众号：<strong>世界上有意思的事</strong>，干货多多等你来看。</p>
<p>作者：何时夕<br>链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/cf5092fa2694">https://www.jianshu.com/p/cf5092fa2694</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h1 id="百度面试题"><a href="#百度面试题" class="headerlink" title="百度面试题"></a><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f0d2ed1254a9">百度面试题</a></h1><p>电话面试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 安卓View绘制流程</span><br><span class="line">2. 事件分发机制</span><br><span class="line">3. JAVA基础思想</span><br><span class="line">4. 多线程和安全问题</span><br><span class="line">5. 安卓性能优化和兼容问题</span><br><span class="line">6. 再问一下常规的组件相关问题</span><br></pre></td></tr></table></figure>





<p>现场笔试</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>  请描述安卓四大组建之间的关系，并说下安卓MVC的设计模式。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> 线程中sleep()和wait()有和却别，各有什么含义                   </span><br><span class="line"></span><br><span class="line"><span class="number">3</span>  <span class="keyword">abstract</span>和<span class="class"><span class="keyword">interface</span>的区别?</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span> array,arrayList, List ,三者有何区别？</span><br><span class="line"></span><br><span class="line"><span class="number">5</span> hashtable和hashmap的区别,并简述Hashmap的实现原理</span><br><span class="line"></span><br><span class="line"><span class="number">6</span> StringBuilder和],String ,subString方法的细微差别</span><br><span class="line">          </span><br><span class="line"><span class="number">7</span> 请写出四种以上你知道的设计模式，并介绍下实现原理</span><br><span class="line">          </span><br><span class="line"><span class="number">8</span> 安卓子线程是否能更新UI，如果能请说明具体细节。</span><br><span class="line"></span><br><span class="line"><span class="number">9</span> ANR产生的原因和解决步骤</span><br><span class="line"></span><br><span class="line"><span class="number">10</span> JavaGC机制的原理和内存泄露</span><br><span class="line"></span><br><span class="line"><span class="number">11</span>  安卓布局优化方案，          </span><br><span class="line"></span><br><span class="line"><span class="number">12</span>  请在<span class="number">100</span>个电话号码找出<span class="number">135</span>的电话号码   注意 不能用正则，（类似怎么最好的遍历LogGat日志）</span><br><span class="line"><span class="number">13</span>  Handler机制，请写出一种更新UI的方法和代码</span><br><span class="line"></span><br><span class="line"><span class="number">14</span>  请解释安卓为啥要加签名机制。</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>   你觉得安卓开发最关键的技术在哪里？</span><br><span class="line"><span class="number">13</span>  Handler机制，请写出一种更新UI的方法和代码</span><br><span class="line"></span><br><span class="line"><span class="number">14</span>  请解释安卓为啥要加签名机制。</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>   你觉得安卓开发最关键的技术在哪里？</span><br></pre></td></tr></table></figure>

<p>一轮面试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1  ANR 具体产生的类型有哪些，具体说下其产生的最大超时时间。</span><br><span class="line"></span><br><span class="line">2  多线程多点下载的过程</span><br><span class="line"></span><br><span class="line">3 http协议的理解和用法</span><br><span class="line"></span><br><span class="line">4 安卓解决线程并发问题</span><br><span class="line"></span><br><span class="line">5 你知道的数据结构有哪些，说下具体实现机制</span><br><span class="line"></span><br><span class="line">6 十六进制数据怎么和十进制和二进制之间转换</span><br><span class="line"></span><br><span class="line">7 谈下对Java OOP中多态的理解</span><br><span class="line"></span><br><span class="line">8  activty和Fragmengt之间怎么通信，Fragmengt和Fragmengt怎么通信</span><br><span class="line"></span><br><span class="line">9 怎么让自己的进程不被第三方应用杀掉，系统杀掉之后怎么能启动起来。</span><br><span class="line">10 说下平时开发中比较注意的一些问题，</span><br><span class="line">         </span><br><span class="line">答 ：可以熟说下svn和git的细节，和代码规范问题，和一些安全信息的问题等</span><br><span class="line"></span><br><span class="line">11 自定义view效率高于xml定义吗？说明理由。</span><br><span class="line"></span><br><span class="line">13 广播注册一般有几种，各有什么优缺点</span><br><span class="line"></span><br><span class="line">14 服务启动一般有几种，服务和activty之间怎么通信，服务和服务之间怎么通信</span><br><span class="line">15 布局优化主要哪些？具体优化？</span><br><span class="line"></span><br><span class="line">16 数据库的知识，包括本地数据库优化点。</span><br></pre></td></tr></table></figure>

<p>二轮面试</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 安卓事件分发机制，请详细说下整个流程</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> 安卓view绘制机制和加载过程，请详细说下整个流程</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> activty的加载过程 请详细介绍下（不是生命周期切记）</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> 安卓采用自动垃圾回收机制，请说下安卓内存管理的原理</span><br><span class="line">     </span><br><span class="line"><span class="number">5</span>  说下安卓虚拟机和java虚拟机的原理和不同点 </span><br><span class="line"></span><br><span class="line"><span class="number">6</span> 多线程中的安全队列一般通过什么实现？线程池原理？（java）</span><br><span class="line"></span><br><span class="line"><span class="number">7</span> 安卓权限管理，为何在清单中注册权限，安卓APP就可以使用，反之不可以（操作系统）</span><br><span class="line"></span><br><span class="line"><span class="number">8</span>  socket短线重连怎么实现，心跳机制又是怎样实现，四次握手步骤有哪些（网络通讯原理）</span><br><span class="line"></span><br><span class="line"><span class="number">9</span> http中TCP和UDP有啥区别，说下HTTP请求的IP报文结构（计算机网络）</span><br><span class="line"><span class="number">10</span> 你知道的安全加密有哪些？   （如果你说了一个加密，面试官就会接着跟进提问，所以之前你必须要会，不会的话背也要背下来）（安全加密）</span><br><span class="line"><span class="number">11</span>  你知道的数据存储结构？堆栈和链表内部机制。（数据结构）</span><br><span class="line"></span><br><span class="line"><span class="number">12</span> 说下Linux进程和线程的区别。进程调度优先级，和cpu调度进程关系。（操作系统）</span><br><span class="line"> </span><br><span class="line"><span class="number">13</span> 请你详细说下你知道的一种设计模式，并解释下java的高内聚和低耦合。</span><br><span class="line"></span><br><span class="line"><span class="number">14</span>  spring 的反射和代理，在安卓中应用场景（插件和ROM数据框架）</span><br><span class="line"></span><br><span class="line"><span class="number">15</span> JNI 调用过程中 混淆问题</span><br><span class="line"></span><br><span class="line"><span class="number">16</span> 看过安卓源码吗，请说出一个你看过的API或者组建内部原理。</span><br><span class="line"></span><br><span class="line"><span class="number">17</span> android <span class="number">5.0</span> <span class="number">6.0</span> 以及<span class="number">7.0</span>预测新特性</span><br><span class="line"></span><br><span class="line"><span class="number">18</span> hybrid混合开发，响应式编程等</span><br><span class="line"></span><br><span class="line"><span class="number">17</span>为啥离职呢  对待加班看法</span><br><span class="line"></span><br><span class="line"><span class="number">18</span> 你擅长什么，做了那些东西。</span><br></pre></td></tr></table></figure>



<h1 id="名企面试题"><a href="#名企面试题" class="headerlink" title="名企面试题"></a><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/735be5ece9e8">名企面试题</a></h1><h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/tree/master/android">Android</a></h2><h5 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h5><ul>
<li>[Android 源码中的设计模式(你需要知道的设计模式全在这里)](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android</a> 源码中的设计模式(你需要知道的设计模式全在这里).md)</li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/%E5%85%A8%E9%9D%A2%E4%BA%86%E8%A7%A3Activity.md">全面了解Activity</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Service%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.md">Service全面总结</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/IntentService%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%E5%92%8C%E5%AE%9E%E4%BE%8B%E4%BB%8B%E7%BB%8D.md">IntentService使用详解和实例介绍</a></li>
<li>[Fragment 全解析](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Fragment">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Fragment</a> 全解析.md)</li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/ContentProvider%E5%AE%9E%E4%BE%8B%E8%AF%A6%E8%A7%A3.md">ContentProvider实例详解</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/BroadcastReceiver%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93.md">BroadcastReceiver使用总结</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E6%9C%BA%E5%88%B6%E4%B9%8BAsycTask.md">Android异步任务机制之AsycTask</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%9B%BE%E8%A7%A3.md">Android启动过程图解</a></li>
<li>[Android 自定义View入门](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android</a> 自定义View入门.md)</li>
<li>[Android 自定义ViewGroup入门实践](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android</a> 自定义ViewGroup入门实践.md)</li>
<li>[Android 缓存机制](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android</a> 缓存机制.md)</li>
<li>[Android 数据存储五种方式使用与总结](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android</a> 数据存储五种方式使用与总结.md)</li>
<li>[Android 异步消息处理机制源码解析](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android</a> 异步消息处理机制（Handler 、 Looper 、MessageQueue）源码解析.md)</li>
<li>[Android View事件分发机制源码分析](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android</a> View事件分发机制源码分析.md)</li>
<li>[Android SQLite的使用入门](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android</a> SQLite的使用入门.md)</li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/AIDL%E7%9A%84%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5%E5%92%8C%E5%AE%9E%E4%BE%8B%E4%BB%8B%E7%BB%8D.md">AIDL的使用情况和实例介绍</a></li>
<li>[Android 名企面试题及答案整理（一）](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android</a> 名企面试题及答案整理（一）.md)</li>
</ul>
<h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><ul>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android5.0%E3%80%816.0%E3%80%817.0%E6%96%B0%E7%89%B9%E6%80%A7.md">Android5.0、6.0、7.0新特性</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android%E4%B8%AD%E5%BC%B1%E5%BC%95%E7%94%A8%E4%B8%8E%E8%BD%AF%E5%BC%95%E7%94%A8%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF.md">Android中弱引用与软引用的应用场景</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android%E9%95%BF%E8%BF%9E%E6%8E%A5%EF%BC%8C%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6.md">Android长连接，怎么处理心跳机制</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Asset%E7%9B%AE%E5%BD%95%E4%B8%8Eres%E7%9B%AE%E5%BD%95%E7%9A%84%E5%8C%BA%E5%88%AB.md">Asset目录与res目录的区别</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Binder%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0.md">Binder机制原理和底层实现</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Json%E4%BC%98%E5%8A%A3%E5%8A%BF.md">Json优劣势</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/ListView%E4%BC%98%E5%8C%96.md">ListView优化</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/android%E4%B8%AD%E5%9B%BE%E7%89%87%E7%BC%93%E5%AD%98.md">android中图片缓存</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/%E4%B8%A4%E7%B1%BB%E5%8A%A8%E7%94%BB.md">两类动画</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/%E4%BA%94%E5%A4%A7%E5%B8%83%E5%B1%80%E6%98%93%E6%B7%B7%E6%B7%86%E7%9F%A5%E8%AF%86.md">五大布局易混淆知识</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/%E4%BF%9D%E8%AF%81service%E4%B8%8D%E8%A2%AB%E6%9D%80%E6%AD%BB.md">保证service不被杀死</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/%E5%8A%A0%E9%80%9F%E5%90%AF%E5%8A%A8activity.md">加速启动activity</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/%E6%80%8E%E6%A0%B7%E9%80%80%E5%87%BA%E7%BB%88%E6%AD%A2App.md">怎样退出终止App</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/activity%E5%88%87%E6%8D%A2%E5%8A%A8%E7%94%BB.md">activity切换动画</a></li>
</ul>
<h5 id="外链"><a href="#外链" class="headerlink" title="外链"></a>外链</h5><ul>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://www.trinea.cn/android/layout-performance/">布局性能优化(include, viewstub, merge)</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://www.cnblogs.com/xiaoluo501395377/p/3444744.html">DOM、SAX、Pull解析XML</a></li>
</ul>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/tree/master/java">Java</a></h2><h5 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h5><ul>
<li>[ArrayList、LinkedList、Vector的区别](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> ArrayList、LinkedList、Vector的区别.md)</li>
<li>[Collection包结构，与Collections的区别](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> Collection包结构，与Collections的区别.md)</li>
<li>[Excption与Error包结构,OOM和SOF](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> Excption与Error包结构%2COOM和SOF.md)</li>
<li>[HashMap和HashTable的区别](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> HashMap和HashTable的区别.md)</li>
<li>[HashMap源码分析](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> HashMap源码分析.md)</li>
<li>[Hashcode的作用](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> Hashcode的作用.md)</li>
<li>[Map、Set、List、Queue、Stack的特点与用法](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> Map、Set、List、Queue、Stack的特点与用法.md)</li>
<li>[Object有哪些公用方法？](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> Object有哪些公用方法？.md)</li>
<li>[Override和Overload的使用规则和区别](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> Override和Overload的使用规则和区别.md)</li>
<li>[Switch能否用string做参数？](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> Switch能否用string做参数？.md)</li>
<li>[ThreadLocal的使用规则和源码分析](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> ThreadLocal的使用规则和源码分析.md)</li>
<li>[ThreadPool用法与示例](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> ThreadPool用法与示例.md)</li>
<li>[equals与==的区别](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> equals与%3D%3D的区别.md)</li>
<li>[try catch finally，try里有return，finally还执行么？](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> try catch finally，try里有return，finally还执行么？.md)</li>
<li>[九种基本数据类型的大小，以及他们的封装类](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> 九种基本数据类型的大小，以及他们的封装类.md)</li>
<li>[从源码分析String、StringBuffer与StringBuilder区别和联系](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> 从源码分析String、StringBuffer与StringBuilder区别和联系.md)</li>
<li>[多线程下生产者消费者问题的五种同步方法实现](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> 多线程下生产者消费者问题的五种同步方法实现.md)</li>
<li>[实现多线程的两种方法](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> 实现多线程的两种方法.md)</li>
<li>[接口（Interface）与 抽象类 （Abstract）使用规则和区别](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> 接口（Interface）与 抽象类 （Abstract）使用规则和区别.md)</li>
<li>[方法锁、对象锁和类锁的意义和区别](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> 方法锁、对象锁和类锁的意义和区别.md)</li>
<li>[四种引用，强弱软虚，用到的场景](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> 的四种引用，强弱软虚，用到的场景.md)</li>
<li>[线程同步的方法：sychronized、lock、reentrantLock分析](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> 线程同步的方法：sychronized、lock、reentrantLock分析.md)</li>
<li>[集合框架的层次结构和使用规则梳理](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> 集合框架的层次结构和使用规则梳理.md)</li>
<li>[面向对象的三个特征与含义](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> 面向对象的三个特征与含义.md)</li>
<li>[static的作用和意义](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5Bjava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[java]</a> static的作用和意义.md)</li>
<li>[多态实现的JVM调用过程](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5Bjava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[java]</a> 多态实现的JVM调用过程.md)</li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/wait()%E5%92%8Csleep()%E7%9A%84%E5%8C%BA%E5%88%AB.md">wait()和sleep()的区别</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/git%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8.md">git命令使用</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/Java%E4%B8%8EC++%E5%AF%B9%E6%AF%94.md">Java与C++对比</a></li>
</ul>
<h5 id="外链-1"><a href="#外链-1" class="headerlink" title="外链"></a>外链</h5><ul>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://762626559-qq-com.iteye.com/blog/395402">java反射</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://blog.csdn.net/xiaanming/article/details/8703708/">java回调</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://www.weixueyuan.net/view/6321.html">Java泛型</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://www.cnblogs.com/langtianya/p/3757993.html">java 新特性</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://www.iteye.com/topic/834447">Java IO与NIO</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://www.xuebuyuan.com/780786.html">foreach与正常for循环效率对比</a></li>
</ul>
<h2 id="数据结构-https-link-jianshu-com-t-https-github-com-helen-x-AndroidInterview-tree-master-data-structure"><a href="#数据结构-https-link-jianshu-com-t-https-github-com-helen-x-AndroidInterview-tree-master-data-structure" class="headerlink" title="[数据结构](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/tree/master/data structure)"></a>[数据结构](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/tree/master/data">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/tree/master/data</a> structure)</h2><h5 id="基础-2"><a href="#基础-2" class="headerlink" title="基础"></a>基础</h5><ul>
<li>[九大基础排序总结与对比(排序算法一网打尽)](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/data">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data</a> structure/[数据结构] 九大基础排序总结与对比.md)</li>
<li>[AVL树和AVL旋转、哈夫曼树和哈夫曼编码](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/data">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data</a> structure/[数据结构] AVL树和AVL旋转、哈夫曼树和哈夫曼编码.md)</li>
<li>[B(B-)树、B+树、B树](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/data">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data</a> structure/[数据结构] B(B-)树、B%2B树、B树.md)</li>
<li>[Hash表、Hash函数及冲突解决](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/data">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data</a> structure/[数据结构] Hash表、Hash函数及冲突解决.md)</li>
<li>[KMP的一个简单解释](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/data">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data</a> structure/[数据结构] KMP的一个简单解释.md)</li>
<li>[二分查找与变种二分查找](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/data">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data</a> structure/[数据结构] 二分查找与变种二分查找.md)</li>
<li>[二叉树前中后、层次遍历算法](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/data">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data</a> structure/[数据结构] 二叉树前中后、层次遍历算法.md)</li>
<li>[图的BFS、DFS、prim、Dijkstra算法](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/data">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data</a> structure/[数据结构] 图的BFS、DFS、prim、Dijkstra算法.md)</li>
<li>[字符串操作](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/data">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data</a> structure/[数据结构] 字符串操作.md)</li>
<li>[数组与链表的优缺点和区别](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/data">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data</a> structure/[数据结构] 数组与链表的优缺点和区别.md)</li>
<li>[红黑树](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/data">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data</a> structure/[数据结构] 红黑树.md)</li>
<li>[队列和栈](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/data">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data</a> structure/[数据结构] 队列和栈.md)</li>
</ul>
<h5 id="外链-2"><a href="#外链-2" class="headerlink" title="外链"></a>外链</h5><ul>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://blog.csdn.net/zyq522376829/article/details/47686867">海量数据处理 </a></li>
</ul>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/tree/master/algorithm">算法</a></h2><h5 id="基础-3"><a href="#基础-3" class="headerlink" title="基础"></a>基础</h5><ul>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.md">二叉搜索树与双向链表</a></li>
<li>[二叉树中 和为某值 的所有路径](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/二叉树中</a> 和为某值 的所有路径.md)</li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F.md">二叉树的镜像</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE.md">二维数组中的查找</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0.md">二进制中1的个数</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91.md">从上往下打印二叉树</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8.md">从尾到头打印链表</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97.md">判断二叉搜索树的后序遍历序列</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E5%88%A4%E6%96%AD%E6%A0%88%E7%9A%84%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97.md">判断栈的弹出序列</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E5%88%A4%E6%96%AD%E6%A0%91B%E6%98%AF%E4%B8%8D%E6%98%AF%E6%A0%91A%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84.md">判断树B是不是树A的子结构</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88.md">包含min函数的栈</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.md">反转链表</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6.md">变态跳台阶</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8.md">合并两个排序链表</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6.md">复杂链表的复制</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%A9%BA%E6%A0%BC%E6%9B%BF%E6%8D%A2.md">字符串中空格替换</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%85%A8%E6%8E%92%E5%88%97.md">字符串的顺序全排列</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97.md">数组中出现次数超过一半的数字</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97.md">斐波那契数列</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97.md">旋转数组的最小数字</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9.md">浮点数的整数次方</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.md">用两个栈实现队列</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96.md">矩形覆盖</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2.md">调整数组顺序使奇数位于偶数前面</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E8%B7%B3%E5%8F%B0%E9%98%B6.md">跳台阶</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91.md">重建二叉树</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9.md">链表中倒数第k个结点</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5.md">顺时针打印矩阵</a></li>
</ul>
<h5 id="外链-3"><a href="#外链-3" class="headerlink" title="外链"></a>外链</h5><ul>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741370.html">分治算法</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741374.html">动态规划</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741375.html">贪心算法</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741378.html">分支限界法</a></li>
</ul>
<p>作者：菜刀文<br>链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/735be5ece9e8">https://www.jianshu.com/p/735be5ece9e8</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h1 id="面试和必备的技能"><a href="#面试和必备的技能" class="headerlink" title="面试和必备的技能"></a>面试和必备的技能</h1><p>这里只简单列举一些东西，可能不是特别全，但是却特别适用，也不一定按照下面的流程，有可能是穿插的，也有可能都有，根据公司的规模以及面试官的心情而定（哈哈哈 ，你们就自求多福吧）。建议大家还是要将下面的东西全部掌握，没事写写代码，练练手，在项目中能用到的地方一定要用，有可能会遇到很多坑，一定要自己想办法填坑，之后回忆起这段经历，肯定可以敢理直气壮的跟别人讨论。如果你说的头头是道，那么对方会先输一层，然后在心里对你佩服。</p>
<ol>
<li><p>一般情况下第一轮都是基础面试，需要扎实的基础</p>
<ul>
<li>最常用的Android 基础知识</li>
<li>Java 基础知识</li>
<li>了解一些 常用东西的原理，例如：handler， thread 等</li>
<li>项目中的技术点</li>
</ul>
</li>
<li><p>第二轮的时候需要了解更深层次的东西</p>
<ul>
<li>Android 事件分发机制原理</li>
<li>Android 绘图机制原理</li>
<li>WindowManager 的相关知识</li>
<li>进程间传输方式</li>
<li>Java 内存管理机制</li>
<li>一些常用的 list,map 原理，以及子类之间的差别</li>
</ul>
</li>
<li><p>能进入第三轮基本没什么问题，但是要注意以下问题</p>
<ul>
<li><p>该轮一般是 老大或者部门负责人，问的问题一般都看 深度与广度</p>
</li>
<li><p>当问及薪水的时候，要说一个合适的，小公司随意，大公司一定要慎重，当心里没底的时候，可以告诉对方，让对方给一个合理的薪资。一般都是在原工资基础之上增长，听猎头说一般涨幅都在15%-30%，超 NB 的可以要30%及以上，如果感觉自己还不错的，挺厉害的，建议最高20%，一般人就定在15% 左右最靠谱。公司内部一般有一套机制，根据公司情况而定。</p>
</li>
<li><p>我们的面试原则就是拿到合理薪资，得到 offer</p>
</li>
<li><p>个人发展情况，这个问题很难回答，如果和公司方向不符合，极有可能和公司无缘。建议多试探性的问问公司缺少什么，你能否给予公司对应的东西。当然对于有自我追求的人，那可以放心大胆的提。我的方向就是架构师，哈哈哈，挺极端的，别学我哦。我感觉选择都是双向的，因此我知道自己需要的是什么。</p>
</li>
<li><p>你最擅长什么UI 还是其他什么？这个问题更不好回答。你要说你擅长 UI，是不是意味着你其他能力就不行？虽然我不知道面试官的用意，但是我能感觉到，这个问题不是那么好回答，我会回答说自己都行，来什么业务接什么需求。可能回答不太好，总之和公司的职位吻合就行，这样总不至于出错吧。</p>
</li>
</ul>
</li>
</ol>
<h2 id="Android-高级面试题及答案"><a href="#Android-高级面试题及答案" class="headerlink" title="Android 高级面试题及答案"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html">Android 高级面试题及答案</a></h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label0">1.如何对 Android 应用进行性能分析</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label1">2.什么情况下会导致内存泄露</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label2">3.如何避免 OOM 异常</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label3">4.Android 中如何捕获未捕获的异常</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label4">5.ANR 是什么？怎样避免和解决 ANR（重要）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label5">6.Android 线程间通信有哪几种方式</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label6">7.Devik 进程，linux 进程，线程的区别</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label7">8.描述一下 android 的系统架构</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label8">9.android 应用对内存是如何限制的?我们应该如何合理使用内存？</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label9">10. 简述 android 应用程序结构是哪些</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label10">11.请解释下 Android 程序运行时权限与文件系统权限的区别</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label11">12.Framework 工作方式及原理，Activity 是如何生成一个 view 的，机制是什么</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label12">13.多线程间通信和多进程之间通信有什么不同，分别怎么实现</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label13">14.Android 屏幕适配</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label14">15.什么是 AIDL 以及如何使用</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label15">16.Handler 机制</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label16">17.事件分发机制</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label17">18.子线程发消息到主线程进行更新 UI，除了 handler 和 AsyncTask，还有什么</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label18">19.子线程中能不能 new handler？为什么</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label19">20.Android 中的动画有哪几类，它们的特点和区别是什么</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label20">21.如何修改 Activity 进入和退出动画</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label21">22.SurfaceView &amp; View 的区别</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label22">23.开发中都使用过哪些框架、平台</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label23">24.使用过那些自定义View</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label24">25.自定义控件：绘制圆环的实现过程</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label25">26.自定义控件：摩天轮的实现过程</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label27">28.流式布局的实现过程</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label28">29.第三方登陆</a></li>
<li>[30.第三方支付](</li>
</ul>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Your name"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Your name</p><p class="is-size-6 is-block">Your title</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Your location</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">221</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">18</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">31</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/ANDROID/"><span class="level-start"><span class="level-item">ANDROID</span></span><span class="level-end"><span class="level-item tag">58</span></span></a></li><li><a class="level is-mobile" href="/categories/BLE/"><span class="level-start"><span class="level-item">BLE</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/DataStructure/"><span class="level-start"><span class="level-item">DataStructure</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/DesignPatterns/"><span class="level-start"><span class="level-item">DesignPatterns</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/ENGLISH/"><span class="level-start"><span class="level-item">ENGLISH</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/JAVA/"><span class="level-start"><span class="level-item">JAVA</span></span><span class="level-end"><span class="level-item tag">27</span></span></a></li><li><a class="level is-mobile" href="/categories/Jetpack/"><span class="level-start"><span class="level-item">Jetpack</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Kotlin/"><span class="level-start"><span class="level-item">Kotlin</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/LINUX/"><span class="level-start"><span class="level-item">LINUX</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Mathematics/"><span class="level-start"><span class="level-item">Mathematics</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/OS/"><span class="level-start"><span class="level-item">OS</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Organization/"><span class="level-start"><span class="level-item">Organization</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/SOURCE/"><span class="level-start"><span class="level-item">SOURCE</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/TEST/"><span class="level-start"><span class="level-item">TEST</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/TOOL/"><span class="level-start"><span class="level-item">TOOL</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/VIEW/"><span class="level-start"><span class="level-item">VIEW</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/anim/"><span class="level-start"><span class="level-item">anim</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/flutter/"><span class="level-start"><span class="level-item">flutter</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-10-21T15:18:58.000Z">2023-10-21</time></p><p class="title"><a href="/2023/10/21/proxy/">proxy</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-09-04T07:54:57.000Z">2023-09-04</time></p><p class="title"><a href="/2023/09/04/Android_interview%20organize/">Android_itnerview_organize</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-09-03T07:54:57.000Z">2023-09-03</time></p><p class="title"><a href="/2023/09/03/Android-itnerview-algorithm/">Android_itnerview_algorithm</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-08-20T13:41:06.000Z">2023-08-20</time></p><p class="title"><a href="/2023/08/20/compose-layout/">compose_layout</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-08-19T09:16:56.000Z">2023-08-19</time></p><p class="title"><a href="/2023/08/19/compose/">compose</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/"><span class="level-start"><span class="level-item">2022</span></span><span class="level-end"><span class="level-item tag">33</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/"><span class="level-start"><span class="level-item">2021</span></span><span class="level-end"><span class="level-item tag">23</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/"><span class="level-start"><span class="level-item">2020</span></span><span class="level-end"><span class="level-item tag">46</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/"><span class="level-start"><span class="level-item">2019</span></span><span class="level-end"><span class="level-item tag">21</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/"><span class="level-start"><span class="level-item">2018</span></span><span class="level-end"><span class="level-item tag">32</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/"><span class="level-start"><span class="level-item">2017</span></span><span class="level-end"><span class="level-item tag">57</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/ANDROID/"><span class="tag">ANDROID</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AOSP/"><span class="tag">AOSP</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Activity/"><span class="tag">Activity</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AndroidNewFeatures/"><span class="tag">AndroidNewFeatures</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Assembly/"><span class="tag">Assembly</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BLOG/"><span class="tag">BLOG</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ConstraintLayout/"><span class="tag">ConstraintLayout</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DB/"><span class="tag">DB</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Drawer/"><span class="tag">Drawer</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Fragment/"><span class="tag">Fragment</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JVM/"><span class="tag">JVM</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LEETCODE/"><span class="tag">LEETCODE</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Operators/"><span class="tag">Operators</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Performance/"><span class="tag">Performance</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RecyclerView/"><span class="tag">RecyclerView</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RxJava/"><span class="tag">RxJava</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/THINK/"><span class="tag">THINK</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TOOL/"><span class="tag">TOOL</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TabLayout/"><span class="tag">TabLayout</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Test/"><span class="tag">Test</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TouchEvent/"><span class="tag">TouchEvent</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/VIEW/"><span class="tag">VIEW</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/XML/"><span class="tag">XML</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/anim/"><span class="tag">anim</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/compose/"><span class="tag">compose</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/concurrency/"><span class="tag">concurrency</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/coroutie/"><span class="tag">coroutie</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/inter/"><span class="tag">inter</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/keyboard/"><span class="tag">keyboard</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/proguard/"><span class="tag">proguard</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe for updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Hexo" height="28"></a><p class="is-size-7"><span>&copy; 2023 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>