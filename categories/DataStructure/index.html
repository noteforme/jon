<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>Category: DataStructure - Hexo</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Hexo"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Hexo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Hexo"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="Hexo"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="John Doe"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"Hexo","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"John Doe"},"publisher":{"@type":"Organization","name":"Hexo","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Hexo" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">Categories</a></li><li class="is-active"><a href="#" aria-current="page">DataStructure</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-04-02T09:32:31.000Z" title="4/2/2023, 5:32:31 PM">2023-04-02</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-08-09T14:42:00.048Z" title="8/9/2023, 10:42:00 PM">2023-08-09</time></span><span class="level-item"><a class="link-muted" href="/categories/DataStructure/">DataStructure</a></span><span class="level-item">18 minutes read (About 2679 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/04/02/LC-DP/">LC-DP</a></p><div class="content"><p>Labuladong</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1XV411Y7oE">https://www.bilibili.com/video/BV1XV411Y7oE</a></p>
<ol>
<li>重叠子问题</li>
<li>状态转移方程 (最关键)</li>
<li>最优子结构</li>
</ol>
<ol>
<li>明确状态</li>
<li>明确 选择</li>
<li>明确dp函数/数组的定义</li>
<li>明确base case</li>
</ol>
<p>随想录</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13Q4y197Wg">https://www.bilibili.com/video/BV13Q4y197Wg</a></p>
<h4 id="动规5部曲"><a href="#动规5部曲" class="headerlink" title="动规5部曲"></a>动规5部曲</h4><p><strong>对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 确定dp数组（dp table）以及下标的含义</span><br><span class="line">2. 确定递推公式</span><br><span class="line">3. dp数组如何初始化</span><br><span class="line">4. 确定遍历顺序</span><br><span class="line">5. 举例推导dp数组</span><br></pre></td></tr></table></figure>





<p>动态规划解法代码框架</p>
<p><img src="/2023/04/02/LC-DP/20230701162055.jpg" alt="20230701162055"></p>
<h4 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fibonacci-number/">509. 斐波那契数</a></h4><h5 id="随想录-迭代递推"><a href="#随想录-迭代递推" class="headerlink" title="随想录 迭代递推"></a>随想录 迭代递推</h5><p>自底向上</p>
<p>通过for循环递推出 dp[n]的值，一开始解的时候写成了  dp[n] = dp[n - 1] + dp[n- 2] </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随想录视频思路解法1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fib1</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line"><span class="comment">//        println(n)</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(n+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line"><span class="comment">//            println(&quot; dp[n - 1]= $&#123; dp[n - 1]&#125;  dp[n - 2]= $&#123;dp[n - 2]&#125;&quot;)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h5 id="随想录-视频思路解法2"><a href="#随想录-视频思路解法2" class="headerlink" title="随想录  视频思路解法2"></a>随想录  视频思路解法2</h5><p>这种解法，dp数组空间复杂度减少了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 随想录视频思路解法2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fib</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">val</span> dp = IntArray(<span class="number">2</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">        sum = dp[<span class="number">0</span>] + dp[<span class="number">1</span>]</span><br><span class="line">        println(<span class="string">&quot;sum <span class="variable">$sum</span>  dp[0]= <span class="subst">$&#123;dp[<span class="number">0</span>]&#125;</span> , dp[1]= <span class="subst">$&#123;dp[<span class="number">1</span>]&#125;</span>&quot;</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>]</span><br><span class="line">        dp[<span class="number">1</span>] = sum</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="labuladong"><a href="#labuladong" class="headerlink" title="labuladong"></a>labuladong</h5><p>把所有计算的值先保存起来，后面需要的话先直接返回，避免重复计算.</p>
<p>为什么申请 n+1 数组大小</p>
<p>因为索引从0开始 ，后面要取memory[n]，所有就申请 n+1 大小.</p>
<p>自顶向下</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fib</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> memory = IntArray(n + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> (memory[n] != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> memory[n]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    memory[n] = fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> memory[n]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fib</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>还有一种lablado解法一开始没想出来,双指针应该怎么操作</p>
<p>这个思路和随想录的思路2是一样的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fib</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> pre1 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> pre2 = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">        sum = pre1 + pre2  <span class="comment">// 得到当前n的num</span></span><br><span class="line">        pre1 = pre2     <span class="comment">//移动指针</span></span><br><span class="line">        pre2 = sum</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70 爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">70 爬楼梯</a></h4><p>根据阶梯</p>
<p>0阶                                 1 //  需要返回1，2 = 1 +1,否则2就不正确了,正常理解应该返回0,不过递归解法，需要返回1</p>
<p>1阶                                  1      </p>
<p>2阶    1+1 , 2                   2</p>
<p>3阶  1+1+1, 1+2, 2+1    3</p>
<p>四阶                                 5</p>
<p>根据上面的推导，这个问题也类似于 斐波那契数    ， 看了随想录的视频，这个推导过程还是没看明白</p>
<p>看了这个视频推导明白了</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1G54y1X72H/">https://www.bilibili.com/video/BV1G54y1X72H/</a>        进度条5分钟.</p>
<p>到达 k 只有 两种方式 , k-2过去和k-1过去，所以到k的所有情况就是  (k-2)  + (k-1) ,我们这里讨论的是多少种不同的方法，而不用管k-2,k-1多少步到达k.</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">k</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">k-1</td>
<td align="center"></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center">k-2</td>
<td align="center"></td>
<td align="center"></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h5 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h5><p>超时</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归解法 ， 会超时</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">climbStairs</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span> <span class="comment">// 需要返回1，2 = 1 +1,否则2就不正确了</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">val</span> dp = IntArray(n + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> climbStairs(n - <span class="number">1</span>) + climbStairs(n - <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="迭代解法"><a href="#迭代解法" class="headerlink" title="迭代解法"></a>迭代解法</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">climbStairs1</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">val</span> dp = IntArray(n + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746 使用最小花费爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-cost-climbing-stairs/">746 使用最小花费爬楼梯</a></h4><p>如果要走到dp[i] 的位置， 有两种选择，dp[i-1] + cost[i-1]    ，dp[i-2] + cost[i-2]， cost就是从当前位置跳出消耗的能量值，dp[i-1] 已经包含dp[0]开始的所有 消费值。     </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] &#x3D; min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2]) </span><br></pre></td></tr></table></figure>





<p>可以用这个推导</p>
<p><img src="/2023/04/02/LC-DP/023-07-09-20-24-53.png" alt="023-07-09-20-24-53"></p>
<p>官方题解</p>
<p>这种方式比较好理解</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">minCostClimbingStairs</span><span class="params">(cost: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> dp = IntArray(cost.size + <span class="number">1</span>) <span class="comment">//要走完数组最后一步的下一步</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.cost.size) &#123;</span><br><span class="line">        dp[i] = min(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[cost.size]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他的后面在看吧</p>
<h4 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></h4><p>这题二叉树解法没看懂，给忘了。</p>
<p>递归公式的推导，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">那么很自然，dp[i][j] &#x3D; dp[i - 1][j] + dp[i][j - 1]，因为dp[i][j]只有这两个方向过来。</span><br></pre></td></tr></table></figure>

<ol>
<li>dp数组的初始化</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如何初始化呢，首先dp[i][0]一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，因为只能向右向下走，那么dp[0][j]也同理。</span><br></pre></td></tr></table></figure>

<p>所以初始化代码为：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; m; i++) dp[i][0] = 1;</span><br><span class="line">for (int j = 0; j &lt; n; j++) dp[0][j] = 1;</span><br></pre></td></tr></table></figure>



<p> <img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201209113631392.png" alt="62.不同路径1"></p>
<p>可以根据上图来推导出  <code> dp[i][j]</code></p>
<p>i =1 时  , j 代入进去进行推导。</p>
<p>j = 1 : <code>  dp[i][j] = dp[i-1][j] + dp[i][j-1]</code></p>
<p>j = 2 : <code>  dp[i][j] = dp[i-1][j] + dp[i][j-1]</code></p>
<p>j = 3 : <code>  dp[i][j] = dp[i-1][j] + dp[i][j-1]</code></p>
<p>然后逐步就能推导出所有的值,注意<code>dp[m][n]</code> 要-1,否则会越界。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">uniquePaths</span><span class="params">(m: <span class="type">Int</span>, n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> dp = Array(m) &#123; IntArray(n) &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until m) dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) dp[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths-ii/">63. 不同路径 II</a></h4><p>原理还是一样，从左到右,<code>array[i][0] :  array[0][0],array[1][0],array[2][0] </code>，从上到下 进行推导。</p>
<p>这一题是上一题的拓展版本</p>
<p>通过62题可以看到 m 是竖线，n是横线。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210104114513928.png" alt="63.不同路径II"></p>
<ol>
<li><p><code>[0][0] [m-1][n-1] </code> 那么不可能有有路径往后走了。</p>
</li>
<li><p>有一点不同的是，如果是有障碍，后面就不用初始化了。</p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg" alt="img"></p>
</li>
<li><p>还有一点不同的是，如果要找的位置没有障碍物，才有求出递推值的意义。</p>
</li>
</ol>
<ol start="3">
<li> 递推公式和前面差不多 ，在处理递推公式的时候，看上图，前一步有障碍物的时候，影响的是 <code>dp[i-1]  dp[j-1]</code> 前一步的一个值。</li>
<li>后续递推的时候，碰到obstacles后，obstacles的点就是0，所以下一个点就是障碍物 0 和另一个点相加。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(obstacleGrid: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> m = obstacleGrid.size <span class="comment">// 表示有多少个数组</span></span><br><span class="line">    <span class="keyword">val</span> n = obstacleGrid[<span class="number">0</span>].size <span class="comment">// 其中一个数组的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> || obstacleGrid[m-<span class="number">1</span>][n-<span class="number">1</span>] == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span> <span class="comment">// if there are obstacle in these two points, will no path.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> dp = Array(m) &#123; IntArray(n) &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until m) &#123; <span class="comment">// 里面再加个条件不好加</span></span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>) <span class="keyword">break</span>      <span class="comment">// when init dats, hit path , following init will 0</span></span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// 前面[i][0] i表述多少个数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>) <span class="keyword">break</span></span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">1</span> <span class="comment">// [0][j] 后面表述一个数组的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][j] != <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343. 整数拆分"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/integer-break/">343. 整数拆分</a></h4><p>我们按照动规 5 部曲来分析先</p>
<ol>
<li><p>确定dp数组（dp table）以及下标的含义</p>
<p>拆分i，最大乘积是dp[i]  </p>
</li>
<li><p>确定递推公式</p>
<p>这一步是比较难的， 对 i 进行拆分，看了随想录的视频，有3种可能</p>
<p>第一种:  拆成2个数的情况  i * j  也就是  dp[i] = i * (i-j)</p>
<p>第二种：拆成2个数以上的情况 : dp[i] = i * dp[i-j]</p>
<p> 这种可以用6来测试拆分</p>
<p>1 * 5</p>
<p>2 * 4</p>
<p>3 * 3</p>
<p>4 * 2</p>
<p>5 * 1</p>
<p>上面我们可以只拆分j,  我们有必要拆分i吗，其实是没必要的， 我的理解是2 * 4 中， 2已经被 1 * 5 中的5包含了，</p>
<p>那么5 拆成<code> 2 *1 * 1 * 1</code> 就包括了 2的情况，不知道我的理解对不对。</p>
<p>第三种 : 就是 i本身。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">integerBreak</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>  <span class="comment">// 1+1</span></span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">3.</span>.n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until i) &#123;</span><br><span class="line"><span class="comment">//                println(&quot;i $i    j $j &quot;)</span></span><br><span class="line">                <span class="keyword">val</span> a = j * (i - j)</span><br><span class="line">                <span class="keyword">val</span> b = j * dp[i - j]</span><br><span class="line"><span class="comment">//                maxNum = max(a, b, i)</span></span><br><span class="line">                println(<span class="string">&quot;j * (i - j)  <span class="variable">$j</span> * (<span class="variable">$i</span> - <span class="variable">$j</span>)  a =<span class="variable">$a</span>  dp[i - j] <span class="subst">$&#123;dp[i - j]&#125;</span>  b= <span class="variable">$b</span> &quot;</span>)</span><br><span class="line"><span class="comment">//                maxNum = max(a, b,dp[i])</span></span><br><span class="line"><span class="comment">//                maxNum= max(a,b)</span></span><br><span class="line"><span class="comment">//                val abMax = max(a, b)</span></span><br><span class="line"><span class="comment">//                println(&quot;abMax $abMax dp[$i] $&#123;dp[i]&#125; &quot;)</span></span><br><span class="line">                dp[i] = max(a, b, dp[i]) <span class="comment">// dp[i] 初始值是0，所以得出的值还是从a,b中拿到最大值</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            println(&quot;dp[$i]     $&#123;dp[i]&#125;&quot;)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">max</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>, c: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> max = a</span><br><span class="line">    <span class="keyword">if</span> (b &gt; max) &#123;</span><br><span class="line">        max = b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c &gt; max) &#123;</span><br><span class="line">        max = c</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h4><p>​      </p>
<p>   上面是i==3的情况，</p>
<p>   <img src="https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg"></p>
<p>   root node =1的时候， left tree 0 , right tree 2种情况 , 右子树和 root node =2的树的结构是一样的。</p>
<p>   root node =2的时候， left tree 1 , right tree 1种情况,  左，右子树和 root node =1的树的结构是一样的。</p>
<p>   root node =3的时候， left tree 2 , right tree 0种情况. 左子树和 root node =2的树的结构是一样的。</p>
<p>   所以 dp[3] =  (root node ==1 +dp[2]) +  (root node ==2 +dp[1]) +   (root node ==3 +dp[2]) </p>
<p>   dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量</p>
<p>   元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量</p>
<p>   元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量</p>
<p>   元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量</p>
<p>   有2个元素的搜索树数量就是dp[2]。</p>
<p>   有1个元素的搜索树数量就是dp[1]。</p>
<p>   有0个元素的搜索树数量就是dp[0]。</p>
<p>   所以dp[3] = dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]</p>
<p>   <img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210107093226241.png" alt="96.不同的二叉搜索树2"></p>
<p>   这个图更直观</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义目前可以根据下面推导来，确认dp数组的含义。dp[1] =1dp[2]= 2dp[3] =5</li>
<li>确定递推公式这个没推导出来，i j没搞清楚。把随想录的拿过来<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在上面的分析中，其实已经看出其递推关系， dp[i] +&#x3D; dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]</span><br><span class="line"></span><br><span class="line">j相当于是头结点的元素，从1遍历到i为止。</span><br><span class="line"></span><br><span class="line">所以递推公式：dp[i] +&#x3D; dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量</span><br></pre></td></tr></table></figure></li>
<li>dp数组如何初始化</li>
<li>确定遍历顺序</li>
<li>举例推导dp数组</li>
</ol>
   <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">numTrees</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 确定dp数组（dp table）以及下标的含义</span></span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="comment">//3. dp数组如何初始化</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.确定遍历顺序</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2</span> ..n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> ..i) &#123; <span class="comment">// 注意这里边界，一开始都 没加==</span></span><br><span class="line"><span class="comment">//                println(&quot; dp[$i] $&#123;dp[i]&#125; += (dp[j - 1] $&#123;dp[j - 1]&#125;  * dp[i - j]) $&#123;dp[i - j]&#125;  j = $j&quot;)</span></span><br><span class="line">                dp[i] += (dp[j - <span class="number">1</span>] * dp[i - j]) <span class="comment">//2.确定递推公式</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>











</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-01-02T14:42:03.000Z" title="1/2/2023, 10:42:03 PM">2023-01-02</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-04-02T11:24:38.736Z" title="4/2/2023, 7:24:38 PM">2023-04-02</time></span><span class="level-item"><a class="link-muted" href="/categories/DataStructure/">DataStructure</a></span><span class="level-item">31 minutes read (About 4718 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/01/02/LC-GREEDY/">LC-GREEDY</a></p><div class="content"><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1sA4y1S7Sp">https://www.bilibili.com/video/BV1sA4y1S7Sp</a></p>
<p>这个视频讲到暴力 对数器可以验证答案，有意思。</p>
<p>有同学问了如何验证可不可以用贪心算法呢？</p>
<p><strong>刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心</strong>。</p>
<p>贪心算法一般分为如下四步：</p>
<ul>
<li>将问题分解为若干个子问题</li>
<li>找出适合的贪心策略</li>
<li>求解每一个子问题的最优解</li>
<li>将局部最优解堆叠成全局最优解</li>
</ul>
<p>这个四步其实过于理论化了，我们平时在做贪心类的题目 很难去按照这四步去思考，真是有点“鸡肋”。</p>
<p>做题的时候，只要想清楚 局部最优 是什么，如果推导出全局最优，其实就够了。</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1XY411A766">https://www.bilibili.com/video/BV1XY411A766</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Hz4y117CP/">https://www.bilibili.com/video/BV1Hz4y117CP/</a></p>
<h4 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455.分发饼干"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/assign-cookies/">455.分发饼干</a></h4><h5 id="分解题目"><a href="#分解题目" class="headerlink" title="分解题目"></a>分解题目</h5><ol>
<li>每个孩子最多只能给一块饼干。</li>
<li>每个孩子 <code>i</code>，都有一个胃口值 <code>g[i]</code>，每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code>。</li>
</ol>
<h5 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g &#x3D; [1,3], s &#x3D; [1,2,4]</span><br></pre></td></tr></table></figure>

<ol>
<li><p>对孩子的胃口值和， 饼干的大小进行排序，得到两行数组。</p>
</li>
<li><p>如上面示例，s中的s[0]=1饼干大小，满足g[0]=1 孩子的胃口值,那么同时向右移动.s[1]=2 不满足g[1],s指针向右移动，s[2]满足g[1].</p>
<p>这样所有孩子都满足了。</p>
</li>
</ol>
<p>上面思路和随想录的不一样，随想录的是大饼干喂 胃口值大的孩子，不过觉得我这个更好理解。</p>
<h5 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findContentChildren</span><span class="params">(g: <span class="type">IntArray</span>, s: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.isEmpty()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    Arrays.sort(g)  <span class="comment">// 写了s.isEmpty()， 一开始忘了加这个排序</span></span><br><span class="line">    Arrays.sort(s)</span><br><span class="line">    <span class="keyword">var</span> pg = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> ps = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (pg &lt; g.size &amp;&amp; ps &lt; s.size) &#123; <span class="comment">// 控制边界</span></span><br><span class="line">        <span class="keyword">if</span> (s[ps] &gt;= g[pg]) &#123;       <span class="comment">//饼干满足孩子的胃口大小.</span></span><br><span class="line">            count++</span><br><span class="line">            pg++</span><br><span class="line">            ps++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ps++    <span class="comment">//饼干不满足孩子的胃口大小，饼干数组指针往右走.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="376摆动序列"><a href="#376摆动序列" class="headerlink" title="376摆动序列"></a>376摆动序列</h4><h5 id="Idea-1"><a href="#Idea-1" class="headerlink" title="Idea"></a>Idea</h5><p>摆动序列，其实求波峰 波谷的个数，所以有一个方向改变就算一个波动。</p>
<ol>
<li><p>根据图1可以看到</p>
<p>preDiff = 17-1 &gt;0 , curveDiff = 5 -10&lt;0 ，这个就是一个摆动序列。还有</p>
<p>preDiff = 5-10 &lt;0 , curveDiff = 16 -5&gt;0 的情况，这又是另一种情况的摆动序列。</p>
</li>
<li><p>根据图2可以看到</p>
<p>preDiff ==0  , curveDiff = 5 -2 &gt; 0,  </p>
<p>preDiff ==0  , curveDiff = 5 -8 &gt; 0,  题目说 两个不等元素的序列也视作摆动序列。所以这种情况也是摆动序列。 但是我感觉这个和前面的 “如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 <strong>摆动序列</strong>”,是有矛盾的。</p>
<p>根据 1.2,所以条件可以合并, preDiff  &gt;=0 , curveDiff &lt;=0 ,preDiff &lt;=0 , curveDiff &gt;=0</p>
</li>
<li><p>图3，只有2个摆动，但是根据根据1，2的总结代码在2,3节点处，红色pre的地方也有1个摆动，这种情况要去掉，因为他是同方向的摆动。所以pre应该停在绿色的地方，只有摆动发生她才需要改变，平波不用管。</p>
</li>
</ol>
<p><img src="/2023/01/02/LC-GREEDY/2023-01-18-9.11.23.png" alt="2023-01-18-9.11.23"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">wiggleMaxLength</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.size &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums.size</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> preDiff = <span class="number">0</span> <span class="comment">//前一对差值</span></span><br><span class="line">    <span class="keyword">var</span> curveDiff = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until nums.size) &#123; <span class="comment">// 第一个数已经计入摆动序列了，所以从1开始</span></span><br><span class="line">        curveDiff = nums[i] - nums[i - <span class="number">1</span>] <span class="comment">// 因为要给值给preDiff，所以从i开始，随想录c++解法是从0开始的。</span></span><br><span class="line">        <span class="keyword">if</span> ((preDiff &gt;= <span class="number">0</span> &amp;&amp; curveDiff &lt; <span class="number">0</span>) || (preDiff &lt;= <span class="number">0</span> &amp;&amp; curveDiff &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">            result++</span><br><span class="line">            preDiff = curveDiff</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53 最大子序和"></a>53 最大子序和</h4><p>  -2,    1,    -3,    4,    -1,    2,    1,    -5,    4</p>
<p>*Q *P </p>
<h5 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h5><ol>
<li>题意是找到最大和的连续子数组， 所以是不能对数组排序。</li>
<li>这题可以考虑用双指针解法，移动*p，从0开始 加上指针对应的计数。如果计数增加则是正数计入，如果减小则重置，移动 *q指针。</li>
</ol>
<p>上面这个思路是不行的，4,    -1,    2,    1这种就有问题。</p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.gif" alt="53.最大子序和"></p>
<p>间隔后新的黄色部分是重置数据。</p>
<p>根据随想录的思路</p>
<p>局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。</p>
<p>这句话看起来有问题，但是也拿不出反例.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">maxSubArray</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> maxResult = <span class="built_in">Int</span>.MIN_VALUE</span><br><span class="line">    <span class="keyword">for</span> (pIndex <span class="keyword">in</span> nums.indices) &#123;</span><br><span class="line">        result += nums[pIndex]</span><br><span class="line">        maxResult = maxResult.coerceAtLeast(result)</span><br><span class="line">        <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            result = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxResult</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122 买卖股票的最佳时机 II"></a>122 买卖股票的最佳时机 II</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7,	1,	5,	3,	6,	4</span><br><span class="line">	-6	4		-2	3		-2</span><br></pre></td></tr></table></figure>



<p>假如第0天买入，第3天卖出，那么利润为：prices[3] - prices[0]。</p>
<p>相当于(prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])。</p>
<p><strong>此时就是把利润分解为每天为单位的维度，而不是从0天到第3天整体去考虑！</strong></p>
<p>那么根据prices可以得到每天的利润序列：(prices[i] - prices[i - 1])…..(prices[1] - prices[0])。</p>
<p><img src="https://img-blog.csdnimg.cn/2020112917480858.png" alt="122.买卖股票的最佳时机II"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">maxProfit</span><span class="params">(prices: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> diffArray = IntArray(prices.size - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until prices.size) &#123;</span><br><span class="line">        println(i)</span><br><span class="line">        diffArray[i - <span class="number">1</span>] = prices[i] - prices[i - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> diffArray.indices) &#123;</span><br><span class="line">        <span class="keyword">if</span> (diffArray[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += diffArray[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55 跳跃游戏"></a>55 跳跃游戏</h4><p>[2,3,1,1,4]</p>
<h5 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h5><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度，比如在2的位置，可以跳一格到3的位置，也可以两格到1的位置。</p>
<p><img src="https://img-blog.csdnimg.cn/20201124154758229.png" alt="55.跳跃游戏"></p>
<p>上面第二幅图，第一条线应该有问题，应该覆盖到2 3 1</p>
<p>遍历每个位置，确定每个位置能覆盖的最大范围。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">canJump</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> coverArea = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span>.coverArea) &#123; <span class="comment">// 注意:这里是coverArea,需要确定能走多少步</span></span><br><span class="line">        coverArea = (i + nums[i]).coerceAtLeast(coverArea) <span class="comment">//新的范围和 之前的范围做比较</span></span><br><span class="line">        <span class="keyword">if</span> (coverArea &gt;= nums.size - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45 跳跃游戏 II"></a>45 跳跃游戏 II</h4><h5 id="Idea-2"><a href="#Idea-2" class="headerlink" title="Idea"></a>Idea</h5><p>题目意思 总是可以到达数组的最后一个位置</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">jump</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> maxCover = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span>.maxCover) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i + nums[i] &gt; maxCover) &#123;</span><br><span class="line">            maxCover = i + nums[i]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count++</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (maxCover &gt;= nums.size) &#123;</span><br><span class="line">            println(<span class="string">&quot;count <span class="variable">$count</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> count</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>找到能覆盖的最远距离，如果移动到了这个地方，那么就计算一次，直到  nums.size - 1- 1个节点，然后再count++就可以了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">jump</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nextCover = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> currentCover = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until nums.size - <span class="number">1</span>) &#123;</span><br><span class="line">        nextCover = Math.max(i + nums[i], nextCover)</span><br><span class="line">        <span class="keyword">if</span> (i == currentCover) &#123;</span><br><span class="line">            currentCover = nextCover</span><br><span class="line">            count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1005-K-次取反后最大化的数组和"><a href="#1005-K-次取反后最大化的数组和" class="headerlink" title="1005. K 次取反后最大化的数组和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/">1005. K 次取反后最大化的数组和</a></h4><ol>
<li>先对数组进行排序，把 &lt; 0的数按位取反 ,直到数组的数据都&gt;0,此时翻转了n次</li>
<li>对翻转后的数组重新进行排序，对最小的数 翻转 k-n 次</li>
</ol>
<p>My Idea</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largestSumAfterKNegations</span><span class="params">(nums: <span class="type">IntArray</span>, k: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    Arrays.sort(nums)</span><br><span class="line">    <span class="keyword">var</span> balanceK = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until k) &#123; <span class="comment">// kotlin用while 应该更好</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= nums.size || nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            balanceK = k - i</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        nums[i] = Math.abs(nums[i])</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(nums)</span><br><span class="line">    <span class="keyword">if</span> (balanceK &gt; <span class="number">0</span> &amp;&amp; (balanceK % <span class="number">2</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        nums[<span class="number">0</span>] = -nums[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (value <span class="keyword">in</span> nums) &#123;</span><br><span class="line">        sum += value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个也可以</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1iY411s7qB">https://www.bilibili.com/video/BV1iY411s7qB</a></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largestSumAfterKNegations</span><span class="params">(nums: <span class="type">IntArray</span>, k: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> typedArray = nums.toTypedArray() <span class="comment">// 转成数组</span></span><br><span class="line">    Arrays.sort(typedArray, Comparator.comparingInt(Math::abs)) <span class="comment">// 按照绝对值排序</span></span><br><span class="line">    <span class="keyword">var</span> k = k</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> typedArray.indices) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; typedArray[i] &lt; <span class="number">0</span>) &#123;  <span class="comment">// 碰到数组中&gt;0的数</span></span><br><span class="line">            typedArray[i] *= -<span class="number">1</span></span><br><span class="line">            k--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(typedArray)</span><br><span class="line">    <span class="keyword">if</span> (k % <span class="number">2</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        typedArray[<span class="number">0</span>] *= -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (value <span class="keyword">in</span> nums) &#123;</span><br><span class="line">        sum += value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 参考随想录，但是编译不通过</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV138411G7LY">https://www.bilibili.com/video/BV138411G7LY</a></p>
<h4 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134 加油站"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/gas-station/">134 加油站</a></h4><h5 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">canCompleteCircuit</span><span class="params">(gas: <span class="type">IntArray</span>, cost: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> gas.indices) &#123;</span><br><span class="line">        <span class="keyword">var</span> balance = gas[i] - cost[i]</span><br><span class="line">        <span class="keyword">var</span> index = (i + <span class="number">1</span>) % gas.size</span><br><span class="line">        <span class="keyword">while</span> (balance &gt; <span class="number">0</span> &amp;&amp; i != index) &#123;  <span class="comment">// 还有油的话，没走完一圈，继续走</span></span><br><span class="line">            balance += (gas[index] - cost[index])</span><br><span class="line">            index = (index + <span class="number">1</span>) % gas.size</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (balance &gt;= <span class="number">0</span> &amp;&amp; (index == i)) &#123;<span class="comment">//走完一圈，返回下标</span></span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="贪心解法"><a href="#贪心解法" class="headerlink" title="贪心解法"></a>贪心解法</h5><p>这里k不用看</p>
<p><img src="/2023/01/02/LC-GREEDY/20230211173204.jpg" alt="20230211173204"></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1DF411L7cz">https://www.bilibili.com/video/BV1DF411L7cz</a></p>
<p>j 到 j+1跑不到 , 从i 到 j +1 油量&lt;0</p>
<ol>
<li>因为 i 能开到j,从 i 出发到 i+1 油量 &gt;=0 ,  那么 i+1 到 j+1 油量一定 &lt;0.</li>
<li>如果起点在 i+1, 因为 i 到j+1&lt;0 ,因此 i 到  i+1&gt;=0 , i+1 到j+1一定&lt;0.</li>
</ol>
<p>总结来看,  i 到 j+1&lt;0 ,中间不用看，直接从 j+1开始即可。</p>
<p>LC134我的解法有问题，看到随想录的解法后感觉很妙</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">canCompleteCircuit</span><span class="params">(gas: <span class="type">IntArray</span>, cost: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> totalSum = <span class="number">0</span> <span class="comment">//  所有路程需要的油量</span></span><br><span class="line">    <span class="keyword">var</span> currentSum = <span class="number">0</span>  <span class="comment">// 当前位置开始所需要的油量</span></span><br><span class="line">    <span class="keyword">var</span> start = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> gas.indices) &#123;</span><br><span class="line">        totalSum += gas[i] - cost[i]</span><br><span class="line">        currentSum += gas[i] - cost[i]</span><br><span class="line">        <span class="keyword">if</span> (currentSum &lt; <span class="number">0</span>) &#123; <span class="comment">// 到i加油站需要油量 &lt;0, 如果接下来 gas[i+1] - cost[i+1]还是&lt;0,那么start ,currentSum 继续更新</span></span><br><span class="line">            start = i + <span class="number">1</span></span><br><span class="line">            currentSum = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (totalSum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li> 到i加油站需要油量 &lt;0, 如果接下来 gas[i+1] - cost[i+1]还是&lt;0,那么start ,currentSum 继续更新.</li>
<li> j ,j+1是负数节点,如果存在这样一个节点,满足条件，那么j+1开始后面一圈的一定都是&gt;0</li>
</ol>
<h4 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135 分发糖果"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/candy/">135 分发糖果</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1,2,2]</span><br><span class="line"> 1 2 1 &#x2F;&#x2F;为什么array[2] 糖果是1，因为题目意思只有评分高才有更多的糖果，相等的情况按照最少的1个糖果了。</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">5</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">左&lt;右</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">左&gt;右</td>
</tr>
</tbody></table>
<h5 id="Idea-3"><a href="#Idea-3" class="headerlink" title="Idea"></a>Idea</h5><p>需要一边一边考虑，否则顾此失彼</p>
<ol>
<li>先考虑  左边孩子粉丝的情况 &lt; 右边孩子分数  ，此时需要从左往右, 得到第三行的分数.</li>
<li>再考虑 左边孩子粉丝 &gt; 右边孩子分数的情况, 此时需要从右向左，因为这种情况需要依赖，右边的孩子。如果从左到右，得到第4行结果，此时  2 3 4 5都是错的。</li>
<li>然后从右往左的过程，还需要考虑之前 左边孩子&lt; 右边的情况，所以取最大值。</li>
</ol>
<h5 id="code"><a href="#code" class="headerlink" title="code"></a>code</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">candy</span><span class="params">(ratings: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> answer = IntArray(ratings.size)</span><br><span class="line">        answer[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        左边孩子粉丝的情况 &lt; 右边孩子分数  ，此时需要从左往右</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until ratings.size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                answer[i] = answer[i - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                answer[i] = <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        println()</span><br><span class="line">        answer.printIntArray()</span><br><span class="line">        <span class="comment">//左边孩子粉丝 &gt; 右边孩子分数的情况, 此时需要从右向左</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> ratings.size - <span class="number">1</span> downTo <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i - <span class="number">1</span>] &gt; ratings[i]) &#123;</span><br><span class="line">                answer[i - <span class="number">1</span>] = answer[i - <span class="number">1</span>].coerceAtLeast(answer[i] + <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        answer.printIntArray()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> answer) &#123;</span><br><span class="line">            sum += i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="860-柠檬水找零"><a href="#860-柠檬水找零" class="headerlink" title="860 柠檬水找零"></a>860 柠檬水找零</h4><h5 id="Idea-4"><a href="#Idea-4" class="headerlink" title="Idea"></a>Idea</h5><ol>
<li>一开始想到的是暴力解法， 用map 存 5 , 10两种金额的个数，20不用考虑</li>
<li>来了5存起来 map5 +1，来了10存起来 map10+1 , map5 -1 ,  来了20， map10-1, map5-1</li>
</ol>
<h5 id="code-暴力解法"><a href="#code-暴力解法" class="headerlink" title="code  暴力解法"></a>code  暴力解法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">fun lemonadeChange(bills: IntArray): Boolean &#123;</span><br><span class="line">    val map &#x3D; HashMap&lt;Int, Int&gt;()</span><br><span class="line">    for ((index, money) in bills.withIndex()) &#123;</span><br><span class="line">        if (money &#x3D;&#x3D; 5) &#123;</span><br><span class="line">            map[5] &#x3D; map.getOrDefault(5, 0).plus(1)</span><br><span class="line">        &#125; else if (money &#x3D;&#x3D; 10) &#123;</span><br><span class="line">            map[5] &#x3D; map.getOrDefault(5, 0) - 1</span><br><span class="line">            map[10] &#x3D; map.getOrDefault(10, 0).plus(1)</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F;for 20 rmb</span><br><span class="line">            if (map.getOrDefault(10, 0) &gt; 0 &amp;&amp; map.getOrDefault(5, 0) &gt; 0) &#123; &#x2F;&#x2F;at lease 10rmb 1  , 5rmb 1</span><br><span class="line">                map[10] &#x3D; map.getOrDefault(10, 0) - 1</span><br><span class="line">                map[5] &#x3D; map.getOrDefault(5, 0) - 1</span><br><span class="line">            &#125; else if (map.getOrDefault(5, 0) &gt; 2) &#123; &#x2F;&#x2F; at least 3 * 5 rmb</span><br><span class="line">                map[5] &#x3D; map.getOrDefault(5, 0) - 3</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        println(&quot; index $index    map5 $&#123;map[5]&#125; map10 $&#123;map[10]&#125; &quot;)</span><br><span class="line">        if (map.getOrDefault(5, 0) &lt; 0 || map.getOrDefault(10, 0) &lt; 0) &#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>看了随想录的解法，和我的解法类似，知识map中的值可以用变量来做.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> five = <span class="number">0</span>, ten = <span class="number">0</span>, twenty = <span class="number">0</span>;</span><br><span class="line">这样++,--更方便.</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0860.%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6.html#%E6%80%9D%E8%B7%AF">https://programmercarl.com/0860.%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6.html#%E6%80%9D%E8%B7%AF</a></p>
<h4 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406 根据身高重建队列"></a>406 根据身高重建队列</h4><h5 id="Idea-随想录"><a href="#Idea-随想录" class="headerlink" title="Idea 随想录"></a>Idea 随想录</h5><p>对于本题相信大家困惑的点是先确定k还是先确定h呢，也就是究竟先按h排序呢，还是先按照k排序呢？</p>
<p>如果按照k来从小到大排序，排完之后，会发现k的排列并不符合条件，身高也不符合条件，两个维度哪一个都没确定下来。</p>
<p>那么按照身高h来排序呢，身高一定是从大到小排（身高相同的话则k小的站前面），让高个子在前面。</p>
<p><strong>此时我们可以确定一个维度了，就是身高，前面的节点一定都比本节点高！</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fun reconstructQueue(people: Array&lt;IntArray&gt;): Array&lt;IntArray&gt; &#123;</span><br><span class="line">    Arrays.sort(people, object : Comparator&lt;IntArray&gt; &#123; </span><br><span class="line">        override fun compare(o1: IntArray, o2: IntArray): Int &#123;</span><br><span class="line">            if (o2[0] &#x3D;&#x3D; o1[0]) &#123;       &#x2F;&#x2F; 如果身高相同，k小的排在前面</span><br><span class="line">                return o1[1] - o2[1]</span><br><span class="line">            &#125;</span><br><span class="line">            return o2[0] - o1[0]        &#x2F;&#x2F; 对数组先按照身高来排序</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    val linkedList &#x3D; LinkedList&lt;IntArray&gt;()</span><br><span class="line"></span><br><span class="line">    for (value in people)&#123;</span><br><span class="line">        val index &#x3D; value[1]</span><br><span class="line">        linkedList.add(index,value) &#x2F;&#x2F; 按照k插入对应的位置, 这里插入时很容易越界。</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return linkedList.toTypedArray()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452. 用最少数量的箭引爆气球"></a>452. 用最少数量的箭引爆气球</h4><p>IDEA</p>
<ol>
<li>先对数组按照左边界大小进行排序。</li>
<li>如果当前i数组右边的值 &gt;  或者前面数组重叠区域的最小右边界， 此时没有重叠（和之前的共有区域），数量+1</li>
<li>否则有重叠，取最小右边界值。</li>
</ol>
<p>一开始看题解，没理解特别是 points[i][1]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">points[i][<span class="number">1</span>] = <span class="built_in">min</span>(points[i - <span class="number">1</span>][<span class="number">1</span>], points[i][<span class="number">1</span>]); <span class="comment">// 更新重叠气球最小右边界</span></span><br></pre></td></tr></table></figure>



<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findMinArrowShots1</span><span class="params">(points: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line"><span class="comment">//        Arrays.sort(points)&#123;o1,o2 -&gt; o1[0] - o2[0]&#125; 这个回报越界错 [[-2147483646,-2147483645],[2147483646,2147483647]]</span></span><br><span class="line">        points.sortBy&#123;it[<span class="number">0</span>]&#125;</span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until points.size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (points[i][<span class="number">0</span>] &gt; points[i - <span class="number">1</span>][<span class="number">1</span>]) &#123; <span class="comment">// 如果当前气球的左边界 &gt; 公共右边界</span></span><br><span class="line">                count++</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有大于公共右边界</span></span><br><span class="line">                <span class="comment">//points[i][1] = points[i][1].minus(points[i - 1][1]) // 用minus是有问题的</span></span><br><span class="line">                points[i][<span class="number">1</span>] = points[i][<span class="number">1</span>].coerceAtMost(points[i - <span class="number">1</span>][<span class="number">1</span>]) <span class="comment">// 更新重叠气球最小右边界</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        points.printDimensionalArray()</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>1       6</p>
<p>​    2            8</p>
<p>​             7                12</p>
<p>​                        10         16</p>
<h5 id="使用chatGPT的算法，更好"><a href="#使用chatGPT的算法，更好" class="headerlink" title="使用chatGPT的算法，更好"></a>使用chatGPT的算法，更好</h5><p>确定右边界, 如果新的左边界&gt;之前的右边界+1 , 使用新的数据，并且确定右边界。</p>
<p>The solution sorts the balloons by their end positions in ascending order, and then uses a greedy algorithm to shoot the balloons. We start with the first balloon and set <code>end</code> to its end position. Then, we iterate through the rest of the balloons and compare their start positions to <code>end</code>. If the start position of a balloon is greater than <code>end</code>, we shoot another arrow and update <code>end</code> to the end position of the current balloon.</p>
<p>At the end, the function returns the number of arrows shot.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findMinArrowShots</span><span class="params">(points: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (points.isEmpty()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    points.sortBy &#123; it[<span class="number">1</span>] &#125;</span><br><span class="line">    <span class="keyword">var</span> arrows = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> end = points[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until points.size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (points[i][<span class="number">0</span>]&gt;end) &#123;</span><br><span class="line">            arrows++</span><br><span class="line">            end = points[i][<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arrows</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/non-overlapping-intervals/">435. 无重叠区间</a></h4><p>[1,2] [3,6] [7,12] [4,8] [10,16]</p>
<p>1     2</p>
<p>​            3       6</p>
<p>​                 4                  8</p>
<p>​                          7                      12</p>
<p>​                                            10                16</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1A14y1c7E1">https://www.bilibili.com/video/BV1A14y1c7E1</a></p>
<h5 id="左边数组进行排序。"><a href="#左边数组进行排序。" class="headerlink" title="左边数组进行排序。"></a>左边数组进行排序。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. if [i][0] &lt; [i-1][1] 说明会有重合，那么求出 [i][1] [i-1][1]中的最小值，作为右边界，更新数量</span><br><span class="line">否则就没重合更新右边界限。</span><br><span class="line">2. 否则，没有重合直接更新  end。</span><br></pre></td></tr></table></figure>



<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">eraseOverlapIntervals</span><span class="params">(intervals: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.isEmpty()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">        Arrays.sort(intervals) &#123; a, b -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>] &#125; <span class="comment">// 按照左边数组进行排序</span></span><br><span class="line">        <span class="keyword">var</span> end = intervals[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until intervals.size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt; end) &#123;    <span class="comment">//重合的情况</span></span><br><span class="line">                count++</span><br><span class="line">                end = end.coerceAtMost(intervals[i][<span class="number">1</span>]) <span class="comment">// 确定最小重合的 右边界, 这里一开始弄错了</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                end = intervals[i][<span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        intervals.printDimensionalArray()</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h5 id="右边数组排序"><a href="#右边数组排序" class="headerlink" title="右边数组排序"></a>右边数组排序</h5><p><strong>这种解法不理解.</strong></p>
<p>根据随想录的思路，总的个数 - 非交叉个数 = 交叉个数。</p>
<p>这里的难点是要知道交叉后的右边界的</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230201164134.png" alt="img"></p>
<p>如果3在 1,2 右边最小值的左边，所以3条线还会有交叉，如果在1，2最小值的右边那么 2去掉就可以了，还是去掉1。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">eraseOverlapIntervals</span><span class="params">(intervals: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.isEmpty()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">1</span> <span class="comment">//非交叉区间个数</span></span><br><span class="line">        Arrays.sort(intervals) &#123; a, b -&gt; a[<span class="number">1</span>] - b[<span class="number">1</span>] &#125; <span class="comment">// 按照左边数组进行排序</span></span><br><span class="line">        <span class="keyword">var</span> end = intervals[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until intervals.size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &gt;= end) &#123;</span><br><span class="line">                count ++</span><br><span class="line">                end = intervals[i][<span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            else&#123;</span></span><br><span class="line"><span class="comment">//                end = intervals[i][1].coerceAtMost(end) // 这个不需要</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        intervals.printDimensionalArray()</span></span><br><span class="line">        <span class="keyword">return</span> intervals.size - count</span><br><span class="line">    &#125;	</span><br></pre></td></tr></table></figure>



<p>12</p>
<h4 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763 划分字母区间"></a>763 划分字母区间</h4><h5 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h5><ol>
<li><p>遍历出每个字母的最远距离，出现的座标。</p>
<p>根据字母的hash值得到当前的座标，后面如果有重复的hash,会覆盖前面的。</p>
</li>
<li><p>遍历后序列找 当前字母hash值 == i , right = i 拿到当前 right + 1 - left, 就是片段的长度。</p>
<p>然后更新left值.</p>
</li>
</ol>
<p>​        </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">partitionLabels</span><span class="params">(s: <span class="type">String</span>)</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> result = arrayListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">val</span> hash = IntArray(<span class="number">26</span>)</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> s.indices) &#123;</span><br><span class="line">            hash[s[i] - <span class="string">&#x27;a&#x27;</span>] = i</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> right = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> s.indices) &#123;</span><br><span class="line">            right = hash[s[i] - <span class="string">&#x27;a&#x27;</span>].coerceAtLeast(right) <span class="comment">// 要找到当前hash值的最大值</span></span><br><span class="line">            <span class="keyword">if</span> (right == i) &#123;   <span class="comment">//如果 hash值的最大值 和座标相等，就用到了分割点</span></span><br><span class="line">                result.add(right + <span class="number">1</span> - left)</span><br><span class="line">                left = i + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        hash.printIntArray()</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56 合并区间"></a>56 合并区间</h4><h5 id="Idea-My"><a href="#Idea-My" class="headerlink" title="Idea My"></a>Idea My</h5><p>初始化 left. right</p>
<ol>
<li>按照左边数组 排序。</li>
<li>如果没重合直接[left,right]把前面数组加入区间 。</li>
<li>如果重合，那么确定 right右边界，判断<code> [i][0]</code>和right,确定右边界，把right放入右边界。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">merge</span><span class="params">(intervals: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: Array&lt;IntArray&gt; &#123;</span><br><span class="line">    Arrays.sort(intervals) &#123; a, b -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>] &#125;</span><br><span class="line">    <span class="keyword">var</span> left = intervals[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> right = intervals[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">val</span> arrayOf = arrayListOf&lt;IntArray&gt;()</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until intervals.size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt;= right) &#123;</span><br><span class="line">            right = right.coerceAtLeast(intervals[i][<span class="number">1</span>])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arrayOf.add(intArrayOf(left, right))</span><br><span class="line">            left = intervals[i][<span class="number">0</span>]</span><br><span class="line">            right = intervals[i][<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arrayOf.add(intArrayOf(left, right))</span><br><span class="line">    <span class="keyword">return</span> arrayOf.toTypedArray()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="Idea-2"><a href="#Idea-2" class="headerlink" title="Idea 2"></a>Idea 2</h5><p>看了随想录的题解，觉得比我上面的更好，只需要更新右边界。</p>
<p>1     3</p>
<p>​    2         6       8     10         15        18</p>
<p>​                    </p>
<ol>
<li>还是按照数组左边界排好序。</li>
<li>把第一组数组放入结果数组中，然后取出来，用它的右边界和第二组数组的左边界比较大小.</li>
<li>如果新的数组的左边界 &lt; 结果数组的右边界，说明有重合，更新结果数组的右边界。</li>
<li>如果新的数组的左边界 &gt; 结果数组的右边界,没有重合，新数组直接添加到结果数组集中。</li>
</ol>
<h4 id="738-单调递增的数字"><a href="#738-单调递增的数字" class="headerlink" title="738 单调递增的数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/monotone-increasing-digits/">738 单调递增的数字</a></h4><h5 id="Idea-5"><a href="#Idea-5" class="headerlink" title="Idea"></a>Idea</h5><p>看了随想录的题解</p>
<p>那么拿一个两位的数字来举例。</p>
<p>例如：98，一旦出现strNum[i - 1] &gt; strNum[i]的情况（非单调递增），首先想让strNum[i - 1]–，然后strNum[i]给为9，这样这个整数就是89，即小于98的最大的单调递增整数。</p>
<p>此时是从前向后遍历还是从后向前遍历呢？</p>
<p>这么说有点抽象，举个例子，数字：332，从前向后遍历的话，那么就把变成了329，此时2又小于了第一位的3了，真正的结果应该是299。</p>
<p>那么从后向前遍历，就可以重复利用上次比较得出的结果了，从后向前遍历332的数值变化为：332 -&gt; 329 -&gt; 299</p>
<p>确定了遍历顺序之后，那么此时局部最优就可以推出全局，找不出反例，试试贪心。</p>
<h5 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h5><p>初始的想法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> arrStr = n.toString().toCharArray()</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> arrStr.size - <span class="number">1</span> downTo <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arrStr[i - <span class="number">1</span>] &gt; arrStr[i]) &#123;</span><br><span class="line">            arrStr[i] = <span class="string">&#x27;9&#x27;</span></span><br><span class="line">            arrStr[i - <span class="number">1</span>] = arrStr[i - <span class="number">1</span>].toInt().minus(<span class="number">1</span>).toChar() </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> String(arrStr).toInt()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>100 跑完后变成90,其实后面所有位都要变成 ‘9’,只有当前位减1</p>
<p>找到 minus 1 的位置，后面的位都变成9</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> arrStr = n.toString().toCharArray()</span><br><span class="line">    <span class="keyword">var</span> position = arrStr.size <span class="comment">//初始位置不能是  arrStr.size - 1 ，否则最后一位都会变成 &#x27;9&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> arrStr.size - <span class="number">1</span> downTo <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arrStr[i - <span class="number">1</span>] &gt; arrStr[i]) &#123;</span><br><span class="line">            arrStr[i - <span class="number">1</span>] = arrStr[i - <span class="number">1</span>].toInt().minus(<span class="number">1</span>).toChar() <span class="comment">// digitToInt leetcode跑不了</span></span><br><span class="line">            position = i <span class="comment">// 找到-1 的位置，后面的位都变成9</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> position until arrStr.size) &#123;</span><br><span class="line">        arrStr[i] = <span class="string">&#x27;9&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> String(arrStr).toInt()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="968-监控二叉树"><a href="#968-监控二叉树" class="headerlink" title="968 监控二叉树"></a>968 监控二叉树</h4><p>这题比较难，暂时没必要写。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-10-30T02:27:10.000Z" title="10/30/2022, 10:27:10 AM">2022-10-30</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-07-17T13:34:08.142Z" title="7/17/2023, 9:34:08 PM">2023-07-17</time></span><span class="level-item"><a class="link-muted" href="/categories/DataStructure/">DataStructure</a></span><span class="level-item">39 minutes read (About 5892 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/10/30/LC-backtrack-combination/">LC-backtrack-combination</a></p><div class="content"><p>组合</p>
<p>组合的元素是无序的[1,2]  , [2,1]是一个组合</p>
<p>组合的元素是不能重复的 </p>
<img src="https://img-blog.csdnimg.cn/20201123195242899.png" alt="77.组合1" style="zoom: 67%;">







<h4 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combinations/">77. 组合</a></h4><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ti4y1L7cv">https://www.bilibili.com/video/BV1ti4y1L7cv</a> </p>
<ol>
<li>拿到第一个元素.</li>
<li>用上面的图很形象,在剩余的元素中取数据，和 二叉树路径很像,递归加回溯的过程.</li>
</ol>
<p>这里一开始用的是 startIndex+1,不理解，这里回溯后,最第一次的for (i in startIndex..n)如果i ==2,或者3，或者4, 递归到底层，再回溯到第一次循环的时候，startIndex都是第一次的2,这样就导致剩余的元素不对</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">combine</span><span class="params">(n: <span class="type">Int</span>, k: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    backTracking(n, k, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTracking</span><span class="params">(n: <span class="type">Int</span>, k: <span class="type">Int</span>, startIndex: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.size == k) &#123;</span><br><span class="line">        result.add(path.toMutableList())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex..n) &#123;</span><br><span class="line">        path.add(i)</span><br><span class="line">        backTracking(n, k, i + <span class="number">1</span>) <span class="comment">// 这里一开始用的是 startIndex+1</span></span><br><span class="line">        path.remove(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="组合剪枝"><a href="#组合剪枝" class="headerlink" title="组合剪枝"></a>组合剪枝</h5><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1wi4y157er/">https://www.bilibili.com/video/BV1wi4y157er/</a></p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html#%E5%89%AA%E6%9E%9D%E4%BC%98%E5%8C%96">https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html#%E5%89%AA%E6%9E%9D%E4%BC%98%E5%8C%96</a></p>
<p>来举一个例子，n = 4，k = 4的话，那么第一层for循环的时候，从元素2开始的遍历都没有意义了。 在第二层for循环，从元素3开始的遍历都没有意义了。</p>
<p><img src="https://img-blog.csdnimg.cn/20210130194335207.png" alt="77.组合4"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> startIndex..n) &#123; <span class="comment">// 这里对应模拟就是,取1,取2 ,取3,取4 ,几个子孩子的操作.</span></span><br><span class="line">         path.add(i)</span><br><span class="line">         backTracking(n, k, i + <span class="number">1</span>) <span class="comment">// 这里一开始用的是 startIndex+1</span></span><br><span class="line">         path.remove(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>剪枝就是 i&lt; n这个范围里面做操作。</p>
<p>接下来看一下优化过程如下：</p>
<ol>
<li>已经选择的元素个数：path.size();</li>
<li>还需要的元素个数为: k - path.size();</li>
<li>在集合n中至多要从该起始位置 : n - (k - path.size()) + 1，开始遍历</li>
</ol>
<p>为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。</p>
<p>举个例子，n = 4，k = 3， 目前已经选取的元素为0（path.size为0），n - (k - 0) + 1 即 4 - ( 3 - 0) + 1 = 2。</p>
<p>从2开始搜索都是合理的，可以是组合[2, 3, 4]。</p>
<p>这里大家想不懂的话，建议也举一个例子，就知道是不是要+1了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> path = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="keyword">val</span> result = ArrayList&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">combine</span><span class="params">(n: <span class="type">Int</span>, k: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    backTracking1(n, k, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//剪枝操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTracking1</span><span class="params">(n: <span class="type">Int</span>, k: <span class="type">Int</span>, startIndex: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.size == k) &#123;</span><br><span class="line">        result.add(path.toMutableList())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex..(n - (k - path.size) + <span class="number">1</span>)) &#123;</span><br><span class="line">        path.add(i)</span><br><span class="line">        backTracking1(n, k, i + <span class="number">1</span>) <span class="comment">// 这里一开始用的是 startIndex+1</span></span><br><span class="line">        path.remove(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III</a></h4><ul>
<li>只使用数字1到9 .</li>
<li>每个数字 <strong>最多使用一次</strong> .</li>
</ul>
<ol>
<li><p>从1开始选取，每次循环往后选取，如果往前选数字入[1,2], [2,1]的情况，就重复了.</p>
</li>
<li><p>选取元素综合==n ,  并且是k个，装入数组。</p>
</li>
</ol>
<p>我的解法if (sum == n &amp;&amp; pathList.size == k)放一起不好 ，pathList.size到了k 个数，后面的就不用加了，达到竖向剪枝的目的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> result = ArrayList&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> sum: <span class="built_in">Int</span> = <span class="number">0</span> <span class="comment">//集合的和</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> pathList = ArrayList&lt;<span class="built_in">Int</span>&gt;() <span class="comment">// 集合</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">combinationSum3</span><span class="params">(k: <span class="type">Int</span>, n: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    blockTracking(k, n, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">blockTracking</span><span class="params">(k: <span class="type">Int</span>, n: <span class="type">Int</span>, startIndex: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sum == n &amp;&amp; pathList.size == k) &#123; <span class="comment">// 相加之和为 n 的 k 个数的组合</span></span><br><span class="line">        result.add(pathList.toMutableList())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex.<span class="number">.9</span>) &#123;</span><br><span class="line">        sum += i</span><br><span class="line">        pathList.add(i)</span><br><span class="line">        blockTracking(k, n, i + <span class="number">1</span>)</span><br><span class="line">        sum -= i</span><br><span class="line">        pathList.remove(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h5><p>还没想好</p>
<p><img src="https://img-blog.csdnimg.cn/2020112319580476.png" alt="216.组合总和III1"></p>
<ol>
<li><p>pathList.size到了k 个数，后面的就不用加了，达到竖向剪枝的目的。</p>
</li>
<li><p>(9 - (k - pathList.size) + 1) 分析 </p>
<p>k - pathList.size :  从1开始选取,还差多少个元素</p>
<p>9 - (k - pathList.size)  : 如果从1…9选取，为了避免重复，一直往大的数选取,第1次选到了8,如果k==2,那么过了8就没意义了，第一次的9就不需要选取了.</p>
<p>(9 - (k - pathList.size) + 1) 处理下标值。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> result = ArrayList&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> sum: <span class="built_in">Int</span> = <span class="number">0</span> <span class="comment">//集合的和</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> pathList = ArrayList&lt;<span class="built_in">Int</span>&gt;() <span class="comment">// 集合</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">combinationSum3</span><span class="params">(k: <span class="type">Int</span>, n: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    blockTracking(k, n, <span class="number">1</span>)</span><br><span class="line">    println(result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">blockTracking</span><span class="params">(k: <span class="type">Int</span>, n: <span class="type">Int</span>, startIndex: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pathList.size == k) &#123; <span class="comment">//shuxiang</span></span><br><span class="line">        <span class="keyword">if</span> (sum == n) &#123;</span><br><span class="line">            result.add(pathList.toMutableList())</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex..(<span class="number">9</span> - (k - pathList.size) + <span class="number">1</span>)) &#123; <span class="comment">// 横向剪枝</span></span><br><span class="line">        <span class="keyword">if</span> (sum &gt; n) &#123; <span class="comment">//剪枝</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        sum += i</span><br><span class="line">        pathList.add(i)</span><br><span class="line">        blockTracking(k, n, i + <span class="number">1</span>)</span><br><span class="line">        sum -= i</span><br><span class="line">        pathList.remove(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">blockTracking</span><span class="params">(k: <span class="type">Int</span>, n: <span class="type">Int</span>, startIndex: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; n) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">//sum &gt; n 直接返回，随想录的解法，这样更好.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pathList.size == k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == n) &#123;</span><br><span class="line">            result.add(pathList.toMutableList())</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex..(<span class="number">9</span> - (k - pathList.size) + <span class="number">1</span>)) &#123;</span><br><span class="line">        sum += i</span><br><span class="line">        pathList.add(i)</span><br><span class="line">        blockTracking(k, n, i + <span class="number">1</span>)</span><br><span class="line">        sum -= i</span><br><span class="line">        pathList.remove(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17.电话号码的字母组合"></a>17.电话号码的字母组合</h4><p>前面的题目都是在一个数组里面取，看到这个问题，这个问题是在数组里面，再取里面的数组。</p>
<p>问题是，如果输入”235”,那么他们内部数组的索引startIndex怎么求出来.</p>
<h5 id="String中的数字转int"><a href="#String中的数字转int" class="headerlink" title="String中的数字转int"></a>String中的数字转int</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> digits = <span class="string">&quot;23&quot;</span></span><br><span class="line"><span class="keyword">val</span> c = digits[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span> <span class="comment">// 50 - 48</span></span><br><span class="line">println(digits[<span class="number">0</span>].code) <span class="comment">// ASCII是 50</span></span><br><span class="line">println(<span class="string">&#x27;0&#x27;</span>.code)       <span class="comment">//ASCII是 48</span></span><br></pre></td></tr></table></figure>



<h4 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39.组合总和"></a>39.组合总和</h4><p>这题目和前面的区别是，可以选取重复的元素.</p>
<p>选了2后，第二列选5这时候不能选2了，否则就会重复了。</p>
<p><img src="/2022/10/30/LC-backtrack-combination/20221120103956.jpg"></p>
<p>看了随想录分析视频，在分析代码前，根据上面的图了解到的思路.</p>
<ol>
<li>整体回溯架构和前面的都是一样的,选了2后，后面还是可以继续253, 选了5后只有53了，否则就有重复的。</li>
<li>一开始我的解法是backTrack(candidates.toList(), target,i),传入for循环中的i，这样会导致有漏掉前面的情况。要知道for循环的部分就是树的宽度。</li>
<li>后面的剪枝应该也是针对这部分。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> path = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> result = ArrayList&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">combinationSum</span><span class="params">(candidates: <span class="type">IntArray</span>, target: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    backTrack(candidates.toList(), target)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(candidates: <span class="type">List</span>&lt;<span class="type">Int</span>&gt;, target: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; target) &#123;  <span class="comment">// 节点和</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum == target) &#123; </span><br><span class="line">        result.add(path.toList())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ((i, item) <span class="keyword">in</span> candidates.withIndex()) &#123;</span><br><span class="line">        path.add(item)</span><br><span class="line">        sum += item</span><br><span class="line">        backTrack(candidates.toMutableList().subList(i, candidates.size), target) <span class="comment">// 只需要传入后面能选取的数组部分</span></span><br><span class="line">        path.remove(item)</span><br><span class="line">        sum -= item</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>看了随想录的部分解法视频后，感觉这种更好，根据startIndex来取数组位置。传入startIndex后，后面的智能从startIndex后面取，和分割数组是一样的道理，感觉效率会更好。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> path = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> result = ArrayList&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">combinationSum</span><span class="params">(candidates: <span class="type">IntArray</span>, target: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    backTrack(candidates.toList(), target, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(candidates: <span class="type">List</span>&lt;<span class="type">Int</span>&gt;, target: <span class="type">Int</span>, startIndex: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">        result.add(path.toList())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex until candidates.size) &#123;</span><br><span class="line">        path.add(candidates[i])</span><br><span class="line">        sum += candidates[i]</span><br><span class="line">        backTrack(candidates, target, i) <span class="comment">// i后分割元素，一开始写的是startIndex，这样for循环后面的就没过滤到了,只有startIndex过滤到了。</span></span><br><span class="line">        path.remove(candidates[i])</span><br><span class="line">        sum -= candidates[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="剪枝-1"><a href="#剪枝-1" class="headerlink" title="剪枝"></a>剪枝</h5><p><img src="/2022/10/30/LC-backtrack-combination/20221120103956.jpg"></p>
<p>如果target ==4</p>
<p>可以看这张图，如果经过排序左边的 235,取了2,3已经 &gt;=4了，那么后面的5就不用去取了.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> path = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> result = ArrayList&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">combinationSum</span><span class="params">(candidates: <span class="type">IntArray</span>, target: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line"><span class="comment">//        backTrack1(candidates.toList(), target)</span></span><br><span class="line">        Arrays.sort(candidates) <span class="comment">//剪枝前需要排序</span></span><br><span class="line">        backTrack(candidates.toList(), target, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(candidates: <span class="type">List</span>&lt;<span class="type">Int</span>&gt;, target: <span class="type">Int</span>, startIndex: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            result.add(path.toList())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex until candidates.size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum + candidates[i] &gt; target) &#123; <span class="comment">//  剪枝操作</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            path.add(candidates[i])</span><br><span class="line">            sum += candidates[i]</span><br><span class="line">            backTrack(candidates, target, i)</span><br><span class="line">            path.remove(candidates[i])</span><br><span class="line">            sum -= candidates[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack1</span><span class="params">(candidates: <span class="type">IntArray</span>, target: <span class="type">Int</span>, startIndex: <span class="type">Int</span>, used: <span class="type">BooleanArray</span>, layer: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">        result.add(path.toList())</span><br><span class="line">        println(path)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex until candidates.size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum + candidates[i] &gt; target) &#123; <span class="comment">// 这样判断更好，因为是生序的数组，右边的枝没必要</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;layer<span class="variable">$layer</span> i: <span class="variable">$i</span> candidates[i]: <span class="subst">$&#123;candidates[i]&#125;</span>   used: <span class="subst">$&#123;used[i]&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            println(<span class="string">&quot;continue <span class="subst">$&#123;candidates[i]&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        path.add(candidates[i])</span><br><span class="line">        sum += candidates[i]</span><br><span class="line">        used[i] = <span class="literal">true</span></span><br><span class="line">        println(<span class="string">&quot;path <span class="variable">$path</span>&quot;</span>)</span><br><span class="line">        backTrack1(candidates, target, i + <span class="number">1</span>, used, layer + <span class="number">1</span>) <span class="comment">// 经过日志排查后, i + 1之前写的是 startIndex +1, 第二层报错</span></span><br><span class="line">        path.remove(candidates[i])</span><br><span class="line">        println(<span class="string">&quot;path backTrack <span class="variable">$path</span>&quot;</span>)</span><br><span class="line">        sum -= candidates[i]</span><br><span class="line">        used[i] = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40.组合总和 II"></a>40.组合总和 II</h4><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV12V4y1V73A/">https://www.bilibili.com/video/BV12V4y1V73A/</a></p>
<p> 这一题的 [10,1,2,7,6,1,5]，有两个1，可能都和7组成了[1,7]就重复了，这里就是要去掉这种重复。</p>
<p>一开始想不到去重的思路 。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20221021163812.png" alt="img"></p>
<ol>
<li>看了视频，对应这个图. 重复的原因在于树宽 第二次取1的地方，因为第1次取1，已经包括了第二次取1的所有树枝。所以把第二次取1的树枝剪掉既可。</li>
<li>剪枝条件1：candidates[i] == candidates[i - 1] </li>
<li>剪枝条件2: 通过设置used数组，只有used[i - 1] 是false才有意义, used[i - 1]= false ,说明数组的第一个1没有取，取的是第二个1，结果是[1,2]，所以可以舍弃掉，否则导致和第一次的取第一个1和下一层取2,结果是[1,2]重复了。这样判断就可以把 第二次取1的这个枝干给剪掉。 也叫 树层去重。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">val</span> path = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="keyword">val</span> result = ArrayList&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">combinationSum2</span><span class="params">(candidates: <span class="type">IntArray</span>, target: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    Arrays.sort(candidates)</span><br><span class="line">    println(candidates.joinToString())</span><br><span class="line">    <span class="keyword">val</span> used = BooleanArray(candidates.size)</span><br><span class="line">    backTrack(candidates, target, <span class="number">0</span>, used, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(candidates: <span class="type">IntArray</span>, target: <span class="type">Int</span>, startIndex: <span class="type">Int</span>, used: <span class="type">BooleanArray</span>, layer: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">        result.add(path.toList())</span><br><span class="line">        println(path)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex until candidates.size) &#123;</span><br><span class="line">        println(<span class="string">&quot;layer<span class="variable">$layer</span> i: <span class="variable">$i</span> candidates[i]: <span class="subst">$&#123;candidates[i]&#125;</span>   used: <span class="subst">$&#123;used[i]&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            println(<span class="string">&quot;continue <span class="subst">$&#123;candidates[i]&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        path.add(candidates[i])</span><br><span class="line">        sum += candidates[i]</span><br><span class="line">        used[i] = <span class="literal">true</span></span><br><span class="line">        println(<span class="string">&quot;path <span class="variable">$path</span>&quot;</span>)</span><br><span class="line">        backTrack(candidates, target, i + <span class="number">1</span>, used, layer + <span class="number">1</span>) <span class="comment">// 经过日志排查后, i + 1之前写的是 startIndex +1, 第二层报错</span></span><br><span class="line">        path.remove(candidates[i])</span><br><span class="line">        println(<span class="string">&quot;path backTrack <span class="variable">$path</span>&quot;</span>)</span><br><span class="line">        sum -= candidates[i]</span><br><span class="line">        used[i] = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131.分割回文串"></a>131.分割回文串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;aab&quot;</span><br><span class="line">输出：[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]</span><br></pre></td></tr></table></figure>

<p>没想明白 [[“a”,”a”,”b”],[“aa”,”b”]] 这个数组是怎么弄出来的。</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1c54y1e7k6">https://www.bilibili.com/video/BV1c54y1e7k6</a></p>
<p>这题是边看答案变做出来的。</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg" alt="131.分割回文串"></p>
<p>根据上图可以这样理解 ，</p>
<ol>
<li>DFS递归是 纵向切割， a|ab 取[a],  a|a|b 取 [a,a] , a|a|b| 最终到叶子节点取 [a,a,b]，到终点。</li>
<li>for循环是横向切割 。</li>
<li>  val str = s.substring(startIndex,i+1) // 这个也很关键，startIndex作为分割的起点</li>
</ol>
<p>这题类似于树中符合条件的所有的路径，一旦纵向路径中，有一个不符合条件[a,ab] ab不符合，就直接回溯去其他路径.所以放if里判断递归会更好。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = ArrayList&lt;List&lt;String&gt;&gt;()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> path = ArrayList&lt;String&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">partition</span><span class="params">(s: <span class="type">String</span>)</span></span>: List&lt;List&lt;String&gt;&gt; &#123;</span><br><span class="line">    backTrack(s, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(s: <span class="type">String</span>, startIndex: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (startIndex &gt;= s.length) &#123; <span class="comment">// 纵向到叶子节点，就网上回溯</span></span><br><span class="line">        result.add(path.toList())</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">//可以用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex until s.length) &#123;  <span class="comment">//for循环是 横向切割</span></span><br><span class="line">        <span class="keyword">if</span> (isPalindromeNum(s,startIndex,i+<span class="number">1</span>))&#123; <span class="comment">// 判断startIndex,到 i+1是否是回文串</span></span><br><span class="line">            <span class="keyword">val</span> str = s.substring(startIndex,i+<span class="number">1</span>) <span class="comment">// 这个也很关键，startIndex作为分割的起点</span></span><br><span class="line">            path.add(str)</span><br><span class="line">          </span><br><span class="line">       <span class="comment">// backTrack(s, i + 1)    //递归是 纵向切割，也没有循环。这个放if里面可能更好.</span></span><br><span class="line">       <span class="comment">// path.removeAt(path.size-1)</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">continue</span> <span class="comment">// 如ab不是回文串，也不用继续了 </span></span><br><span class="line">        &#125;</span><br><span class="line">        backTrack(s, i + <span class="number">1</span>)    <span class="comment">//递归是 纵向切割，也没有循环。这个放if里面可能更好.</span></span><br><span class="line">        path.removeAt(path.size-<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isPalindromeNum</span><span class="params">(str: <span class="type">String</span>,start:<span class="type">Int</span>,end:<span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> charArray = str.substring(start,end)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until charArray.length / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (charArray[i] != charArray[charArray.length - <span class="number">1</span> - i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="优化解法"><a href="#优化解法" class="headerlink" title="优化解法"></a>优化解法</h5><p>对判断是否回文串的优化.</p>
<h4 id="93-复原-IP-地址"><a href="#93-复原-IP-地址" class="headerlink" title="93.复原 IP 地址"></a>93.复原 IP 地址</h4><p>我的分析</p>
<p>这题和上面131类似，可以通过切割方式解决。</p>
<ol>
<li>ip地址都有四位，需要切割4次，所以树的深度是4。也是回溯终止条件之一，startIndex是切割线。(应该是i+1是切割线，否则只能分割一个字母)</li>
<li>选取有效的ip, 前导不为0，只能是数字。</li>
<li>&lt;255 , 可以限制树的宽度。</li>
</ol>
<p>我写完代码后，切割成这样 2.5.5.2， 不是全部的数字，没想到什么方式能切割所有的数字。</p>
<p>s.substring(startIndex, s.length) 先分割前三个，然后判断最后一个字符串，这样就能分割所有的字母。</p>
<p>startIndex解释，下面这张图更清楚，第一层取 元素2.</p>
<p><img src="https://img-blog.csdnimg.cn/202011232041348.png" alt="78.子集"></p>
<p><img src="https://img-blog.csdnimg.cn/20201123203735933.png" alt="93.复原IP地址"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = ArrayList&lt;String&gt;()</span><br><span class="line"><span class="keyword">val</span> path = ArrayList&lt;String&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">restoreIpAddresses</span><span class="params">(s: <span class="type">String</span>)</span></span>: List&lt;String&gt; &#123;</span><br><span class="line">    backTrack(s, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(s: <span class="type">String</span>, startIndex: <span class="type">Int</span>, layer: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 看了随想录解法，这里加上终止条件会更好。</span></span><br><span class="line">    <span class="keyword">if</span> (layer == <span class="number">3</span>) &#123;   <span class="comment">// 第三个分割线</span></span><br><span class="line">        <span class="keyword">val</span> substring = s.substring(startIndex, s.length) <span class="comment">// 这里的方式就解决了，分割所有子串的问题，最后一次分割，直接到字符串的终点。</span></span><br><span class="line">        <span class="keyword">if</span> (isValid(substring)) &#123;</span><br><span class="line">            path.add(substring)</span><br><span class="line">            result.add(path.toList().joinToString(separator = <span class="string">&quot;.&quot;</span>))</span><br><span class="line">            path.removeAt(path.size-<span class="number">1</span>) <span class="comment">// 最后的字符串回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex until s.length) &#123;</span><br><span class="line">        <span class="keyword">val</span> substring = s.substring(startIndex, i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (isValid(substring)) &#123;</span><br><span class="line">            path.add(substring)</span><br><span class="line">            backTrack(s, i + <span class="number">1</span>, layer + <span class="number">1</span>) <span class="comment">// 注意我这里经常传错用 startIndex,如果第一次已经分割到了超过第2个位置，那么就应该传这个位置，</span></span><br><span class="line">            path.removeAt(path.size-<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断字符串s在左闭又闭区间[start, end]所组成的数字是否合法</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isValid</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> start = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> end = s.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s[start] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; start != end) &#123; <span class="comment">// 0开头的数字不合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> start..end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt; <span class="string">&#x27;9&#x27;</span> || s[i] &lt; <span class="string">&#x27;0&#x27;</span>) &#123; <span class="comment">// 遇到非数字字符不合法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num = num * <span class="number">10</span> + (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (num &gt; <span class="number">255</span>) &#123; <span class="comment">// 如果大于255了不合法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/">78. 子集</a></h4><p><img src="https://img-blog.csdnimg.cn/202011232041348.png" alt="78.子集"></p>
<p>这题把上图画出来后，还是比较简单的。只要把所有步数情况添加就可以了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = ArrayList&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line"><span class="keyword">val</span> path = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">subsets</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    backTrack(nums, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(nums: <span class="type">IntArray</span>, startIndex: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    result.add(path.toList()) <span class="comment">// 这棵树所有的步长，都添加</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex until nums.size) &#123;</span><br><span class="line">        path.add(nums[i])</span><br><span class="line">        backTrack(nums, i + <span class="number">1</span>) <span class="comment">// 注意</span></span><br><span class="line">        path.remove(nums[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90.子集 II"></a>90.<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets-ii/description/">子集 II</a></h4><p><img src="https://img-blog.csdnimg.cn/20201124195411977.png" alt="90.子集II"></p>
<p>第一层 第二列取元素2的时候，此时子集就有2了，第三列再取就重复了。</p>
<p>从图中可以看出，同一树层上重复取2 就要过滤掉，同一树枝上就可以重复取2，因为同一树枝上元素的集合才是唯一子集！</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> result = ArrayList&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> path = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">subsetsWithDup</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">        Arrays.sort(nums)</span><br><span class="line">        <span class="keyword">val</span> used = BooleanArray(nums.size)</span><br><span class="line">        backTrack(nums, used, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(nums: <span class="type">IntArray</span>, used: <span class="type">BooleanArray</span>, startIndex: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        result.add(path.toList())</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex until nums.size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            used[i] = <span class="literal">true</span></span><br><span class="line">            path.add(nums[i])</span><br><span class="line">            backTrack(nums,used,i+<span class="number">1</span>)</span><br><span class="line">            path.remove(nums[i])</span><br><span class="line">            used[i] = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>!used[i - 1] 这个条件是判断树层的条件，否则会把树枝给剪掉了。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>本题也可以不使用used数组来去重，因为递归的时候下一个startIndex是i+1而不是0。</p>
<p>随想录这句没理解。</p>
<h4 id="491-递增子序列"><a href="#491-递增子序列" class="headerlink" title="491.递增子序列"></a>491.递增子序列</h4><ol>
<li><p>不能排序,所以子集中used解法不行</p>
</li>
<li><p>树枝中小心判断大小。</p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1EG4y1h78v/">https://www.bilibili.com/video/BV1EG4y1h78v/</a></p>
<p>一开始按照下面子集的解法做的,但是存在问题，子集是经过排序后的，然后nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]这样的条件判断，这题不能排序的，所以情况不一样。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(nums: <span class="type">IntArray</span>, used: <span class="type">BooleanArray</span>, startIndex: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.size &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        result.add(path.toList())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex until nums.size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt; nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        path.add(nums[i])</span><br><span class="line">        used[i] = <span class="literal">true</span></span><br><span class="line">        backTrack(nums,used,i+<span class="number">1</span>)</span><br><span class="line">        path.remove(nums[i])</span><br><span class="line">        used[i] = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://img-blog.csdnimg.cn/20201124200229824.png" alt="491. 递增子序列1"></p>
<p>上图可以看到，树层中是不能重复的，因为签名的 7包含后面7的所有情况。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> result = ArrayList&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> path = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findSubsequences</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">        backTrack(nums, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(nums: <span class="type">IntArray</span>, startIndex: <span class="type">Int</span>, layer: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size &gt; <span class="number">1</span>) &#123;                      <span class="comment">//  至少有两个元素</span></span><br><span class="line">            result.add(path.toList())</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">set</span> = mutableSetOf&lt;<span class="built_in">Int</span>&gt;()             <span class="comment">// 树层中是否包含 相同的元素。</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex until nums.size) &#123;</span><br><span class="line"><span class="comment">//            println(&quot;startIndex $startIndex set $set&quot;)</span></span><br><span class="line">            <span class="keyword">if</span> (layer == <span class="number">0</span>) &#123;</span><br><span class="line">                println(<span class="string">&quot;layer  set <span class="variable">$set</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((path.isNotEmpty() &amp;&amp; nums[i] &lt; path.last()) || <span class="keyword">set</span>.contains(nums[i])) &#123; <span class="comment">// 小于上一个元素，这个分支以下不用走了， set树层中包含相同的与元素。</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">set</span>.add(nums[i])  <span class="comment">//因为是判断树层，而且是每一层都局部会new 一个set，所以这个没有回溯。</span></span><br><span class="line">            path.add(nums[i])</span><br><span class="line">            backTrack(nums, i + <span class="number">1</span>, layer + <span class="number">1</span>)</span><br><span class="line">            path.remove(nums[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(nums: <span class="type">IntArray</span>, startIndex: <span class="type">Int</span>, layer: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.size &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        result.add(path.toList())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> used = IntArray(<span class="number">201</span>) <span class="comment">// -100 &lt;= nums[i] &lt;= 100 ， 包括 0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex until nums.size) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((path.isNotEmpty() &amp;&amp; nums[i] &lt; path.last()) || used[nums[i] + <span class="number">100</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        used[nums[i] + <span class="number">100</span>] = <span class="number">1</span></span><br><span class="line">        path.add(nums[i])</span><br><span class="line">        backTrack(nums, i + <span class="number">1</span>, layer + <span class="number">1</span>)</span><br><span class="line">        path.remove(nums[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="46全排列"><a href="#46全排列" class="headerlink" title="46全排列"></a>46全排列</h4><p>[1,2,3] 选了2之后， 1，3 就不知道从哪里开始了，子集问题有个startIndex</p>
<h5 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> result = ArrayList&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> path = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">permute</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> size = nums.size</span><br><span class="line">    <span class="keyword">val</span> used = BooleanArray(size)</span><br><span class="line">    backTrack(nums, used)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(nums: <span class="type">IntArray</span>, used: <span class="type">BooleanArray</span>)</span></span> &#123;</span><br><span class="line">    println(path)</span><br><span class="line">  <span class="comment">//if (totalUsed(used)) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (totalUsed(used)) &#123;</span><br><span class="line">        result.add(path.toList())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ((index, value) <span class="keyword">in</span> nums.withIndex()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (used[index]) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        path.add(nums[index])</span><br><span class="line">        used[index] = <span class="literal">true</span></span><br><span class="line">        backTrack(nums, used)</span><br><span class="line">        path.remove(nums[index])</span><br><span class="line">        used[index] = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">totalUsed</span><span class="params">(used: <span class="type">BooleanArray</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> used.contains(<span class="literal">false</span>).not()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>先画图分析 </p>
<p><img src="https://img-blog.csdnimg.cn/20201209174225145.png" alt="46.全排列"></p>
<p>单测中把数据打印出来，能大概理清这种思路，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[]</span><br><span class="line">[1]</span><br><span class="line">[1, 2]</span><br><span class="line">[1, 2, 3]</span><br><span class="line">[1, 3]</span><br><span class="line">[1, 3, 2]</span><br><span class="line">[2]</span><br><span class="line">[2, 1]</span><br><span class="line">[2, 1, 3]</span><br><span class="line">[2, 3]</span><br><span class="line">[2, 3, 1]</span><br><span class="line">[3]</span><br><span class="line">[3, 1]</span><br><span class="line">[3, 1, 2]</span><br><span class="line">[3, 2]</span><br><span class="line">[3, 2, 1]</span><br><span class="line">[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]</span><br></pre></td></tr></table></figure>





<h4 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47.全排列 II"></a>47.全排列 II</h4><p>我的解法有一点点问题[2,2,1,1]这个跑步过去,path.removeAt(path.lastIndex),看了随想录的解法和我没区别，才发现这里的。</p>
<p>思路</p>
<ol>
<li>和组合去重没区别 ,(index &gt; 0 &amp;&amp; nums[index] == nums[index - 1] &amp;&amp; !used[index - 1])重复元素，树层去重</li>
<li>全排列使用过的元素。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> path = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> result = ArrayList&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">permuteUnique</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">        Arrays.sort(nums)</span><br><span class="line"><span class="comment">//        nums.printIntArray()</span></span><br><span class="line">        <span class="keyword">val</span> used = BooleanArray(nums.size)</span><br><span class="line">        backTrack(nums, used)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    private fun backTrack(nums: IntArray, used: BooleanArray) &#123;</span></span><br><span class="line"><span class="comment">//        println(path)</span></span><br><span class="line"><span class="comment">//        if (path.size == nums.size) &#123;</span></span><br><span class="line"><span class="comment">//            result.add(path.toList())</span></span><br><span class="line"><span class="comment">//            return</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        for ((index, value) in nums.withIndex()) &#123;</span></span><br><span class="line"><span class="comment">//            if (used[index] || (index &gt; 0 &amp;&amp; nums[index] == nums[index - 1] &amp;&amp; !used[index - 1])) &#123;</span></span><br><span class="line"><span class="comment">//                continue</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            used[index] = true</span></span><br><span class="line"><span class="comment">//            path.add(value)</span></span><br><span class="line"><span class="comment">//            backTrack(nums, used)</span></span><br><span class="line"><span class="comment">//            used[index] = false</span></span><br><span class="line"><span class="comment">//            path.remove(value)</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(nums: <span class="type">IntArray</span>, used: <span class="type">BooleanArray</span>)</span></span> &#123;</span><br><span class="line">        println(path)</span><br><span class="line">        <span class="keyword">if</span> (path.size == nums.size) &#123;</span><br><span class="line">            result.add(path.toList())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (index <span class="keyword">in</span> nums.indices) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((index &gt; <span class="number">0</span> &amp;&amp; nums[index] == nums[index - <span class="number">1</span>] &amp;&amp; !used[index - <span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (used[index]) &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            used[index] = <span class="literal">true</span></span><br><span class="line">            path.add(nums[index])</span><br><span class="line">            backTrack(nums, used)</span><br><span class="line">            path.removeAt(path.lastIndex) <span class="comment">// 用path.remove(value)是有问题的，会把所有的这个元素删除掉，46没问题是因为没有重复元素，leetcode removeLast() cannot build</span></span><br><span class="line">            used[index] = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="332-重新安排行程"><a href="#332-重新安排行程" class="headerlink" title="332.重新安排行程"></a>332.重新安排行程</h4><p>随想录解法那个数组处理没看明白</p>
<p>这里用到的回溯，就是目的地可能有多个。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reconstruct-itinerary/solutions/654811/java-bu-yong-ou-la-zhi-yong-hui-su-si-lu-4v83/">https://leetcode.cn/problems/reconstruct-itinerary/solutions/654811/java-bu-yong-ou-la-zhi-yong-hui-su-si-lu-4v83/</a></p>
<p>看了他的视频</p>
<ol>
<li>给定的tickets转成 from to 的结构,就可以知道出发点对应的，到达点和到达点的线路数。 // 这个数据处理也是有点麻烦的。</li>
<li>根据多个到达点回溯，找到最合适的路径</li>
<li>如果到达点的是线路是0，那么找下一题跳线路。</li>
<li> 遇到的机场个数path ==航班数量+</li>
</ol>
<p>putIfAbsent</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hbtj_1216/article/details/75093428">https://blog.csdn.net/hbtj_1216/article/details/75093428</a></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> path = ArrayList&lt;String&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findItinerary</span><span class="params">(tickets: <span class="type">List</span>&lt;<span class="type">List</span>&lt;<span class="type">String</span>&gt;&gt;)</span></span>: List&lt;String&gt; &#123;</span><br><span class="line">    <span class="comment">//1. list转成 from to 的结构</span></span><br><span class="line">    <span class="comment">//2. 回溯找到最合适的路径</span></span><br><span class="line">    <span class="comment">//3.  遇到的机场个数path ==航班数量+</span></span><br><span class="line">    <span class="keyword">val</span> hashMap = HashMap&lt;String, TreeMap&lt;String, <span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line">    tickets.stream().forEach &#123; ticket -&gt;</span><br><span class="line">        <span class="keyword">val</span> from = ticket[<span class="number">0</span>] <span class="comment">// 出发地</span></span><br><span class="line">        <span class="keyword">val</span> to = ticket[<span class="number">1</span>]  <span class="comment">//目的地</span></span><br><span class="line"></span><br><span class="line">        hashMap.putIfAbsent(from, TreeMap())</span><br><span class="line">        <span class="keyword">val</span> treeMap = hashMap[from] ?: TreeMap()  <span class="comment">//获取出发地对应的容器TreeMap,如果之前没用过的出发地key,那么新建一个容器TreeMap</span></span><br><span class="line">        treeMap[to] = treeMap.getOrDefault(to, <span class="number">0</span>) + <span class="number">1</span> <span class="comment">// 容器内，目的地的个数++,一开始这里写的有问题。</span></span><br><span class="line">    &#125;</span><br><span class="line">    path.add(<span class="string">&quot;JFK&quot;</span>) <span class="comment">// 所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。</span></span><br><span class="line">    backTrack(hashMap, tickets.size)</span><br><span class="line">    <span class="keyword">return</span> path</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(hashMap: <span class="type">HashMap</span>&lt;<span class="type">String</span>, TreeMap&lt;String, <span class="built_in">Int</span>&gt;&gt;, ticketSize: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.size == ticketSize + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.根据path找到出发点,从hashmap根据出发点找到对应的 可能多个到达点</span></span><br><span class="line">    <span class="comment">// 2. 多个可能的目的地进行回溯.</span></span><br><span class="line">    <span class="keyword">val</span> recentTo = path[path.size - <span class="number">1</span>] <span class="comment">//path.last() LeetCode build failed</span></span><br><span class="line">    <span class="keyword">val</span> toDestinations = hashMap[recentTo]</span><br><span class="line">    <span class="keyword">if</span> (toDestinations.isNullOrEmpty()) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> (to <span class="keyword">in</span> toDestinations) &#123;<span class="comment">// forEach也行, for习惯点</span></span><br><span class="line">        <span class="keyword">if</span> (to.value == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        path.add(to.key)</span><br><span class="line">        to.setValue(to.value - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (backTrack(hashMap, ticketSize)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        path.removeAt(path.size - <span class="number">1</span>)</span><br><span class="line">        to.setValue(to.value + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="51-N-皇后"><a href="#51-N-皇后" class="headerlink" title="51.N 皇后"></a>51.N 皇后</h4><img src="https://img-blog.csdnimg.cn/20210130182532303.jpg" alt="51.N皇后" style="zoom:50%;">



<p>这题思路不难，实现还是有难度，主要是皇后冲突代码不好理解，<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1bK4y1n7iq">https://www.bilibili.com/video/BV1bK4y1n7iq</a></p>
<p>大概11分钟，判断 皇后位置的冲突情况。</p>
<ol>
<li>这一题思路就是主要 首先行，然后列摆放皇后问题，然后回溯。</li>
<li>还一个就是将要放下皇后的位置之前，8个方向只用考虑3个,确定左上，正上方，右上方的皇后是否存在。当前行不用考了，因为每行一个，后面的更不看了，因为还没放皇后.</li>
<li>最后就是要注意边界的问题，二刷的时候尤其注意这个。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="comment">//1. 初始化棋盘放上.</span></span><br><span class="line">    <span class="keyword">char</span>[][] chessBoard = <span class="keyword">new</span> <span class="keyword">char</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span>[] c : chessBoard) &#123;</span><br><span class="line">        Arrays.fill(c, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 开始放Queue,首先从行开始，一行一行回溯的放， 然后每一行开始从第1列开始。</span></span><br><span class="line">    <span class="comment">// 3. 每次新的一行开始放Queue时，要考虑当前位置列的 前面的列有没有Queue,</span></span><br><span class="line">    <span class="comment">// 当前位置的左边45度和135度有没有Queue,对于当前行和后面的行和斜对角不用考虑，因为每一行只有一个Queue,后面的行更是没有。</span></span><br><span class="line">    <span class="comment">//4 。只有能放下，才会放后续的，然后进行回溯.</span></span><br><span class="line">    <span class="comment">//5. 当放下的Queue时最后一行n时，递归结束，开始收集结果。</span></span><br><span class="line">    backTrack(n, <span class="number">0</span>, chessBoard);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> row, <span class="keyword">char</span>[][] chessBoard)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == row) &#123;</span><br><span class="line">        result.add(Array2List(chessBoard));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; n; ++column) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isValid(row, column, chessBoard, n)) &#123; <span class="comment">// row,column待放入Queue的位置</span></span><br><span class="line">            chessBoard[row][column] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            backTrack(n, row + <span class="number">1</span>, chessBoard);</span><br><span class="line">            chessBoard[row][column] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> pRow, <span class="keyword">int</span> pColumn, <span class="keyword">char</span>[][] chessBoard, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pRow; ++i) &#123; <span class="comment">//列</span></span><br><span class="line">        <span class="keyword">if</span> (chessBoard[i][pColumn] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = pRow - <span class="number">1</span>, y = pColumn - <span class="number">1</span>; x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span>; x--, y--) &#123; <span class="comment">//左上角 首次==边界错了</span></span><br><span class="line">        <span class="keyword">if</span> (chessBoard[x][y] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = pRow - <span class="number">1</span>, y = pColumn + <span class="number">1</span>; x &gt;= <span class="number">0</span> &amp;&amp; y &lt;= n - <span class="number">1</span>; x--, y++) &#123;<span class="comment">//右上角  首次==,n-1边界错了 ,y &lt; n - 1一开始写成这样，找了半天</span></span><br><span class="line">        <span class="keyword">if</span> (chessBoard[x][y] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List <span class="title">Array2List</span><span class="params">(<span class="keyword">char</span>[][] chessboard)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span>[] c : chessboard) &#123;</span><br><span class="line">        list.add(String.copyValueOf(c));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这题for里面有x,y两个变量，kotlin不好弄，就用java了。</p>
<h4 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37.解数独"></a>37.解数独</h4><p>随想录讲解.</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1TW4y1471V/">https://www.bilibili.com/video/BV1TW4y1471V/</a></p>
<p><img src="/2022/10/30/LC-backtrack-combination/20230102104449.jpg" alt="20230102104449"></p>
<p><a target="_blank" rel="noopener" href="https://xiaochen1024.com/video?id=6285f1b6ede03c002e46b218">https://xiaochen1024.com/video?id=6285f1b6ede03c002e46b218</a></p>
<p>根据下面公式可以找到 3 *3的开始位置。</p>
<pre><code>val startRow = (row / 3) * 3    
val startColumn = (column / 3) * 3
</code></pre>
<p>把红方框代入进去， val 3 = (4 / 3) * 3    就是红色箭头的位置。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.先行 后列的顺序，找到字符位 &#x27;.&#x27;的空格，填入 1 - 9 的数字</span></span><br><span class="line"><span class="comment">// 2.填入后，开始回溯</span></span><br><span class="line"><span class="comment">// 3.填入空格的时候，如果没有返回true,if就返回false</span></span><br><span class="line"><span class="comment">// 4. 如果全部填满了都没返回true,此时说明已经到了叶子节点，直接返回true.</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">solveSudoku</span><span class="params">(board: <span class="type">Array</span>&lt;<span class="type">CharArray</span>&gt;)</span></span>: <span class="built_in">Unit</span> &#123;</span><br><span class="line">    backTrack(board)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(board: <span class="type">Array</span>&lt;<span class="type">CharArray</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> board.indices) &#123;   <span class="comment">// 遍历行</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> board[<span class="number">0</span>].indices) &#123;<span class="comment">// 遍历列</span></span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (k <span class="keyword">in</span> <span class="string">&#x27;1&#x27;</span>..<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isValid(i, j, k, board)) &#123;</span><br><span class="line">                        board[i][j] = k</span><br><span class="line">                        <span class="keyword">if</span> (backTrack(board)) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        board[i][j] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">//放上面一层，循环后直接返回false了,// 9个数都试完了，都不行，那么就返回false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isValid</span><span class="params">(row: <span class="type">Int</span>, column: <span class="type">Int</span>, k: <span class="type">Char</span>, board: <span class="type">Array</span>&lt;<span class="type">CharArray</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> board[<span class="number">0</span>].indices) &#123; <span class="comment">// 判断行里是否重复,一开始不理解很多解法包括，随想录用的是9,这样如果不是9*9就有问题了,原来题目给的就是9*9的方格</span></span><br><span class="line">        <span class="keyword">if</span> (board[row][i] == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> board.indices) &#123;  <span class="comment">// 判断列里是否重复</span></span><br><span class="line">        <span class="keyword">if</span> (board[i][column] == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> startRow = (row / <span class="number">3</span>) * <span class="number">3</span>    </span><br><span class="line">    <span class="keyword">val</span> startColumn = (column / <span class="number">3</span>) * <span class="number">3</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> startRow until (startRow + <span class="number">3</span>)) &#123;  <span class="comment">// 判断9方格里是否重复</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> startColumn until startColumn + <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == k) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-10-05T14:00:07.000Z" title="10/5/2022, 10:00:07 PM">2022-10-05</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-01-02T03:31:39.080Z" title="1/2/2023, 11:31:39 AM">2023-01-02</time></span><span class="level-item"><a class="link-muted" href="/categories/DataStructure/">DataStructure</a></span><span class="level-item">26 minutes read (About 3954 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/10/05/LC-Tree-Search-22/">LC-Tree-Search-22</a></p><div class="content"><h3 id="二叉树搜索-BST"><a href="#二叉树搜索-BST" class="headerlink" title="二叉树搜索 BST"></a>二叉树搜索 BST</h3><p><strong>根节点比左子树所有节点的数值都大，比右子树所有节点的数值都小.</strong> </p>
<h4 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700. 二叉搜索树中的搜索"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></h4><p>My idea</p>
<h5 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h5><ol>
<li><p>先序遍历搜索，如果找到了直接返回当前节点。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">searchBST</span><span class="params">(root: <span class="type">TreeNode</span>?, `<span class="keyword">val</span>`: <span class="type">Int</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (root.`<span class="keyword">val</span>` == `<span class="keyword">val</span>`) &#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> nodeLeft = searchBST(root.left, `<span class="keyword">val</span>`)</span><br><span class="line">    <span class="keyword">if</span> (nodeLeft != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nodeLeft</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> nodeRight = searchBST(root.right, `<span class="keyword">val</span>`)</span><br><span class="line">    <span class="keyword">if</span> (nodeRight != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nodeRight</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>看了官方解法,利用二叉搜索树的特性 </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">searchBST1</span><span class="params">(root: <span class="type">TreeNode</span>?, `<span class="keyword">val</span>`: <span class="type">Int</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> node: TreeNode? = root.left</span><br><span class="line">    <span class="keyword">if</span> (root.`<span class="keyword">val</span>` == `<span class="keyword">val</span>`) &#123; <span class="comment">//一开始没有做出来，这个条件没写,导致一直往下递归</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.`<span class="keyword">val</span>` &lt; `<span class="keyword">val</span>`) &#123;</span><br><span class="line">        node = root.right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> searchBST1(node, `<span class="keyword">val</span>`)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h5><p>二叉搜索树的迭代法相对简单，暂时先不看了</p>
<h4 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h4><p>二叉搜索树是一个有序树：</p>
<ul>
<li>若它的左子树不空，则左子树上<strong>所有结点</strong>的值均小于它的根结点的值；  注意==都不行</li>
<li>若它的右子树不空，则右子树上<strong>所有结点</strong>的值均大于它的根结点的值；</li>
<li>它的左、右子树也分别为二叉搜索树</li>
</ul>
<p>这就决定了，二叉搜索树，递归遍历和迭代遍历和普通二叉树都不一样。</p>
<p>一开始理解错了，只比较根节点和左右子树，导致下面这个testcase没通过，应该是根节点和所有的左右子树的节点数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5, 4, 6, null, null, 3, 7</span><br></pre></td></tr></table></figure>



<h5 id="转数组"><a href="#转数组" class="headerlink" title="转数组"></a>转数组</h5><p>把中序遍历转成数组很好理解</p>
<ol>
<li><p> 中序遍历递归 得到list数组</p>
</li>
<li><p>比较数组的前后节点大大小,</p>
</li>
<li><p>如果前面节点值更大，那么直接返回false, ==也不行</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isValidBST3</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    dfsTraversal(root) <span class="comment">// 中序遍历递归 得到list数组</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until list.size - <span class="number">1</span>) &#123; <span class="comment">// 比较数组的前后节点大大小</span></span><br><span class="line">        <span class="keyword">if</span> (list[i] &gt;= list[i + <span class="number">1</span>]) &#123; <span class="comment">// 如果前面节点值更大，那么直接返回false, ==也不行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dfsTraversal</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">    dfsTraversal(root.left)</span><br><span class="line">    list.add(root.`<span class="keyword">val</span>`)</span><br><span class="line">    dfsTraversal(root.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h5><p>随想录的递归解法，一开始怎么也理解不了，其实和上面 中序转数组的类似，就是把根据中序遍历遍历的节点，后一个节点一定比前一个节点的数值高。</p>
<ol>
<li>中序遍历 后一个节点比前一个节点的值大，就可以了，所以存储前一个节点。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> preNode: TreeNode? = <span class="literal">null</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isValidBST4</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (!isValidBST4(root.left)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (preNode != <span class="literal">null</span> &amp;&amp; preNode!!.`<span class="keyword">val</span>` &gt;= root.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    preNode = root</span><br><span class="line">    <span class="keyword">if</span> (!isValidBST4(root.right)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>之前的题主要用到 后序和先序，二叉搜索这里开始用到了 中序遍历。</p>
<h4 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530. 二叉搜索树的最小绝对差"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差</a></h4><p>My idea </p>
<p>这一题和上一题 98 思路差不多，</p>
<p>中序遍历的节点之间的数组相差最小，所以找出节点间的间隔最小值就可以了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> preNode: TreeNode? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">var</span> miniNum = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getMinimumDifference</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line">    getMinimumDifference(root.left)</span><br><span class="line">    <span class="keyword">if</span> (preNode != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> gapNum = root.`<span class="keyword">val</span>` - preNode!!.`<span class="keyword">val</span>`<span class="comment">//这一步可以简化 Math.min()</span></span><br><span class="line">        <span class="keyword">if</span> (gapNum &lt; miniNum) &#123;</span><br><span class="line">            miniNum = gapNum</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    preNode = root</span><br><span class="line">    getMinimumDifference(root.right)</span><br><span class="line">    <span class="keyword">return</span> miniNum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>也可以先中序遍历转成数组，然后求数组元素间的差值就可以了。</p>
<h4 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501. 二叉搜索树中的众数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数</a></h4><p>My idea</p>
<p>我的想法和上面的类似。</p>
<ol>
<li>中序遍历相邻节点用map存下value和值的个数。</li>
<li>遍历map求得最大个事的数组。把map按照value个数进行数组排序</li>
<li> 然后取排序后的前面的元素</li>
</ol>
<p>。了。/其实上面这种方式，用先序 后序都可以，都不需要二叉搜索树。</p>
<p>其实上面我的想法也是 打算用二叉搜索树的特性，放到map中，然后把map排序,就不知道怎么处理更好。看了随想录的处理方式,理了下思路.</p>
<ol>
<li>根据中序遍历的前后节点，他们的值相同的是一起的，进行遍历。</li>
<li>对value值进行count计数，如果count == 最大个数，加入集合。</li>
<li>如果count&gt;最大个数，清空集合.</li>
</ol>
<p>一开始不知道放哪里, maxCount=count ，以为在前面if (preNode != null &amp;&amp; preNode!!.<code>val</code> == node.<code>val</code>) 前面的比较里面,还想着Math.max,但是都不合适。然后看了一半随想录是放在更新节点的位置，更好.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> array = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findMode</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: IntArray &#123;</span><br><span class="line">    inDFS(root)</span><br><span class="line">    <span class="keyword">return</span> array.toIntArray()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> preNode: TreeNode? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">var</span> maxCount = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">inDFS</span><span class="params">(node: <span class="type">TreeNode</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> printNode = node?.`<span class="keyword">val</span>`</span><br><span class="line">    println(<span class="string">&quot;printNode <span class="variable">$printNode</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    inDFS(node.left)</span><br><span class="line">    <span class="keyword">if</span> (preNode != <span class="literal">null</span> &amp;&amp; preNode!!.`<span class="keyword">val</span>` == node.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        count++</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count == maxCount) &#123;</span><br><span class="line">        array.add(node.`<span class="keyword">val</span>`)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; maxCount) &#123;</span><br><span class="line">        maxCount = count<span class="comment">//这一步一开始不知道放哪里,看了一眼随想录答案</span></span><br><span class="line">        array.clear() <span class="comment">// 有更大的值，清空之前的集合</span></span><br><span class="line">        array.add(node.`<span class="keyword">val</span>`)</span><br><span class="line">    &#125;</span><br><span class="line">    preNode = node</span><br><span class="line">    inDFS(node.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>官方还有 o(1)的处理，while循环</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/solution/er-cha-sou-suo-shu-zhong-de-zhong-shu-by-leetcode-/">https://leetcode.cn/problems/find-mode-in-binary-search-tree/solution/er-cha-sou-suo-shu-zhong-de-zhong-shu-by-leetcode-/</a></p>
<h4 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h4><p>这一题有两种想法</p>
<ol>
<li>之前做的环形链表 走对方的路</li>
<li>先序遍历每一个节点，只要下面的节点都走过，只要下一个节点没有走到，就返回上一个节点，但是先序遍历DFS 两个节点都走了不知道怎么返回。</li>
</ol>
<p>看了随想录视频思路后 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1jd4y1B7E2">https://www.bilibili.com/video/BV1jd4y1B7E2</a></p>
<ol>
<li>后序遍历如果碰到p或q,就返回他们的节点.</li>
<li>如果一个节点的左右子树都不为空说明当前节点是他们的最近公共祖先.</li>
<li>还一种情况，有一个节点p就是祖先节点</li>
</ol>
<p>debug调试，拼凑把代码写出来了</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">lowestCommonAncestor</span><span class="params">(root: <span class="type">TreeNode</span>?, p: <span class="type">TreeNode</span>?, q: <span class="type">TreeNode</span>?)</span></span>: TreeNode? &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">// 随想录这里改成 碰到节点判断，直接在这里返回</span></span><br><span class="line"><span class="comment">//        val printData = root.`val`</span></span><br><span class="line"><span class="comment">//        println(printData)</span></span><br><span class="line">        <span class="keyword">val</span> leftNode = lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        <span class="keyword">val</span> rightNode = lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> (leftNode != <span class="literal">null</span> &amp;&amp; rightNode != <span class="literal">null</span>) &#123; <span class="comment">// 如果左右子树都不为空，那么当前节点就是最近公共祖先节点</span></span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; root.`<span class="keyword">val</span>` == p.`<span class="keyword">val</span>`) &#123;   <span class="comment">//碰到了其中一个节点返回</span></span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (q != <span class="literal">null</span> &amp;&amp; root.`<span class="keyword">val</span>` == q.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">            <span class="keyword">return</span> root                             <span class="comment">//碰到了其中一个节点返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftNode != <span class="literal">null</span>) <span class="keyword">return</span> leftNode       <span class="comment">//回溯之前碰到的节点</span></span><br><span class="line">        <span class="keyword">if</span> (rightNode != <span class="literal">null</span>) <span class="keyword">return</span> rightNode</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h5 id="终止条件写法"><a href="#终止条件写法" class="headerlink" title="终止条件写法"></a>终止条件写法</h5><p> 随想录这里改成 碰到节点判断，直接在这里返回，下次可以改成在终止条件这里，更简单</p>
<h4 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></h4><p>My idea</p>
<p>可以根据二叉搜索树的特性， 祖先节点的值大小有两种情况</p>
<ol>
<li>在p和q之前,</li>
<li>如果p&lt;q, 祖先节点的值 等于p , 大于q</li>
<li>只要满足上述条件，用先序遍历或者后序遍历都可以，把节点返回</li>
</ol>
<p>官方和随想录解法都是给出了相反的条件 ，当前节点&lt;p , &gt;q,在外面的情况（其实这里没想清楚,不存在这样的&lt;2 &gt;4的节点）, 但是我这里ide testcase也没问题。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/solution/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-26/">https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/solution/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-26/</a></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 很奇怪，IDE可以跑这个testcase没问题</span></span><br><span class="line"><span class="comment"> *[2,1]</span></span><br><span class="line"><span class="comment"> * 2</span></span><br><span class="line"><span class="comment"> * 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lowestCommonAncestor</span><span class="params">(root: <span class="type">TreeNode</span>?, p: <span class="type">TreeNode</span>?, q: <span class="type">TreeNode</span>?)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (p!!.`<span class="keyword">val</span>` &gt; q!!.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        swap(p, q)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.`<span class="keyword">val</span>` &gt; p.`<span class="keyword">val</span>` &amp;&amp; root.`<span class="keyword">val</span>` &lt; q.`<span class="keyword">val</span>`) &#123; </span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.`<span class="keyword">val</span>` == p.`<span class="keyword">val</span>` &amp;&amp; root.`<span class="keyword">val</span>` &lt; q.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.`<span class="keyword">val</span>` == q.`<span class="keyword">val</span>` &amp;&amp; root.`<span class="keyword">val</span>` &gt; p.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> leftNode = lowestCommonAncestor(root.left, p, q)</span><br><span class="line">    <span class="keyword">if</span> (leftNode != <span class="literal">null</span>) <span class="keyword">return</span> leftNode</span><br><span class="line">    <span class="keyword">val</span> rightNode = lowestCommonAncestor(root.right, p, q)</span><br><span class="line">    <span class="keyword">if</span> (rightNode != <span class="literal">null</span>) <span class="keyword">return</span> rightNode</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">swap</span><span class="params">(p: <span class="type">TreeNode</span>, q: <span class="type">TreeNode</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> temp = p.`<span class="keyword">val</span>`</span><br><span class="line">    p.`<span class="keyword">val</span>` = q!!.`<span class="keyword">val</span>`</span><br><span class="line">    q.`<span class="keyword">val</span>` = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0235.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html">https://programmercarl.com/0235.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Zt4y1F7ww">https://www.bilibili.com/video/BV1Zt4y1F7ww</a></p>
<p>看了随想录视频，其实相反的就两种情况</p>
<ol>
<li>当前节点 &lt;p , &lt;q， 那么p,q一定在右子树上，就去右子树去找</li>
<li>当前节点 &gt; p , &gt;q ,那么p,q一定在左子树上，就去左子树去找</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lowestCommonAncestor</span><span class="params">(root: <span class="type">TreeNode</span>?, p: <span class="type">TreeNode</span>?, q: <span class="type">TreeNode</span>?)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (root.`<span class="keyword">val</span>` &lt; p!!.`<span class="keyword">val</span>` &amp;&amp; root.`<span class="keyword">val</span>` &lt; q!!.`<span class="keyword">val</span>`) &#123; <span class="comment">// 当前节点比p和q的值都小，那么一定p,q一定在右子树上，就往右边遍历</span></span><br><span class="line">        <span class="keyword">val</span> rightNode = lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> (rightNode != <span class="literal">null</span>) <span class="keyword">return</span> rightNode</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root.`<span class="keyword">val</span>` &gt; p.`<span class="keyword">val</span>` &amp;&amp; root.`<span class="keyword">val</span>` &gt; q!!.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        <span class="keyword">val</span> leftNode = lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        <span class="keyword">if</span> (leftNode != <span class="literal">null</span>) <span class="keyword">return</span> leftNode</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a></h4><h5 id="DFS-1"><a href="#DFS-1" class="headerlink" title="DFS"></a>DFS</h5><p>My idea</p>
<p>可以用后序遍历，按照二叉树的特性，走到叶子节点后，连接到叶子节点，然后回溯到根节点并返回</p>
<ol>
<li>后序遍历根据待插入值和当前节点比较，找到需要插入的位置。</li>
<li>如果需要插入的位置左或右节点刚好为空，就插入。</li>
</ol>
<p>随想录其中一个解法和我的这个类似，不过感觉比我这个更复杂点</p>
<p>自己的做的解法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">insertIntoBST</span><span class="params">(root: <span class="type">TreeNode</span>?, `<span class="keyword">val</span>`: <span class="type">Int</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> TreeNode(`<span class="keyword">val</span>`) <span class="comment">//有一个这个test case  [] 5 ,空树的话返回 [5]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (`<span class="keyword">val</span>` &lt; root.`<span class="keyword">val</span>`) &#123; <span class="comment">// 插入点小于当前节点，往左子树中插入</span></span><br><span class="line">        insertIntoBST(root.left, `<span class="keyword">val</span>`)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (`<span class="keyword">val</span>` &gt; root.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        insertIntoBST(root.right, `<span class="keyword">val</span>`)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一开始这个放前面导致添加了两个5的左节点，因为 insertIntoBST(root.left, `val`)又走了一次</span></span><br><span class="line">    <span class="keyword">val</span> treeNode = TreeNode(`<span class="keyword">val</span>`) <span class="comment">// 只有一次机会走这个</span></span><br><span class="line">    <span class="keyword">if</span> (root.right == <span class="literal">null</span> &amp;&amp; `<span class="keyword">val</span>` &gt; root.`<span class="keyword">val</span>`) &#123; <span class="comment">//  待插入点大于当前节点，所以要插入右子树中，此时右子树为空，那么直接插入</span></span><br><span class="line">        root.right = treeNode</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; `<span class="keyword">val</span>` &lt; root.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        root.left = treeNode</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>看了随想录的解法，其实还可以每一个都被父节点接住更简单,也是后序遍历的精髓 </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">insertIntoBST</span><span class="params">(root: <span class="type">TreeNode</span>?, `<span class="keyword">val</span>`: <span class="type">Int</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> TreeNode(`<span class="keyword">val</span>`)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (`<span class="keyword">val</span>` &lt; root.`<span class="keyword">val</span>`) &#123; <span class="comment">// 插入点小于当前节点，往左子树中插入</span></span><br><span class="line">        root.left = insertIntoBST1(root.left, `<span class="keyword">val</span>`)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (`<span class="keyword">val</span>` &gt; root.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        root.right = insertIntoBST1(root.right, `<span class="keyword">val</span>`)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="迭代法-1"><a href="#迭代法-1" class="headerlink" title="迭代法"></a>迭代法</h5><p>官方用迭代法 ,看起来也不难</p>
<p> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/solution/er-cha-sou-suo-shu-zhong-de-cha-ru-cao-zuo-by-le-3/">https://leetcode.cn/problems/insert-into-a-binary-search-tree/solution/er-cha-sou-suo-shu-zhong-de-cha-ru-cao-zuo-by-le-3/</a></p>
<h4 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></h4><p>My idea</p>
<p>和上面思路类似，用后序遍历的 父节点接住，当前要删除节点的左或者右节点，那么当前节点就删除了，然后左右节点再改变指向。</p>
<ol>
<li><p>后序遍历到要删除的节点.</p>
</li>
<li><p>当前节点的右节点指向它的左节点。被上一个节点回溯的父节点接住。</p>
</li>
<li><p>返回当前节点的左节点，</p>
</li>
</ol>
<p>[5,3,6,2,4,null,7]<br>5<br>优先还是需要右节点上去，否则就很麻烦，需要4上去</p>
<p>删除节点主要有这5种情况</p>
<ul>
<li>第一种情况：没找到删除的节点，遍历到空节点直接返回了</li>
<li>找到删除的节点<ul>
<li>第二种情况：删除的左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</li>
<li>第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点</li>
<li>第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</li>
<li>第五种情况：删除节点的左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。</li>
</ul>
</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbj3k596mg30dq0aigyz.gif" alt="450.删除二叉搜索树中的节点"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">deleteNode</span><span class="params">(root: <span class="type">TreeNode</span>?, key: <span class="type">Int</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">//情况一</span></span><br><span class="line">    <span class="keyword">if</span> (key &lt; root.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        root.left = deleteNode(root.left, key)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        root.right = deleteNode(root.right, key)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key == root.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.right == <span class="literal">null</span> &amp;&amp; root.left == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">// 情况2  [0] 0 因为这个testcase 会返回[0]和预期不一致</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.left != <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;            <span class="comment">//情况三 如果左节点不为空</span></span><br><span class="line">            <span class="keyword">val</span> node = root.left  <span class="comment">// 左节点 2 推到删除的节点位置</span></span><br><span class="line">            <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;               <span class="comment">//这两句可以去掉 ，直接返回节点</span></span><br><span class="line">                node.right = root.right         <span class="comment">//此时左节点2在在删除节点位置，它的右子树指向之前右节点4</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.right != <span class="literal">null</span> &amp;&amp; root.left == <span class="literal">null</span>) &#123;  <span class="comment">//情况四 如果右节点不为空</span></span><br><span class="line">            <span class="keyword">val</span> node = root.right <span class="comment">//右节点4 推到删除的节点位置</span></span><br><span class="line">            <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;                 <span class="comment">//这两句可以去掉</span></span><br><span class="line">                node.left = root.left           <span class="comment">// 此时左节点4在在删除节点位置，它的左子树指向之前右节点2</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> rightNode = root.right <span class="comment">//情况五</span></span><br><span class="line">            <span class="keyword">var</span> leftNode = rightNode?.left</span><br><span class="line">            <span class="keyword">while</span> (leftNode?.left!= <span class="literal">null</span>) &#123;</span><br><span class="line">                leftNode = leftNode.left</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (leftNode != <span class="literal">null</span>) &#123;</span><br><span class="line">                leftNode.left = root.left</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rightNode.left = root.left</span><br><span class="line">            &#125;</span><br><span class="line">            root.left = <span class="literal">null</span></span><br><span class="line">            <span class="keyword">return</span> rightNode <span class="comment">// 这里返回的节点，可以被上面的左右子树接住</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="普通二叉树的节点删除"><a href="#普通二叉树的节点删除" class="headerlink" title="普通二叉树的节点删除"></a>普通二叉树的节点删除</h5><p>通用二叉树节点删除</p>
<p><img src="/2022/10/05/LC-Tree-Search-22/20221012115615.jpg"></p>
<p>要加if (leftNode != null)，否则删除报错</p>
<p>这个题目的leetcode的测试用例有问题,单独跑报错.</p>
<h4 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h4><p>看了随想录的解答，从中取中间节点的位置就可以了，如果数字是偶数，中间节点的两个中的一个都可以，</p>
<p>但是问题来了，为什么取中间节点构造的二叉树就是高度平衡的二叉搜索树呢?</p>
<p>先按照这个思路，把代码写出来</p>
<ol>
<li>按照先序遍历思路，先找到根节点，构造出中间节点。</li>
<li>根据中间节点划定新的数组的范围，左边和右边，然后递归找到新的数组的中间节点继续划出范围.</li>
</ol>
<p>在这里 左闭右闭更合理</p>
<p>这题主要注意边界值,if (left &gt; right）这个要注意是&gt; 没有=,因为index-1和index+1了，所以最终一定会超过right</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sortedArrayToBST</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">return</span> buildSearchTree(nums, <span class="number">0</span>, nums.size - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">buildSearchTree</span><span class="params">(nums: <span class="type">IntArray</span>, left: <span class="type">Int</span>, right: <span class="type">Int</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> index = <span class="comment">/*(start + end) / 2*/</span> left + (right - left) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">val</span> node = TreeNode(nums[index])</span><br><span class="line">    <span class="comment">// println(&quot;node $&#123;node.`val`&#125; :  start $left end $right&quot;)</span></span><br><span class="line">    node.left = buildSearchTree(nums, left, index - <span class="number">1</span>)</span><br><span class="line">    node.right = buildSearchTree(nums, index + <span class="number">1</span>, right)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538. 把二叉搜索树转换为累加树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></h4><p>累加树: 按照中序遍历的到的 从小到大的数组 [1,2,3,4] ,累加树就是右到左的值相加 [10,9,7,4]</p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0538.%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91.html#%E9%80%92%E5%BD%92">https://programmercarl.com/0538.%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91.html#%E9%80%92%E5%BD%92</a></p>
<p>中序遍历的树 : 左 中 右 2 , 5, 13</p>
<p>反中序遍历的: 右 中 左 13 , 5 , 2</p>
<p>然后按照反中序遍历的到节点累加就可以了。</p>
<img src="https://img-blog.csdnimg.cn/20210204153440666.png" alt="538.把二叉搜索树转换为累加树" style="zoom:50%;">



<p>这一题一开始没想上面的思路，看了随想录的思路后,写出来的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">convertBST</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    convertBST(root.right)</span><br><span class="line">    sum += root.`<span class="keyword">val</span>`</span><br><span class="line">    root.`<span class="keyword">val</span>` = sum</span><br><span class="line">    convertBST(root.left)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>根据中序遍历的规则，写出反中序 右中左遍历节点。</li>
<li>拿到每次中序的到的节点累加，然后赋值给当前节点。</li>
</ol>
<pre><code>sum += root.`val`
root.`val` = sum
</code></pre>
<p>这一段可以改进，可以保存前一个节点值，然后加上当前节点就可以了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pre = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">convertBST1</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    convertBST(root.right)</span><br><span class="line">    root.`<span class="keyword">val</span>` += pre</span><br><span class="line">    pre = root.`<span class="keyword">val</span>`</span><br><span class="line">    convertBST(root.left)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-09-11T07:39:49.000Z" title="9/11/2022, 3:39:49 PM">2022-09-11</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-01-02T03:31:39.080Z" title="1/2/2023, 11:31:39 AM">2023-01-02</time></span><span class="level-item"><a class="link-muted" href="/categories/DataStructure/">DataStructure</a></span><span class="level-item">41 minutes read (About 6077 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/09/11/LC-TREE08/">LC_TREE08</a></p><div class="content"><h4 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></h4><h5 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h5><p>层序遍历是没法实现的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isSymmetric3</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.offer(root)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">            <span class="keyword">val</span> layerSize = queue.size</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until layerSize) &#123;</span><br><span class="line"><span class="comment">//                val lastIndex = layerSize - 1 - i // 这样不可以,poll取出元素后，就少了元素越界了</span></span><br><span class="line">                <span class="keyword">val</span> headNode = queue.poll()</span><br><span class="line"></span><br><span class="line">                <span class="keyword">val</span> lastNode = queue.lastOrNull()</span><br><span class="line">                <span class="keyword">if</span> (headNode.`<span class="keyword">val</span>` != lastNode?.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">                headNode.left?.let &#123; queue.offer(it) &#125;</span><br><span class="line">                headNode.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><p>// 不能判断true,判断true直接返回了，判断false返回没问题，true返回就不会往下走了</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">leftRightSymmetric</span><span class="params">(nodeLeft: <span class="type">TreeNode</span>?, nodeRight: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nodeLeft?.`<span class="keyword">val</span>` == nodeRight?.`<span class="keyword">val</span>`) &#123; <span class="comment">// 不能判断true,判断true直接返回了，判断false返回没问题，true返回就不会往下走了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeLeft == nodeRight) &#123; <span class="comment">// = null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    leftRightSymmetric(nodeLeft?.left, nodeRight?.right)</span><br><span class="line">    leftRightSymmetric(nodeLeft?.right, nodeRight?.left)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E9%80%92%E5%BD%92%E6%B3%95">https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E9%80%92%E5%BD%92%E6%B3%95</a></p>
<p>从根节点的左右子树开始，深度遍历比较</p>
<p><img src="https://img-blog.csdnimg.cn/20210203144624414.png"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isSymmetric</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> leftRightSymmetric(root?.left, root?.right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">leftRightSymmetric</span><span class="params">(nodeLeft: <span class="type">TreeNode</span>?, nodeRight: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nodeLeft == <span class="literal">null</span> &amp;&amp; nodeRight != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeLeft != <span class="literal">null</span> &amp;&amp; nodeRight == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeLeft?.`<span class="keyword">val</span>` != nodeRight?.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeLeft == <span class="literal">null</span> &amp;&amp; nodeRight == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">//这里需要，否则就递归 溢出了,如果根节点的左右节点为null,退出也是没问题的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> leftFlag = leftRightSymmetric(nodeLeft?.left, nodeRight?.right)</span><br><span class="line">    <span class="keyword">val</span> rightFlag = leftRightSymmetric(nodeLeft?.right, nodeRight?.left)</span><br><span class="line">    <span class="keyword">return</span> leftFlag &amp;&amp; rightFlag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnwcimlj8lg30hm0bqnpd.gif"></p>
<p>队列，一直向下按照对称的条件添加</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isSymmetric1</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123; </span><br><span class="line">        root.left?.let &#123; queue.offer(it) &#125; <span class="comment">// 官方解法中，根节点入队2次也可以</span></span><br><span class="line">        root.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> node1 = queue.poll()</span><br><span class="line">        <span class="keyword">val</span> node2 = queue.poll()</span><br><span class="line">        <span class="keyword">if</span>(node1==<span class="literal">null</span>&amp;&amp;node2==<span class="literal">null</span>)&#123; <span class="comment">// 一开始没写这个条件，提示超出时间限制</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node1?.`<span class="keyword">val</span>` != node2?.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        queue.offer(node1?.left) <span class="comment">// 两边的节点比较</span></span><br><span class="line">        queue.offer(node2?.right)</span><br><span class="line">        queue.offer(node1?.right) <span class="comment">//中间的节点比较</span></span><br><span class="line">        queue.offer(node2?.left)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>栈也是可以的，只要保证位置靠近</p>
<h4 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/same-tree/">100. 相同的树</a></h4><h5 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isSameTree</span><span class="params">(p: <span class="type">TreeNode</span>?, q: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span> &amp;&amp; q != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p?.`<span class="keyword">val</span>` == q?.`<span class="keyword">val</span>` &amp;&amp; isSameTree(p?.left, q?.left) &amp;&amp; isSameTree(p?.right, q?.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="队列-1"><a href="#队列-1" class="headerlink" title="队列"></a>队列</h5><img src="/2022/09/11/LC-TREE08/20220912130345.jpg" alt="20220912130345" style="zoom: 67%;">

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isSameTree1</span><span class="params">(p: <span class="type">TreeNode</span>?, q: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span> &amp;&amp; q != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    queue.offer(p)</span><br><span class="line">    queue.offer(q)</span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> node1 = queue.poll()</span><br><span class="line">        <span class="keyword">val</span> node2 = queue.poll()</span><br><span class="line">        <span class="keyword">if</span> (node1 == <span class="literal">null</span> &amp;&amp; node2 == <span class="literal">null</span>) &#123; <span class="comment">// continue后，因为null,就不会加入新的节点</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node1?.`<span class="keyword">val</span>` != node2?.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        queue.offer(node1?.left)</span><br><span class="line">        queue.offer(node2?.left)</span><br><span class="line">        queue.offer(node1?.right)</span><br><span class="line">        queue.offer(node2?.right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="572-另一棵树的子树"><a href="#572-另一棵树的子树" class="headerlink" title="572. 另一棵树的子树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subtree-of-another-tree/">572. 另一棵树的子树</a></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isSubtree</span><span class="params">(root: <span class="type">TreeNode</span>?, subRoot: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span> &amp;&amp; subRoot == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root == <span class="literal">null</span> &amp;&amp; subRoot != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root != <span class="literal">null</span> &amp;&amp; subRoot == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isSameTree(root, subRoot) || isSubtree(root?.left, subRoot) || isSubtree(root?.right, subRoot) <span class="comment">//subRoot和root相同,subRoot和root左子树相同，subRoot和右子树相同</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isSameTree</span><span class="params">(node1: <span class="type">TreeNode</span>?, node2: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node1 == <span class="literal">null</span> &amp;&amp; node2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node1 == <span class="literal">null</span> &amp;&amp; node2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node1 != <span class="literal">null</span> &amp;&amp; node2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node1?.`<span class="keyword">val</span>` == node2?.`<span class="keyword">val</span>` &amp;&amp; isSameTree(node1?.left, node2?.left) &amp;&amp; isSameTree(</span><br><span class="line">        node1?.right,</span><br><span class="line">        node2?.right</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h4><h5 id="DFS-普通二叉树解法"><a href="#DFS-普通二叉树解法" class="headerlink" title="DFS 普通二叉树解法"></a>DFS 普通二叉树解法</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countNodes</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> leftCount = countNodes(root.left)</span><br><span class="line">    <span class="keyword">val</span> rightCount = countNodes(root.right)</span><br><span class="line">    <span class="keyword">return</span> leftCount + rightCount + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countNodes1</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.offer(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> size = queue.size</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until size) &#123;</span><br><span class="line">            <span class="keyword">val</span> treeNode = queue.poll()</span><br><span class="line">            count++</span><br><span class="line">            treeNode.left?.let &#123; queue.offer(it) &#125;</span><br><span class="line">            treeNode.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="DFS-完全二叉树特性"><a href="#DFS-完全二叉树特性" class="headerlink" title="DFS 完全二叉树特性"></a>DFS 完全二叉树特性</h5><p>一开始打算用先序遍历，但是这样不行,</p>
<p>如果一颗树 是平衡的，永远是得到 1,  想了一下，这种也不属于 先序遍历</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countNodes</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> depth = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> postTraversal(root, depth)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">postTraversal</span><span class="params">(root: <span class="type">TreeNode</span>?, depth: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isBalanced(root)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> shl (depth - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> leftNums = postTraversal(root?.left, depth + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> rightNums = postTraversal(root?.right, depth + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> leftNums + rightNums + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countNodes</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> leftNode = root.left</span><br><span class="line">    <span class="keyword">var</span> depthLeft = <span class="number">0</span> <span class="comment">//左子树深度</span></span><br><span class="line">    <span class="keyword">while</span> (leftNode != <span class="literal">null</span>) &#123;</span><br><span class="line">        leftNode = leftNode.left</span><br><span class="line">        depthLeft++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> rightNode = root.right</span><br><span class="line">    <span class="keyword">var</span> depthRight = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (rightNode != <span class="literal">null</span>) &#123;</span><br><span class="line">        rightNode = rightNode.right</span><br><span class="line">        depthRight++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (depthLeft == depthRight) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">2</span> shl depthLeft) - <span class="number">1</span> <span class="comment">// 节点数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> leftNums = countNodes(root.left)</span><br><span class="line">    <span class="keyword">val</span> rightNums = countNodes(root.right)</span><br><span class="line">    <span class="keyword">return</span> leftNums + rightNums + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countNodes3</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> leftNode = root.left</span><br><span class="line">    <span class="keyword">var</span> depthLeft = <span class="number">0</span> <span class="comment">//左子树深度</span></span><br><span class="line">    <span class="keyword">while</span> (leftNode != <span class="literal">null</span>) &#123;</span><br><span class="line">        leftNode = leftNode.left</span><br><span class="line">        depthLeft++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> rightNode = root.right</span><br><span class="line">    <span class="keyword">var</span> depthRight = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (rightNode != <span class="literal">null</span>) &#123;</span><br><span class="line">        rightNode = rightNode.right</span><br><span class="line">        depthRight++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> leftNums = countNodes(root.left)</span><br><span class="line">    <span class="keyword">val</span> rightNums = countNodes(root.right)</span><br><span class="line">    <span class="keyword">if</span> (depthLeft == depthRight) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">2</span> shl depthLeft) - <span class="number">1</span> <span class="comment">// 节点数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> leftNums + rightNums + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树</a></h4><p>一开始错误的解答是这样的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isBalanced</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> postTraversal(root) != -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">postTraversal</span><span class="params">(node: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> leftDepth = postTraversal(node.left)</span><br><span class="line">        <span class="keyword">val</span> rightDepth = postTraversal(node.right)</span><br><span class="line">        <span class="keyword">val</span> isBalance = Math.abs(leftDepth - rightDepth) &lt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (isBalance) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(leftDepth, rightDepth) + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里问题是   return -1，作为父节点的深度返回给了 depth，然后继续计算 Math.abs(leftDepth - rightDepth) &lt;= 1，出现了问题</p>
<p>改进解法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isBalanced</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> postTraversal(root) != -<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">postTraversal</span><span class="params">(node: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> leftDepth = postTraversal(node.left)</span><br><span class="line">    <span class="keyword">val</span> rightDepth = postTraversal(node.right)</span><br><span class="line">    <span class="keyword">if</span> (leftDepth == -<span class="number">1</span> || rightDepth == -<span class="number">1</span>) &#123; <span class="comment">// 子节点已经有不是平衡的节点 直接返回，来判断</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> isBalance = Math.abs(leftDepth - rightDepth) &lt;= <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (isBalance) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftDepth, rightDepth) + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>随想录迭代遍历，看起来很复杂，看起来是统一解法.</p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E9%A2%98%E5%A4%96%E8%AF%9D">https://programmercarl.com/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E9%A2%98%E5%A4%96%E8%AF%9D</a></p>
<h4 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-paths/">257. 二叉树的所有路径</a></h4><h5 id="隐藏回溯过程"><a href="#隐藏回溯过程" class="headerlink" title="隐藏回溯过程"></a>隐藏回溯过程</h5><p>这一题 没理解透字符串怎么形成的和回溯的, 用到了先序遍历，</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ZG411G7Dh">https://www.bilibili.com/video/BV1ZG411G7Dh</a> 视频包含了回溯过程</p>
<p> 可以看下随想录回溯过程</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">binaryTreePaths</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: List&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> result = LinkedList&lt;String&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    dfs(root, result, root.`<span class="keyword">val</span>`.toString())</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://www.youtube.com/watch?v=swG70SQBJ-A</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. String不能用 StringBuilder,存在引用传递问题，会输出</span></span><br><span class="line"><span class="comment"> *    [&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;2-&gt;5-&gt;3&quot;]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. 在先序位置 val存到path也有问题,头节点会存在重复的情况 [&quot;1-&gt;1-&gt;2-&gt;5&quot;,&quot;1-&gt;1-&gt;2-&gt;5-&gt;3&quot;]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(node: <span class="type">TreeNode</span>?, result: <span class="type">LinkedList</span>&lt;<span class="type">String</span>&gt;, path: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        result.add(path)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        dfs(node.left, result, <span class="string">&quot;<span class="variable">$path</span>-&gt;<span class="subst">$&#123;node.left.`val`&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        dfs(node.right, result, <span class="string">&quot;<span class="variable">$path</span>-&gt;<span class="subst">$&#123;node.right.`val`&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面2的情况演示</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(node: <span class="type">TreeNode</span>?, result: <span class="type">LinkedList</span>&lt;<span class="type">String</span>&gt;, path: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">val</span> mPath = <span class="string">&quot;<span class="variable">$path</span>-&gt; <span class="subst">$&#123;node.`val`&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        result.add(mPath)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        dfs(node.left, result, mPath)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        dfs(node.right, result, mPath)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面两种写法，回溯隐藏在参数里面.</p>
<h5 id="显示回溯"><a href="#显示回溯" class="headerlink" title="显示回溯"></a>显示回溯</h5><p>这是随想录的代码，二刷可以自己写, </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">binaryTreePaths</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: List&lt;String&gt;? &#123;</span><br><span class="line">    <span class="keyword">val</span> res: MutableList&lt;String&gt; = ArrayList()</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> paths: MutableList&lt;<span class="built_in">Int</span>&gt; = ArrayList()</span><br><span class="line">    traversal(root, paths, res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">traversal</span><span class="params">(root: <span class="type">TreeNode</span>, paths: <span class="type">MutableList</span>&lt;<span class="type">Int</span>&gt;, res: <span class="type">MutableList</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    paths.add(root.`<span class="keyword">val</span>`)</span><br><span class="line">    <span class="comment">// 叶子结点</span></span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123; <span class="comment">// 碰到叶子节点，开始把path遍历放进string中 </span></span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        <span class="keyword">val</span> sb = StringBuilder()</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until paths.size - <span class="number">1</span>) &#123;</span><br><span class="line">            sb.append(paths[i]).append(<span class="string">&quot;-&gt;&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(paths[paths.size - <span class="number">1</span>]) <span class="comment">//也可以放到上面一起再把&quot;-&gt;&quot; 删除</span></span><br><span class="line">        res.add(sb.toString()) </span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        traversal(root.left, paths, res)</span><br><span class="line">        paths.removeAt(paths.size - <span class="number">1</span>) <span class="comment">// 回溯  </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        traversal(root.right, paths, res)</span><br><span class="line">        paths.removeAt(paths.size - <span class="number">1</span>) <span class="comment">// 回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paths.removeAt(paths.size - 1) 最初这里没理解，都删除了，为什么,上面还能遍历所有节点，其实递归是一致先走的，碰到叶子节点的时候，遍历path, 最后才开始 paths.removeAt(paths.size - 1) 回溯 到上面. </span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html">https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ZG411G7Dh">https://www.bilibili.com/video/BV1ZG411G7Dh</a></p>
<p>迭代法 后面再说吧</p>
<h4 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404. 左叶子之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-left-leaves/">404. 左叶子之和</a></h4><p>这一题和【 222 完全二叉树的节点个数】很像，这里是普通的二叉树，所以我的想法就前两种做法</p>
<ol>
<li>后序遍历</li>
<li>层序遍历</li>
</ol>
<p>把根节点换成左子树的节点</p>
<p>看错了题目，其实是左子树叶子值的和</p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C.html#%E6%80%9D%E8%B7%AF">https://programmercarl.com/0404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C.html#%E6%80%9D%E8%B7%AF</a></p>
<p>只看了随想录题解，自己这样写的代码</p>
<h5 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sumOfLeftLeaves</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> dfsLeaves(root, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> direction 0 右子树， 1：左子树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dfsLeaves</span><span class="params">(node: <span class="type">TreeNode</span>?, direction: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span> &amp;&amp; direction == <span class="number">1</span>) &#123; <span class="comment">// 左右子树为空，根据父亲节点的传入，判断它是左子树</span></span><br><span class="line">        <span class="keyword">return</span> node.`<span class="keyword">val</span>` <span class="comment">//这种情况返回值，根据后序规则，上层节点叠加</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> leftCount = dfsLeaves(node.left, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> rightCount = dfsLeaves(node.right, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> leftCount + rightCount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>看了随想录解法，可以直接看更下一层节点，就不用再传入方向了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">          leftValue = root-&gt;left-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>迭代法</p>
<p>随想录统一迭代法</p>
<h4 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513. 找树左下角的值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513. 找树左下角的值</a></h4><p>想了下</p>
<ol>
<li>层序遍历可以解决</li>
<li>递归法还没想道，到了最底层，没想到如何判断 哪个是最左边的。</li>
</ol>
<h5 id="BFS-1"><a href="#BFS-1" class="headerlink" title="BFS"></a>BFS</h5><p>先存下来每一层的第一个节点，知道queue为空，那么最后一层的头节点就是要返回的.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findBottomLeftValue1</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.offer(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> leftNodeVal = root?.`<span class="keyword">val</span>`</span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> size = queue.size</span><br><span class="line">        leftNodeVal = queue.peek().`<span class="keyword">val</span>` <span class="comment">//每一层的第一个节点</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until size) &#123;</span><br><span class="line">            <span class="keyword">val</span> node = queue.poll()</span><br><span class="line">            node?.left?.let &#123; queue.offer(it) &#125;</span><br><span class="line">            node?.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> leftNodeVal!! <span class="comment">// queue为empty的时候退出，此时上一层存的节点就是最左边的节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h5><p>My idea</p>
<ol>
<li><p>一开始以为树的层级里，树的左边的值小于右边，来得出结果，但是这是二叉树，不是平衡形的，即使平衡这种思路也不一定对.</p>
</li>
<li><p>然后又看了树结构,想了下可以用 inorder traversal ,中序遍历, 层数最深，然后最先得到的数据就是要拿到的结果. </p>
<p>想下面8肯定是后面遍历到的</p>
</li>
</ol>
<p><img src="/2022/09/11/LC-TREE08/20220924155016.jpg" alt="20220924155016"></p>
<ol>
<li>一开始不知道leetcode可以用全局变量，用对象返回还很麻烦，删掉了</li>
<li>判断层级，如果大于之前的深度，那么就更新深度和值</li>
<li>中序和后序肯定没问题，但是先序不确定（随想录说是可以的）而且随想录 depth + 1 展开了用回溯</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mDepth = <span class="number">0</span> <span class="comment">//一开始不知道leetcode可以用全局变量，用对象返回还很麻烦，删掉了</span></span><br><span class="line"><span class="keyword">var</span> result = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findBottomLeftValue</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    inOrderTraversal(root, mDepth)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最左边的节点最先访问到</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">inOrderTraversal</span><span class="params">(node: <span class="type">TreeNode</span>?, depth: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">    inOrderTraversal(node.left, depth + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> (depth + <span class="number">1</span> &gt; mDepth) &#123; <span class="comment">// 判断层级，如果大于之前的深度，那么就更新深度和值</span></span><br><span class="line">        mDepth = depth + <span class="number">1</span></span><br><span class="line">        result = node.`<span class="keyword">val</span>`</span><br><span class="line">    &#125;</span><br><span class="line">    inOrderTraversal(node.right, depth + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum/">112. 路径总和</a></h4><p>解决所有二叉树路径的问题文章</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-ii/solution/yi-pian-wen-zhang-jie-jue-suo-you-er-cha-oo63/">https://leetcode.cn/problems/path-sum-ii/solution/yi-pian-wen-zhang-jie-jue-suo-you-er-cha-oo63/</a></p>
<p>这一题和  [112. 路径总和]  类似</p>
<p>使用回溯写法，因为添加和删除，回溯的规则，那么感觉用栈比较合适.</p>
<ol>
<li>终止条件就是 到达了叶子节点，此时开始计算当前路径和 是否满足条件</li>
<li>手写判断是否有左子树，有的话继续判断，又继续preOrderTraversal, 这里用的是先序遍历,方法查看条件</li>
<li>遍历完叶子节点后判断，此时这条路径完成，开始回溯，回退上一层preOrderTraversal，继续判断右子树</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">hasPathSum</span><span class="params">(root: <span class="type">TreeNode</span>?, targetSum: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> pathStack = Stack&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        pathStack.push(root.`<span class="keyword">val</span>`) <span class="comment">// root需要放在遍历外面，否则会push多次</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">//按照前面的规则 root==null ,0 应该是对的,但是题目说false,就单独加一句</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> preOrderTraversal(root, targetSum, pathStack) <span class="comment">// pathstack必须传进去，否则每次都new</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">preOrderTraversal</span><span class="params">(root: <span class="type">TreeNode</span>?, targetSum: <span class="type">Int</span>, pathStack: <span class="type">Stack</span>&lt;<span class="type">Int</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root?.left == <span class="literal">null</span> &amp;&amp; root?.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> pathSum = <span class="number">0</span></span><br><span class="line">        pathStack.forEach &#123;</span><br><span class="line">            pathSum += it</span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;pathSum <span class="variable">$pathSum</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (pathSum == targetSum) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root?.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        pathStack.push(root.left.`<span class="keyword">val</span>`) <span class="comment">// 有左节点，加入当前路径</span></span><br><span class="line">        <span class="keyword">if</span> (preOrderTraversal(root.left, targetSum, pathStack)) &#123; <span class="comment">//有路径是和 == targetSum 直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        pathStack.pop()  <span class="comment">// 不会直接把上面的回退了，需要上一句遍历执行完回退后，才把自己回退了，此时已经到了叶子判断了 root?.left == null &amp;&amp; root?.right == null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root?.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        pathStack.push(root.right.`<span class="keyword">val</span>`)</span><br><span class="line">        <span class="keyword">if</span> (preOrderTraversal(root.right, targetSum, pathStack)) &#123; <span class="comment">//有路径是和 == targetSum 直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        pathStack.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">hasPathSum1</span><span class="params">(root: <span class="type">TreeNode</span>?, targetSum: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">//按照前面的规则 root==null ,0 应该是对的,但是题目说false,就单独加一句</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> pathSum = root.`<span class="keyword">val</span>`</span><br><span class="line">    <span class="keyword">return</span> preOrderDFS(root, pathSum, targetSum) <span class="comment">// pathstack必须传进去，否则每次都new</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">preOrderDFS</span><span class="params">(node: <span class="type">TreeNode</span>, pathSum: <span class="type">Int</span>, targetSum: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> nodeValue = node.`<span class="keyword">val</span>`</span><br><span class="line">    println(<span class="string">&quot;nodeValue <span class="variable">$nodeValue</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span> &amp;&amp; targetSum == pathSum) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">if</span> (preOrderDFS(node.left, pathSum + node.left.`<span class="keyword">val</span>`, targetSum)) &#123; <span class="comment">// 这个直接放回，容易忘了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">if</span> (preOrderDFS(node.right, pathSum + node.right.`<span class="keyword">val</span>`, targetSum)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II</a></h4><p>如果是找路径和等于给定target的路径的，那么可以不用新增一个临时变量cursum来判断当前路径和，<br>只需要用给定和target减去节点值，最终结束条件判断target==0即可</p>
<h5 id="DFS-1"><a href="#DFS-1" class="headerlink" title="DFS"></a>DFS</h5><p>这一题的思路和前面的差不多，就是他要求返回所有符合条件的集合，所以直接添加值觉得不合适，除非多加一个参数，不加一个参数就不好弄。</p>
<p>//这种解法要注意 值引用问题，即使最初加入到resultList的pathList是正确的，后序的回退也会把值给修改了.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> resultList = LinkedList&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">pathSum</span><span class="params">(root: <span class="type">TreeNode</span>?, targetSum: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> resultList</span><br><span class="line">    <span class="keyword">val</span> stackList = Stack&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    stackList.add(root.`<span class="keyword">val</span>`)</span><br><span class="line">    preDFS(root, stackList, targetSum)</span><br><span class="line">    <span class="keyword">return</span> resultList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">preDFS</span><span class="params">(node: <span class="type">TreeNode</span>, pathList: <span class="type">Stack</span>&lt;<span class="type">Int</span>&gt;, targetSum: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = node.`<span class="keyword">val</span>`</span><br><span class="line">    println(<span class="keyword">data</span>)</span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span> &amp;&amp; pathSum(pathList) == targetSum) &#123;</span><br><span class="line">        resultList.add(pathList.toMutableList().toList()) <span class="comment">// 注意引用传递</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        pathList.push(node.left.`<span class="keyword">val</span>`)</span><br><span class="line">        preDFS(node.left, pathList, targetSum)</span><br><span class="line">        pathList.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        pathList.push(node.right.`<span class="keyword">val</span>`)</span><br><span class="line">        preDFS(node.right, pathList, targetSum)</span><br><span class="line">        pathList.pop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">pathSum</span><span class="params">(pathList: <span class="type">Stack</span>&lt;<span class="type">Int</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    pathList.forEach &#123;</span><br><span class="line">        sum += it</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这一题的官方DFS解法没看懂，感觉不好理解.</p>
<p>这是看完官方写法自己写的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> pathList = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">pathSum1</span><span class="params">(root: <span class="type">TreeNode</span>?, targetSum: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> resultList</span><br><span class="line">    <span class="keyword">val</span> stackList = Stack&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    stackList.add(root.`<span class="keyword">val</span>`)</span><br><span class="line">    preTraversal(root, targetSum - root.`<span class="keyword">val</span>`)</span><br><span class="line">    <span class="keyword">return</span> resultList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">preTraversal</span><span class="params">(node: <span class="type">TreeNode</span>?, targetSum: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = node.`<span class="keyword">val</span>`</span><br><span class="line">    println(<span class="keyword">data</span>)</span><br><span class="line">    pathList.offer(node.`<span class="keyword">val</span>`)</span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span> &amp;&amp; targetSum == <span class="number">0</span>) &#123;</span><br><span class="line">        resultList.add(pathList.toMutableList())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="literal">null</span>)</span><br><span class="line">        preTraversal(node.left, targetSum - node.left.`<span class="keyword">val</span>`)</span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="literal">null</span>)</span><br><span class="line">        preTraversal(node.right, targetSum - node.right.`<span class="keyword">val</span>`)</span><br><span class="line">    pathList.pop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这是官方解法，也很棒</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">pathSum2</span><span class="params">(root: <span class="type">TreeNode</span>?, targetSum: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> resultList</span><br><span class="line">    <span class="keyword">val</span> stackList = Stack&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    stackList.add(root.`<span class="keyword">val</span>`)</span><br><span class="line">    preDFSTraversal(root, targetSum)</span><br><span class="line">    <span class="keyword">return</span> resultList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">preDFSTraversal</span><span class="params">(node: <span class="type">TreeNode</span>?, targetSum: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = node.`<span class="keyword">val</span>`</span><br><span class="line">    println(<span class="keyword">data</span>)</span><br><span class="line">    <span class="keyword">val</span> targetSum = targetSum - node.`<span class="keyword">val</span>`</span><br><span class="line">    pathList.offer(node.`<span class="keyword">val</span>`)</span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span> &amp;&amp; targetSum == <span class="number">0</span>) &#123;</span><br><span class="line">        resultList.add(pathList.toMutableList())</span><br><span class="line">    &#125;</span><br><span class="line">    preDFSTraversal(node.left, targetSum)</span><br><span class="line">    preDFSTraversal(node.right, targetSum)</span><br><span class="line">    pathList.pop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>官方BFS 就很不好理解</p>
<h3 id="构建树"><a href="#构建树" class="headerlink" title="构建树"></a>构建树</h3><p>先序，中序</p>
<p>后序，中序</p>
<p>inOrder         [L, 3 ,R ]</p>
<p>PostOrder     [L, R, 3] </p>
<p>PreOrder       [3,L ,R]<br>可以看到 只有PostOrder ,PreOrder左右是分不清的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> 			1    					1 </span><br><span class="line"> 		2									2</span><br><span class="line">  3											3</span><br><span class="line">  </span><br><span class="line">PreOrder  1,2,3				PreOrder  1,2,3</span><br><span class="line">PostOrder 3,2,1 			PostOrder 3,2,1</span><br></pre></td></tr></table></figure>



<h4 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h4><p>效率低，但是好理解的方法</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1pp4y1k75Q/">https://www.bilibili.com/video/BV1pp4y1k75Q/</a></p>
<p>为什么post右子树是从 , [i , n-1],因为他是后序遍历，所以从 i开始</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inorder &#x3D; 	[9,3,15,20,7]</span><br><span class="line">postorder &#x3D; [9,15,7,20,3]</span><br></pre></td></tr></table></figure>

<ol>
<li><p>根据后序postorder 得到root 3, 然后根据中序知道 left branch [9] , right branch [15 , 20 , 7]</p>
</li>
<li><p>根据 left branch 的9,可以把 postorder后序分成[9], [15 , 20 , 7]两部分</p>
</li>
<li><p>然后 inorder= [15 , 20 , 7] , postorder=[15 , 20 , 7] 继续进行遍历</p>
</li>
</ol>
<p>总的来说，就是这样</p>
<ol>
<li>确定终止条件</li>
<li>构造节点</li>
<li>构造左子树， 构造右子树</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">buildTree</span><span class="params">(inorder: <span class="type">IntArray</span>, postorder: <span class="type">IntArray</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (inorder.isEmpty() &amp;&amp; postorder.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> node = TreeNode(postorder[postorder.size - <span class="number">1</span>]) <span class="comment">//postorder.size用的地方多，可以提取出来</span></span><br><span class="line">    <span class="keyword">val</span> index = getIndex(node, inorder)</span><br><span class="line">    node.left = buildTree(inorder.copyOfRange(<span class="number">0</span>, index), postorder.copyOfRange(<span class="number">0</span>, index)) <span class="comment">// copyOfRange数组效率低</span></span><br><span class="line">    node.right = buildTree(</span><br><span class="line">        inorder.copyOfRange(index + <span class="number">1</span>, inorder.size), postorder.copyOfRange(index, postorder.size - <span class="number">1</span>)</span><br><span class="line">    ) <span class="comment">// 注意copyOfRange(0,2)获取的是index 0,1两个元素</span></span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getIndex</span><span class="params">(node: <span class="type">TreeNode</span>, inorder: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> inorder.indices) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.`<span class="keyword">val</span>` == inorder[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h5><p>写出来还有问题,先pass这题耗时太久了,边界不好掌握可以考虑用日志调试</p>
<p>还可以再看下随想录的视频讲解</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1vW4y1i7dn">https://www.bilibili.com/video/BV1vW4y1i7dn</a></p>
<p>随想录代码优化前的写法，和上面代码写法是一样的，只是用了C++语言</p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html">https://programmercarl.com/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html</a></p>
<p>最初错误的解法,上面的解法数组有变化所以 end位置就是数组的大小，但是这里不同，数组是没变化，就不能这样做</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 数组不变，只改变下标</span><br><span class="line">private fun buildDFSTree(</span><br><span class="line">    inorder: IntArray,</span><br><span class="line">    postorder: IntArray,</span><br><span class="line">    inStart: Int,</span><br><span class="line">    inEnd: Int,</span><br><span class="line">    postStart: Int,</span><br><span class="line">    postEnd: Int</span><br><span class="line">): TreeNode? &#123;</span><br><span class="line">    if (inStart &gt; inEnd || postStart &gt; postEnd || inEnd &lt; 0 || postEnd &lt; 0) &#123;</span><br><span class="line">        return null</span><br><span class="line">    &#125;</span><br><span class="line">    val node &#x3D; TreeNode(postorder[postEnd]) &#x2F;&#x2F;postorder.size用的地方多，可以提取出来</span><br><span class="line">    val index &#x3D; getIndex(node, inorder)</span><br><span class="line"></span><br><span class="line">    node.left &#x3D; buildDFSTree(inorder, postorder, inStart, index - 1, 0, index - 1)   &#x2F;&#x2F;[0,index) 左闭右开</span><br><span class="line">    node.right &#x3D; buildDFSTree(inorder, postorder, index + 1, inEnd, index + 1, postEnd)</span><br><span class="line">    return node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这一题花了不少时间，思路不难，主要是 切割后序的数组的时候，左右子树的边界值不好处理,</p>
<ol>
<li>map用来存储，中序value值和position的对应关系，这里value应该是唯一的.</li>
<li>采用的是左闭右闭的方案，所以inStart &gt; inEnd 不能用 &gt;=, 否则return了，叶子节点无法构造出来.</li>
<li>根据后序root节点，分割中序数组，拿到左子树后，再用左子树树的分割后序数组,因为左子树的长度是一样的。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> map = HashMap&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">buildTree1</span><span class="params">(inorder: <span class="type">IntArray</span>, postorder: <span class="type">IntArray</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (inorder.isEmpty() &amp;&amp; postorder.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> inStart = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> inEnd = inorder.size - <span class="number">1</span></span><br><span class="line">    <span class="keyword">val</span> postStart = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> postEnd = postorder.size - <span class="number">1</span></span><br><span class="line">    inorder.forEachIndexed &#123; position, item -&gt;</span><br><span class="line">        map[item] = position</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buildDFSTree(inStart, inEnd, postStart, postEnd, inorder, postorder)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组不变，只改变下标</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">buildDFSTree</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    inStart: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    inEnd: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    postStart: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    postEnd: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    inorderArr: <span class="type">IntArray</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    postorderArr: <span class="type">IntArray</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: TreeNode? &#123;</span><br><span class="line">    println(<span class="string">&quot; inStart <span class="variable">$inStart</span> inEnd <span class="variable">$inEnd</span>  postStart <span class="variable">$postStart</span> postEnd <span class="variable">$postEnd</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> (inStart &gt; inEnd || postStart &gt; postEnd) &#123; <span class="comment">// 因为是左闭右闭的方案，所以这里不能用 &gt;= ,否则叶子节点无法构造出来</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> node = TreeNode(postorderArr[postEnd]) <span class="comment">//postorder.size用的地方多，可以提取出来</span></span><br><span class="line">    <span class="keyword">val</span> index = map[postorderArr[postEnd]] ?: <span class="number">0</span> <span class="comment">// 这里要改</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切割左子树,这种坐标定义好更清晰</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> leftInBegin = inStart</span><br><span class="line">    <span class="keyword">val</span> leftInEnd = index - <span class="number">1</span> <span class="comment">// 左闭右闭</span></span><br><span class="line">    <span class="keyword">val</span> leftPostBegin = postStart</span><br><span class="line">    <span class="keyword">val</span> leftPostEnd = postStart + (index - inStart - <span class="number">1</span>) <span class="comment">//(index - inStart) 左子树的长度, 因为选择是左闭右闭的方案，所以自身也-1</span></span><br><span class="line"></span><br><span class="line">    node.left = buildDFSTree(</span><br><span class="line">        leftInBegin, leftInEnd, leftPostBegin, leftPostEnd,</span><br><span class="line">        inorderArr,</span><br><span class="line">        postorderArr</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切割右子树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> rightInBegin = index + <span class="number">1</span></span><br><span class="line">    <span class="keyword">val</span> rightInEnd = inEnd</span><br><span class="line">    <span class="keyword">val</span> rightPostBegin = postStart + index - inStart <span class="comment">//(index - inStart) 这里不用-1,因为左子树的右边就是右子树，所以右子树就是从这个位置开始的</span></span><br><span class="line">    <span class="keyword">val</span> rightPostEnd = postEnd - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    node.right = buildDFSTree(</span><br><span class="line">        rightInBegin, rightInEnd, rightPostBegin, rightPostEnd,</span><br><span class="line">        inorderArr,</span><br><span class="line">        postorderArr</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>官方</p>
<p>先构建右子树的想法好巧妙，要是先构建的是左子树还有个确定后序区间的步骤。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution/cong-zhong-xu-yu-hou-xu-bian-li-xu-lie-gou-zao-14/">https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution/cong-zhong-xu-yu-hou-xu-bian-li-xu-lie-gou-zao-14/</a></p>
<p>官方解法很妙，根据后序数组pop，post_idx–;先开始右子树,然后左子树,构造方法也很简单，这样不用找后序数组的 开始和结束位置在哪. 做了上面的解法，也就是这个后序的边界值最难搞. 这种方式直接给省去了。</p>
<p>不得不说太妙了</p>
<p><img src="https://assets.leetcode-cn.com/solution-static/106/6.png"></p>
<p>官方迭代法后面再看吧 。</p>
<h4 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654. 最大二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-binary-tree/">654. 最大二叉树</a></h4><p>输入：nums = [3,2,1,6,0,5]<br>输出：[6,3,5,null,2,0,null,null,1]<br>解释：递归调用如下所示：</p>
<p>[3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。</p>
<ul>
<li>[3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。 ,3的左边是[]没有节点, 右边是[0,5],所以树也是这样构造的.<ul>
<li>空数组，无子节点。</li>
<li>[2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。<ul>
<li>空数组，无子节点。</li>
<li>只有一个元素，所以子节点是一个值为 1 的节点。</li>
</ul>
</li>
</ul>
</li>
<li>[0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。<ul>
<li>只有一个元素，所以子节点是一个值为 0 的节点。</li>
<li>空数组，无子节点。</li>
</ul>
</li>
</ul>
<h5 id="preTraversal"><a href="#preTraversal" class="headerlink" title="preTraversal"></a>preTraversal</h5><p>思路 : </p>
<ol>
<li>因为需要构造中间节点，所以用先序遍历</li>
<li>先找到数组中最大值，然后切割成左右子树。</li>
<li>在切割后的左右子树中继续切割，直至无法切割为止</li>
</ol>
<p>自己写的，做法和随想录类似 </p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0654.%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html#java">https://programmercarl.com/0654.%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html#java</a></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">constructMaximumBinaryTree</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">return</span> buildTree(nums, <span class="number">0</span>, nums.size - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">buildTree</span><span class="params">(nums: <span class="type">IntArray</span>, start: <span class="type">Int</span>, end: <span class="type">Int</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    println(<span class="string">&quot;buildTree start <span class="variable">$start</span> end <span class="variable">$end</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="literal">null</span>            <span class="comment">//分割的左右下标越界就退出 ,不能加==，否则叶子节点构造不到.</span></span><br><span class="line">    <span class="keyword">val</span> maxIndex = getMaxIndex(nums, start, end)</span><br><span class="line">    <span class="keyword">val</span> node = TreeNode(nums[maxIndex])     <span class="comment">// 构造先序的父节点</span></span><br><span class="line">    node.left = buildTree(nums, start, maxIndex - <span class="number">1</span>) <span class="comment">// 构造左节点</span></span><br><span class="line">    node.right = buildTree(nums, maxIndex + <span class="number">1</span>, end)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getMaxIndex</span><span class="params">(nums: <span class="type">IntArray</span>, start: <span class="type">Int</span>, end: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> maxIndex = start</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> start..end) &#123;  <span class="comment">// 在对应的数组范围内，找到最大值</span></span><br><span class="line">        <span class="keyword">if</span> (nums[maxIndex] &lt; nums[i]) &#123;</span><br><span class="line">            maxIndex = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxIndex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h5><p>官方还有一种单调栈的写法，后面再看吧</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-binary-tree/solution/zui-da-er-cha-shu-by-leetcode-solution-lbeo/">https://leetcode.cn/problems/maximum-binary-tree/solution/zui-da-er-cha-shu-by-leetcode-solution-lbeo/</a></p>
<h4 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h4><p>Idea</p>
<h5 id="只分割中序数组"><a href="#只分割中序数组" class="headerlink" title="只分割中序数组"></a>只分割中序数组</h5><p>按照上面106官方很妙的思路，下面解法</p>
<ol>
<li>根据中序遍历。value和index构造hash map,方便后面获取中序位置</li>
<li>根据先序遍历数组从 左子树到右子树构造节点, 这样就不用分割先序数组，也是很麻烦的</li>
<li>根据先序数组的节点的位置，分割中序遍历数组，拿到左右子树</li>
<li>然后是递归分割.</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> map = HashMap&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="keyword">var</span> preNodeIndex = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">buildTree</span><span class="params">(preorder: <span class="type">IntArray</span>, inorder: <span class="type">IntArray</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    inorder.forEachIndexed &#123; position, item -&gt; <span class="comment">//</span></span><br><span class="line">        map[item] = position</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buildDFS(preorder, inorder, <span class="number">0</span>, inorder.size - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">buildDFS</span><span class="params">(preorder: <span class="type">IntArray</span>, inorder: <span class="type">IntArray</span>, inBegin: <span class="type">Int</span>, inEnd: <span class="type">Int</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (inBegin &gt; inEnd) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> node = TreeNode(preorder[preNodeIndex])  <span class="comment">// 根据先序遍历数组从 左子树到右子树构造节点</span></span><br><span class="line">    <span class="keyword">val</span> inIndex = map[preorder[preNodeIndex]]!! <span class="comment">// 根据先序数组的节点的位置，分割中序遍历数组，拿到左右子树</span></span><br><span class="line">    println(<span class="string">&quot;<span class="subst">$&#123;preorder[preNodeIndex]&#125;</span> inBegin <span class="variable">$inBegin</span> inEnd <span class="variable">$inEnd</span>&quot;</span>)</span><br><span class="line">    preNodeIndex++</span><br><span class="line">    node.left = buildDFS(preorder, inorder, inBegin, inIndex - <span class="number">1</span>)</span><br><span class="line">    node.right = buildDFS(preorder, inorder, inIndex + <span class="number">1</span>, inEnd)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="分割先序-中序数组"><a href="#分割先序-中序数组" class="headerlink" title="分割先序 中序数组"></a>分割先序 中序数组</h5><ol>
<li>根据中序数组构造，位置和值的hashmap 。</li>
<li>根据先序数组的中节点位置，分割中序数组，得到左右子树。</li>
<li>根据中序数组得到的左子树的长度，分割 先序数组的左右子树.</li>
<li>构造左右子树.</li>
</ol>
<p>左闭右闭的情况</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> map = HashMap&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="keyword">var</span> preNodeIndex = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">buildTree1</span><span class="params">(preorder: <span class="type">IntArray</span>, inorder: <span class="type">IntArray</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    inorder.forEachIndexed &#123; position, item -&gt;</span><br><span class="line">        map[item] = position  <span class="comment">// 获得 中序 value和index hash</span></span><br><span class="line">        map.put(item,position)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> splitPreInOrder(preorder, <span class="number">0</span>, preorder.size - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.size - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">splitPreInOrder</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    preorderArr: <span class="type">IntArray</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    preStart: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    preEnd: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    inorderArr: <span class="type">IntArray</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    inStart: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    inEnd: <span class="type">Int</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: TreeNode? &#123;</span><br><span class="line">    println(<span class="string">&quot; preStart <span class="variable">$preStart</span> preEnd <span class="variable">$preEnd</span> inStart <span class="variable">$inStart</span> inEnd <span class="variable">$inEnd</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (preStart &gt; preEnd || inStart &gt; inEnd) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">val</span> inIndex = map[preorderArr[preStart]]!!  <span class="comment">// 分割中序数组</span></span><br><span class="line">    <span class="keyword">val</span> node = TreeNode(preorderArr[preStart])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> leftInBegin = inStart <span class="comment">//左闭</span></span><br><span class="line">    <span class="keyword">val</span> leftInEnd = inIndex-<span class="number">1</span>    <span class="comment">// 右闭</span></span><br><span class="line">    <span class="keyword">val</span> leftPreBegin = preStart + <span class="number">1</span> <span class="comment">// 先序中节点的后一个位置，就是左子树的开始位置</span></span><br><span class="line">    <span class="keyword">val</span> leftPreEnd = preStart + (inIndex - inStart) <span class="comment">// 其实位置 + 中序中左子树的长度</span></span><br><span class="line"></span><br><span class="line">    node.left = splitPreInOrder(preorderArr, leftPreBegin, leftPreEnd, inorderArr, leftInBegin, leftInEnd)</span><br><span class="line">    <span class="keyword">val</span> rightInBegin = inIndex + <span class="number">1</span> <span class="comment">// 分割点的后一个位置</span></span><br><span class="line">    <span class="keyword">val</span> rightInEnd = inEnd</span><br><span class="line">    <span class="keyword">val</span> rightPreBegin = preStart + (inIndex - inStart) + <span class="number">1</span> <span class="comment">// 先序数组 左子树位置+1 后一个位置</span></span><br><span class="line">    <span class="keyword">val</span> rightPreEnd = preEnd</span><br><span class="line">    node.right = splitPreInOrder(preorderArr, rightPreBegin, rightPreEnd, inorderArr, rightInBegin, rightInEnd)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>感觉还是左闭右闭好点，右开的情况容易越界.</p>
<h4 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-binary-trees/">617. 合并二叉树</a></h4><h5 id="DFS-2"><a href="#DFS-2" class="headerlink" title="DFS"></a>DFS</h5><ol>
<li>合并二叉树，通过先序遍历，先构造根节点</li>
<li>然后再分别构造左右子树</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">mergeTrees</span><span class="params">(root1: <span class="type">TreeNode</span>?, root2: <span class="type">TreeNode</span>?)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="literal">null</span> &amp;&amp; root2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">//这里还可以优化, 看官方解法和随想录的优化一样的</span></span><br><span class="line">    <span class="keyword">val</span> node = TreeNode((root1?.`<span class="keyword">val</span>` ?: <span class="number">0</span>) + (root2?.`<span class="keyword">val</span>` ?: <span class="number">0</span>))</span><br><span class="line">    node.left = mergeTrees(root1?.left, root2?.left)</span><br><span class="line">    node.right = mergeTrees(root1?.right, root2?.right)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>BFS</p>
<p>这题官方有一种BFS的解法,感觉有点麻烦，后面继续</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-binary-trees/solution/he-bing-er-cha-shu-by-leetcode-solution/">https://leetcode.cn/problems/merge-two-binary-trees/solution/he-bing-er-cha-shu-by-leetcode-solution/</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-07-17T10:51:21.000Z" title="7/17/2022, 6:51:21 PM">2022-07-17</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-01-02T03:31:39.081Z" title="1/2/2023, 11:31:39 AM">2023-01-02</time></span><span class="level-item"><a class="link-muted" href="/categories/DataStructure/">DataStructure</a></span><span class="level-item">23 minutes read (About 3384 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/07/17/LC-Tree/">LC-Tree</a></p><div class="content"><p>二叉树算法思维</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1nG411x77H">https://www.bilibili.com/video/BV1nG411x77H</a></p>
<p>TreeOperation.java打印树</p>
<h4 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h4><p><img src="/2022/07/17/LC-Tree/20220723171518.jpg" alt="20220723171518"></p>
<p><img src="/2022/07/17/LC-Tree/20220723171848.jpg" alt="20220723171848"></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1JW411i731">https://www.bilibili.com/video/BV1JW411i731</a></p>
<h5 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h5><p>数组存储方式</p>
<p><img src="/2022/07/17/LC-Tree/20220723173810.jpg" alt="20220723173810"></p>
<p>i 是数组下标</p>
<h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p><img src="/2022/07/17/LC-Tree/20220723183845.jpg" alt="20220723183845"></p>
<p>每个Node都有3次访问机会，谁先出现就代表什么序.</p>
<p>中间节点  在哪,代表的遍历方式</p>
<ul>
<li>先序遍历  preorder traversal ：中左右</li>
<li>中序遍历 inorder traversal：左中右</li>
<li>后序遍历 postorder traversal：左右中</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/azl397985856/leetcode/blob/master/thinkings/tree.md">https://github.com/azl397985856/leetcode/blob/master/thinkings/tree.md</a></p>
<h5 id="preorder-traversal-递归"><a href="#preorder-traversal-递归" class="headerlink" title="preorder traversal 递归"></a>preorder traversal 递归</h5><p><img src="/2022/07/17/LC-Tree/20220724172053.jpg" alt="20220724172053"></p>
<p>二叉树的遍历动画</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1RR4y1j7kh">https://www.bilibili.com/video/BV1RR4y1j7kh</a></p>
<p>B的左边遍历完成后，开始遍历B的右子树</p>
<p>遍历过程</p>
<ol>
<li>访问根节点</li>
<li>先序遍历其左子树</li>
<li>先序遍历其右子树</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraversal</span><span class="params">(BinTree BT)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(BT)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, BT -&gt; Data);</span><br><span class="line">    PreOrderTraversal(BT-&gt;Left)</span><br><span class="line">    PreOrderTraversal(BT-&gt;Right)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1JW411i731?p=34&amp;vd_source=d4c5260002405798a57476b318eccac9">https://www.bilibili.com/video/BV1JW411i731?p=34&amp;vd_source=d4c5260002405798a57476b318eccac9</a></p>
<h5 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h5><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV15f4y1W7i2">https://www.bilibili.com/video/BV15f4y1W7i2</a></p>
<h5 id="构建和打印树"><a href="#构建和打印树" class="headerlink" title="构建和打印树"></a>构建和打印树</h5><p><a target="_blank" rel="noopener" href="https://blog.nowcoder.net/n/f3799d64ed764fd49c63947d617d4cd5">https://blog.nowcoder.net/n/f3799d64ed764fd49c63947d617d4cd5</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/playground/VDCGQ8Ds/">https://leetcode.cn/playground/VDCGQ8Ds/</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/vpcMyM/">https://leetcode.cn/circle/discuss/vpcMyM/</a></p>
<p>中序遍历</p>
<p><img src="/2022/07/17/LC-Tree/20220723183055.jpg" alt="20220723183055"></p>
<h5 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h5><p>也叫 广度优先遍历</p>
<p>用队列实现</p>
<p>while遍历纵向层数</p>
<p>for遍历横向</p>
<p><img src="https://labuladong.gitee.io/algo/images/dijkstra/1.jpeg"></p>
<p><img src="/2022/07/17/LC-Tree/20220723185012.jpg" alt="20220723185012"></p>
<h4 id="确定二叉树"><a href="#确定二叉树" class="headerlink" title="确定二叉树"></a>确定二叉树</h4><p>必须有中序遍历，和先 后 序遍历之一</p>
<p><img src="/2022/07/17/LC-Tree/20220723185911.jpg" alt="20220723185911"></p>
<p>二叉搜索树</p>
<p>BST. Binary Search Tree</p>
<p><img src="/2022/07/17/LC-Tree/20220723190752.jpg" alt="20220723190752"></p>
<h5 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h5><p>递归</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">preorderTraversal</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> linkedList = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    preTraversal(root, linkedList)</span><br><span class="line">    <span class="keyword">return</span> linkedList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">preTraversal</span><span class="params">(node: <span class="type">TreeNode</span>?, linkedList: <span class="type">LinkedList</span>&lt;<span class="type">Int</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="comment">// 这样的递归基更好</span></span><br><span class="line">    linkedList.add(node.`<span class="keyword">val</span>`)</span><br><span class="line">    preTraversal(node.left, linkedList)</span><br><span class="line">    preTraversal(node.right, linkedList)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>迭代</p>
<p>随想录</p>
<p>前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。</p>
<p>为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbmss7603g30eq0d4b2a.gif" alt="二叉树前序遍历（迭代法）"></p>
<p>5 4 1 2 6</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">preorderTraversal1</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> linkedList = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">val</span> stack = Stack&lt;TreeNode&gt;()</span><br><span class="line">    root?.let&#123;</span><br><span class="line">        stack.push(it)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> popNode = stack.pop()</span><br><span class="line">        popNode.`<span class="keyword">val</span>`.let&#123;</span><br><span class="line">            linkedList.add(it)</span><br><span class="line">        &#125;</span><br><span class="line">        popNode.right?.let &#123;</span><br><span class="line">            stack.push(it)</span><br><span class="line">        &#125;</span><br><span class="line">        popNode.left?.let &#123;</span><br><span class="line">            stack.push(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> linkedList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h5><p>递归</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">inorderTraversal</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> linkedList = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    orderRecursive(root, linkedList)</span><br><span class="line">    <span class="keyword">return</span> linkedList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">orderRecursive</span><span class="params">(node: <span class="type">TreeNode</span>?, linkedList: <span class="type">LinkedList</span>&lt;<span class="type">Int</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">    orderRecursive(node.left, linkedList)</span><br><span class="line">    linkedList.add(node.`<span class="keyword">val</span>`)</span><br><span class="line">    orderRecursive(node.right, linkedList)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>迭代法</p>
<p>随想录</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbmuj244bg30eq0d4kjm.gif" alt="二叉树中序遍历（迭代法）"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">inorderTraversal1</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> linkedList = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> linkedList</span><br><span class="line">    <span class="keyword">val</span> stack = Stack&lt;TreeNode&gt;()</span><br><span class="line">    <span class="keyword">var</span> node = root</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span> || !stack.empty()) &#123; <span class="comment">//node != null 第一次可以进来</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(node)</span><br><span class="line">            node = node.left</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> resultNode = stack.pop()</span><br><span class="line">            linkedList.add(resultNode.`<span class="keyword">val</span>`)</span><br><span class="line">            node = resultNode.right</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> linkedList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h5><p>递归</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//recurive</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">postorderTraversal</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> linkedList = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    recursiveTraversal(root, linkedList)</span><br><span class="line">    <span class="keyword">return</span> linkedList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">recursiveTraversal</span><span class="params">(node: <span class="type">TreeNode</span>?, linkedList: <span class="type">LinkedList</span>&lt;<span class="type">Int</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">    recursiveTraversal(node.left, linkedList)</span><br><span class="line">    recursiveTraversal(node.right, linkedList)</span><br><span class="line">    linkedList.add(node.`<span class="keyword">val</span>`)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>迭代法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">postorderTraversal</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">     <span class="keyword">var</span> mRoot = root</span><br><span class="line">     <span class="keyword">val</span> resultList = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">     <span class="keyword">val</span> stack = Stack&lt;TreeNode&gt;()</span><br><span class="line">     <span class="keyword">var</span> preNode: TreeNode? = <span class="literal">null</span></span><br><span class="line">     <span class="keyword">while</span> (mRoot != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">         <span class="keyword">while</span> (mRoot != <span class="literal">null</span>) &#123;</span><br><span class="line">             stack.push(mRoot)</span><br><span class="line">             mRoot = mRoot.left</span><br><span class="line">         &#125;</span><br><span class="line">         mRoot = stack.pop()</span><br><span class="line">         <span class="keyword">if</span> (mRoot?.right == <span class="literal">null</span> || mRoot.right == preNode) &#123; <span class="comment">// 一开始写成这样 mRoot == preNode,导致死循环</span></span><br><span class="line">             resultList.add(mRoot.`<span class="keyword">val</span>`)</span><br><span class="line">             preNode = mRoot</span><br><span class="line">             mRoot = <span class="literal">null</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             stack.push(mRoot)</span><br><span class="line">             mRoot = mRoot.right</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> resultList</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-postorder-traversal/solution/er-cha-shu-de-hou-xu-bian-li-by-leetcode-solution/">https://leetcode.cn/problems/binary-tree-postorder-traversal/solution/er-cha-shu-de-hou-xu-bian-li-by-leetcode-solution/</a> 动图</p>
<p>官方题解</p>
<p>迭代法统一写法</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/dai-ma-sui-xiang-lu-che-di-chi-tou-qian-xjof1/">https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/dai-ma-sui-xiang-lu-che-di-chi-tou-qian-xjof1/</a></p>
<p>这个统一法还没研究，先往后学吧，地铁上看了下，其实也不难</p>
<h4 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h4><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnad5itmk8g30iw0cqe83.gif"></p>
<p>按照顺序，下一层的放在后面.</p>
<h5 id="迭代写法"><a href="#迭代写法" class="headerlink" title="迭代写法"></a>迭代写法</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">levelOrder</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> layerList = LinkedList&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.offer(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> layerSize = queue.size <span class="comment">// queue大小，下面循环在不断变化，所以要先定义出来</span></span><br><span class="line">        <span class="keyword">val</span> linkedList = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until layerSize) &#123;</span><br><span class="line">            <span class="keyword">val</span> headNode = queue.poll()</span><br><span class="line">            linkedList.add(headNode.`<span class="keyword">val</span>`)</span><br><span class="line">            headNode.left?.let &#123; queue.offer(it) &#125;</span><br><span class="line">            headNode.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        layerList.add(linkedList)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> layerList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h5><p>递归解法一开始没理解，再看了下，思路很妙</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">levelOrder1</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> layerList = LinkedList&lt;LinkedList&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> layerList</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> depth = <span class="number">0</span> <span class="comment">// 层级</span></span><br><span class="line">    <span class="keyword">return</span> recursive(layerList, root, depth)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">recursive</span><span class="params">(layerList: <span class="type">LinkedList</span>&lt;<span class="type">LinkedList</span>&lt;<span class="type">Int</span>&gt;&gt;, node: <span class="type">TreeNode</span>?, depth: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (layerList.size &lt;= depth) &#123; <span class="comment">//二维数组长度不超过这个层级,随想录这里是用 ==,不过我觉得&lt;=更好</span></span><br><span class="line">        <span class="keyword">val</span> linkedList = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        layerList.add(linkedList)</span><br><span class="line">    &#125;</span><br><span class="line">    node?.`<span class="keyword">val</span>`?.let &#123; layerList[depth].add(it) &#125; <span class="comment">// 拿到当前层级节点的值</span></span><br><span class="line">    <span class="keyword">val</span> mDepth = depth + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (node?.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        recursive(layerList, node.left, mDepth)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node?.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        recursive(layerList, node.right, mDepth)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> layerList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/solution/er-cha-shu-de-ceng-xu-bian-li-by-leetcode-solution/">https://leetcode.cn/problems/binary-tree-level-order-traversal/solution/er-cha-shu-de-ceng-xu-bian-li-by-leetcode-solution/</a></p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html">https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html</a></p>
<h4 id="107-二叉树的层序遍历-II"><a href="#107-二叉树的层序遍历-II" class="headerlink" title="107. 二叉树的层序遍历 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层序遍历 II</a></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">levelOrderBottom</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> resultList = LinkedList&lt;ArrayList&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.offer(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> layerSize = queue.size <span class="comment">// queue循环中 不断的变化</span></span><br><span class="line">        <span class="keyword">val</span> arrayList = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until layerSize) &#123;</span><br><span class="line">            <span class="keyword">val</span> headNode = queue.poll()</span><br><span class="line">            <span class="keyword">if</span> (headNode != <span class="literal">null</span>) &#123;</span><br><span class="line">                arrayList.add(headNode.`<span class="keyword">val</span>`)</span><br><span class="line">                headNode.left?.let &#123; queue.offer(it) &#125;</span><br><span class="line">                headNode.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        resultList.addFirst(arrayList)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultList</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>



<h4 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h4><h5 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">rightSideView</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> resultList = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.add(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> layoutSize = queue.size</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until layoutSize) &#123;</span><br><span class="line">            <span class="keyword">val</span> headNode = queue.poll()</span><br><span class="line">            <span class="keyword">if</span> (i == layoutSize - <span class="number">1</span>) &#123;</span><br><span class="line">                resultList.add(headNode.`<span class="keyword">val</span>`)</span><br><span class="line">            &#125;</span><br><span class="line">            headNode?.left?.let &#123; queue.offer(it) &#125;</span><br><span class="line">            headNode?.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="DFS-深度优先遍历"><a href="#DFS-深度优先遍历" class="headerlink" title="DFS 深度优先遍历"></a>DFS 深度优先遍历</h5><p>这个DFS很妙，这次只是先理解,二刷的时候可以自己写写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solutions</span></span>&#123;</span><br><span class="line">	  List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">       dfs(root,<span class="number">0</span>)</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function">prvidate <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root ==<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(depth == res.size())&#123; <span class="comment">// 当前层级第一个右节点还没有，添加到结果中</span></span><br><span class="line">      res.add(root.val)</span><br><span class="line">    &#125;</span><br><span class="line">    depth++;</span><br><span class="line">    dfs(root.right,depth)</span><br><span class="line">    dfs(root.left,depth)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理解在官方视频中.</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/solution/er-cha-shu-de-you-shi-tu-by-leetcode-solution/">https://leetcode.cn/problems/binary-tree-right-side-view/solution/er-cha-shu-de-you-shi-tu-by-leetcode-solution/</a></p>
<h4 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637. 二叉树的层平均值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">637. 二叉树的层平均值</a></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">averageOfLevels</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: DoubleArray &#123;</span><br><span class="line">    <span class="keyword">val</span> resultList = ArrayList&lt;<span class="built_in">Double</span>&gt;()</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.offer(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> layoutSize = queue.size</span><br><span class="line">        <span class="keyword">var</span> layerSum = <span class="number">0.</span>toDouble()</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until layoutSize) &#123;</span><br><span class="line">            <span class="keyword">val</span> node = queue.poll()</span><br><span class="line">            layerSum += node.`<span class="keyword">val</span>`</span><br><span class="line">            node?.left?.let &#123; queue.offer(it) &#125;</span><br><span class="line">            node?.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> average = resultList.add(layerSum * <span class="number">1.00000</span> / layoutSize)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultList.toDoubleArray()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="429-N-叉树的层序遍历"><a href="#429-N-叉树的层序遍历" class="headerlink" title="429. N 叉树的层序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">429. N 叉树的层序遍历</a></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">levelOrder</span><span class="params">(root: <span class="type">Node</span>?)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> result = LinkedList&lt;ArrayList&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;Node&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.offer(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> layoutSize = queue.size <span class="comment">// 该层级的节点数</span></span><br><span class="line">        <span class="keyword">val</span> layerResult = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until layoutSize) &#123;</span><br><span class="line">            <span class="keyword">val</span> pollNode = queue.poll()</span><br><span class="line">            layerResult.add(pollNode.`<span class="keyword">val</span>`)</span><br><span class="line">            pollNode.children.forEach &#123; <span class="comment">// 只有这里有点不同</span></span><br><span class="line">                queue.offer(it)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(layerResult)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="515-在每个树行中找最大值"><a href="#515-在每个树行中找最大值" class="headerlink" title="515. 在每个树行中找最大值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">515. 在每个树行中找最大值</a></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largestValues</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> answer = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.offer(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> layerSize = queue.size</span><br><span class="line">        <span class="keyword">var</span> maxValue = <span class="built_in">Int</span>.MIN_VALUE <span class="comment">//最小值 , 每一层级都要初始化，否则拿到上一层级的值，就不是最小值，会有问题</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until layerSize) &#123;</span><br><span class="line">            <span class="keyword">val</span> pollNode = queue.poll()</span><br><span class="line">            maxValue = pollNode.`<span class="keyword">val</span>`.coerceAtLeast(maxValue) <span class="comment">// 比较取最大值</span></span><br><span class="line">            pollNode?.left?.let &#123; queue.offer(it) &#125;</span><br><span class="line">            pollNode?.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        answer.add(maxValue)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></p>
<p>一开始用这种方式，但是会提示 “超出内存限制”</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">connect</span><span class="params">(root: <span class="type">Node</span>?)</span></span>: Node? &#123;</span><br><span class="line"><span class="comment">//        val answerList = ArrayList&lt;String&gt;() //根据题意, 一开始以为要返回这个答案,其实只要连接后 返回root就好了</span></span><br><span class="line">        <span class="keyword">val</span> queue = LinkedList&lt;Node&gt;()</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.offer(root)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> preNode: Node?=<span class="literal">null</span></span><br><span class="line">        <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">            <span class="keyword">val</span> layerSize = queue.size</span><br><span class="line">            preNode = <span class="literal">null</span></span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until layerSize) &#123;</span><br><span class="line">                <span class="keyword">val</span> curNode = queue.poll()</span><br><span class="line">                preNode = curNode </span><br><span class="line">                <span class="keyword">if</span> (preNode != <span class="literal">null</span>) &#123;</span><br><span class="line">                    preNode.next = curNode</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//                answerList.add(curNode.`val`.toString())</span></span><br><span class="line">                <span class="keyword">if</span> (i == layerSize - <span class="number">1</span>) &#123;</span><br><span class="line">                    curNode.next = <span class="literal">null</span>  <span class="comment">// 最后个node 指向null</span></span><br><span class="line">                <span class="comment">//    answerList.add(&quot;#&quot;)</span></span><br><span class="line">                &#125;</span><br><span class="line">                curNode?.left?.let &#123; queue.offer(it) &#125;</span><br><span class="line">                curNode?.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>官方解法 还有另一种解法，二刷时可以研究研究</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">connect</span><span class="params">(root: <span class="type">Node</span>?)</span></span>: Node? &#123;</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;Node&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.offer(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> layerSize = queue.size</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until layerSize) &#123;</span><br><span class="line">            <span class="keyword">val</span> curNode = queue.poll()</span><br><span class="line">            <span class="keyword">if</span> (i &lt; layerSize - <span class="number">1</span>) &#123;</span><br><span class="line">                curNode.next = queue.peek()</span><br><span class="line">            &#125;</span><br><span class="line">            curNode?.left?.let &#123; queue.offer(it) &#125;</span><br><span class="line">            curNode?.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/solution/tian-chong-mei-ge-jie-dian-de-xia-yi-ge-you-ce-2-4/">https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/solution/tian-chong-mei-ge-jie-dian-de-xia-yi-ge-you-ce-2-4/</a></p>
<h4 id="117-填充每个节点的下一个右侧节点指针-II"><a href="#117-填充每个节点的下一个右侧节点指针-II" class="headerlink" title="117. 填充每个节点的下一个右侧节点指针 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">117. 填充每个节点的下一个右侧节点指针 II</a></h4><p>和116题唯一的区别，116是完美二叉树</p>
<h4 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h4><h5 id="广度优先-Breadth-First-Search"><a href="#广度优先-Breadth-First-Search" class="headerlink" title="广度优先 Breadth-First-Search"></a>广度优先 <strong>Breadth-First-Search</strong></h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">maxDepth</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    <span class="keyword">var</span> depth = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.offer(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> layerSize = queue.size</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until layerSize) &#123;</span><br><span class="line">            <span class="keyword">val</span> pollNode = queue.poll()</span><br><span class="line">            pollNode?.left?.let &#123; queue.add(it) &#125; </span><br><span class="line">            pollNode?.right?.let &#123; queue.add(it) &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == layerSize - <span class="number">1</span>) &#123;	</span><br><span class="line">                depth++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="递归-Depth-First-Search"><a href="#递归-Depth-First-Search" class="headerlink" title="递归 Depth First Search"></a>递归 Depth <strong>First Search</strong></h5><p>这题用一个方法就可以了，遍历左右子树取最大值后 再加 1</p>
<p>这个其实也是先序遍历,左右中</p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html#%E9%80%92%E5%BD%92%E6%B3%95">https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html#%E9%80%92%E5%BD%92%E6%B3%95</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> leftdepth = <span class="built_in">getdepth</span>(node-&gt;left);       <span class="comment">// 左</span></span><br><span class="line"><span class="keyword">int</span> rightdepth = <span class="built_in">getdepth</span>(node-&gt;right);     <span class="comment">// 右</span></span><br><span class="line"><span class="keyword">int</span> depth = <span class="number">1</span> + <span class="built_in">max</span>(leftdepth, rightdepth); <span class="comment">// 中</span></span><br><span class="line"><span class="keyword">return</span> depth;</span><br></pre></td></tr></table></figure>



<p><strong>可以看看随想录的解法，里面有回溯的过程，过程更详细</strong></p>
<p>下面解法做了简化</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">maxDepth</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> depth = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> depth</span><br><span class="line">    <span class="keyword">return</span> dfsDepth(root, depth)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dfsDepth</span><span class="params">(node: <span class="type">TreeNode</span>?, depth: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> depth</span><br><span class="line">    <span class="keyword">val</span> maxDepth = Math.max(dfsDepth(node.left, depth + <span class="number">1</span>), dfsDepth(node.right, depth + <span class="number">1</span>)) <span class="comment">// 用max函数更直观</span></span><br><span class="line">    <span class="keyword">return</span> maxDepth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/solution/er-cha-shu-de-zui-da-shen-du-by-leetcode-solution/">https://leetcode.cn/problems/maximum-depth-of-binary-tree/solution/er-cha-shu-de-zui-da-shen-du-by-leetcode-solution/</a></p>
<h4 id="559-N-叉树的最大深度"><a href="#559-N-叉树的最大深度" class="headerlink" title="559. N 叉树的最大深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/">559. N 叉树的最大深度</a></h4><p>DFS</p>
<p> 这个DFS解法 看了官方题解答案，自己再做一次</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/solution/n-cha-shu-de-zui-da-shen-du-by-leetcode-n7qtv/">https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/solution/n-cha-shu-de-zui-da-shen-du-by-leetcode-n7qtv/</a></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">maxDepth</span><span class="params">(root: <span class="type">Node</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> maxDepth = <span class="number">0</span></span><br><span class="line">    root.children.forEach &#123;</span><br><span class="line">        <span class="keyword">val</span> depth = maxDepth(it)</span><br><span class="line">        maxDepth = Math.max(maxDepth, depth)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxDepth +<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>BFS</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">maxDepth1</span><span class="params">(root: <span class="type">Node</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;Node&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.offer(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> maxDepth = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> layerSize = queue.size</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until layerSize) &#123;</span><br><span class="line">            <span class="keyword">val</span> pollNode = queue.poll()</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123; <span class="comment">// 这个条件可以去掉</span></span><br><span class="line">                maxDepth++</span><br><span class="line">            &#125;</span><br><span class="line">            pollNode.children.forEach &#123;</span><br><span class="line">                <span class="keyword">if</span> (it != <span class="literal">null</span>)</span><br><span class="line">                    queue.offer(it)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxDepth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">maxDepth1</span><span class="params">(root: <span class="type">Node</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;Node&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.offer(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> maxDepth = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> layerSize = queue.size</span><br><span class="line">        maxDepth++ <span class="comment">//拿到外面更好，不用判断i==1了,每次layerSize 遍历完就是一层了</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until layerSize) &#123;</span><br><span class="line">            <span class="keyword">val</span> pollNode = queue.poll()</span><br><span class="line">            pollNode.children.forEach &#123;</span><br><span class="line">                <span class="keyword">if</span> (it != <span class="literal">null</span>)</span><br><span class="line">                    queue.offer(it)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxDepth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h4><p>BFS</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">minDepth</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.offer(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> depth = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> layerSize = queue.size</span><br><span class="line">        depth++ <span class="comment">// 不用放下面判断，直接是一层新的</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until layerSize) &#123;</span><br><span class="line">            <span class="keyword">val</span> pollNode = queue.poll()</span><br><span class="line">            <span class="keyword">if</span> (pollNode.left == <span class="literal">null</span> &amp;&amp; pollNode.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> depth</span><br><span class="line">            &#125;</span><br><span class="line">            pollNode?.left?.let &#123; queue.offer(it) &#125;</span><br><span class="line">            pollNode?.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>官方题解看起来，更好</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/solution/er-cha-shu-de-zui-xiao-shen-du-by-leetcode-solutio/">https://leetcode.cn/problems/minimum-depth-of-binary-tree/solution/er-cha-shu-de-zui-xiao-shen-du-by-leetcode-solutio/</a></p>
<p>DFS</p>
<p><img src="https://img-blog.csdnimg.cn/20210203155800503.png"></p>
<p> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/solution/bfshe-dfsliang-chong-fang-shi-jie-jue-by-g4eh/">https://leetcode.cn/problems/minimum-depth-of-binary-tree/solution/bfshe-dfsliang-chong-fang-shi-jie-jue-by-g4eh/</a></p>
<p>用了这个视频的解法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">minDepth</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment">//左子节点和右子节点都不为空，然后取最小值才有意义，否则就是错的</span></span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="literal">null</span> &amp;&amp; root.right != <span class="literal">null</span>) &#123; <span class="comment">// 左右都不为空</span></span><br><span class="line">        <span class="keyword">return</span> Math.min(minDepth(root.left), minDepth(root.right)) + <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.left == <span class="literal">null</span>) &#123; <span class="comment">//左不为空</span></span><br><span class="line">        <span class="keyword">return</span> minDepth(root.right) + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minDepth(root.left) + <span class="number">1</span> <span class="comment">//右不为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>理解了这个解法，再看官方的DFS解法，也简单明了</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/solution/er-cha-shu-de-zui-xiao-shen-du-by-leetcode-solutio/">https://leetcode.cn/problems/minimum-depth-of-binary-tree/solution/er-cha-shu-de-zui-xiao-shen-du-by-leetcode-solutio/</a></p>
<h4 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></h4><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnakm26jtog30e409s4qp.gif"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">invertTree</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    swapNode(root) </span><br><span class="line">    invertTree(root.left)</span><br><span class="line">    invertTree(root.right)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">swapNode</span><span class="params">(node: <span class="type">TreeNode</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> temp = node?.left</span><br><span class="line">    node?.left = node?.right</span><br><span class="line">    node?.right = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    invertTree(root.left);<span class="comment">//注意这里是left</span></span><br><span class="line">    TreeNode temp = root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = temp;</span><br><span class="line">    invertTree(root.left);<span class="comment">//这里还是left</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>————————————————<br>版权声明：本文为CSDN博主「xsybg」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/xsybg/article/details/122687168">https://blog.csdn.net/xsybg/article/details/122687168</a></p>
<p>注意两个递归调用的参数都是root.left, 因为在第二步是交换root的左右孩子，所以在第三步要处理的右孩子其实已经变成了root的左孩子，是不是很有趣？<br>这个题目很简单，但是确实会稀里糊涂地通过，没搞清楚是树的哪一种遍历，看了代码随想录的解析感觉还挺惊喜的。<br>代码随想录的链接贴在这里：<br>————————————————<br>版权声明：本文为CSDN博主「xsybg」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/xsybg/article/details/122687168">https://blog.csdn.net/xsybg/article/details/122687168</a></p>
<p>根据下面打印</p>
<p>4的坐子树中的1,3交换了两次， 6,9一次都没交换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">      4      </span><br><span class="line">    &#x2F;   \    </span><br><span class="line">  2       7  </span><br><span class="line"> &#x2F; \     &#x2F; \ </span><br><span class="line">1   3   6   9</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> node 4</span><br><span class="line">      4      </span><br><span class="line">    &#x2F;   \    </span><br><span class="line">  2       7  </span><br><span class="line"> &#x2F; \     &#x2F; \ </span><br><span class="line">1   3   6   9</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> node 2</span><br><span class="line">      4      </span><br><span class="line">    &#x2F;   \    </span><br><span class="line">  2       7  </span><br><span class="line"> &#x2F; \     &#x2F; \ </span><br><span class="line">1   3   6   9</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> node 1</span><br><span class="line">      4      </span><br><span class="line">    &#x2F;   \    </span><br><span class="line">  2       7  </span><br><span class="line"> &#x2F; \     &#x2F; \ </span><br><span class="line">1   3   6   9</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> node 1</span><br><span class="line">      4      </span><br><span class="line">    &#x2F;   \    </span><br><span class="line">  2       7  </span><br><span class="line"> &#x2F; \     &#x2F; \ </span><br><span class="line">3   1   6   9</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> node 2</span><br><span class="line">      4      </span><br><span class="line">    &#x2F;   \    </span><br><span class="line">  7       2  </span><br><span class="line"> &#x2F; \     &#x2F; \ </span><br><span class="line">6   9   3   1</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> node 3</span><br><span class="line">      4      </span><br><span class="line">    &#x2F;   \    </span><br><span class="line">  7       2  </span><br><span class="line"> &#x2F; \     &#x2F; \ </span><br><span class="line">6   9   3   1</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> node 3</span><br><span class="line">      4      </span><br><span class="line">    &#x2F;   \    </span><br><span class="line">  7       2  </span><br><span class="line"> &#x2F; \     &#x2F; \ </span><br><span class="line">6   9   1   3</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="广度优先遍历-层序遍历"><a href="#广度优先遍历-层序遍历" class="headerlink" title="广度优先遍历(层序遍历)"></a>广度优先遍历(层序遍历)</h5><p>遍历左右节点就可以.然后交换就可以了</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">invertTree1</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.offer(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty())&#123;</span><br><span class="line">        <span class="keyword">val</span> layerSize = queue.size</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until layerSize)&#123;</span><br><span class="line">            <span class="keyword">val</span> pollNode = queue.poll()</span><br><span class="line">            swapNode(pollNode)</span><br><span class="line">            pollNode.left?.let &#123; queue.offer(it) &#125;</span><br><span class="line">            pollNode.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-07-03T04:16:17.000Z" title="7/3/2022, 12:16:17 PM">2022-07-03</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-01-02T03:31:39.091Z" title="1/2/2023, 11:31:39 AM">2023-01-02</time></span><span class="level-item"><a class="link-muted" href="/categories/DataStructure/">DataStructure</a></span><span class="level-item">11 minutes read (About 1634 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/07/03/LC-stack-queue/">LC-stack-queue</a></p><div class="content"><h4 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h4><p>最初写的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> stack = Stack&lt;<span class="built_in">Int</span>&gt;() <span class="comment">// 元素栈</span></span><br><span class="line"><span class="keyword">val</span> tempStack = Stack&lt;<span class="built_in">Int</span>&gt;()  <span class="comment">// 备用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">push</span><span class="params">(x: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    stack.push(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">pop</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">        tempStack.push(stack.pop())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> pop = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (!tempStack.isEmpty()) &#123;</span><br><span class="line">        pop = tempStack.pop() <span class="comment">// 这里取的就是头元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!tempStack.empty()) &#123;</span><br><span class="line">        stack.push(tempStack.pop())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pop</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">peek</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">        tempStack.push(stack.pop())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> peek = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (!tempStack.isEmpty()) &#123;</span><br><span class="line">        peek = tempStack.peek() <span class="comment">// 这里取的就是头元素,不会删除</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!tempStack.empty()) &#123;</span><br><span class="line">        stack.push(tempStack.pop())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> peek</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">empty</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> stack.empty()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在LC232基础上进行的优化，之前每次pop后，还得把元素放回去,这里只有push判断 tempStack有没有元素</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-queue-using-stacks/solution/wen-zi-shi-pin-de-fang-shi-xiang-xi-jiang-jie-li-2/">https://leetcode.cn/problems/implement-queue-using-stacks/solution/wen-zi-shi-pin-de-fang-shi-xiang-xi-jiang-jie-li-2/</a></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> stackIn = Stack&lt;<span class="built_in">Int</span>&gt;() <span class="comment">// 元素栈</span></span><br><span class="line"><span class="keyword">val</span> tempStack = Stack&lt;<span class="built_in">Int</span>&gt;()  <span class="comment">// 备用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">push</span><span class="params">(x: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!tempStack.empty())&#123; <span class="comment">//</span></span><br><span class="line">        stackIn.push(tempStack.pop())</span><br><span class="line">    &#125;</span><br><span class="line">    stackIn.push(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">pop</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!stackIn.empty()) &#123;</span><br><span class="line">        tempStack.push(stackIn.pop())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> pop = -<span class="number">1</span> <span class="comment">// 需要-1</span></span><br><span class="line">    <span class="keyword">if</span> (!tempStack.isEmpty()) &#123;</span><br><span class="line">        pop = tempStack.pop() <span class="comment">// 这里取的就是头元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pop</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">peek</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> pop = <span class="keyword">this</span>.pop()</span><br><span class="line">    stackIn.push(pop) <span class="comment">// 复用pop，拿出来 再放回去</span></span><br><span class="line">    <span class="keyword">return</span> pop</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">empty</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> tempStack.empty()&amp;&amp;stackIn.empty()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>随想录写法</p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%89%88%E6%9C%AC2.gif"></p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC">https://programmercarl.com/0232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC</a></p>
<p>在LC232_01基础上进行的优化，push的时候不用每次都判断，只有stackOut是空的时候，才需要取后面的元素</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> stackIn = Stack&lt;<span class="built_in">Int</span>&gt;() <span class="comment">// 输入栈</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> stackOut = Stack&lt;<span class="built_in">Int</span>&gt;()  <span class="comment">// 输出栈</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">push</span><span class="params">(x: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    stackIn.push(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">pop</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (stackOut.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stackIn.empty()) &#123;</span><br><span class="line">            stackOut.push(stackIn.pop())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">data</span> = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (!stackOut.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">data</span> = stackOut.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">data</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">peek</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> pop = <span class="keyword">this</span>.pop()</span><br><span class="line">    stackOut.push(pop) <span class="comment">// 复用pop，拿出来 再放回去</span></span><br><span class="line">    <span class="keyword">return</span> pop</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">empty</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> stackOut.empty() &amp;&amp; stackIn.empty()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h4><h5 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> mainDeque = ArrayDeque&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> tempDeque = ArrayDeque&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">push</span><span class="params">(x: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!tempDeque.isEmpty()) &#123;</span><br><span class="line">        mainDeque.offerLast(tempDeque.poll())</span><br><span class="line">    &#125;</span><br><span class="line">    mainDeque.offerLast(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">pop</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">data</span> = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (!mainDeque.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mainDeque.size == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">data</span> = mainDeque.poll()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">data</span> = mainDeque.poll()</span><br><span class="line">            tempDeque.offerLast(<span class="keyword">data</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!tempDeque.isEmpty()) &#123;</span><br><span class="line">        mainDeque.offerLast(tempDeque.poll())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">data</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">top</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> pop = <span class="keyword">this</span>.pop()</span><br><span class="line">    mainDeque.offerLast(pop)</span><br><span class="line">    <span class="keyword">return</span> pop</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">empty</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> tempDeque.isEmpty() &amp;&amp; mainDeque.isEmpty()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="两个队列"><a href="#两个队列" class="headerlink" title="两个队列"></a>两个队列</h5><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.html">https://programmercarl.com/0225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.html</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-stack-using-queues/solution/yong-dui-lie-shi-xian-zhan-by-leetcode-solution/">https://leetcode.cn/problems/implement-stack-using-queues/solution/yong-dui-lie-shi-xian-zhan-by-leetcode-solution/</a></p>
<p>这里的视频教程更好理解.</p>
<p><img src="https://assets.leetcode-cn.com/solution-static/225/225_fig1.gif"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> mainDeque = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> tempDeque = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">push</span><span class="params">(x: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    tempDeque.offer(x)</span><br><span class="line">    <span class="keyword">while</span> (!mainDeque.isEmpty()) &#123;</span><br><span class="line">        tempDeque.offerLast(mainDeque.poll())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> temp = mainDeque <span class="comment">//此时mainDeque一定是空的,不过没关系，不用再创建一个</span></span><br><span class="line">    mainDeque = tempDeque <span class="comment">//交换队列元素, tempDeque的元素给mainDeque</span></span><br><span class="line">    tempDeque = temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">pop</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mainDeque.poll() <span class="comment">//删除并返回元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">top</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mainDeque.peek() <span class="comment">// 返回元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">empty</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> tempDeque.isEmpty() &amp;&amp; mainDeque.isEmpty()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="一个队列"><a href="#一个队列" class="headerlink" title="一个队列"></a>一个队列</h5><p>也是上面官方教程</p>
<p><img src="https://assets.leetcode-cn.com/solution-static/225/225_fig2.gif"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> mainDeque = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">push</span><span class="params">(x: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    mainDeque.offer(x)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until mainDeque.size - <span class="number">1</span>) &#123; <span class="comment">// 注意这里要-1,这样最后入队的就在头部.否则就没有意义了</span></span><br><span class="line">        mainDeque.offer(mainDeque.poll())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">pop</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mainDeque.poll() <span class="comment">//删除并返回元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">top</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mainDeque.peek() <span class="comment">// 返回元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">empty</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mainDeque.isEmpty()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> queue = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">queue.offer(<span class="number">0</span>)</span><br><span class="line">queue.offer(<span class="number">1</span>)</span><br><span class="line">queue.offer(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">queue.offer(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until queue.size - <span class="number">1</span>) &#123;</span><br><span class="line">    queue.offer(queue.poll())</span><br><span class="line">    println(queue)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//看到这个入队结果</span></span><br><span class="line"><span class="comment">// [1, 2, 3, 0]</span></span><br><span class="line"><span class="comment">//[2, 3, 0, 1]</span></span><br><span class="line"><span class="comment">//[3, 0, 1, 2]</span></span><br></pre></td></tr></table></figure>





<h4 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isValid</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> mapOf = mapOf(<span class="string">&#x27;(&#x27;</span> to <span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span> to <span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;[&#x27;</span> to <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">    <span class="keyword">val</span> stack = Stack&lt;<span class="built_in">Char</span>&gt;()</span><br><span class="line">    s.chars().forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (!stack.empty() &amp;&amp; mapOf[stack.peek()] == it.toChar()) &#123; <span class="comment">//stack 为空 取出会抛出异常, mapOf应该取左边的符号也就是stack里的</span></span><br><span class="line">            stack.pop()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.push(it.toChar())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.empty()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047. 删除字符串中的所有相邻重复项"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项</a></h4><p>而且<strong>在企业项目开发中，尽量不要使用递归！</strong>在项目比较大的时候，由于参数多，全局变量等等，使用递归很容易判断不充分return的条件，非常容易无限递归（或者递归层级过深），<strong>造成栈溢出错误（这种问题还不好排查！）</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">removeDuplicates</span><span class="params">(s: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> stack = Stack&lt;<span class="built_in">Char</span>&gt;()</span><br><span class="line">    s.chars().forEach &#123;</span><br><span class="line">        <span class="keyword">if</span>(!stack.empty()&amp;&amp;stack.peek()==it.toChar())&#123;</span><br><span class="line">            stack.pop()</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            stack.push(it.toChar())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.joinToString(separator = <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">evalRPN</span><span class="params">(tokens: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> stack = Stack&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    tokens.forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (it == <span class="string">&quot;+&quot;</span> || it == <span class="string">&quot;-&quot;</span> || it == <span class="string">&quot;*&quot;</span> || it == <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> pop1 = stack.takeUnless &#123; p1 -&gt; p1.empty() &#125;?.pop()</span><br><span class="line">            <span class="keyword">val</span> pop2 = stack.takeUnless &#123; p2 -&gt; p2.empty() &#125;?.pop()</span><br><span class="line">            <span class="keyword">if</span> (pop1 != <span class="literal">null</span> &amp;&amp; pop2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> result = getResult(it, pop2.toInt(), pop1.toInt()) <span class="comment">// stack取的第二个数放前面</span></span><br><span class="line">                stack.push(result)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.push(it.toInt())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.peek()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getResult</span><span class="params">(<span class="keyword">operator</span>: <span class="type">String</span>, pop1: <span class="type">Int</span>, pop2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span> (<span class="keyword">operator</span>) &#123;</span><br><span class="line">        <span class="string">&quot;+&quot;</span> -&gt; pop1 + pop2</span><br><span class="line">        <span class="string">&quot;-&quot;</span> -&gt; pop1 - pop2</span><br><span class="line">        <span class="string">&quot;*&quot;</span> -&gt; pop1 * pop2</span><br><span class="line">        <span class="string">&quot;/&quot;</span> -&gt; pop1 / pop2</span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;oh something went wrong&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h4><h5 id="存储元素坐标"><a href="#存储元素坐标" class="headerlink" title="存储元素坐标"></a>存储元素坐标</h5><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.html">https://programmercarl.com/0239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.html</a></p>
<p>nums[index - k]是队列头部最大元素，此时最大元素出队列,因为最大元素一定改窗口的最左侧元素，</p>
<p>如果不是最大元素，因为滑动窗口可能没有k个元素,也不用担心是不是留在窗口里，这种情况下其实在下面push已经早出去了</p>
<p>这样更好理解 移动窗口,队列头结点需要在[i - k + 1, i]范围内，不符合则要弹出</p>
<p>这种也是官方解法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">maxSlidingWindow2</span><span class="params">(nums: <span class="type">IntArray</span>, k: <span class="type">Int</span>)</span></span>: IntArray &#123;</span><br><span class="line">    <span class="keyword">val</span> linkedList = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">val</span> resultArray = IntArray(nums.size - (k - <span class="number">1</span>))  <span class="comment">// 如果窗口是3个元素，结构数组就需要少两个元素</span></span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    nums.forEachIndexed &#123; index, value -&gt;</span><br><span class="line">        <span class="keyword">if</span> (!linkedList.isEmpty() &amp;&amp; linkedList.peek() &lt; index - (k - <span class="number">1</span>)) &#123; <span class="comment">//这样更好理解 移动窗口,队列头结点需要在[i - k + 1, i]范围内，不符合则要弹出</span></span><br><span class="line">            linkedList.pop()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!linkedList.isEmpty() &amp;&amp; value &gt; nums[linkedList.last()]) &#123;   <span class="comment">// 如果大于最后一个元素</span></span><br><span class="line">            linkedList.removeLast()                                     <span class="comment">//最后一个元素出队列</span></span><br><span class="line">        &#125;</span><br><span class="line">        linkedList.offer(index)                                          <span class="comment">//否则直接入队,这样保持队列元素单调递减</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt;= (k - <span class="number">1</span>)) &#123; <span class="comment">//如果是3个元素，从位置2开始存最大值，如果是1个元素，就从0存最大值</span></span><br><span class="line">            resultArray[i++] = nums[linkedList.peek()]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/solution/hua-dong-chuang-kou-de-zui-da-zhi-bao-mu-9eci/">https://leetcode.cn/problems/sliding-window-maximum/solution/hua-dong-chuang-kou-de-zui-da-zhi-bao-mu-9eci/</a></p>
<h5 id="MyQueue"><a href="#MyQueue" class="headerlink" title="MyQueue"></a>MyQueue</h5><p>随想录定义Myquue,更好，单一指责，更有层次感</p>
<p>//  注意先将前k的元素放进队列,此时push方法，放完后已经是按照单调递减队列来的了</p>
<p>二刷来刷刷刷</p>
<h4 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h4><p>大顶堆 看官方题解理解了</p>
<p>但是大顶堆 小顶堆区别不是很明白，学完树再来继续做这个题目</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-06-05T03:06:28.000Z" title="6/5/2022, 11:06:28 AM">2022-06-05</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-01-02T03:31:39.091Z" title="1/2/2023, 11:31:39 AM">2023-01-02</time></span><span class="level-item"><a class="link-muted" href="/categories/DataStructure/">DataStructure</a></span><span class="level-item">10 minutes read (About 1519 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/06/05/LC-string/">LC-string</a></p><div class="content"><h4 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串</a></h4><p>双指针</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">reverseString</span><span class="params">(s: <span class="type">CharArray</span>)</span></span>: <span class="built_in">Unit</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> right = s.size - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        swap(s, left, right)</span><br><span class="line">        left++</span><br><span class="line">        right--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">swap</span><span class="params">(s: <span class="type">CharArray</span>, left: <span class="type">Int</span>, right: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> temp = s[left]</span><br><span class="line">    s[left] = s[right]</span><br><span class="line">    s[right] = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="541-反转字符串-II"><a href="#541-反转字符串-II" class="headerlink" title="541. 反转字符串 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string-ii/">541. 反转字符串 II</a></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">reverseStr</span><span class="params">(s: <span class="type">String</span>, k: <span class="type">Int</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> charArray = s.toCharArray()</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> s.indices step <span class="number">2</span> * k) &#123;</span><br><span class="line">        <span class="keyword">var</span> left = i  <span class="comment">// 每次的left指针设置好</span></span><br><span class="line">        <span class="keyword">var</span> right = (i + k - <span class="number">1</span>)   <span class="comment">//接着设置每次的 右指针</span></span><br><span class="line">        <span class="keyword">if</span> (right &gt; s.length - <span class="number">1</span>) &#123; <span class="comment">// 如果字符串长度小于 这次的右指针，使用字符串的右边界作为右指针</span></span><br><span class="line">            right = s.length - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;  <span class="comment">//反转</span></span><br><span class="line">            LC344().swap(charArray, left, right)</span><br><span class="line">            left++</span><br><span class="line">            right--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> String(charArray)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>随想录感觉解法不太好</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string-ii/solution/gong-shui-san-xie-jian-dan-zi-fu-chuan-m-p88f/">https://leetcode.cn/problems/reverse-string-ii/solution/gong-shui-san-xie-jian-dan-zi-fu-chuan-m-p88f/</a></p>
<p>这个解法和我的差不多，更优雅</p>
<h4 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/solution/zhe-dao-ti-mu-zhen-de-you-zhe-yao-jian-dan-ma-qing/">https://leetcode.cn/problems/ti-huan-kong-ge-lcof/solution/zhe-dao-ti-mu-zhen-de-you-zhe-yao-jian-dan-ma-qing/</a></p>
<h4 id="151-颠倒字符串中的单词"><a href="#151-颠倒字符串中的单词" class="headerlink" title="151. 颠倒字符串中的单词"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 颠倒字符串中的单词</a></h4><p>这题的难点，主要就是去除 字符串中间的空格</p>
<h5 id="栈或双端队列解法"><a href="#栈或双端队列解法" class="headerlink" title="栈或双端队列解法"></a>栈或双端队列解法</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/*   栈或双端队列解法</span></span><br><span class="line"><span class="comment">    *    1. 设置left , right指针，移动指针，类似移除两端的空格</span></span><br><span class="line"><span class="comment">    *    2. 从第一个元素开始遍历,添加到StringBuilder,直到遇到第一个空格，StringBuilder的数据加入队列,清空StringBuilder</span></span><br><span class="line"><span class="comment">    *    3. 直到最后一个加入队列</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * if (s[left] != &#x27; &#x27;) 中的&#x27; &#x27;是Ascii十进制32,单测中有验证</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">reverseWords</span><span class="params">(s: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> right = s.length - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (s[left] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (s[right] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            right--</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> deque: Deque&lt;String&gt; = ArrayDeque()</span><br><span class="line">        <span class="keyword">val</span> sb = StringBuilder()</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> left..right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[left] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                sb.append(s[left])</span><br><span class="line"><span class="comment">//            &#125; else if (s[left] == &#x27; &#x27; &amp;&amp; sb[sb.length - 1] != &#x27; &#x27;) &#123; // 一开始以为官方也是这样写的，其实也是下面我这种的</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[left] == <span class="string">&#x27; &#x27;</span> &amp;&amp; sb.isNotEmpty()) &#123; <span class="comment">// 这里改成这样是因为加入 &quot;the sky is blue&quot; ， left==3走到了空格，</span></span><br><span class="line">                deque.offerFirst(sb.toString())             <span class="comment">//就初始化sb,然后left==4走到了s,如果两个空格，sb[sb.length - 1]就会越界</span></span><br><span class="line">                sb.setLength(<span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">        deque.offerFirst(sb.toString())</span><br><span class="line">        <span class="keyword">return</span> java.lang.String.join(<span class="string">&quot; &quot;</span>, deque)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>官方题解，文字版的感觉更好点，因为有java的版本的，视频的c++的不用stringbuilder</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-words-in-a-string/solution/fan-zhuan-zi-fu-chuan-li-de-dan-ci-by-leetcode-sol/">https://leetcode.cn/problems/reverse-words-in-a-string/solution/fan-zhuan-zi-fu-chuan-li-de-dan-ci-by-leetcode-sol/</a></p>
<h5 id="两次反转字符串"><a href="#两次反转字符串" class="headerlink" title="两次反转字符串"></a>两次反转字符串</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 去除空格，并且用StringBuilder组合</span></span><br><span class="line"><span class="comment"> * 2. 翻转整个StringBuilder</span></span><br><span class="line"><span class="comment"> * 3. 翻转StringBuilder中的单个字符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">reverseWords2</span><span class="params">(s: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> sb = deleteStartEndSpace(s)</span><br><span class="line">    reverseStringBuilder(sb, <span class="number">0</span>, sb.length - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">var</span> wStart = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> wEnd = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (wStart &lt; sb.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sb.getOrElse(wEnd) &#123; <span class="string">&#x27; &#x27;</span> &#125; == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            reverseStringBuilder(sb, wStart, wEnd - <span class="number">1</span>)</span><br><span class="line">            wStart = ++wEnd</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            wEnd++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">deleteStartEndSpace</span><span class="params">(s: <span class="type">String</span>)</span></span>: StringBuilder &#123;</span><br><span class="line">    <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> right = s.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (s[left] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">        left++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (s[right] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">        right--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> sb = StringBuilder()</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123; <span class="comment">// 注意这里最右边的字符是需要添加的</span></span><br><span class="line">        <span class="keyword">if</span> (s[left] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            sb.append(s[left])</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[left] == <span class="string">&#x27; &#x27;</span> &amp;&amp; s[left - <span class="number">1</span>] != <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">//不提前去掉空格，如果字符左边&quot;  hello world  &quot;有空格就会越界，</span></span><br><span class="line">            sb.append(s[left])                            <span class="comment">//而且StringBuilder右边空格也会添加空格，而且不好去掉</span></span><br><span class="line">        &#125;</span><br><span class="line">        left++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">reverseStringBuilder</span><span class="params">(sb: <span class="type">StringBuilder</span>, leftP: <span class="type">Int</span>, rightP: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> left = leftP</span><br><span class="line">    <span class="keyword">var</span> right = rightP</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">val</span> temp = sb[left]</span><br><span class="line">        sb.setCharAt(left, sb[right])</span><br><span class="line">        sb.setCharAt(right, temp)</span><br><span class="line">        left++</span><br><span class="line">        right--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>官方解法，翻转子字符串这种更妙</p>
<pre><code>public void reverseEachWord(StringBuilder sb) &#123;
    int n = sb.length();
    int start = 0, end = 0;

    while (start &lt; n) &#123;
        // 循环至单词的末尾
        while (end &lt; n &amp;&amp; sb.charAt(end) != &#39; &#39;) &#123;
            ++end;
        &#125;
        // 翻转单词
        reverse(sb, start, end - 1);
        // 更新start，去找下一个单词
        start = end + 1;
        ++end;
    &#125;
&#125;
</code></pre>
<h4 id="剑指-Offer-58-II-左旋转字符串"><a href="#剑指-Offer-58-II-左旋转字符串" class="headerlink" title="剑指 Offer 58 - II. 左旋转字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串</a></h4><h5 id="数组System-arraycopy"><a href="#数组System-arraycopy" class="headerlink" title="数组System.arraycopy"></a>数组System.arraycopy</h5><p>深入分析用到了汇编指令,后面可以加强学习,其实底层的知识还是需要的，要不然没法深入下去了</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/jackgo73/article/details/111866491">https://blog.csdn.net/jackgo73/article/details/111866491</a></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">reverseLeftWords</span><span class="params">(s: <span class="type">String</span>, n: <span class="type">Int</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> sb = StringBuilder(s)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        sb.append(s[i])</span><br><span class="line">        sb.deleteCharAt(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>不能申请额外空间，只能在本串上操作</strong></p>
<p>我觉得用carl的方法更好</p>
<ol>
<li>反转区间为前n的子串</li>
<li>反转区间为n到末尾的子串</li>
<li>反转整个字符串</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/%E5%89%91%E6%8C%87Offer58-II.%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC">https://programmercarl.com/%E5%89%91%E6%8C%87Offer58-II.%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC</a></p>
<h4 id="28-实现-strStr"><a href="#28-实现-strStr" class="headerlink" title="28. 实现 strStr()"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-strstr/">28. 实现 strStr()</a></h4><h5 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h5><p>aabaabaaf</p>
<p>aabaaf</p>
<p>整体移动底下的字串，然后匹配</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">strStr</span><span class="params">(haystack: <span class="type">String</span>, needle: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> needleIndex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> haystack.indices) &#123;</span><br><span class="line">        <span class="keyword">var</span> hayIndex = i</span><br><span class="line">        <span class="keyword">while</span> (needleIndex &lt; needle.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (haystack.getOrNull(hayIndex) == needle[needleIndex]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (needleIndex == needle.length - <span class="number">1</span>) <span class="keyword">return</span> i</span><br><span class="line">                hayIndex++</span><br><span class="line">                needleIndex++</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                needleIndex = <span class="number">0</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个暴力解法，也有更好的写法</p>
<h5 id="kmp"><a href="#kmp" class="headerlink" title="kmp"></a>kmp</h5><p><a target="_blank" rel="noopener" href="https://noteforme.github.io/2021/06/17/kmp/">https://noteforme.github.io/2021/06/17/kmp/</a></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">strStrKmp</span><span class="params">(haystack: <span class="type">String</span>, needle: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> nextArray = initNext(needle) <span class="comment">// 初始化next数组</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> haystack.indices) &#123;       <span class="comment">// 文本串指针i 移动</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack[i] != needle[j]) &#123;</span><br><span class="line">            j = nextArray[j - <span class="number">1</span>]    <span class="comment">// 模式串 指针 根据next数组的下标回退</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (haystack[i] == needle[j]) &#123; <span class="comment">// 文本串 模式串对应的字符相等</span></span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == needle.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> i - j + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模式串</span></span><br><span class="line"><span class="comment"> * i指向后缀末尾位置</span></span><br><span class="line"><span class="comment"> * j 指向前缀末尾位置， 也代表 i和i之前的 最长公共前后缀的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">initNext</span><span class="params">(needle: <span class="type">String</span>)</span></span>: IntArray &#123;</span><br><span class="line">    <span class="keyword">var</span> nextArray = IntArray(needle.length)</span><br><span class="line">    <span class="keyword">var</span> j = <span class="number">0</span> <span class="comment">// j 前缀0开始初始化</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until needle.length) &#123; <span class="comment">// i后缀末尾 ，从1开始初始化</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; needle[i] != needle[j]) &#123;</span><br><span class="line">            j = nextArray[j - <span class="number">1</span>]            <span class="comment">// 前一个位置下标 回退</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (needle[i] == needle[j]) j++     <span class="comment">// 找到新的相等字符， 在之前最长公共前后缀长度 +1</span></span><br><span class="line">        nextArray[i] = j <span class="comment">// 更新next下标</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nextArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459. 重复的子字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/repeated-substring-pattern/">459. 重复的子字符串</a></h4><p>这题根据随想录的 公式 套的</p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC">https://programmercarl.com/0459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC</a></p>
<p>next[len - 1] = 7，next[len - 1] + 1 = 8 这句话的意思是. 这里数组统一减1，所以需要加1 == 8</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">repeatedSubstringPattern</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> nxtArrr = initNext(s)</span><br><span class="line">    <span class="keyword">val</span> len = s.length</span><br><span class="line">    <span class="keyword">if</span> (nxtArrr[len - <span class="number">1</span>] != <span class="number">0</span> &amp;&amp; len % (len - nxtArrr[len - <span class="number">1</span>]) == <span class="number">0</span>) &#123; <span class="comment">//这两句 是根据随想录的公式抄的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">initNext</span><span class="params">(s: <span class="type">String</span>)</span></span>: IntArray &#123;</span><br><span class="line">    <span class="keyword">var</span> j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> nxt = IntArray(s.length)</span><br><span class="line">    nxt[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until s.length) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) &#123;</span><br><span class="line">            j = nxt[j - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[j]) j++</span><br><span class="line">        nxt[i] = j</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nxt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-05-21T13:53:24.000Z" title="5/21/2022, 9:53:24 PM">2022-05-21</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-01-02T03:31:39.088Z" title="1/2/2023, 11:31:39 AM">2023-01-02</time></span><span class="level-item"><a class="link-muted" href="/categories/DataStructure/">DataStructure</a></span><span class="level-item">19 minutes read (About 2789 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/05/21/LC-hash/">LC-hash</a></p><div class="content"><h4 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词</a></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isAnagram</span><span class="params">(s: <span class="type">String</span>, t: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> record = IntArray(<span class="number">26</span>) <span class="comment">// 存整数，就用整形数</span></span><br><span class="line">    s.toCharArray().forEachIndexed &#123; _, char -&gt;</span><br><span class="line">        record[char - <span class="string">&#x27;a&#x27;</span>]++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t.toCharArray().forEachIndexed &#123; _, char -&gt;</span><br><span class="line">        record[char - <span class="string">&#x27;a&#x27;</span>]--</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    record.forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (it != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ransom-note/">383. 赎金信</a></h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/c15158032319/article/details/78209740">https://blog.csdn.net/c15158032319/article/details/78209740</a></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">canConstruct</span><span class="params">(ransomNote: <span class="type">String</span>, magazine: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> record = IntArray(<span class="number">26</span>)</span><br><span class="line">    magazine.toCharArray().forEach &#123; char -&gt;</span><br><span class="line">        record[char - <span class="string">&#x27;a&#x27;</span>] += <span class="number">1</span> <span class="comment">// 这里可以优化下</span></span><br><span class="line">    &#125;</span><br><span class="line">    ransomNote.toCharArray().forEach &#123; char -&gt;</span><br><span class="line">        record[char - <span class="string">&#x27;a&#x27;</span>] -= <span class="number">1</span>		<span class="comment">//同上</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    record.forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (it &lt; <span class="number">0</span>) &#123; <span class="comment">//就这里和242.有效的字母异位词 不一样，数量不够就&lt;0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>//若 a = i++; 则等价于 a=i;i=i+1;<br>//而 a = ++i; 则等价于 i=i+1;a=i;<br>//a += 1 和   a = a + 1</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">canConstruct</span><span class="params">(ransomNote: <span class="type">String</span>, magazine: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> record = IntArray(<span class="number">26</span>)</span><br><span class="line">    magazine.toCharArray().forEach &#123; char -&gt;</span><br><span class="line">        record[char - <span class="string">&#x27;a&#x27;</span>] ++ </span><br><span class="line">    &#125;</span><br><span class="line">    ransomNote.toCharArray().forEach &#123; char -&gt;</span><br><span class="line">        record[char - <span class="string">&#x27;a&#x27;</span>] --</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    record.forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (it &lt; <span class="number">0</span>) &#123; <span class="comment">//就这里和242.有效的字母异位词 不一样，数量不够就&lt;0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/group-anagrams/">49. 字母异位词分组</a></h4><p>用的官方题解</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/group-anagrams/solution/zi-mu-yi-wei-ci-fen-zu-by-leetcode-solut-gyoc/">https://leetcode.cn/problems/group-anagrams/solution/zi-mu-yi-wei-ci-fen-zu-by-leetcode-solut-gyoc/</a></p>
<h5 id="题解一"><a href="#题解一" class="headerlink" title="题解一"></a>题解一</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">groupAnagrams</span><span class="params">(strs: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>: List&lt;List&lt;String&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> ansMap = HashMap&lt;String, ArrayList&lt;String&gt;&gt;() <span class="comment">// 相同异位词的key, 和所有异位词的数组</span></span><br><span class="line">    strs.forEach &#123; str -&gt;</span><br><span class="line">        <span class="keyword">val</span> char = str.toCharArray() <span class="comment">// String to char 进行排序，结果相同异位词key一致</span></span><br><span class="line">        Arrays.sort(char)</span><br><span class="line">        <span class="keyword">val</span> key = String(char)</span><br><span class="line">        <span class="keyword">if</span> (!ansMap.containsKey(key)) &#123; <span class="comment">// map不存在，就创建新的ArrayList()</span></span><br><span class="line">            ansMap[key] = ArrayList()</span><br><span class="line">        &#125;</span><br><span class="line">        ansMap[key]?.add(str)          <span class="comment">//拿到ArrayList(),添加元素</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ArrayList(ansMap.values)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="题解二"><a href="#题解二" class="headerlink" title="题解二"></a>题解二</h5><p>官方题解2 和题解一差不多，题解一进行排序的相同key,题解二用的散列计数，中间用#间隔作为 key.</p>
<p>其他的都类似，后面再写吧 。</p>
<p><img src="/2022/05/21/LC-hash/LC-carl-hash/1262C65F-FDC3-4290-957B-AEA8405D53FA.png" alt="1262C65F-FDC3-4290-957B-AEA8405D53FA"></p>
<p>复杂度分析</p>
<p>时间复杂度：O(nk \log k)O(nklogk)，其中 nn 是 \textit{strs}strs 中的字符串的数量，kk 是 \textit{strs}strs 中的字符串的的最大长度。需要遍历 nn 个字符串，对于每个字符串，需要 O(k \log k)O(klogk) 的时间进行排序以及 O(1)O(1) 的时间更新哈希表，因此总时间复杂度是 O(nk \log k)O(nklogk)。</p>
<p>空间复杂度：O(nk)O(nk)，其中 nn 是 \textit{strs}strs 中的字符串的数量，kk 是 \textit{strs}strs 中的字符串的的最大长度。需要用哈希表存储全部字符串。</p>
<h4 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a></h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/solution/zhao-dao-zi-fu-chuan-zhong-suo-you-zi-mu-xzin/">https://leetcode.cn/problems/find-all-anagrams-in-a-string/solution/zhao-dao-zi-fu-chuan-zhong-suo-you-zi-mu-xzin/</a></p>
<h5 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findAnagrams</span><span class="params">(s: <span class="type">String</span>, p: <span class="type">String</span>)</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> sLength = s.length</span><br><span class="line">    <span class="keyword">val</span> pLength = p.length</span><br><span class="line">    <span class="keyword">if</span> (sLength &lt; pLength) &#123; <span class="comment">// 如果字符s的长度 小于p 直接返回</span></span><br><span class="line">        <span class="keyword">return</span> emptyList()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> ansList = arrayListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">val</span> sCount = IntArray(<span class="number">26</span>)</span><br><span class="line">    <span class="keyword">val</span> pCount = IntArray(<span class="number">26</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> sCharArray = s.toCharArray()</span><br><span class="line">    <span class="keyword">val</span> pCharArray = p.toCharArray()</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until pLength) &#123;      <span class="comment">//初始情况， p s字符相同，看是否相等.</span></span><br><span class="line">        sCount[sCharArray[i] - <span class="string">&#x27;a&#x27;</span>]++          <span class="comment">// 对于位置字符个数</span></span><br><span class="line">        pCount[pCharArray[i] - <span class="string">&#x27;a&#x27;</span>]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sCount.contentEquals(pCount)) &#123;         <span class="comment">//比较初始数量</span></span><br><span class="line">        ansList.add(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until (sLength - pLength)) &#123; <span class="comment">// 从0开始，s的字符 左边-1 右边+1 字符，调整相应位置字符数量，</span></span><br><span class="line">        sCount[sCharArray[i] - <span class="string">&#x27;a&#x27;</span>]--</span><br><span class="line">        sCount[sCharArray[i + pLength] - <span class="string">&#x27;a&#x27;</span>]++</span><br><span class="line">        <span class="keyword">if</span> (sCount.contentEquals(pCount)) &#123;</span><br><span class="line">            ansList.add(i + <span class="number">1</span>)              <span class="comment">//如果 i==0, 那么0位置字符去掉， p.length + 0 字符+1, 新的字符开始位置就是1了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ansList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h5><p>diff方式，感觉没太明白 , 而且感觉作用不大,后面可以试试</p>
<h5 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h5><p>这个滑动窗口，解法很高级，但是没明白</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; findAnagrams(String s, String p) &#123;</span><br><span class="line">    int[] cnt = new int[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">for</span> (char c : p.toCharArray()) cnt[c]++;</span><br><span class="line">    int lo = <span class="number">0</span>, hi = <span class="number">0</span>;</span><br><span class="line">    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 该循环确保[lo, hi)的区间中的出现的字符总是p的一个子集</span></span><br><span class="line">    <span class="comment">// PS1: &quot;na&quot;是&quot;and&quot;的子集，而&quot;nn&quot;则不是&quot;and&quot;的子集</span></span><br><span class="line">    <span class="comment">// PS2: 除了评论中那个边际条件，前面已经有评论解释过了</span></span><br><span class="line">    <span class="keyword">while</span> (hi &lt; s.length()) &#123;</span><br><span class="line">        char c = s.charAt(hi);</span><br><span class="line">        <span class="keyword">if</span> (cnt[c] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 子集条件满足，右移增大窗口</span></span><br><span class="line">            char c1 = s.charAt(hi++);</span><br><span class="line">            cnt[c1]--;</span><br><span class="line">            <span class="comment">// 窗口长度 == p.len，且窗口内字符是p的子集</span></span><br><span class="line">            <span class="comment">// &lt;=&gt; (充要条件) s.substring(lo, hi)是p的同字母异序词</span></span><br><span class="line">            <span class="keyword">if</span> (hi - lo == p.length())&#123;</span><br><span class="line">                res.add(lo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 再右移hi不可能满足子集条件，</span></span><br><span class="line">            <span class="comment">// 右移左边界lo、复位计数器，直到这个条件（子集条件）再次满足</span></span><br><span class="line">            char c1 = s.charAt(lo++);</span><br><span class="line">            cnt[c1]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. 两个数组的交集</a></h4><p>计算两个数组的交集，直观的方法是遍历数组 nums1，对于其中的每个元素，遍历数组 nums2 判断该元素是否在数组 nums2 中，如果存在，则将该元素添加到返回值。假设数组 nums1 和 nums2 的长度分别是 mm 和 nn，则遍历数组 nums1 需要 O(m)O(m) 的时间，判断 nums1 中的每个元素是否在数组 nums2 中需要 O(n)O(n) 的时间，因此总时间复杂度是 O(mn)O(mn)。</p>
<p>如果使用哈希集合存储元素，则可以在 O(1)的时间内判断一个元素是否在集合中，从而降低时间复杂度。 if (set.contains(it))这句是o(1)?</p>
<p>首先使用两个集合分别存储两个数组中的元素，然后遍历较小的集合，判断其中的每个元素是否在另一个集合中，如果元素也在另一个集合中，则将该元素添加到返回值。该方法的时间复杂度可以降低到 O(m+n)</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> <span class="keyword">set</span> = hashSetOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">nums1.forEach &#123;</span><br><span class="line">    <span class="keyword">set</span>.add(it)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> anSet = hashSetOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">nums2.forEach &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">set</span>.contains(it)) &#123; <span class="comment">// hashmap是怎么hash表是怎么存储的，为什么这样时间复杂度低, 因为在hash表中存储</span></span><br><span class="line">        anSet.add(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> anSet.toIntArray()</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html#_349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86">https://programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html#_349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-arrays/solution/liang-ge-shu-zu-de-jiao-ji-by-leetcode-solution/">https://leetcode.cn/problems/intersection-of-two-arrays/solution/liang-ge-shu-zu-de-jiao-ji-by-leetcode-solution/</a></p>
<h4 id="350-两个数组的交集-II"><a href="#350-两个数组的交集-II" class="headerlink" title="350. 两个数组的交集 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-arrays-ii/">350. 两个数组的交集 II</a></h4><h5 id="解法一-1"><a href="#解法一-1" class="headerlink" title="解法一"></a>解法一</h5><p>自己的思路</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">intersect</span><span class="params">(nums1: <span class="type">IntArray</span>, nums2: <span class="type">IntArray</span>)</span></span>: IntArray &#123;</span><br><span class="line">    <span class="keyword">val</span> ansArray = arrayListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">val</span> map1 = hashMapOf&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line">    nums1.forEach &#123;</span><br><span class="line">        map1[it] = (map1[it] ?: <span class="number">0</span>).plus(<span class="number">1</span>) <span class="comment">// key是 nums1 数组的值，value是个数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> map2 = hashMapOf&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line">    nums2.forEach &#123;</span><br><span class="line">        map2[it] = (map2[it] ?: <span class="number">0</span>).plus(<span class="number">1</span>) <span class="comment">//key是 nums2 数组的值，value是个数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> map3 = hashMapOf&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">val</span> keySet2 = map2.keys</span><br><span class="line">    map1.entries.forEach &#123; entry -&gt;</span><br><span class="line">        <span class="keyword">if</span> (keySet2.contains(entry.key)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.value &lt; map2[entry.key]!!) &#123; <span class="comment">// 存在相同的值，比较数组的个数</span></span><br><span class="line">                map3[entry.key] = entry.value</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map3[entry.key] = map2[entry.key]!!      <span class="comment">//较小的放给新的map</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    map3.entries.forEach &#123; entry -&gt;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until entry.value) &#123; <span class="comment">// entry.value是map的个数，然后添加的list</span></span><br><span class="line">            ansArray.add(entry.key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ansArray.toIntArray()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="解法二-1"><a href="#解法二-1" class="headerlink" title="解法二"></a>解法二</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">intersect1</span><span class="params">(nums1: <span class="type">IntArray</span>, nums2: <span class="type">IntArray</span>)</span></span>: IntArray &#123;</span><br><span class="line">    <span class="keyword">val</span> ansArray = arrayListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">val</span> map = hashMapOf&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line">    nums1.forEach &#123;</span><br><span class="line">        map[it] = (map[it] ?: <span class="number">0</span>).plus(<span class="number">1</span>) <span class="comment">// key是 nums1 数组的值，value是个数</span></span><br><span class="line">    &#125;</span><br><span class="line">    nums2.forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> ((map[it] ?: <span class="number">0</span>) &gt; <span class="number">0</span>) &#123;   <span class="comment">// 判断是否存在相同的元素</span></span><br><span class="line">            ansArray.add(it)        <span class="comment">// 添加</span></span><br><span class="line">            map[it] = map[it]!!.minus(<span class="number">1</span>) <span class="comment">// 原来的元素-1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.remove(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ansArray.toIntArray()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="解法三-1"><a href="#解法三-1" class="headerlink" title="解法三"></a>解法三</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">intersect3</span><span class="params">(nums1: <span class="type">IntArray</span>, nums2: <span class="type">IntArray</span>)</span></span>: IntArray &#123;</span><br><span class="line">    Arrays.sort(nums1)</span><br><span class="line">    Arrays.sort(nums2)</span><br><span class="line">    <span class="keyword">val</span> ansArray = arrayListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">var</span> index1 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> index2 = <span class="number">0</span> <span class="comment">// 排序后，设置两个指针，指向数组头节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (index1 &lt; nums1.size &amp;&amp; index2 &lt; nums2.size)</span><br><span class="line">        <span class="keyword">if</span> (nums1[index1] &gt; nums2[index2]) &#123; <span class="comment">// 谁小，谁走</span></span><br><span class="line">            index2++</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[index1] &lt; nums2[index2]) &#123;</span><br><span class="line">            index1++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                        <span class="comment">//相等的情况，就添加到结果数组中</span></span><br><span class="line">            ansArray.add(nums1[index1])</span><br><span class="line">            index2++</span><br><span class="line">            index1++</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ansArray.toIntArray()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>还有进阶题目</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-arrays-ii/solution/liang-ge-shu-zu-de-jiao-ji-ii-by-leetcode-solution/">https://leetcode.cn/problems/intersection-of-two-arrays-ii/solution/liang-ge-shu-zu-de-jiao-ji-ii-by-leetcode-solution/</a></p>
<h4 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/happy-number/">202. 快乐数</a></h4><p>可以看作一个链表， 不是快乐数会形成环, 否则就是快乐数了</p>
<ol>
<li>最终会得到 11。</li>
<li>最终会进入循环。</li>
<li>值会越来越大，最后接近无穷大。</li>
</ol>
<p>根据题解猜测，第3种情况不会发生</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/happy-number/solution/kuai-le-shu-by-leetcode-solution/">https://leetcode.cn/problems/happy-number/solution/kuai-le-shu-by-leetcode-solution/</a></p>
<h5 id="Hash表解法"><a href="#Hash表解法" class="headerlink" title="Hash表解法"></a>Hash表解法</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isHappy</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">set</span> = hashSetOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">var</span> value = n</span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">set</span>.contains(value)) &#123; <span class="comment">// 没有环，就继续下一个</span></span><br><span class="line">        <span class="keyword">if</span> (value == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>.add(value)          <span class="comment">// 把中间数加入hash表，为了判断是否有环的情况</span></span><br><span class="line">        value = nextSquareSum(value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">nextSquareSum</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> num = n</span><br><span class="line">    <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> balance = num % <span class="number">10</span> <span class="comment">//每次都获取余数</span></span><br><span class="line">        sum += balance * balance</span><br><span class="line">        num = (num / <span class="number">10</span>)       <span class="comment">// 拿到上一位，然后求余</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="双指针解法"><a href="#双指针解法" class="headerlink" title="双指针解法"></a>双指针解法</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isHappy2</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> slow = n</span><br><span class="line">    <span class="keyword">var</span> fast = n</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        slow = nextSquareSum(slow) <span class="comment">//每个数据可以看作一个node, 然后设置快慢节点</span></span><br><span class="line">        fast = nextSquareSum(fast)</span><br><span class="line">        fast = nextSquareSum(fast)</span><br><span class="line">        <span class="keyword">if</span> (slow == <span class="number">1</span> || fast == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (slow != fast)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h4><h5 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h5><p>当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过(这个一句一开始不理解，其实如果i = 6,  j = 5+1(1+1 , 2+1.. 4+1) 之前的都没匹配上，所以说x之前的都没匹配)，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-solution/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="Hash法"><a href="#Hash法" class="headerlink" title="Hash法"></a>Hash法</h5><p>2, 7, 11, 15</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">twoSum</span><span class="params">(nums: <span class="type">IntArray</span>, target: <span class="type">Int</span>)</span></span>: IntArray &#123;</span><br><span class="line">    <span class="keyword">val</span> map = hashMapOf&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line">    nums.forEachIndexed &#123; index, value -&gt;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(target - nums[index])) &#123;    <span class="comment">//假如index = 0加入map,当index==2时, 9 - 7 = 2 就可以在map中找到，就匹配上了</span></span><br><span class="line">            <span class="keyword">return</span> intArrayOf(index, map[target - nums[index]]!!) <span class="comment">//相当于另一个数先加入map，找对应的数</span></span><br><span class="line">        &#125;</span><br><span class="line">        map[value] = index    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;do not have the array&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="454-四数相加-II"><a href="#454-四数相加-II" class="headerlink" title="454. 四数相加 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum-ii/">454. 四数相加 II</a></h4><p>这题不是很明白</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fourSumCount</span><span class="params">(nums1: <span class="type">IntArray</span>, nums2: <span class="type">IntArray</span>, nums3: <span class="type">IntArray</span>, nums4: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> map = hashMapOf&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line">    nums1.forEach &#123; n1 -&gt;</span><br><span class="line">        nums2.forEach &#123; n2 -&gt;</span><br><span class="line">            map[n1 + n2] = map.getOrDefault(n1 + n2, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ans = <span class="number">0</span></span><br><span class="line">    nums3.forEach &#123; n3 -&gt;</span><br><span class="line">        nums4.forEach &#123; n4 -&gt;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(-n3 - n4)) &#123; <span class="comment">// 6, 12 , -7 , -11   4个数2 2相加 不管怎么组合，结果都一样</span></span><br><span class="line">                ans += map[-n3 - n4] ?: <span class="number">0</span>  <span class="comment">// 根据当前的key,区前面num1 num2找个数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h4><p>i 位置为target = nuts[-i] , 剩下的left right就是 twosum的问题</p>
<h5 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    fun threeSum(nums: IntArray): List&lt;List&lt;Int&gt;&gt; &#123;</span><br><span class="line">        Arrays.sort(nums)</span><br><span class="line">        val hashSetOf &#x3D; hashSetOf&lt;List&lt;Int&gt;&gt;()</span><br><span class="line">        nums.forEachIndexed &#123; i, value -&gt;</span><br><span class="line">            val target &#x3D; -nums[i]</span><br><span class="line">            var left &#x3D; i + 1</span><br><span class="line">            var right &#x3D; nums.size - 1</span><br><span class="line">            while (left &lt; right) &#123;</span><br><span class="line">                if (nums[left] + nums[right] &lt; target) &#123;</span><br><span class="line">                    left++</span><br><span class="line">                &#125; else if (nums[left] + nums[right] &gt; target) &#123;</span><br><span class="line">                    right--</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    val list &#x3D; arrayListOf(nums[i], nums[left], nums[right])</span><br><span class="line">                    hashSetOf.add(list)</span><br><span class="line">                    right--  &#x2F;&#x2F; 为了防止重复元素，所以这两个也需要移动</span><br><span class="line">                    left++</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#x2F;&#x2F;        return hashSetOf.toList()</span><br><span class="line">        return ArrayList(hashSetOf) &#x2F;&#x2F; 这里时间复杂度是 o(n),第2种解法是对这里进行优化</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h5 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h5><p>优化后的第二种解法，竟然超出时间限制，刷第2遍再看看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;超出时间限制</span><br><span class="line">fun threeSum2(nums: IntArray): List&lt;List&lt;Int&gt;&gt; &#123;</span><br><span class="line">    Arrays.sort(nums)</span><br><span class="line">    val ans &#x3D; ArrayList&lt;List&lt;Int&gt;&gt;()</span><br><span class="line">    for (i in nums.indices) &#123;</span><br><span class="line">        if (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) &#123; &#x2F;&#x2F; 相同的target元素直接pass</span><br><span class="line">            continue</span><br><span class="line">        &#125;</span><br><span class="line">        val target &#x3D; -nums[i]</span><br><span class="line">        var left &#x3D; i + 1</span><br><span class="line">        var right &#x3D; nums.size - 1</span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            if (nums[left] + nums[right] &lt; target) &#123;</span><br><span class="line">                left++</span><br><span class="line">            &#125; else if (nums[left] + nums[right] &gt; target) &#123;</span><br><span class="line">                right--</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                val list &#x3D; arrayListOf(nums[i], nums[left], nums[right])</span><br><span class="line">                ans.add(list)</span><br><span class="line">                right--  &#x2F;&#x2F; 为了防止重复元素，所以这两个也需要移动</span><br><span class="line">                left++</span><br><span class="line">                while (left &lt; right &amp;&amp; nums[left] &#x3D;&#x3D; nums[left - 1]) continue &#x2F;&#x2F; 这两句放在while循环外面 退出不了,拿到结果后， 相同的元素pass</span><br><span class="line">                while (left &lt; right &amp;&amp; nums[right] &#x3D;&#x3D; nums[right - 1]) continue</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-05-02T05:07:27.000Z" title="5/2/2022, 1:07:27 PM">2022-05-02</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-10-21T14:43:16.486Z" title="10/21/2023, 10:43:16 PM">2023-10-21</time></span><span class="level-item"><a class="link-muted" href="/categories/DataStructure/">DataStructure</a></span><span class="level-item">15 minutes read (About 2277 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/05/02/LC-array/">LC-array</a></p><div class="content"><h4 id="Array结构"><a href="#Array结构" class="headerlink" title="Array结构"></a>Array结构</h4><p>数组为什么从0开始.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> foo[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">foo[<span class="number">0</span>] </span><br><span class="line">*(foo + <span class="number">0</span>) <span class="comment">// 因为c语言指针偏移量从0开始</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdn.net/20161111021559583" alt="这里写图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[3][4]</span><br><span class="line">a[0][0], a[0][1] , a[0][2] , a[0][3]</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://developer.51cto.com/article/649423.html">https://developer.51cto.com/article/649423.html</a></p>
<h4 id="LEETCODE-26"><a href="#LEETCODE-26" class="headerlink" title="LEETCODE 26"></a>LEETCODE 26</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/</a></p>
<p>解法： 双指针</p>
<p>首先注意数组是有序的，那么重复的元素一定会相邻。</p>
<p>要求删除重复元素，实际上就是将不重复的元素移到数组的左侧。</p>
<p>考虑用 2 个指针，一个在前记作 p，一个在后记作 q，算法流程如下：</p>
<p>比较 p 和 q 位置的元素是否相等。</p>
<p>如果相等，q 后移 1 位<br>如果不相等，将 q 位置的元素复制到 p+1 位置上，p 后移一位，q 后移 1 位<br>重复上述过程，直到 q 等于数组长度。</p>
<p>返回 p + 1，即为新数组长度。</p>
<p><img src="https://pic.leetcode-cn.com/0039d16b169059e8e7f998c618b6c2b269c2d95b02f43415350bde1f661e503a-1.png" alt="1.png"></p>
<ol>
<li>Nums[p] == nums[q]  q 后移1位</li>
<li>Nums[p] != nums[q].  Nums[p+1] = nums[q]. p 后移1位， q后移1位</li>
<li>Nums[p] != nums[q] 。。。。</li>
</ol>
<p>上图向下的箭头，只代表步骤，不代表指针位置</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个更好理解 https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/shuang-zhi-zhen-shan-chu-zhong-fu-xiang-dai-you-hu/</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">removeDuplicates1</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> slowIndex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (fastIndex <span class="keyword">in</span> <span class="number">1</span> until nums.size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[fastIndex] != nums[slowIndex]) &#123;</span><br><span class="line">            nums[slowIndex + <span class="number">1</span>] = nums[fastIndex] <span class="comment">// 慢指针的后一个位置，放上 快指针不同的值</span></span><br><span class="line">            slowIndex++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slowIndex+<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//官方解法，不好理解</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">removeDuplicates</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> slowIndex = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (fastIndex <span class="keyword">in</span> <span class="number">1</span> until nums.size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[fastIndex] != nums[slowIndex - <span class="number">1</span>]) &#123;</span><br><span class="line">            nums[slowIndex] = nums[fastIndex]</span><br><span class="line">            slowIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slowIndex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/move-zeroes/">283. 移动零</a></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">moveZeroes</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Unit</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> slowIndex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (fastIndex <span class="keyword">in</span> <span class="number">1</span> until nums.size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[fastIndex] != <span class="number">0</span> &amp;&amp; nums[slowIndex] == <span class="number">0</span>) &#123; <span class="comment">//符合条件就交换位置，慢指针让它在后面的条件移动</span></span><br><span class="line">            nums[slowIndex] = nums[fastIndex]</span><br><span class="line">            nums[fastIndex] = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[slowIndex] != <span class="number">0</span>) &#123; <span class="comment">// 慢指针 !=0就移动</span></span><br><span class="line">            slowIndex++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="844-比较含退格的字符串"><a href="#844-比较含退格的字符串" class="headerlink" title="844. 比较含退格的字符串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/backspace-string-compare/">844. 比较含退格的字符串</a></h4><h6 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h6><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">backspaceCompare1</span><span class="params">(s: <span class="type">String</span>, t: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> sStack = Stack&lt;<span class="built_in">Char</span>&gt;()</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> s.indices) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sStack.isNotEmpty()) &#123;</span><br><span class="line">                sStack.pop()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sStack.push(s[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> tStack = Stack&lt;<span class="built_in">Char</span>&gt;()</span><br><span class="line">    <span class="keyword">for</span> (j <span class="keyword">in</span> t.indices) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t[j] == <span class="string">&#x27;#&#x27;</span>) &#123; <span class="comment">// 复制还不如自己写，一开始写成s[i]</span></span><br><span class="line">            <span class="keyword">if</span> (tStack.isNotEmpty()) &#123; <span class="comment">//放上面if,tStack是空的情况，会把 #添加进来</span></span><br><span class="line">                tStack.pop()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tStack.push(t[j])<span class="comment">// 复制还不如自己写，一开始写成s[i]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sStack == tStack</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="双指针1"><a href="#双指针1" class="headerlink" title="双指针1"></a>双指针1</h6><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">backspaceCompare</span><span class="params">(s: <span class="type">String</span>, t: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i = s.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> j = t.length - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> skipS = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> skipT = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;#&#x27;</span>) &#123; <span class="comment">// 碰到这个先累计</span></span><br><span class="line">                skipS++</span><br><span class="line">                i--</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (skipS &gt; <span class="number">0</span>) &#123; <span class="comment">// 把#处理</span></span><br><span class="line">                skipS--</span><br><span class="line">                i--</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t[j] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                skipT++</span><br><span class="line">                j--</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (skipT &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                skipT--</span><br><span class="line">                j--</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123; <span class="comment">//上面有可能 i, j有可能到-1</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] != t[j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123; <span class="comment">// i ,j有多余的，也有问题</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        i--</span><br><span class="line">        j--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/backspace-string-compare/solution/shuang-zhi-zhen-bi-jiao-han-tui-ge-de-zi-8fn8/">https://leetcode-cn.com/problems/backspace-string-compare/solution/shuang-zhi-zhen-bi-jiao-han-tui-ge-de-zi-8fn8/</a></p>
<h6 id="双指针2"><a href="#双指针2" class="headerlink" title="双指针2"></a>双指针2</h6><p>这种双指针写法也不错,只是最后的String.valueOf不同语言有出入，和这个题目意思有点对不上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean backspaceCompare(String s, String t) &#123;</span><br><span class="line">        // equals()判断返回的两个字符串是否相等</span><br><span class="line">        return changeString(s).equals(changeString(t));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String changeString (String str) &#123;</span><br><span class="line">        // 先将字符串转为数组，方便使用双指针法</span><br><span class="line">        char[] x = str.toCharArray();</span><br><span class="line">        int slow = 0;</span><br><span class="line">        for (int fast = 0; fast &lt; x.length; fast++) &#123;</span><br><span class="line">            // 当x[fast] != &#x27;#&#x27;时，x[fast]覆盖x[slow]，然后slow++</span><br><span class="line">            if (x[fast] != &#x27;#&#x27;)</span><br><span class="line">                x[slow++] = x[fast];</span><br><span class="line">            // 当x[fast] = &#x27;#&#x27;且slow!=0时，slow--</span><br><span class="line">            else if(x[fast] == &#x27;#&#x27; &amp;&amp; slow != 0)</span><br><span class="line">                slow--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 返回字符串</span><br><span class="line">        return String.valueOf(x, 0, slow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">https://leetcode-cn.com/problems/backspace-string-compare/solution/shuang-zhi-zhen-fa-si-lu-jian-dan-rong-y-bmn6/</span><br></pre></td></tr></table></figure>

<h3 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h3><h4 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977. 有序数组的平方"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></h4><p>left ,right  左右两端比较大小，大的放新数组的最右端</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sortedSquares</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: IntArray &#123;</span><br><span class="line">    <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> right = nums.size - <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> index = nums.size - <span class="number">1</span></span><br><span class="line">    <span class="keyword">val</span> arrayNew = IntArray(nums.size)</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">val</span> leftSquare = nums[left] * nums[left]</span><br><span class="line">        <span class="keyword">val</span> rightSquare = nums[right] * nums[right]</span><br><span class="line">        <span class="keyword">if</span> (leftSquare &lt;= rightSquare) &#123;</span><br><span class="line">            arrayNew[index--] = rightSquare</span><br><span class="line">            right--</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arrayNew[index--] = leftSquare</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrayNew</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/solution/c-dong-hua-yan-shi-977-you-xu-shu-zu-de-gxlvm/">https://leetcode-cn.com/problems/squares-of-a-sorted-array/solution/c-dong-hua-yan-shi-977-you-xu-shu-zu-de-gxlvm/</a></p>
<h4 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></h4><h6 id="双指针（滑动窗口）"><a href="#双指针（滑动窗口）" class="headerlink" title="双指针（滑动窗口）"></a>双指针（滑动窗口）</h6><p>滑动窗口主要找到移动左指针的条件</p>
<p>其实就是精简出暴力解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fun minSubArrayLen(target: Int, nums: IntArray): Int &#123;</span><br><span class="line">    var sum = 0</span><br><span class="line">    var leftP = 0;</span><br><span class="line">    var result = Int.MAX_VALUE</span><br><span class="line">    for (rightP in nums.indices) &#123;</span><br><span class="line">        sum += nums[rightP]</span><br><span class="line">        while (sum &gt;= target) &#123;</span><br><span class="line">            val subLength = rightP - leftP + 1</span><br><span class="line">            if (subLength &lt; result) result = subLength</span><br><span class="line">            sum -= nums[leftP++]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (result == Int.MAX_VALUE) result = 0</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**一些录友会疑惑为什么时间复杂度是O(n)**。</p>
<p>不要以为for里放一个while就以为是O(n^2)啊， 主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被被操作两次，所以时间复杂度是 2 × n 也就是O(n)。</p>
<p>对于这个解释 o(n)其实我还是有一些不理解.</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/solution/209-chang-du-zui-xiao-de-zi-shu-zu-hua-dong-chua-7/">https://leetcode-cn.com/problems/minimum-size-subarray-sum/solution/209-chang-du-zui-xiao-de-zi-shu-zu-hua-dong-chua-7/</a></p>
<h6 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h6><p>先移动前面的，再移动后面的遍历找出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> s, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = INT32_MAX; <span class="comment">// 最终的结果</span></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">// 子序列的数值之和</span></span><br><span class="line">        <span class="type">int</span> subLength = <span class="number">0</span>; <span class="comment">// 子序列的长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 设置子序列起点为i</span></span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; nums.<span class="built_in">size</span>(); j++) &#123; <span class="comment">// 设置子序列终止位置为j</span></span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt;= s) &#123; <span class="comment">// 一旦发现子序列和超过了s，更新result</span></span><br><span class="line">                    subLength = j - i + <span class="number">1</span>; <span class="comment">// 取子序列的长度</span></span><br><span class="line">                    result = result &lt; subLength ? result : subLength;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 因为我们是找符合条件最短的子序列，所以一旦符合条件就break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span></span><br><span class="line">        <span class="keyword">return</span> result == INT32_MAX ? <span class="number">0</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">时间复杂度：<span class="built_in">O</span>(n^<span class="number">2</span>)</span><br><span class="line">空间复杂度：<span class="built_in">O</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">作者：carlsun<span class="number">-2</span></span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/minimum-size-subarray-sum/solution/209-chang-du-zui-xiao-de-zi-shu-zu-hua-dong-chua-7/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处.</span><br></pre></td></tr></table></figure>

<h4 id="904-水果成篮"><a href="#904-水果成篮" class="headerlink" title="904. 水果成篮"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fruit-into-baskets/">904. 水果成篮</a></h4><p>双指针（滑动窗口）</p>
<p>题目不好懂 [1,2,3,2,2]. , 1 ,2,3,数字大小分别表示水果树类别</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">totalFruit</span><span class="params">(fruits: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> leftP = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> basketList = mutableMapOf&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;() <span class="comment">// key存元素，value存出现的次数</span></span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> subLength: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">for</span> (rightP <span class="keyword">in</span> fruits.indices) &#123;</span><br><span class="line">        <span class="keyword">val</span> element = fruits[rightP] <span class="comment">//快指针扫到的元素</span></span><br><span class="line">        <span class="keyword">if</span> (basketList.containsKey(element)) &#123; <span class="comment">//包含这个元素 个数+1</span></span><br><span class="line">            basketList[element] = basketList[element]!!.plus(<span class="number">1</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            basketList[element] = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (basketList.size &gt; <span class="number">2</span>) &#123; <span class="comment">// 元素类型&gt;2,就开始移动左指针</span></span><br><span class="line">                basketList[fruits[leftP]] = basketList[fruits[leftP]]!!.minus(<span class="number">1</span>) <span class="comment">//左指针次数-1</span></span><br><span class="line">                <span class="keyword">if</span> (basketList[fruits[leftP]] == <span class="number">0</span>) &#123;</span><br><span class="line">                    basketList.remove(fruits[leftP]) <span class="comment">//删除移动的左指针</span></span><br><span class="line">                &#125;</span><br><span class="line">                leftP++</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                subLength = rightP - leftP + <span class="number">1</span>  <span class="comment">// 子序列长度</span></span><br><span class="line">                <span class="keyword">if</span> (subLength &gt; result) &#123;          <span class="comment">//比较找出最长的子序列</span></span><br><span class="line">                    result = subLength</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">上面解法</span><br><span class="line">    <span class="keyword">if</span> (basketList.containsKey(element)) &#123; <span class="comment">//包含这个元素 个数+1</span></span><br><span class="line">            basketList[element] = basketList[element]!!.plus(<span class="number">1</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            basketList[element] = <span class="number">1</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">可以用这一句替换</span><br><span class="line">basketList[element] = basketList.getOrDefault(element, <span class="number">0</span>).plus(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h4 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串</a></h4><p>滑动窗口 (sliding window)</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> * 核心思想: s的 left right,已经覆盖了t字串，那么就移动left,看看是否还在范围内</span><br><span class="line"> * 通过判断T中A B C都 &gt;<span class="number">0</span>没被抵消， &lt;<span class="number">0</span>说明 s有多余这个字符个数</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LC76</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minWindow</span><span class="params">(s: <span class="type">String</span>, t: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> map = mutableMapOf&lt;<span class="built_in">Char</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">for</span> (element <span class="keyword">in</span> t) &#123;</span><br><span class="line">            map[element] = map.getOrDefault(element, <span class="number">0</span>).plus(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> leftP = <span class="number">0</span> <span class="comment">// 左指针</span></span><br><span class="line">        <span class="keyword">var</span> rightLast = <span class="number">0</span> <span class="comment">//最后匹配的最短的右指针</span></span><br><span class="line">        <span class="keyword">var</span> resultLength = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line">        <span class="keyword">var</span> resultStr = <span class="string">&quot;&quot;</span> <span class="comment">// 最短结果字符</span></span><br><span class="line">        <span class="keyword">for</span> (rightP <span class="keyword">in</span> s.indices) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(s[rightP])) &#123;  <span class="comment">// t字符包含该元素， 元素+1</span></span><br><span class="line">                map[s[rightP]] = map.getOrDefault(s[rightP], <span class="number">0</span>).minus(<span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (isMatch(map, t)) &#123; <span class="comment">// 判断这个S的left right中是否含有t所有字符</span></span><br><span class="line">                <span class="keyword">val</span> subLength = rightP - leftP + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> (subLength &lt; resultLength) &#123;</span><br><span class="line">                    rightLast = rightP</span><br><span class="line">                    resultLength = subLength</span><br><span class="line">                    resultStr = s.substring(</span><br><span class="line">                        leftP,</span><br><span class="line">                        rightLast + <span class="number">1</span></span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(s[leftP])) &#123; <span class="comment">// 向右移动left,如果元素是 map t中的，就+1，因为这个不算了</span></span><br><span class="line">                    map[s[leftP]] = map.getOrDefault(s[leftP], <span class="number">0</span>).plus(<span class="number">1</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                leftP++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resultStr<span class="comment">//  the beginning index, inclusive ,endIndex – the ending index, exclusive. [begin,end)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * map中有元素&gt;0,说明有元素还没有,map&lt;0才全部抵消了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isMatch</span><span class="params">(map: <span class="type">Map</span>&lt;<span class="type">Char</span>, <span class="built_in">Int</span>&gt;, t: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (element <span class="keyword">in</span> t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map[element]!! &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>视频讲解很清晰</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-window-substring/solution/zui-xiao-fu-gai-zi-chuan-by-leetcode-solution/">https://leetcode-cn.com/problems/minimum-window-substring/solution/zui-xiao-fu-gai-zi-chuan-by-leetcode-solution/</a></p>
<p>这道题参考去看看 labuladong解法,我没找到，后面再看看,</p>
<h3 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h3><h4 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59. 螺旋矩阵 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">generateMatrix</span><span class="params">(n: <span class="type">Int</span>)</span></span>: Array&lt;IntArray&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> top = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> right = n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> bottom = n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">1</span></span><br><span class="line">    <span class="keyword">val</span> target = n * n</span><br><span class="line">    <span class="keyword">var</span> arr = Array(n) &#123; IntArray(n) &#125;</span><br><span class="line">    <span class="keyword">while</span> (num &lt;= target) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> left..right) arr[top][i] = num++ <span class="comment">//  从左到右 // 这里不是从0开始，是从left开始</span></span><br><span class="line">        top++ <span class="comment">// 上边向下收窄1</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> top..bottom) arr[i][right] = num++ <span class="comment">//  从上到下</span></span><br><span class="line">        right-- <span class="comment">// 右边收窄1</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> right downTo left) arr[bottom][i] = num++ <span class="comment">// 从右到左</span></span><br><span class="line">        bottom--</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> bottom downTo top)&#123; <span class="comment">// 从底到上</span></span><br><span class="line">            arr[i][left] = num++</span><br><span class="line">        &#125;</span><br><span class="line">        left++                            <span class="comment">//收缩左边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题解根据下面这个解法，简单巧妙</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/spiral-matrix-ii/solution/spiral-matrix-ii-mo-ni-fa-she-ding-bian-jie-qing-x/">https://leetcode-cn.com/problems/spiral-matrix-ii/solution/spiral-matrix-ii-mo-ni-fa-she-ding-bian-jie-qing-x/</a></p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/categories/DataStructure/page/0/">Previous</a></div><div class="pagination-next"><a href="/categories/DataStructure/page/2/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/categories/DataStructure/">1</a></li><li><a class="pagination-link" href="/categories/DataStructure/page/2/">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Your name"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Your name</p><p class="is-size-6 is-block">Your title</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Your location</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">221</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">18</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">31</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/ANDROID/"><span class="level-start"><span class="level-item">ANDROID</span></span><span class="level-end"><span class="level-item tag">58</span></span></a></li><li><a class="level is-mobile" href="/categories/BLE/"><span class="level-start"><span class="level-item">BLE</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/DataStructure/"><span class="level-start"><span class="level-item">DataStructure</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/DesignPatterns/"><span class="level-start"><span class="level-item">DesignPatterns</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/ENGLISH/"><span class="level-start"><span class="level-item">ENGLISH</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/JAVA/"><span class="level-start"><span class="level-item">JAVA</span></span><span class="level-end"><span class="level-item tag">27</span></span></a></li><li><a class="level is-mobile" href="/categories/Jetpack/"><span class="level-start"><span class="level-item">Jetpack</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Kotlin/"><span class="level-start"><span class="level-item">Kotlin</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/LINUX/"><span class="level-start"><span class="level-item">LINUX</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Mathematics/"><span class="level-start"><span class="level-item">Mathematics</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/OS/"><span class="level-start"><span class="level-item">OS</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Organization/"><span class="level-start"><span class="level-item">Organization</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/SOURCE/"><span class="level-start"><span class="level-item">SOURCE</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/TEST/"><span class="level-start"><span class="level-item">TEST</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/TOOL/"><span class="level-start"><span class="level-item">TOOL</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/VIEW/"><span class="level-start"><span class="level-item">VIEW</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/anim/"><span class="level-start"><span class="level-item">anim</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/flutter/"><span class="level-start"><span class="level-item">flutter</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-10-21T15:18:58.000Z">2023-10-21</time></p><p class="title"><a href="/2023/10/21/proxy/">proxy</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-09-04T07:54:57.000Z">2023-09-04</time></p><p class="title"><a href="/2023/09/04/Android_interview%20organize/">Android_itnerview_organize</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-09-03T07:54:57.000Z">2023-09-03</time></p><p class="title"><a href="/2023/09/03/Android-itnerview-algorithm/">Android_itnerview_algorithm</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-08-20T13:41:06.000Z">2023-08-20</time></p><p class="title"><a href="/2023/08/20/compose-layout/">compose_layout</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-08-19T09:16:56.000Z">2023-08-19</time></p><p class="title"><a href="/2023/08/19/compose/">compose</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/"><span class="level-start"><span class="level-item">2022</span></span><span class="level-end"><span class="level-item tag">33</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/"><span class="level-start"><span class="level-item">2021</span></span><span class="level-end"><span class="level-item tag">23</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/"><span class="level-start"><span class="level-item">2020</span></span><span class="level-end"><span class="level-item tag">46</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/"><span class="level-start"><span class="level-item">2019</span></span><span class="level-end"><span class="level-item tag">21</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/"><span class="level-start"><span class="level-item">2018</span></span><span class="level-end"><span class="level-item tag">32</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/"><span class="level-start"><span class="level-item">2017</span></span><span class="level-end"><span class="level-item tag">57</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/ANDROID/"><span class="tag">ANDROID</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AOSP/"><span class="tag">AOSP</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Activity/"><span class="tag">Activity</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AndroidNewFeatures/"><span class="tag">AndroidNewFeatures</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Assembly/"><span class="tag">Assembly</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BLOG/"><span class="tag">BLOG</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ConstraintLayout/"><span class="tag">ConstraintLayout</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DB/"><span class="tag">DB</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Drawer/"><span class="tag">Drawer</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Fragment/"><span class="tag">Fragment</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JVM/"><span class="tag">JVM</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LEETCODE/"><span class="tag">LEETCODE</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Operators/"><span class="tag">Operators</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Performance/"><span class="tag">Performance</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RecyclerView/"><span class="tag">RecyclerView</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RxJava/"><span class="tag">RxJava</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/THINK/"><span class="tag">THINK</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TOOL/"><span class="tag">TOOL</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TabLayout/"><span class="tag">TabLayout</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Test/"><span class="tag">Test</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TouchEvent/"><span class="tag">TouchEvent</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/VIEW/"><span class="tag">VIEW</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/XML/"><span class="tag">XML</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/anim/"><span class="tag">anim</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/compose/"><span class="tag">compose</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/concurrency/"><span class="tag">concurrency</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/coroutie/"><span class="tag">coroutie</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/inter/"><span class="tag">inter</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/keyboard/"><span class="tag">keyboard</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/proguard/"><span class="tag">proguard</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe for updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Hexo" height="28"></a><p class="is-size-7"><span>&copy; 2023 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>