<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>LC_TREE08 | Jon&#39;s Blog</title>
  <meta name="author" content="Jon">
  
  <meta name="description" content="101. 对称二叉树层序遍历层序遍历是没法实现的
123456789101112131415161718192021    fun isSymmetric3(root: TreeNode?): Boolean &amp;#123;        val queue = LinkedList&amp;lt;TreeN">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="LC_TREE08"/>
  <meta property="og:site_name" content="Jon&#39;s Blog"/>

  
    <meta property="og:image" content=""/>
  

  
    <link rel="alternative" href="/atom.xml" title="Jon&#39;s Blog" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/prism.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-70812759-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-70812759-1');
</script>






<meta name="generator" content="Hexo 6.3.0"></head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">Jon&#39;s Blog</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class=""></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class=""></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class=""></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class=""></i>About
			</a>
		  </li>
		  
		  <li>
			<a href="/atom.xml" title="Subscribe me.">
			  <i class=""></i>RSS
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> LC_TREE08</h1>
		</div>
	



<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  		

	  <h4 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></h4><h5 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h5><p>层序遍历是没法实现的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isSymmetric3</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.offer(root)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">            <span class="keyword">val</span> layerSize = queue.size</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until layerSize) &#123;</span><br><span class="line"><span class="comment">//                val lastIndex = layerSize - 1 - i // 这样不可以,poll取出元素后，就少了元素越界了</span></span><br><span class="line">                <span class="keyword">val</span> headNode = queue.poll()</span><br><span class="line"></span><br><span class="line">                <span class="keyword">val</span> lastNode = queue.lastOrNull()</span><br><span class="line">                <span class="keyword">if</span> (headNode.`<span class="keyword">val</span>` != lastNode?.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">                headNode.left?.let &#123; queue.offer(it) &#125;</span><br><span class="line">                headNode.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><p>// 不能判断true,判断true直接返回了，判断false返回没问题，true返回就不会往下走了</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">leftRightSymmetric</span><span class="params">(nodeLeft: <span class="type">TreeNode</span>?, nodeRight: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nodeLeft?.`<span class="keyword">val</span>` == nodeRight?.`<span class="keyword">val</span>`) &#123; <span class="comment">// 不能判断true,判断true直接返回了，判断false返回没问题，true返回就不会往下走了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeLeft == nodeRight) &#123; <span class="comment">// = null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    leftRightSymmetric(nodeLeft?.left, nodeRight?.right)</span><br><span class="line">    leftRightSymmetric(nodeLeft?.right, nodeRight?.left)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E9%80%92%E5%BD%92%E6%B3%95">https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E9%80%92%E5%BD%92%E6%B3%95</a></p>
<p>从根节点的左右子树开始，深度遍历比较</p>
<p><img src="https://img-blog.csdnimg.cn/20210203144624414.png"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isSymmetric</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> leftRightSymmetric(root?.left, root?.right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">leftRightSymmetric</span><span class="params">(nodeLeft: <span class="type">TreeNode</span>?, nodeRight: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nodeLeft == <span class="literal">null</span> &amp;&amp; nodeRight != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeLeft != <span class="literal">null</span> &amp;&amp; nodeRight == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeLeft?.`<span class="keyword">val</span>` != nodeRight?.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeLeft == <span class="literal">null</span> &amp;&amp; nodeRight == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">//这里需要，否则就递归 溢出了,如果根节点的左右节点为null,退出也是没问题的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> leftFlag = leftRightSymmetric(nodeLeft?.left, nodeRight?.right)</span><br><span class="line">    <span class="keyword">val</span> rightFlag = leftRightSymmetric(nodeLeft?.right, nodeRight?.left)</span><br><span class="line">    <span class="keyword">return</span> leftFlag &amp;&amp; rightFlag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnwcimlj8lg30hm0bqnpd.gif"></p>
<p>队列，一直向下按照对称的条件添加</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isSymmetric1</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123; </span><br><span class="line">        root.left?.let &#123; queue.offer(it) &#125; <span class="comment">// 官方解法中，根节点入队2次也可以</span></span><br><span class="line">        root.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> node1 = queue.poll()</span><br><span class="line">        <span class="keyword">val</span> node2 = queue.poll()</span><br><span class="line">        <span class="keyword">if</span>(node1==<span class="literal">null</span>&amp;&amp;node2==<span class="literal">null</span>)&#123; <span class="comment">// 一开始没写这个条件，提示超出时间限制</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node1?.`<span class="keyword">val</span>` != node2?.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        queue.offer(node1?.left) <span class="comment">// 两边的节点比较</span></span><br><span class="line">        queue.offer(node2?.right)</span><br><span class="line">        queue.offer(node1?.right) <span class="comment">//中间的节点比较</span></span><br><span class="line">        queue.offer(node2?.left)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>栈也是可以的，只要保证位置靠近</p>
<h4 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/same-tree/">100. 相同的树</a></h4><h5 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isSameTree</span><span class="params">(p: <span class="type">TreeNode</span>?, q: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span> &amp;&amp; q != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p?.`<span class="keyword">val</span>` == q?.`<span class="keyword">val</span>` &amp;&amp; isSameTree(p?.left, q?.left) &amp;&amp; isSameTree(p?.right, q?.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="队列-1"><a href="#队列-1" class="headerlink" title="队列"></a>队列</h5><img src="/2022/09/11/LC-TREE08/20220912130345.jpg" alt="20220912130345" style="zoom: 67%;">

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isSameTree1</span><span class="params">(p: <span class="type">TreeNode</span>?, q: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span> &amp;&amp; q != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    queue.offer(p)</span><br><span class="line">    queue.offer(q)</span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> node1 = queue.poll()</span><br><span class="line">        <span class="keyword">val</span> node2 = queue.poll()</span><br><span class="line">        <span class="keyword">if</span> (node1 == <span class="literal">null</span> &amp;&amp; node2 == <span class="literal">null</span>) &#123; <span class="comment">// continue后，因为null,就不会加入新的节点</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node1?.`<span class="keyword">val</span>` != node2?.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        queue.offer(node1?.left)</span><br><span class="line">        queue.offer(node2?.left)</span><br><span class="line">        queue.offer(node1?.right)</span><br><span class="line">        queue.offer(node2?.right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="572-另一棵树的子树"><a href="#572-另一棵树的子树" class="headerlink" title="572. 另一棵树的子树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subtree-of-another-tree/">572. 另一棵树的子树</a></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isSubtree</span><span class="params">(root: <span class="type">TreeNode</span>?, subRoot: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span> &amp;&amp; subRoot == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root == <span class="literal">null</span> &amp;&amp; subRoot != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root != <span class="literal">null</span> &amp;&amp; subRoot == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isSameTree(root, subRoot) || isSubtree(root?.left, subRoot) || isSubtree(root?.right, subRoot) <span class="comment">//subRoot和root相同,subRoot和root左子树相同，subRoot和右子树相同</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isSameTree</span><span class="params">(node1: <span class="type">TreeNode</span>?, node2: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node1 == <span class="literal">null</span> &amp;&amp; node2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node1 == <span class="literal">null</span> &amp;&amp; node2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node1 != <span class="literal">null</span> &amp;&amp; node2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node1?.`<span class="keyword">val</span>` == node2?.`<span class="keyword">val</span>` &amp;&amp; isSameTree(node1?.left, node2?.left) &amp;&amp; isSameTree(</span><br><span class="line">        node1?.right,</span><br><span class="line">        node2?.right</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h4><h5 id="DFS-普通二叉树解法"><a href="#DFS-普通二叉树解法" class="headerlink" title="DFS 普通二叉树解法"></a>DFS 普通二叉树解法</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countNodes</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> leftCount = countNodes(root.left)</span><br><span class="line">    <span class="keyword">val</span> rightCount = countNodes(root.right)</span><br><span class="line">    <span class="keyword">return</span> leftCount + rightCount + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countNodes1</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.offer(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> size = queue.size</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until size) &#123;</span><br><span class="line">            <span class="keyword">val</span> treeNode = queue.poll()</span><br><span class="line">            count++</span><br><span class="line">            treeNode.left?.let &#123; queue.offer(it) &#125;</span><br><span class="line">            treeNode.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="DFS-完全二叉树特性"><a href="#DFS-完全二叉树特性" class="headerlink" title="DFS 完全二叉树特性"></a>DFS 完全二叉树特性</h5><p>一开始打算用先序遍历，但是这样不行,</p>
<p>如果一颗树 是平衡的，永远是得到 1,  想了一下，这种也不属于 先序遍历</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countNodes</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> depth = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> postTraversal(root, depth)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">postTraversal</span><span class="params">(root: <span class="type">TreeNode</span>?, depth: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isBalanced(root)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> shl (depth - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> leftNums = postTraversal(root?.left, depth + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> rightNums = postTraversal(root?.right, depth + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> leftNums + rightNums + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countNodes</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> leftNode = root.left</span><br><span class="line">    <span class="keyword">var</span> depthLeft = <span class="number">0</span> <span class="comment">//左子树深度</span></span><br><span class="line">    <span class="keyword">while</span> (leftNode != <span class="literal">null</span>) &#123;</span><br><span class="line">        leftNode = leftNode.left</span><br><span class="line">        depthLeft++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> rightNode = root.right</span><br><span class="line">    <span class="keyword">var</span> depthRight = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (rightNode != <span class="literal">null</span>) &#123;</span><br><span class="line">        rightNode = rightNode.right</span><br><span class="line">        depthRight++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (depthLeft == depthRight) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">2</span> shl depthLeft) - <span class="number">1</span> <span class="comment">// 节点数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> leftNums = countNodes(root.left)</span><br><span class="line">    <span class="keyword">val</span> rightNums = countNodes(root.right)</span><br><span class="line">    <span class="keyword">return</span> leftNums + rightNums + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countNodes3</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> leftNode = root.left</span><br><span class="line">    <span class="keyword">var</span> depthLeft = <span class="number">0</span> <span class="comment">//左子树深度</span></span><br><span class="line">    <span class="keyword">while</span> (leftNode != <span class="literal">null</span>) &#123;</span><br><span class="line">        leftNode = leftNode.left</span><br><span class="line">        depthLeft++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> rightNode = root.right</span><br><span class="line">    <span class="keyword">var</span> depthRight = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (rightNode != <span class="literal">null</span>) &#123;</span><br><span class="line">        rightNode = rightNode.right</span><br><span class="line">        depthRight++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> leftNums = countNodes(root.left)</span><br><span class="line">    <span class="keyword">val</span> rightNums = countNodes(root.right)</span><br><span class="line">    <span class="keyword">if</span> (depthLeft == depthRight) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">2</span> shl depthLeft) - <span class="number">1</span> <span class="comment">// 节点数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> leftNums + rightNums + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树</a></h4><p>一开始错误的解答是这样的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isBalanced</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> postTraversal(root) != -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">postTraversal</span><span class="params">(node: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> leftDepth = postTraversal(node.left)</span><br><span class="line">        <span class="keyword">val</span> rightDepth = postTraversal(node.right)</span><br><span class="line">        <span class="keyword">val</span> isBalance = Math.abs(leftDepth - rightDepth) &lt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (isBalance) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(leftDepth, rightDepth) + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里问题是   return -1，作为父节点的深度返回给了 depth，然后继续计算 Math.abs(leftDepth - rightDepth) &lt;= 1，出现了问题</p>
<p>改进解法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isBalanced</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> postTraversal(root) != -<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">postTraversal</span><span class="params">(node: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> leftDepth = postTraversal(node.left)</span><br><span class="line">    <span class="keyword">val</span> rightDepth = postTraversal(node.right)</span><br><span class="line">    <span class="keyword">if</span> (leftDepth == -<span class="number">1</span> || rightDepth == -<span class="number">1</span>) &#123; <span class="comment">// 子节点已经有不是平衡的节点 直接返回，来判断</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> isBalance = Math.abs(leftDepth - rightDepth) &lt;= <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (isBalance) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftDepth, rightDepth) + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>随想录迭代遍历，看起来很复杂，看起来是统一解法.</p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E9%A2%98%E5%A4%96%E8%AF%9D">https://programmercarl.com/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E9%A2%98%E5%A4%96%E8%AF%9D</a></p>
<h4 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-paths/">257. 二叉树的所有路径</a></h4><h5 id="隐藏回溯过程"><a href="#隐藏回溯过程" class="headerlink" title="隐藏回溯过程"></a>隐藏回溯过程</h5><p>这一题 没理解透字符串怎么形成的和回溯的, 用到了先序遍历，</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ZG411G7Dh">https://www.bilibili.com/video/BV1ZG411G7Dh</a> 视频包含了回溯过程</p>
<p> 可以看下随想录回溯过程</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">binaryTreePaths</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: List&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> result = LinkedList&lt;String&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    dfs(root, result, root.`<span class="keyword">val</span>`.toString())</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://www.youtube.com/watch?v=swG70SQBJ-A</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. String不能用 StringBuilder,存在引用传递问题，会输出</span></span><br><span class="line"><span class="comment"> *    [&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;2-&gt;5-&gt;3&quot;]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. 在先序位置 val存到path也有问题,头节点会存在重复的情况 [&quot;1-&gt;1-&gt;2-&gt;5&quot;,&quot;1-&gt;1-&gt;2-&gt;5-&gt;3&quot;]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(node: <span class="type">TreeNode</span>?, result: <span class="type">LinkedList</span>&lt;<span class="type">String</span>&gt;, path: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        result.add(path)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        dfs(node.left, result, <span class="string">&quot;<span class="variable">$path</span>-&gt;<span class="subst">$&#123;node.left.`val`&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        dfs(node.right, result, <span class="string">&quot;<span class="variable">$path</span>-&gt;<span class="subst">$&#123;node.right.`val`&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面2的情况演示</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(node: <span class="type">TreeNode</span>?, result: <span class="type">LinkedList</span>&lt;<span class="type">String</span>&gt;, path: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">val</span> mPath = <span class="string">&quot;<span class="variable">$path</span>-&gt; <span class="subst">$&#123;node.`val`&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        result.add(mPath)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        dfs(node.left, result, mPath)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        dfs(node.right, result, mPath)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面两种写法，回溯隐藏在参数里面.</p>
<h5 id="显示回溯"><a href="#显示回溯" class="headerlink" title="显示回溯"></a>显示回溯</h5><p>这是随想录的代码，二刷可以自己写, </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">binaryTreePaths</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: List&lt;String&gt;? &#123;</span><br><span class="line">    <span class="keyword">val</span> res: MutableList&lt;String&gt; = ArrayList()</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> paths: MutableList&lt;<span class="built_in">Int</span>&gt; = ArrayList()</span><br><span class="line">    traversal(root, paths, res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">traversal</span><span class="params">(root: <span class="type">TreeNode</span>, paths: <span class="type">MutableList</span>&lt;<span class="type">Int</span>&gt;, res: <span class="type">MutableList</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    paths.add(root.`<span class="keyword">val</span>`)</span><br><span class="line">    <span class="comment">// 叶子结点</span></span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123; <span class="comment">// 碰到叶子节点，开始把path遍历放进string中 </span></span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        <span class="keyword">val</span> sb = StringBuilder()</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until paths.size - <span class="number">1</span>) &#123;</span><br><span class="line">            sb.append(paths[i]).append(<span class="string">&quot;-&gt;&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(paths[paths.size - <span class="number">1</span>]) <span class="comment">//也可以放到上面一起再把&quot;-&gt;&quot; 删除</span></span><br><span class="line">        res.add(sb.toString()) </span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        traversal(root.left, paths, res)</span><br><span class="line">        paths.removeAt(paths.size - <span class="number">1</span>) <span class="comment">// 回溯  </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        traversal(root.right, paths, res)</span><br><span class="line">        paths.removeAt(paths.size - <span class="number">1</span>) <span class="comment">// 回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paths.removeAt(paths.size - 1) 最初这里没理解，都删除了，为什么,上面还能遍历所有节点，其实递归是一致先走的，碰到叶子节点的时候，遍历path, 最后才开始 paths.removeAt(paths.size - 1) 回溯 到上面. </span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html">https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ZG411G7Dh">https://www.bilibili.com/video/BV1ZG411G7Dh</a></p>
<p>迭代法 后面再说吧</p>
<h4 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404. 左叶子之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-left-leaves/">404. 左叶子之和</a></h4><p>这一题和【 222 完全二叉树的节点个数】很像，这里是普通的二叉树，所以我的想法就前两种做法</p>
<ol>
<li>后序遍历</li>
<li>层序遍历</li>
</ol>
<p>把根节点换成左子树的节点</p>
<p>看错了题目，其实是左子树叶子值的和</p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C.html#%E6%80%9D%E8%B7%AF">https://programmercarl.com/0404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C.html#%E6%80%9D%E8%B7%AF</a></p>
<p>只看了随想录题解，自己这样写的代码</p>
<h5 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sumOfLeftLeaves</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> dfsLeaves(root, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> direction 0 右子树， 1：左子树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dfsLeaves</span><span class="params">(node: <span class="type">TreeNode</span>?, direction: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span> &amp;&amp; direction == <span class="number">1</span>) &#123; <span class="comment">// 左右子树为空，根据父亲节点的传入，判断它是左子树</span></span><br><span class="line">        <span class="keyword">return</span> node.`<span class="keyword">val</span>` <span class="comment">//这种情况返回值，根据后序规则，上层节点叠加</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> leftCount = dfsLeaves(node.left, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> rightCount = dfsLeaves(node.right, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> leftCount + rightCount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>看了随想录解法，可以直接看更下一层节点，就不用再传入方向了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">          leftValue = root-&gt;left-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>迭代法</p>
<p>随想录统一迭代法</p>
<h4 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513. 找树左下角的值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513. 找树左下角的值</a></h4><p>想了下</p>
<ol>
<li>层序遍历可以解决</li>
<li>递归法还没想道，到了最底层，没想到如何判断 哪个是最左边的。</li>
</ol>
<h5 id="BFS-1"><a href="#BFS-1" class="headerlink" title="BFS"></a>BFS</h5><p>先存下来每一层的第一个节点，知道queue为空，那么最后一层的头节点就是要返回的.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findBottomLeftValue1</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.offer(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> leftNodeVal = root?.`<span class="keyword">val</span>`</span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> size = queue.size</span><br><span class="line">        leftNodeVal = queue.peek().`<span class="keyword">val</span>` <span class="comment">//每一层的第一个节点</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until size) &#123;</span><br><span class="line">            <span class="keyword">val</span> node = queue.poll()</span><br><span class="line">            node?.left?.let &#123; queue.offer(it) &#125;</span><br><span class="line">            node?.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> leftNodeVal!! <span class="comment">// queue为empty的时候退出，此时上一层存的节点就是最左边的节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h5><p>My idea</p>
<ol>
<li><p>一开始以为树的层级里，树的左边的值小于右边，来得出结果，但是这是二叉树，不是平衡形的，即使平衡这种思路也不一定对.</p>
</li>
<li><p>然后又看了树结构,想了下可以用 inorder traversal ,中序遍历, 层数最深，然后最先得到的数据就是要拿到的结果. </p>
<p>想下面8肯定是后面遍历到的</p>
</li>
</ol>
<p><img src="/2022/09/11/LC-TREE08/20220924155016.jpg" alt="20220924155016"></p>
<ol>
<li>一开始不知道leetcode可以用全局变量，用对象返回还很麻烦，删掉了</li>
<li>判断层级，如果大于之前的深度，那么就更新深度和值</li>
<li>中序和后序肯定没问题，但是先序不确定（随想录说是可以的）而且随想录 depth + 1 展开了用回溯</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mDepth = <span class="number">0</span> <span class="comment">//一开始不知道leetcode可以用全局变量，用对象返回还很麻烦，删掉了</span></span><br><span class="line"><span class="keyword">var</span> result = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findBottomLeftValue</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    inOrderTraversal(root, mDepth)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最左边的节点最先访问到</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">inOrderTraversal</span><span class="params">(node: <span class="type">TreeNode</span>?, depth: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">    inOrderTraversal(node.left, depth + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> (depth + <span class="number">1</span> &gt; mDepth) &#123; <span class="comment">// 判断层级，如果大于之前的深度，那么就更新深度和值</span></span><br><span class="line">        mDepth = depth + <span class="number">1</span></span><br><span class="line">        result = node.`<span class="keyword">val</span>`</span><br><span class="line">    &#125;</span><br><span class="line">    inOrderTraversal(node.right, depth + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum/">112. 路径总和</a></h4><p>解决所有二叉树路径的问题文章</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-ii/solution/yi-pian-wen-zhang-jie-jue-suo-you-er-cha-oo63/">https://leetcode.cn/problems/path-sum-ii/solution/yi-pian-wen-zhang-jie-jue-suo-you-er-cha-oo63/</a></p>
<p>这一题和  [112. 路径总和]  类似</p>
<p>使用回溯写法，因为添加和删除，回溯的规则，那么感觉用栈比较合适.</p>
<ol>
<li>终止条件就是 到达了叶子节点，此时开始计算当前路径和 是否满足条件</li>
<li>手写判断是否有左子树，有的话继续判断，又继续preOrderTraversal, 这里用的是先序遍历,方法查看条件</li>
<li>遍历完叶子节点后判断，此时这条路径完成，开始回溯，回退上一层preOrderTraversal，继续判断右子树</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">hasPathSum</span><span class="params">(root: <span class="type">TreeNode</span>?, targetSum: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> pathStack = Stack&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        pathStack.push(root.`<span class="keyword">val</span>`) <span class="comment">// root需要放在遍历外面，否则会push多次</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">//按照前面的规则 root==null ,0 应该是对的,但是题目说false,就单独加一句</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> preOrderTraversal(root, targetSum, pathStack) <span class="comment">// pathstack必须传进去，否则每次都new</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">preOrderTraversal</span><span class="params">(root: <span class="type">TreeNode</span>?, targetSum: <span class="type">Int</span>, pathStack: <span class="type">Stack</span>&lt;<span class="type">Int</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root?.left == <span class="literal">null</span> &amp;&amp; root?.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> pathSum = <span class="number">0</span></span><br><span class="line">        pathStack.forEach &#123;</span><br><span class="line">            pathSum += it</span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;pathSum <span class="variable">$pathSum</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (pathSum == targetSum) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root?.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        pathStack.push(root.left.`<span class="keyword">val</span>`) <span class="comment">// 有左节点，加入当前路径</span></span><br><span class="line">        <span class="keyword">if</span> (preOrderTraversal(root.left, targetSum, pathStack)) &#123; <span class="comment">//有路径是和 == targetSum 直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        pathStack.pop()  <span class="comment">// 不会直接把上面的回退了，需要上一句遍历执行完回退后，才把自己回退了，此时已经到了叶子判断了 root?.left == null &amp;&amp; root?.right == null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root?.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        pathStack.push(root.right.`<span class="keyword">val</span>`)</span><br><span class="line">        <span class="keyword">if</span> (preOrderTraversal(root.right, targetSum, pathStack)) &#123; <span class="comment">//有路径是和 == targetSum 直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        pathStack.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">hasPathSum1</span><span class="params">(root: <span class="type">TreeNode</span>?, targetSum: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">//按照前面的规则 root==null ,0 应该是对的,但是题目说false,就单独加一句</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> pathSum = root.`<span class="keyword">val</span>`</span><br><span class="line">    <span class="keyword">return</span> preOrderDFS(root, pathSum, targetSum) <span class="comment">// pathstack必须传进去，否则每次都new</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">preOrderDFS</span><span class="params">(node: <span class="type">TreeNode</span>, pathSum: <span class="type">Int</span>, targetSum: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> nodeValue = node.`<span class="keyword">val</span>`</span><br><span class="line">    println(<span class="string">&quot;nodeValue <span class="variable">$nodeValue</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span> &amp;&amp; targetSum == pathSum) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">if</span> (preOrderDFS(node.left, pathSum + node.left.`<span class="keyword">val</span>`, targetSum)) &#123; <span class="comment">// 这个直接放回，容易忘了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">if</span> (preOrderDFS(node.right, pathSum + node.right.`<span class="keyword">val</span>`, targetSum)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II</a></h4><p>如果是找路径和等于给定target的路径的，那么可以不用新增一个临时变量cursum来判断当前路径和，<br>只需要用给定和target减去节点值，最终结束条件判断target==0即可</p>
<h5 id="DFS-1"><a href="#DFS-1" class="headerlink" title="DFS"></a>DFS</h5><p>这一题的思路和前面的差不多，就是他要求返回所有符合条件的集合，所以直接添加值觉得不合适，除非多加一个参数，不加一个参数就不好弄。</p>
<p>//这种解法要注意 值引用问题，即使最初加入到resultList的pathList是正确的，后序的回退也会把值给修改了.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> resultList = LinkedList&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">pathSum</span><span class="params">(root: <span class="type">TreeNode</span>?, targetSum: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> resultList</span><br><span class="line">    <span class="keyword">val</span> stackList = Stack&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    stackList.add(root.`<span class="keyword">val</span>`)</span><br><span class="line">    preDFS(root, stackList, targetSum)</span><br><span class="line">    <span class="keyword">return</span> resultList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">preDFS</span><span class="params">(node: <span class="type">TreeNode</span>, pathList: <span class="type">Stack</span>&lt;<span class="type">Int</span>&gt;, targetSum: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = node.`<span class="keyword">val</span>`</span><br><span class="line">    println(<span class="keyword">data</span>)</span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span> &amp;&amp; pathSum(pathList) == targetSum) &#123;</span><br><span class="line">        resultList.add(pathList.toMutableList().toList()) <span class="comment">// 注意引用传递</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        pathList.push(node.left.`<span class="keyword">val</span>`)</span><br><span class="line">        preDFS(node.left, pathList, targetSum)</span><br><span class="line">        pathList.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        pathList.push(node.right.`<span class="keyword">val</span>`)</span><br><span class="line">        preDFS(node.right, pathList, targetSum)</span><br><span class="line">        pathList.pop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">pathSum</span><span class="params">(pathList: <span class="type">Stack</span>&lt;<span class="type">Int</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    pathList.forEach &#123;</span><br><span class="line">        sum += it</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这一题的官方DFS解法没看懂，感觉不好理解.</p>
<p>这是看完官方写法自己写的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> pathList = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">pathSum1</span><span class="params">(root: <span class="type">TreeNode</span>?, targetSum: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> resultList</span><br><span class="line">    <span class="keyword">val</span> stackList = Stack&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    stackList.add(root.`<span class="keyword">val</span>`)</span><br><span class="line">    preTraversal(root, targetSum - root.`<span class="keyword">val</span>`)</span><br><span class="line">    <span class="keyword">return</span> resultList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">preTraversal</span><span class="params">(node: <span class="type">TreeNode</span>?, targetSum: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = node.`<span class="keyword">val</span>`</span><br><span class="line">    println(<span class="keyword">data</span>)</span><br><span class="line">    pathList.offer(node.`<span class="keyword">val</span>`)</span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span> &amp;&amp; targetSum == <span class="number">0</span>) &#123;</span><br><span class="line">        resultList.add(pathList.toMutableList())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="literal">null</span>)</span><br><span class="line">        preTraversal(node.left, targetSum - node.left.`<span class="keyword">val</span>`)</span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="literal">null</span>)</span><br><span class="line">        preTraversal(node.right, targetSum - node.right.`<span class="keyword">val</span>`)</span><br><span class="line">    pathList.pop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这是官方解法，也很棒</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">pathSum2</span><span class="params">(root: <span class="type">TreeNode</span>?, targetSum: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> resultList</span><br><span class="line">    <span class="keyword">val</span> stackList = Stack&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    stackList.add(root.`<span class="keyword">val</span>`)</span><br><span class="line">    preDFSTraversal(root, targetSum)</span><br><span class="line">    <span class="keyword">return</span> resultList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">preDFSTraversal</span><span class="params">(node: <span class="type">TreeNode</span>?, targetSum: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = node.`<span class="keyword">val</span>`</span><br><span class="line">    println(<span class="keyword">data</span>)</span><br><span class="line">    <span class="keyword">val</span> targetSum = targetSum - node.`<span class="keyword">val</span>`</span><br><span class="line">    pathList.offer(node.`<span class="keyword">val</span>`)</span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span> &amp;&amp; targetSum == <span class="number">0</span>) &#123;</span><br><span class="line">        resultList.add(pathList.toMutableList())</span><br><span class="line">    &#125;</span><br><span class="line">    preDFSTraversal(node.left, targetSum)</span><br><span class="line">    preDFSTraversal(node.right, targetSum)</span><br><span class="line">    pathList.pop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>官方BFS 就很不好理解</p>
<h3 id="构建树"><a href="#构建树" class="headerlink" title="构建树"></a>构建树</h3><p>先序，中序</p>
<p>后序，中序</p>
<p>inOrder         [L, 3 ,R ]</p>
<p>PostOrder     [L, R, 3] </p>
<p>PreOrder       [3,L ,R]<br>可以看到 只有PostOrder ,PreOrder左右是分不清的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> 			1    					1 </span><br><span class="line"> 		2									2</span><br><span class="line">  3											3</span><br><span class="line">  </span><br><span class="line">PreOrder  1,2,3				PreOrder  1,2,3</span><br><span class="line">PostOrder 3,2,1 			PostOrder 3,2,1</span><br></pre></td></tr></table></figure>



<h4 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h4><p>效率低，但是好理解的方法</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1pp4y1k75Q/">https://www.bilibili.com/video/BV1pp4y1k75Q/</a></p>
<p>为什么post右子树是从 , [i , n-1],因为他是后序遍历，所以从 i开始</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inorder &#x3D; 	[9,3,15,20,7]</span><br><span class="line">postorder &#x3D; [9,15,7,20,3]</span><br></pre></td></tr></table></figure>

<ol>
<li><p>根据后序postorder 得到root 3, 然后根据中序知道 left branch [9] , right branch [15 , 20 , 7]</p>
</li>
<li><p>根据 left branch 的9,可以把 postorder后序分成[9], [15 , 20 , 7]两部分</p>
</li>
<li><p>然后 inorder= [15 , 20 , 7] , postorder=[15 , 20 , 7] 继续进行遍历</p>
</li>
</ol>
<p>总的来说，就是这样</p>
<ol>
<li>确定终止条件</li>
<li>构造节点</li>
<li>构造左子树， 构造右子树</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">buildTree</span><span class="params">(inorder: <span class="type">IntArray</span>, postorder: <span class="type">IntArray</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (inorder.isEmpty() &amp;&amp; postorder.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> node = TreeNode(postorder[postorder.size - <span class="number">1</span>]) <span class="comment">//postorder.size用的地方多，可以提取出来</span></span><br><span class="line">    <span class="keyword">val</span> index = getIndex(node, inorder)</span><br><span class="line">    node.left = buildTree(inorder.copyOfRange(<span class="number">0</span>, index), postorder.copyOfRange(<span class="number">0</span>, index)) <span class="comment">// copyOfRange数组效率低</span></span><br><span class="line">    node.right = buildTree(</span><br><span class="line">        inorder.copyOfRange(index + <span class="number">1</span>, inorder.size), postorder.copyOfRange(index, postorder.size - <span class="number">1</span>)</span><br><span class="line">    ) <span class="comment">// 注意copyOfRange(0,2)获取的是index 0,1两个元素</span></span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getIndex</span><span class="params">(node: <span class="type">TreeNode</span>, inorder: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> inorder.indices) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.`<span class="keyword">val</span>` == inorder[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h5><p>写出来还有问题,先pass这题耗时太久了,边界不好掌握可以考虑用日志调试</p>
<p>还可以再看下随想录的视频讲解</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1vW4y1i7dn">https://www.bilibili.com/video/BV1vW4y1i7dn</a></p>
<p>随想录代码优化前的写法，和上面代码写法是一样的，只是用了C++语言</p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html">https://programmercarl.com/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html</a></p>
<p>最初错误的解法,上面的解法数组有变化所以 end位置就是数组的大小，但是这里不同，数组是没变化，就不能这样做</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 数组不变，只改变下标</span><br><span class="line">private fun buildDFSTree(</span><br><span class="line">    inorder: IntArray,</span><br><span class="line">    postorder: IntArray,</span><br><span class="line">    inStart: Int,</span><br><span class="line">    inEnd: Int,</span><br><span class="line">    postStart: Int,</span><br><span class="line">    postEnd: Int</span><br><span class="line">): TreeNode? &#123;</span><br><span class="line">    if (inStart &gt; inEnd || postStart &gt; postEnd || inEnd &lt; 0 || postEnd &lt; 0) &#123;</span><br><span class="line">        return null</span><br><span class="line">    &#125;</span><br><span class="line">    val node &#x3D; TreeNode(postorder[postEnd]) &#x2F;&#x2F;postorder.size用的地方多，可以提取出来</span><br><span class="line">    val index &#x3D; getIndex(node, inorder)</span><br><span class="line"></span><br><span class="line">    node.left &#x3D; buildDFSTree(inorder, postorder, inStart, index - 1, 0, index - 1)   &#x2F;&#x2F;[0,index) 左闭右开</span><br><span class="line">    node.right &#x3D; buildDFSTree(inorder, postorder, index + 1, inEnd, index + 1, postEnd)</span><br><span class="line">    return node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这一题花了不少时间，思路不难，主要是 切割后序的数组的时候，左右子树的边界值不好处理,</p>
<ol>
<li>map用来存储，中序value值和position的对应关系，这里value应该是唯一的.</li>
<li>采用的是左闭右闭的方案，所以inStart &gt; inEnd 不能用 &gt;=, 否则return了，叶子节点无法构造出来.</li>
<li>根据后序root节点，分割中序数组，拿到左子树后，再用左子树树的分割后序数组,因为左子树的长度是一样的。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> map = HashMap&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">buildTree1</span><span class="params">(inorder: <span class="type">IntArray</span>, postorder: <span class="type">IntArray</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (inorder.isEmpty() &amp;&amp; postorder.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> inStart = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> inEnd = inorder.size - <span class="number">1</span></span><br><span class="line">    <span class="keyword">val</span> postStart = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> postEnd = postorder.size - <span class="number">1</span></span><br><span class="line">    inorder.forEachIndexed &#123; position, item -&gt;</span><br><span class="line">        map[item] = position</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buildDFSTree(inStart, inEnd, postStart, postEnd, inorder, postorder)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组不变，只改变下标</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">buildDFSTree</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    inStart: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    inEnd: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    postStart: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    postEnd: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    inorderArr: <span class="type">IntArray</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    postorderArr: <span class="type">IntArray</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: TreeNode? &#123;</span><br><span class="line">    println(<span class="string">&quot; inStart <span class="variable">$inStart</span> inEnd <span class="variable">$inEnd</span>  postStart <span class="variable">$postStart</span> postEnd <span class="variable">$postEnd</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> (inStart &gt; inEnd || postStart &gt; postEnd) &#123; <span class="comment">// 因为是左闭右闭的方案，所以这里不能用 &gt;= ,否则叶子节点无法构造出来</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> node = TreeNode(postorderArr[postEnd]) <span class="comment">//postorder.size用的地方多，可以提取出来</span></span><br><span class="line">    <span class="keyword">val</span> index = map[postorderArr[postEnd]] ?: <span class="number">0</span> <span class="comment">// 这里要改</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切割左子树,这种坐标定义好更清晰</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> leftInBegin = inStart</span><br><span class="line">    <span class="keyword">val</span> leftInEnd = index - <span class="number">1</span> <span class="comment">// 左闭右闭</span></span><br><span class="line">    <span class="keyword">val</span> leftPostBegin = postStart</span><br><span class="line">    <span class="keyword">val</span> leftPostEnd = postStart + (index - inStart - <span class="number">1</span>) <span class="comment">//(index - inStart) 左子树的长度, 因为选择是左闭右闭的方案，所以自身也-1</span></span><br><span class="line"></span><br><span class="line">    node.left = buildDFSTree(</span><br><span class="line">        leftInBegin, leftInEnd, leftPostBegin, leftPostEnd,</span><br><span class="line">        inorderArr,</span><br><span class="line">        postorderArr</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切割右子树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> rightInBegin = index + <span class="number">1</span></span><br><span class="line">    <span class="keyword">val</span> rightInEnd = inEnd</span><br><span class="line">    <span class="keyword">val</span> rightPostBegin = postStart + index - inStart <span class="comment">//(index - inStart) 这里不用-1,因为左子树的右边就是右子树，所以右子树就是从这个位置开始的</span></span><br><span class="line">    <span class="keyword">val</span> rightPostEnd = postEnd - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    node.right = buildDFSTree(</span><br><span class="line">        rightInBegin, rightInEnd, rightPostBegin, rightPostEnd,</span><br><span class="line">        inorderArr,</span><br><span class="line">        postorderArr</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>官方</p>
<p>先构建右子树的想法好巧妙，要是先构建的是左子树还有个确定后序区间的步骤。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution/cong-zhong-xu-yu-hou-xu-bian-li-xu-lie-gou-zao-14/">https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution/cong-zhong-xu-yu-hou-xu-bian-li-xu-lie-gou-zao-14/</a></p>
<p>官方解法很妙，根据后序数组pop，post_idx–;先开始右子树,然后左子树,构造方法也很简单，这样不用找后序数组的 开始和结束位置在哪. 做了上面的解法，也就是这个后序的边界值最难搞. 这种方式直接给省去了。</p>
<p>不得不说太妙了</p>
<p><img src="https://assets.leetcode-cn.com/solution-static/106/6.png"></p>
<p>官方迭代法后面再看吧 。</p>
<h4 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654. 最大二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-binary-tree/">654. 最大二叉树</a></h4><p>输入：nums = [3,2,1,6,0,5]<br>输出：[6,3,5,null,2,0,null,null,1]<br>解释：递归调用如下所示：</p>
<p>[3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。</p>
<ul>
<li>[3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。 ,3的左边是[]没有节点, 右边是[0,5],所以树也是这样构造的.<ul>
<li>空数组，无子节点。</li>
<li>[2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。<ul>
<li>空数组，无子节点。</li>
<li>只有一个元素，所以子节点是一个值为 1 的节点。</li>
</ul>
</li>
</ul>
</li>
<li>[0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。<ul>
<li>只有一个元素，所以子节点是一个值为 0 的节点。</li>
<li>空数组，无子节点。</li>
</ul>
</li>
</ul>
<h5 id="preTraversal"><a href="#preTraversal" class="headerlink" title="preTraversal"></a>preTraversal</h5><p>思路 : </p>
<ol>
<li>因为需要构造中间节点，所以用先序遍历</li>
<li>先找到数组中最大值，然后切割成左右子树。</li>
<li>在切割后的左右子树中继续切割，直至无法切割为止</li>
</ol>
<p>自己写的，做法和随想录类似 </p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0654.%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html#java">https://programmercarl.com/0654.%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html#java</a></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">constructMaximumBinaryTree</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">return</span> buildTree(nums, <span class="number">0</span>, nums.size - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">buildTree</span><span class="params">(nums: <span class="type">IntArray</span>, start: <span class="type">Int</span>, end: <span class="type">Int</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    println(<span class="string">&quot;buildTree start <span class="variable">$start</span> end <span class="variable">$end</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="literal">null</span>            <span class="comment">//分割的左右下标越界就退出 ,不能加==，否则叶子节点构造不到.</span></span><br><span class="line">    <span class="keyword">val</span> maxIndex = getMaxIndex(nums, start, end)</span><br><span class="line">    <span class="keyword">val</span> node = TreeNode(nums[maxIndex])     <span class="comment">// 构造先序的父节点</span></span><br><span class="line">    node.left = buildTree(nums, start, maxIndex - <span class="number">1</span>) <span class="comment">// 构造左节点</span></span><br><span class="line">    node.right = buildTree(nums, maxIndex + <span class="number">1</span>, end)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getMaxIndex</span><span class="params">(nums: <span class="type">IntArray</span>, start: <span class="type">Int</span>, end: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> maxIndex = start</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> start..end) &#123;  <span class="comment">// 在对应的数组范围内，找到最大值</span></span><br><span class="line">        <span class="keyword">if</span> (nums[maxIndex] &lt; nums[i]) &#123;</span><br><span class="line">            maxIndex = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxIndex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h5><p>官方还有一种单调栈的写法，后面再看吧</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-binary-tree/solution/zui-da-er-cha-shu-by-leetcode-solution-lbeo/">https://leetcode.cn/problems/maximum-binary-tree/solution/zui-da-er-cha-shu-by-leetcode-solution-lbeo/</a></p>
<h4 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h4><p>Idea</p>
<h5 id="只分割中序数组"><a href="#只分割中序数组" class="headerlink" title="只分割中序数组"></a>只分割中序数组</h5><p>按照上面106官方很妙的思路，下面解法</p>
<ol>
<li>根据中序遍历。value和index构造hash map,方便后面获取中序位置</li>
<li>根据先序遍历数组从 左子树到右子树构造节点, 这样就不用分割先序数组，也是很麻烦的</li>
<li>根据先序数组的节点的位置，分割中序遍历数组，拿到左右子树</li>
<li>然后是递归分割.</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> map = HashMap&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="keyword">var</span> preNodeIndex = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">buildTree</span><span class="params">(preorder: <span class="type">IntArray</span>, inorder: <span class="type">IntArray</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    inorder.forEachIndexed &#123; position, item -&gt; <span class="comment">//</span></span><br><span class="line">        map[item] = position</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buildDFS(preorder, inorder, <span class="number">0</span>, inorder.size - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">buildDFS</span><span class="params">(preorder: <span class="type">IntArray</span>, inorder: <span class="type">IntArray</span>, inBegin: <span class="type">Int</span>, inEnd: <span class="type">Int</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (inBegin &gt; inEnd) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> node = TreeNode(preorder[preNodeIndex])  <span class="comment">// 根据先序遍历数组从 左子树到右子树构造节点</span></span><br><span class="line">    <span class="keyword">val</span> inIndex = map[preorder[preNodeIndex]]!! <span class="comment">// 根据先序数组的节点的位置，分割中序遍历数组，拿到左右子树</span></span><br><span class="line">    println(<span class="string">&quot;<span class="subst">$&#123;preorder[preNodeIndex]&#125;</span> inBegin <span class="variable">$inBegin</span> inEnd <span class="variable">$inEnd</span>&quot;</span>)</span><br><span class="line">    preNodeIndex++</span><br><span class="line">    node.left = buildDFS(preorder, inorder, inBegin, inIndex - <span class="number">1</span>)</span><br><span class="line">    node.right = buildDFS(preorder, inorder, inIndex + <span class="number">1</span>, inEnd)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="分割先序-中序数组"><a href="#分割先序-中序数组" class="headerlink" title="分割先序 中序数组"></a>分割先序 中序数组</h5><ol>
<li>根据中序数组构造，位置和值的hashmap 。</li>
<li>根据先序数组的中节点位置，分割中序数组，得到左右子树。</li>
<li>根据中序数组得到的左子树的长度，分割 先序数组的左右子树.</li>
<li>构造左右子树.</li>
</ol>
<p>左闭右闭的情况</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> map = HashMap&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="keyword">var</span> preNodeIndex = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">buildTree1</span><span class="params">(preorder: <span class="type">IntArray</span>, inorder: <span class="type">IntArray</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    inorder.forEachIndexed &#123; position, item -&gt;</span><br><span class="line">        map[item] = position  <span class="comment">// 获得 中序 value和index hash</span></span><br><span class="line">        map.put(item,position)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> splitPreInOrder(preorder, <span class="number">0</span>, preorder.size - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.size - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">splitPreInOrder</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    preorderArr: <span class="type">IntArray</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    preStart: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    preEnd: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    inorderArr: <span class="type">IntArray</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    inStart: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    inEnd: <span class="type">Int</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: TreeNode? &#123;</span><br><span class="line">    println(<span class="string">&quot; preStart <span class="variable">$preStart</span> preEnd <span class="variable">$preEnd</span> inStart <span class="variable">$inStart</span> inEnd <span class="variable">$inEnd</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (preStart &gt; preEnd || inStart &gt; inEnd) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">val</span> inIndex = map[preorderArr[preStart]]!!  <span class="comment">// 分割中序数组</span></span><br><span class="line">    <span class="keyword">val</span> node = TreeNode(preorderArr[preStart])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> leftInBegin = inStart <span class="comment">//左闭</span></span><br><span class="line">    <span class="keyword">val</span> leftInEnd = inIndex-<span class="number">1</span>    <span class="comment">// 右闭</span></span><br><span class="line">    <span class="keyword">val</span> leftPreBegin = preStart + <span class="number">1</span> <span class="comment">// 先序中节点的后一个位置，就是左子树的开始位置</span></span><br><span class="line">    <span class="keyword">val</span> leftPreEnd = preStart + (inIndex - inStart) <span class="comment">// 其实位置 + 中序中左子树的长度</span></span><br><span class="line"></span><br><span class="line">    node.left = splitPreInOrder(preorderArr, leftPreBegin, leftPreEnd, inorderArr, leftInBegin, leftInEnd)</span><br><span class="line">    <span class="keyword">val</span> rightInBegin = inIndex + <span class="number">1</span> <span class="comment">// 分割点的后一个位置</span></span><br><span class="line">    <span class="keyword">val</span> rightInEnd = inEnd</span><br><span class="line">    <span class="keyword">val</span> rightPreBegin = preStart + (inIndex - inStart) + <span class="number">1</span> <span class="comment">// 先序数组 左子树位置+1 后一个位置</span></span><br><span class="line">    <span class="keyword">val</span> rightPreEnd = preEnd</span><br><span class="line">    node.right = splitPreInOrder(preorderArr, rightPreBegin, rightPreEnd, inorderArr, rightInBegin, rightInEnd)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>感觉还是左闭右闭好点，右开的情况容易越界.</p>
<h4 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-binary-trees/">617. 合并二叉树</a></h4><h5 id="DFS-2"><a href="#DFS-2" class="headerlink" title="DFS"></a>DFS</h5><ol>
<li>合并二叉树，通过先序遍历，先构造根节点</li>
<li>然后再分别构造左右子树</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">mergeTrees</span><span class="params">(root1: <span class="type">TreeNode</span>?, root2: <span class="type">TreeNode</span>?)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="literal">null</span> &amp;&amp; root2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">//这里还可以优化, 看官方解法和随想录的优化一样的</span></span><br><span class="line">    <span class="keyword">val</span> node = TreeNode((root1?.`<span class="keyword">val</span>` ?: <span class="number">0</span>) + (root2?.`<span class="keyword">val</span>` ?: <span class="number">0</span>))</span><br><span class="line">    node.left = mergeTrees(root1?.left, root2?.left)</span><br><span class="line">    node.right = mergeTrees(root1?.right, root2?.right)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>BFS</p>
<p>这题官方有一种BFS的解法,感觉有点麻烦，后面继续</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-binary-trees/solution/he-bing-er-cha-shu-by-leetcode-solution/">https://leetcode.cn/problems/merge-two-binary-trees/solution/he-bing-er-cha-shu-by-leetcode-solution/</a></p>

	  <div class="article-footer-copyright">

    本博客采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议(CC BY-NC-SA 4.0) 发布.</a>
</div>

	</div>

	
	
	<div>
  	<center>

	<div class="pagination">

    
    
    <a href="/2022/09/15/Fragment-StateLoss/" type="button" class="btn btn-default"><i
                class="fa fa-arrow-circle-o-left"></i> Prev</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a href="/2022/08/27/view-custom/" type="button" class="btn btn-default ">Next<i
                class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>


    </center>
	</div>
	
	<!-- comment -->
	<!--
<section id="comment">
    <h2 class="title">Comments</h2>

    
</section>

-->
	
	
	
	</div> <!-- col-md-9/col-md-12 -->


	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2022-09-11 
	</div>
	

	<!-- categories -->
    
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>	
    <ul id="categorys" class="tag_box list-unstyled collapse in">
          
  <li>
    <li><a href="/categories/DataStructure/">DataStructure<span>16</span></a></li>
  </li>

    </ul>
	</div>
	

	<!-- tags -->
	
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#tags"><i class="fa fa-tags"></i></a>		  
    <ul id="tags" class="tag_box list-unstyled collapse in">	  
	    
  <li><a href="/tags/LEETCODE/">LEETCODE<span>12</span></a></li>
    </ul>
	</div>
		

	<!-- toc -->
	<div class="meta-widget">
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

		

	</div>
	
		

</div><!-- row -->

<!--
 -->



	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  
  &copy; 2023 Jon's Blog
  
      powered by <a href="http://hexo.io/" target="_blank">Hexo</a>.Theme <a href="https://github.com/Ares-X/hexo-theme-freemind.bithack" target="_blank">freemind.bithack</a>  
</p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



</body>
   </html>
