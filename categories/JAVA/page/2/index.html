<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>Category: JAVA - Hexo</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Hexo"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Hexo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Hexo"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="Hexo"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="John Doe"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"Hexo","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"John Doe"},"publisher":{"@type":"Organization","name":"Hexo","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Hexo" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">Categories</a></li><li class="is-active"><a href="#" aria-current="page">JAVA</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-03-23T09:47:11.000Z" title="3/23/2020, 5:47:11 PM">2020-03-23</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-09-03T11:27:29.866Z" title="9/3/2023, 7:27:29 PM">2023-09-03</time></span><span class="level-item"><a class="link-muted" href="/categories/JAVA/">JAVA</a></span><span class="level-item">an hour read (About 9043 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/03/23/Android_itnerview2/">Java_Queue</a></p><div class="content"><h1 id="爱奇艺"><a href="#爱奇艺" class="headerlink" title="爱奇艺"></a>爱奇艺</h1><ul>
<li>Android消息机制</li>
<li>Android View绘制流程，当一个TextView的实例调用setText()方法后执行了什么</li>
<li>Android dalvik虚拟机和Art虚拟机的优化升级点</li>
<li>Android屏幕渲染机制</li>
<li>热修复的原理，你都了解过哪几种热修复框架</li>
<li>OkHttp的原理</li>
<li>Android 线程池的实现原理</li>
<li>JavaGC机制</li>
<li>HashMap的实现机制，怎么样HashMap线程安全</li>
<li>可重入锁的实现，公平锁非公平锁都是什么定义？</li>
<li>都用过那些常用的数据结构，说说对树的了解？</li>
<li>Activity启动模式，allowReparent的特点和栈亲和性</li>
<li>WebView优化</li>
<li>有没有Jni使用经验</li>
<li>有使用过RxJava吗？</li>
<li>说说你对设计模式的理解，开发过程中主要用到了哪些设计模式？</li>
<li>快排写一下，动态规划了解吗？</li>
</ul>
<h1 id="小米"><a href="#小米" class="headerlink" title="小米"></a>小米</h1><ul>
<li>冒泡排序的链表实现</li>
<li>写个快排</li>
<li>写个单例模式 -Activity启动模式</li>
<li>异常生命周期</li>
<li>从点击应用图标到进入应用，Android系统都做了哪些工作，期间涉及到的进程切换有哪些？</li>
<li>说说你了解的IPC方法</li>
<li>说说Binder的大体实现</li>
<li>怎么控制另外一个进程的View显示</li>
<li>广播中怎么进行网络请求</li>
<li>说说Android中线程池的实现</li>
<li>HashMap如果Hash冲突了怎么解决？</li>
<li>双线程通过线程同步的方式打印12121212…….</li>
</ul>
<h1 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h1><ul>
<li>HTTPS是怎么实现的？</li>
<li>Android事件传递流程和OnTouchListener的关系</li>
<li>Activity启动模式</li>
<li>Android线程池实现原理</li>
<li>双指缩放拖动大图</li>
<li>客户端网络安全实现</li>
<li>Webview优化</li>
<li>Android应用保活</li>
<li>RemoteViews实现和使用场景</li>
<li>RecyclerView绘制步骤和复用机制</li>
<li>Binder的大体设计模式</li>
<li>Activity遵循什么设计模式</li>
<li>EventBus源码解析，遵循什么设计模式</li>
<li>Handler为什么会发生内存泄漏</li>
<li>Java内存模块分区和GC机制，GC算法有哪些</li>
<li>Finalize机制</li>
<li>强引用 弱引用 软引用 虚引用的区别和使用场景</li>
<li>LeakCanary的使用和实现原理</li>
<li>介绍一下你在开发过程中使用到的设计模式</li>
<li>快排</li>
<li>对服务器众多错误码的处理（错误码有好几万个）</li>
</ul>
<h1 id="阿里"><a href="#阿里" class="headerlink" title="阿里"></a>阿里</h1><ul>
<li>Android消息机制</li>
<li>Android事件传递流程</li>
<li>Android View绘制流程</li>
<li>Activity启动模式</li>
<li>Android IPC机制</li>
<li>Android线程池设计原理</li>
<li>EventBus源码和设计模式</li>
<li>Android应用保活</li>
<li>Android UI优化</li>
<li>Android启动优化</li>
<li>快排 堆排 单例</li>
<li>进程线程在操作系统中的实现</li>
<li>HTTPS的组成是什么？</li>
<li>ClassLoader的双亲委托</li>
<li>Android中的ClassLoader</li>
<li>有过Jni使用经验吗？</li>
<li>有过跨平台开发经验吗？</li>
</ul>
<h1 id="今日头条"><a href="#今日头条" class="headerlink" title="今日头条"></a>今日头条</h1><ul>
<li>视频加密</li>
<li>Android Native Crash</li>
<li>视频组成</li>
<li>播放器原理</li>
</ul>
<p>作者：Android小崽<br>链接：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/?type=11023_0">https://www.nowcoder.com/?type=11023_0</a><br>来源：牛客网</p>
<h1 id="哈啰安卓一面面经"><a href="#哈啰安卓一面面经" class="headerlink" title="哈啰安卓一面面经"></a>哈啰安卓一面面经</h1><p>问了一个半小时  很多问题没记住  挑几个说一下<br>1、进程通信方式有哪些<br>2、线程通信方式有哪些<br>3、进程线程区别<br>4、JAVAGC如何判断是否回收以及僵尸线程<br>5、AOP了解吗<br>6、为什么安卓用BINDER 有啥优点<br>7、GC回收算法有哪些<br>8、http的流程以及和https的区别<br>9、OSI七层有哪些  TCP UDP在哪些层  交换器路由器在哪些层<br>10、UDP STL  和TCP区别<br>11、对称加密和非对称加密有哪些算法  什么区别<br>12、有哪些数据结构   增删改查的复杂度多少<br>13、算法的五大基本要素有哪些？为什么算法效率不是基本要素？<br>14、算法题  判断二叉树深度</p>
<p>1、Glide<br>2、http和https<br>3、view绘制流程<br>4、TCP/UDP<br>5、Handler和AsyncTask<br>6、TCP\UDP<br>7、MVP<br>8、Retrofit<br>9、AsyncTask  Handler</p>
<p>作者：想去广西嗦粉的小黄鸭在学习腾讯一面 50分钟</p>
<p>1.MVVM与mvc、mvp架构的区别与联系</p>
<p>2.mvvm用到的设计模式</p>
<p>3.viewmodel的实现原理</p>
<p>4.viewmodel怎么更新数据的</p>
<p>5.安卓的线程通信</p>
<p>6.looper阻塞为什么不会造成ANR</p>
<p>7.广播里怎么执行耗时操作</p>
<p>8.阻塞多久会出现ANR</p>
<p>9.开发遇到的一些异常，怎么处理</p>
<p>10.线程安全的队列有哪些</p>
<p>11.concurrenthashmap详解</p>
<p>12.fragment的生命周期</p>
<p>13.安卓里解决多线程冲突的方法</p>
<p>14.volatile详解、synchronized详解，两者区别</p>
<p>15.activity生命周期</p>
<p>16.onStart与onResume解释</p>
<p>17.安卓中进程间通信方式</p>
<p>18.内核态与用户态</p>
<p>21.TCP传输中header里的字段</p>
<p>22.http状态码</p>
<p>23.Java GC机制</p>
<p>24.进程、线程、协程的联系与区别</p>
<p>25.死锁的必要条件</p>
<p>26.银行家算法</p>
<p>27.TCP拥塞控制</p>
<p>28.四次挥手详解</p>
<p>29.TCP与UDP区别</p>
<p>30.TCP怎么保证可靠传输</p>
<p>31.DNS解析过程</p>
<p>32.TCP报文里的字段 </p>
<p>33.算法题：计算二叉树的高度（递归与非递归两种方式）</p>
<h1 id="腾讯二面，35分钟"><a href="#腾讯二面，35分钟" class="headerlink" title="腾讯二面，35分钟"></a>腾讯二面，35分钟</h1><p>1.mvvm，mvp,mvc</p>
<p>2.详细介绍项目</p>
<p>3.网络传输层的协议</p>
<p>4.TCP报头</p>
<p>5.TCP三次握手，为什么三次</p>
<p>6.linux内存管理机制</p>
<p>7.虚拟内存与物理内存</p>
<p>8.常用数据结构</p>
<p>9.堆排序原理</p>
<h1 id="vivo一面-45分钟"><a href="#vivo一面-45分钟" class="headerlink" title="vivo一面 45分钟"></a>vivo一面 45分钟</h1><p>1.面向对象三大特性，多态怎么实现</p>
<p>2.静态方法与变量是否可以继承，原因</p>
<p>3.Java代理是否用过，怎么实现</p>
<p>4.Java异常详解</p>
<p>5.项目中遇到的异常</p>
<p>线程安全的队列</p>
<p>7.类加载的过程</p>
<p>8.类加载器，双亲委派模型</p>
<p>9.对象生命周期</p>
<p>10.判断对象是否可以回收的方法</p>
<p>11.有哪些GC roots</p>
<p>12.Java引用类型</p>
<p>13.抽象类与接口区别，各自优缺点</p>
<p>14.Java线程间通信， volatile详解、synchronized详解</p>
<p>15.线程的状态</p>
<p>16.进程、线程、协程</p>
<p>17.死锁怎么造成的</p>
<p>18.线程池详解</p>
<p>19.线程池怎么做到线程复用</p>
<p>20.thread local详解</p>
<p>21.Java泛型，泛型擦除机制</p>
<p>22.TCP与UDP区别，优缺点</p>
<p>23.TCP可靠传输机制</p>
<p>24.介绍http协议</p>
<p>25.https请求流程</p>
<p>26.b树、b+树、红黑树</p>
<p>27.红黑树怎么增加、删除节点</p>
<p>28.输入一个URL到网页显示的过程</p>
<p>29.localhost 与127.0.0.1的区别</p>
<p>30.MVVM、MVC、MVP的区别与联系，各自优缺点</p>
<p>31.activity的生命周期</p>
<p>32.安卓中的数据存储，sharedpreference详解</p>
<h1 id="字节一面-1小时"><a href="#字节一面-1小时" class="headerlink" title="字节一面 1小时"></a>字节一面 1小时</h1><p>1.进程、线程、协程</p>
<p>2.进程间能共享内存吗</p>
<p>3.安卓中挂起函数怎么实现的</p>
<p>4.安卓中实现多线程的方法</p>
<p>5.线程池详解</p>
<p>6.线程池设计模式，怎么自己设计一个线程池</p>
<p>7.handler详解，是否会内存泄漏，泄露的原理</p>
<p>8.匿名内部类，原理是什么</p>
<p>9.Java GC算法</p>
<p>10.Java引用类型，弱引用的作用，引用队列。</p>
<p>11.安卓图片缓存，加载</p>
<p>12.安卓中的布局，布局优化方法，常用标签</p>
<p>13.安卓四大组件</p>
<p>14.activity四大启动模式</p>
<p>15.onnewintent方法</p>
<p>16.本地广播</p>
<p>17.jetpack组件</p>
<p>18.viewmodel设计模式，mvc,mvp,mvvm介绍</p>
<p>19.retrofit的具体实现，其中接口的作用，注解的作用</p>
<p>20.hashtable,hashmap与 concurrenthashmap详解</p>
<p>21.哈希冲突解决方法，</p>
<p>22.算法题：随机生成不重复的100个数0-99</p>
<h1 id="字节二面，50分钟"><a href="#字节二面，50分钟" class="headerlink" title="字节二面，50分钟"></a>字节二面，50分钟</h1><p>1.https详细介绍</p>
<p>2.get与post区别</p>
<p>3.请求状态码</p>
<p>4.cookie与session</p>
<p>5.Java内部类</p>
<p>6.泛型擦除机制</p>
<p>7.Java内存回收</p>
<p>8.GC roots</p>
<p>9.Java加锁方式</p>
<p>10.线程安全的单例模式（双重检测），为什么要两次判断，volatile作用</p>
<p>11.安卓的事件分发机制</p>
<p>12.算法题：获得二叉树的最大宽度，写出最优解</p>
<h1 id="字节三面，50分钟"><a href="#字节三面，50分钟" class="headerlink" title="字节三面，50分钟"></a>字节三面，50分钟</h1><p>5道代码题</p>
<p>1.写一个泛型方法，实现删除数组中的元素功能</p>
<p>2.写一个单例模式</p>
<p>3.返回二叉树的第k大数</p>
<p>另外两个记不得了，代码写的很差，所以三面卒。。。</p>
<h1 id="顺丰一面，30分钟"><a href="#顺丰一面，30分钟" class="headerlink" title="顺丰一面，30分钟"></a>顺丰一面，30分钟</h1><p>1.面向对象三大特性与面向过程区别</p>
<p>2.怎么判断对象相等，equals详解</p>
<p>3.抽象类与接口区别</p>
<p>4.Java跨平台的原因</p>
<p>5.JVM，GC算法</p>
<p>6.安卓view绘制流程</p>
<p>7.view怎么确认位置与大小，测量模式</p>
<p>8.常用的viewgroup，与view区别，在事件处理过程中有什么区别</p>
<p>9.安卓事件传递机制</p>
<p>10.listview详解，缓存机制与recyclerview区别</p>
<h1 id="顺丰二面，15分钟"><a href="#顺丰二面，15分钟" class="headerlink" title="顺丰二面，15分钟"></a>顺丰二面，15分钟</h1><p>1.项目详细介绍</p>
<p>2.安卓中的listview与recyclerview</p>
<p>3.安卓中的网络请求方式</p>
<p>4.项目中的设计模式</p>
<h1 id="美团一面，1小时"><a href="#美团一面，1小时" class="headerlink" title="美团一面，1小时"></a>美团一面，1小时</h1><p>1.安卓项目介绍</p>
<p>2.mvc,mvp,mvvm架构</p>
<p>3.jetpack组件</p>
<p>4.lifecycle介绍</p>
<p>5.viewmodel实现原理</p>
<p>6.retrofit介绍</p>
<p>7.retrofit怎么实现多线程</p>
<p>8.线程池详解</p>
<p>9.多线程会遇到什么问题</p>
<p>10.死锁的条件，手写一个死锁代码并运行出来</p>
<p>11.怎么避免死锁问题</p>
<p>12.可重入锁</p>
<p>13.安卓怎么进行ui操作</p>
<p>14.安卓点击事件的处理</p>
<p>15.下拉刷新原理</p>
<p>16.安卓存储方式</p>
<p>17.contentprovider介绍，能实现耗时操作吗</p>
<p>18.service介绍，生命周期与 contentprovider区别</p>
<p>19.https请求过程</p>
<p>20.算法题：返回第k大的数，先说下你能想到的方法，再选一个最优方法。</p>
<h1 id="美团二面，50分钟"><a href="#美团二面，50分钟" class="headerlink" title="美团二面，50分钟"></a>美团二面，50分钟</h1><p>1.Java入口函数</p>
<p>2.方法签名</p>
<p>3.方法修饰符</p>
<p>4.static关键字详解，说下自己知道的关键字</p>
<p>5.Java基本类型</p>
<p>6.字符串详解</p>
<p>7.字符串的常用操作</p>
<p>8.Java io</p>
<p>9.Java异常介绍，是否所有异常都需要捕获</p>
<p>10.对Java抽象的理解</p>
<p>11.接口与抽象类区别</p>
<p>12.类编译过程</p>
<p>13.介绍对安卓中intent的理解</p>
<p>14.自定义view过程</p>
<p>15.介绍service</p>
<p>16.service与activity通信</p>
<p>17.输入URL到返回页面的完整过程</p>
<p>18.怎么加速http连接</p>
<p>19.虚拟内存</p>
<p>20.线程并发会遇到哪些问题，怎么解决</p>
<p>21.详细介绍自己的项目，项目可以有哪些改进的地方</p>
<p>22.算法题：二分法查找目标数</p>
<p>作者：Android大牛</p>
<h1 id="小米安卓开发一二面面经一面9-29"><a href="#小米安卓开发一二面面经一面9-29" class="headerlink" title="小米安卓开发一二面面经一面9.29"></a>小米安卓开发一二面面经<strong>一面9.29</strong></h1><p>1、手撕：使用一个固定长度数组实现队列，包括添加和取数据的功能</p>
<p>2、时间复杂度、空间复杂度，如何优化</p>
<p>3、链表如何优化，可以降低查询的时间复杂度？</p>
<p>4、hashmap插入数据的流程？</p>
<p>5、如何计算hashmap数据插入的位置？</p>
<p>6、如何解决哈希冲突？</p>
<p>7、多线程如何解决线程冲突？</p>
<p>8、手撕：手写一个单例模式</p>
<p>9、volatile 和 synchronized 有什么区别？</p>
<p>10、synchronized 和 lock 有什么区别？</p>
<p>11、synchronized 底层是如何实现加锁操作的？</p>
<p>12、对象、锁、对象监视器相互之间的关系？</p>
<p>13、乐观锁如何实现？缺点有哪些？</p>
<p>14、ThreadLocal 是如何存储的？</p>
<p>15、ThreadLocalMap中遇到冲突是如何处理的？</p>
<p>16、框架部分是如何学习的？遇到问题如何解决？</p>
<p>17、如果转安卓开发，将怎样制定学习路线？</p>
<p>18、对小米的了解？（我说我老米粉了，给面试官整笑了）</p>
<p>反问</p>
<p>（面试之前沟通时我说不会安卓，他也就没问我安卓的东西，面试官人还挺好的）</p>
<h1 id="二面9-30"><a href="#二面9-30" class="headerlink" title="二面9.30"></a><strong>二面9.30</strong></h1><p>1、为什么会转码？（…每次面试必问）</p>
<p>2、有一千个键值对的数据，如何设计HashMap的初始容量大小？</p>
<p>3、HashMap的扩容机制是什么样的？</p>
<p>4、ConcurrentHashMap 是如何实现线程安全的？如果让你设计锁的数量你会怎么设计来提高效率？</p>
<p>5、synchronized 底层是如何实现的？</p>
<p>6、ReentrantLock 如何实现公平锁与非公平锁？</p>
<p>7、公平锁与非公平锁的释放有什么区别？</p>
<p>8、线程的 wait 和 block 有什么区别？和 sleep 有什么区别？</p>
<p>9、JVM 中创建一个对象的过程是什么样的？</p>
<p>10、JVM 如何判断一个对象需要被回收?</p>
<p>11、如果电脑内存是4G，已经使用了3G，现在启动一个程序需要超过1G的内存，会发生什么？(内存回收)</p>
<p>12、SpringBoot相比于Spring有什么优势？</p>
<p>13、Spring中控制反转和依赖注入有什么区别和联系？为什么要进行控制反转？有什么好处？</p>
<p>14、单例模式的好处有哪些？应用场景有哪些？</p>
<p>15、三种工厂模式有什么区别？</p>
<p>16、类加载过程是什么样的？</p>
<p>17、双亲委派模型有什么作用？</p>
<p>18、项目中如何设计单点登录？如何实现你这边登陆，另一边强制下线的功能？</p>
<p>19、OSI七层模型介绍一下？应用层有什么协议？</p>
<p>20、三次握手变成两次可不可以？为什么？</p>
<p>21、手撕：二叉搜索树第 k 小的节点</p>
<p>小米面试官感觉都挺好的，不会的问题会进行引导，二面多问些场景题。</p>
<p>作者：CodeWH</p>
<p>2.==和equals的区别</p>
<p>3.重载和重写的区别</p>
<p>4.值传递和引用传递</p>
<p>5.static、final作用</p>
<p>6.所有类的父类</p>
<p>7.this()和super()</p>
<p>8.int和Integer的区别</p>
<p>9.线程池和线程</p>
<p>10.锁了解哪些（说了分布式锁，又问我分布式锁是什么）</p>
<p>11.项目的难点，解决</p>
<p>Java反射原理<br>Java面向对象的理解，封装，继承，多态<br>HashMap底层原理<br>接口和抽象类的区别<br>你是怎么学习的，你的学习能力怎么样<br>Activity的启动模式有哪些<br>多进程通信的方式<br>Android intent如何传递数据<br>Android广播<br>谈谈Android性能优化</p>
<p>https和http的区别<br>三次握手<br>你都用过哪些设计模式？</p>
<p>作者：被光选中的人</p>
<h1 id="字节跳动安卓工程师一、二面社招"><a href="#字节跳动安卓工程师一、二面社招" class="headerlink" title="字节跳动安卓工程师一、二面社招"></a>字节跳动安卓工程师一、二面社招</h1><h2 id="一面-1h"><a href="#一面-1h" class="headerlink" title="一面|1h"></a>一面|1h</h2><p>聊了好久，一面也太正式了，问得较为基础，但是问得真的挺多的，心累。<br>项目介绍</p>
<p>Java四次引用</p>
<p>垃圾回收机制</p>
<p>线程安全的集合有哪些（问得比较细）</p>
<p>进程间通信的方式</p>
<p>HashMap的底层实现</p>
<p>eventbus原理</p>
<p>View的绘制过程</p>
<p>Surfaceview可以在非主线程绘制吗</p>
<p>Glide的缓存机制</p>
<p>内存优化（追着问）</p>
<p>TCP三次握手</p>
<p>算法：合并区间</p>
<p>算法：排序数组</p>
<h2 id="二面-45min"><a href="#二面-45min" class="headerlink" title="二面|45min"></a>二面|45min</h2><p>二面在源码这块真的问得很深，Android部分问得比较多，不能小看啊</p>
<p>Java虚拟机</p>
<p>okhttp的请求机制</p>
<p>RxJava实现原理</p>
<p>handler处理流程，looper和handler是一对一还是一对多，为什么主线程loop不会ANR？</p>
<p>AsyncTask的底层是怎么实现的</p>
<p>消费者与生产者模型</p>
<p>Activity的生命周期，从Activity A启动Activity B生命周期的变化</p>
<p>touch事件的传递机制</p>
<p>TCP与UDP的区别</p>
<p>常用的数据结构</p>
<p>算法：序列化和反序列化二叉搜索树</p>
<p>作者：田鸡不是鸡</p>
<p>对Java面向对象的理解（重点讲三大特性，哪些可以继承下来）<br>你知道Java哪些数据类型呢？<br>接口和抽象类的区别<br>进程间通信的方式<br>线程池参数<br>HashMap的扩容机制，它线程安全吗？<br>ArrayList和LinkedList区别<br>String、StringBuffer、StringBuidler的区别<br>讲讲activity的生命周期<br>Android框架有了解过吗？binder原理<br>安卓是如何进行数据存储的？<br>TCP三次握手，为什么三次？<br>用过哪些设计模式吗？单例模式有哪些实现方法</p>
<h1 id="客户端技术成长路线分享"><a href="#客户端技术成长路线分享" class="headerlink" title="客户端技术成长路线分享"></a>客户端技术成长路线分享</h1><ul>
<li><strong>计算机网络、操作系统、计算机组成原理、数据结构与算法、数据库原理等计算机基础课：</strong>学习这些一方面是为了应付面试，就Android的面试，很多公司爱问http/https，tcp/udp，hashmap，linkedhashmap，用户态/核心态等八股；更重要的是，对Android开发及体系的全面理解，Android应用层建立在linux操作系统上，所以才有Java和C++分别去写应用层代码和系统层代码，而系统层代码会做一些系统调用，这就需要了解一些操作系统。      </li>
<li><strong>Java：</strong>由于笔者之前学习的是Java后端开发，所以Java基础还比较扎实，语言的学习一定是需要不断地实践思考的。在学习Java的同时也需要去搞懂Java中的多线程（包括各种锁和线程管理）、JVM、集合类实现原理，这部分一定需要去慢慢啃原理甚至源码。      </li>
<li><strong>kotlin：</strong>kt目前作为Google主推的Android开发语言，以其空安全、简便性和各种语法糖会更进一步受到Android开发工程师的喜爱，同时支持Java和kt相互调用。同样地，kt的学习也需要不断地去实践，写一些小demo，更重要的是去识别kt与Java之间的区别，以及kt所拥有的新特性（协程、扩展函数、更优秀的函数式编程、一些常用的关键字如by lazy、lateinit、apply、run、with、object等等）。总之，kt学习过程中一定是需要和Java去对比着来的。      </li>
<li><strong>Android基础 推荐Android第一行代码（尽量看最新的版本，用kt写的）</strong></li>
</ul>
<ol>
<li>​    Android四大组件（Activity、Service、ContentProvider、BroadcastReceiver）的使用；      </li>
<li>​    Activity的生命周期，Activity显式跳转和隐式跳转，各种操作的生命周期变化（包括横竖屏切换、Activity间跳转、Activity非正常销毁生命周期变化），Activity的LaunchMode；      </li>
<li>Android动画；</li>
<li>​    Service两种启动方式及生命周期；      </li>
<li>​    网络编程、SqlLite、SharedPreferences；      </li>
<li>​    Fragment管理，与Activity之间的通信；      </li>
<li>​    Intent、Bundle、Parcelable使用；      </li>
<li>​    常见的控件和布局使用，ContraintLayout；      </li>
<li>​    常见的UI框架如ViewPager、ViewPager2、ListView、GridView、RecyclerView的使用，ListView和RecyclerView的缓存机制，RecyclerView的LayoutManager自定义布局，ViewPager2原理。     </li>
</ol>
<ul>
<li><strong>Android进阶 推荐Android系统源代码情景分析</strong></li>
</ul>
<p>​    笔者认为学习Android Framework非常有必要，一方面对于整个Android体系的把握，另一方面做Android Framework可以往智能车载系统开发等方向走。笔者花了1-2个月的时间看了Android系统源代码情景分析，看完以后对我触动很大，也理解了Android体系工作过程，所以笔者还是非常推荐读者有时间的话都学习一下Framework的知识，只要你肯专研，其实也并没有想象中那么难。   </p>
<ol>
<li><p>c++学习，学c++一方面是为了看懂系统源码，特别是binder基本上是用c++写的；另一方面NDK相关开发用的就是c++；</p>
</li>
<li><p>​      Android Framework，包括handler（Android线程间通信、Android应用层心脏）、Binder（Android 进程间通信、Android系统层心脏）、AMS、PMS、WMS工作原理；          </p>
</li>
<li><p>​      Android 启动流程（包括系统开机流程、应用启动），Launcher工作原理，zygote工作原理；</p>
</li>
<li><p>​      自定义View，View绘制（ViewRootImpl中三大绘制整个过程），滑动冲突；          </p>
</li>
<li><p>​      Hook，动态代理；          </p>
</li>
<li><p>​      AIDL使用和原理（其实本质上还是用的Binder），Messager使用和原理；          </p>
</li>
<li><p>​      Android启动优化，Android应用整个启动流程和可以优化的点（1、业务，2、线程处理耗时任务，3、线程池管理，4、界面渲染，5、避免启动卡顿，6、闪屏），还有一些启动优化常用的工具如systrace；          </p>
</li>
<li><p>​      Android卡顿优化，卡顿产生的原因，卡顿的检测；          </p>
</li>
<li><p>​      Android内存优化，内存泄漏产生的原因和检测，内存溢出产生的原因和检测，LeakCanary原理；          </p>
</li>
<li><p>​      构建原理（gradle、groovy），Dalvik虚拟机和dex文件；          </p>
</li>
<li><p>​      ANR原理和解决手段；          </p>
</li>
<li><p>​      开源库使用和源码，okhttp、retrofit、livedata、databinding、rxjava、glide等，glide缓存机制和内存优化；          </p>
</li>
<li><p>​      MVC、MVP、MVVM使用；          </p>
</li>
<li><p>​      Android开发架构，组件化、模块化；          </p>
</li>
<li><p>​      黑科技：插件化、热部署（笔者也还在学）；</p>
</li>
</ol>
<p>作者：_Hawper</p>
<h1 id="欧科云链安卓工程师"><a href="#欧科云链安卓工程师" class="headerlink" title="欧科云链安卓工程师"></a>欧科云链安卓工程师</h1><h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><p>项目提问（这里就不说了，大家看自己项目就好，项目尽量不要写得模棱两可）</p>
<p>Java基本的数据类型有哪些？</p>
<p>注解的类型有哪些？</p>
<p>sychronized和lock的区别</p>
<p>Java创建线程的方式</p>
<p>JVM的内存模型</p>
<p>自定义view的流程</p>
<p>HashMap的实现原理，和HashTable区别，线程不安全的原因</p>
<p>Activity生命周期，横竖屏切换的 Activity 生命周期变化？</p>
<p>view事件分发机制</p>
<p>https请求到响应的过程（加密过程）</p>
<p>TCP拥塞控制</p>
<p>单例模式的实现方法，如何破坏一个单例模式？</p>
<h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><p>项目介绍</p>
<p>有用过kotlin，那问这块没问题吧？</p>
<p>Kotlin有没有static 关键字？那创建静态函数怎么办</p>
<p>构造方法有哪些</p>
<p>协程Flow有哪些应用场景？</p>
<p>（问了四五道就没问了，内心OS：要不还是问Java吧）</p>
<p>Handler原理</p>
<p>looper死循环会不会卡死？为什么？</p>
<p>内存泄漏的情况有哪些，讲一种检测方法</p>
<p>okhttp拦截器</p>
<p>Retrofit的调用过程（我给你点提示，你自己思考一下）</p>
<p>mvp是什么？</p>
<p>TCP三次握手，如何保证安全传输的</p>
<p>现在Android岗位真的不多了，各位面试Android的朋友可以抱个团，共享下最新情况，我可以给大家分享一份自己整理的Android面试手册，需要的话可以给到大家，也可以看我专栏哦，都是新鲜面经。</p>
<p>作者：汉尼拔哈哈</p>
<h1 id="海信"><a href="#海信" class="headerlink" title="海信"></a>海信</h1><p>项目介绍（听你讲完项目觉得你Android这块是没啥问题的，还是问了下Android架构和性能优化这块，让我具体谈谈）<br>对Java面向对象思想的理解<br>讲一下Java的基本数据类型（没答全，开头棒喝）<br>深拷贝和浅拷贝分别是什么？<br>Java 容器都有哪些？List、Set和Map的区别知道吗？<br>String 类可以继承吗？为什么？它和StringBuilder、StringBuffer有什么区别？<br>线程的 sleep() 方法和 yield() 方法有什么区别呢？<br>线程不安全的情形有哪些？<br>为什么要使用线程池？<br>GC Root有哪些呢?那你就讲Java垃圾收集机制就行<br>MVC架构是怎样的？<br>https和http的区别，它是如何来保证安全性的？<br>TCP三次握手的步骤？两次握手为什么不行？</p>
<p>作者：汉尼拔哈哈</p>
<h1 id="荣耀Android技术面面经"><a href="#荣耀Android技术面面经" class="headerlink" title="荣耀Android技术面面经"></a>荣耀Android技术面面经</h1><p>荣耀是一个很值得去的地方，我9月初投的简历，国庆上来陆续进行了面试，荣耀是有一轮技术面、一轮综合面以及一轮HR面，我也都感受了一遍，这里重点给大家讲一下技术面的内容，希望能够帮到大家。</p>
<h2 id="技术面丨50min"><a href="#技术面丨50min" class="headerlink" title="技术面丨50min"></a>技术面丨50min</h2><p>自我介绍</p>
<p>项目中遇到的难题 使用了什么技术来解决</p>
<p>Java垃圾回收</p>
<p>HashMap底层原理</p>
<p>哈希表解决冲突的方法</p>
<p>什么是多态，怎么去实现呢</p>
<p>接口和抽象类的区别，它们各自的使用场景呢</p>
<p>安卓的四大组件</p>
<p>Activity回调的方法</p>
<p>你都用过哪些设计模式？</p>
<p>实现多线程的几种方式</p>
<p>用过哪些数据结构</p>
<p>Java面向对象</p>
<p>synchronized</p>
<p>equals和hashCode方法</p>
<p>广播的两种启动方式</p>
<p>三次握手</p>
<p>kotlin有了解过吗（聊了一会）</p>
<p>作者：牛牛！向前冲！<br>链接：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/?type=11023_0">https://www.nowcoder.com/?type=11023_0</a><br>来源：牛客网</p>
<h1 id="小米安卓面经-已offer"><a href="#小米安卓面经-已offer" class="headerlink" title="小米安卓面经(已offer)"></a>小米安卓面经(已offer)</h1><h3 id="9-5-一面-25min"><a href="#9-5-一面-25min" class="headerlink" title="9.5 一面 25min"></a>9.5 一面 25min</h3><ol>
<li>​    <strong>自我介绍</strong>   </li>
<li>​    <strong>写代码带来的快乐</strong>   </li>
<li>​    <strong>设计模式</strong>   </li>
<li>​    <strong>单例模式的好处</strong>   </li>
<li>​    <strong>线程安全</strong>   </li>
<li>​    <strong>形成死锁的条件,破解死锁的方法</strong>   </li>
<li>​    <strong>gc是什么</strong>   </li>
<li>​    <strong>垃圾标记方法(拓展了很多)</strong>   </li>
<li>​    <strong>强引用,弱引用</strong>   </li>
<li>​    <strong>对操作系统的了解</strong>   </li>
</ol>
<h3 id="9-9-二面-40min"><a href="#9-9-二面-40min" class="headerlink" title="9.9 二面  40min"></a>9.9 二面  40min</h3><ol>
<li>​    <strong>自我介绍</strong>   </li>
<li>​    <strong>多线程</strong>   </li>
<li>​    <strong>线程池</strong>   </li>
<li>​    <strong>并行与并发</strong>   </li>
<li>​    <strong>死锁</strong>   </li>
<li>​    <strong>arraylist与linkedlist</strong>   </li>
<li>​    <strong>hashmap</strong>   </li>
<li>​    <strong>hashtable与concurrenthashmap</strong>   </li>
<li>​    <strong>手撕快速排序</strong>   </li>
<li>​    <strong>手撕单例模式</strong>   </li>
<li>​    <strong>内存泄露</strong>   </li>
<li>​    <strong>项目中碰到的异常</strong></li>
</ol>
<p>作者：rsthh<br>链接：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/?type=11023_0">https://www.nowcoder.com/?type=11023_0</a><br>来源：牛客网</p>
<h1 id="蚂蚁金服Android客户端一面面经"><a href="#蚂蚁金服Android客户端一面面经" class="headerlink" title="蚂蚁金服Android客户端一面面经"></a>蚂蚁金服Android客户端一面面经</h1><h2 id="一面-40min"><a href="#一面-40min" class="headerlink" title="一面|40min"></a>一面|40min</h2><p>java四种引用<br>JVM内存区域<br>乐观锁和悲观锁<br>gradle打包流程<br>线程和进程的区别<br>线程池的参数<br>多线程同步问题，怎么保证线程安全？<br>Android签名流程<br>Android的四大组件有哪些？活动的生命周期<br>http的缓存机制<br>tcp滑动窗口，三次握手<br>hashmap的底层结构<br>常用的设计模式，重点问了单例模式的实现<br>对AMS的了解<br>讲一个红黑树和一个排序算法的时间复杂度问题的分析思路</p>
<h2 id="二面-35min"><a href="#二面-35min" class="headerlink" title="二面|35min"></a>二面|35min</h2><p>实习项目和小应用开发过程（扒裤子）<br>HTTPS是怎么保证安全的<br>DNS协议<br>tap和udp的区别<br>对称加密<br>Android签名机制<br>okhttp如何处理网络缓存的</p>
<p>作者：汉尼拔哈哈</p>
<h1 id="OPPO安卓岗一、二面的面经"><a href="#OPPO安卓岗一、二面的面经" class="headerlink" title="OPPO安卓岗一、二面的面经"></a>OPPO安卓岗一、二面的面经</h1><h2 id="一面-35min"><a href="#一面-35min" class="headerlink" title="一面|35min"></a>一面|35min</h2><p>数组和链表的区别</p>
<p>hashmap原理</p>
<p>java中的异常处理与分类</p>
<p>线程池的参数</p>
<p>java垃圾回收机制</p>
<p>GC ROOT包括什么</p>
<p>dns协议</p>
<p>thread</p>
<p>fragment的生命周期</p>
<p>handler的作用</p>
<p>hashmap相关</p>
<p>TCP传输层</p>
<p>https怎么保证他的安全性</p>
<p>http与https的区别</p>
<p>单例模式</p>
<h2 id="二面-45min-1"><a href="#二面-45min-1" class="headerlink" title="二面|45min"></a>二面|45min</h2><p>view绘制流程</p>
<p>双亲委派机制</p>
<p>内存泄漏的原因及方案</p>
<p>try catch finally 中遇到的return问题</p>
<p>讲一下排序算法的思路</p>
<p>作者：统一鲜橙多</p>
<h1 id="商米-安卓开发-一面面经"><a href="#商米-安卓开发-一面面经" class="headerlink" title="商米-安卓开发-一面面经"></a>商米-安卓开发-一面面经</h1><p><strong>技术问题包括数据结构、算法、计算机网络和安卓的知识</strong></p>
<p><strong>数据结构：</strong></p>
<p>数据结构的分类</p>
<p>数组和链表最大的区别</p>
<p>5个元素没有排序，数组和链表查找哪个更快一些？</p>
<p>如果排序了，哪个会快一些？为什么？</p>
<p>hashmap具体是怎么实现的？</p>
<p>hash冲突如何解决？</p>
<p>栈和队列的区别</p>
<p>二叉查找树的概念</p>
<p>树退化成链表如何解决？</p>
<p>B树以及B树可以解决什么问题？</p>
<p>图的遍历以及具体代码如何实现？（迭代）</p>
<p><strong>算法：</strong></p>
<p>时间复杂度和空间复杂度的概念</p>
<p>常见的排序算法以及时间复杂度</p>
<p>链表的反转怎么实现？</p>
<p><strong>安卓：</strong></p>
<p>安卓的四大组件</p>
<p>activity的声明周期</p>
<p>activity的启动模式</p>
<p>事件的触发流程</p>
<p><strong>计算机网络：</strong></p>
<p>5层结构以及相应的作用</p>
<p>传输层的主要协议有哪些</p>
<p>作者：鲸鱼sama<br>链接：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/?type=11023_0">https://www.nowcoder.com/?type=11023_0</a><br>来源：牛客网</p>
<h1 id="商米安卓校招面经分享"><a href="#商米安卓校招面经分享" class="headerlink" title="商米安卓校招面经分享"></a>商米安卓校招面经分享</h1><p>先说结果：技术面挂了，但是感觉收获还是蛮大的。</p>
<p>简历过了，先是笔试关，一共8道题，全是lc上刷到过的原题，毫不犹豫的过了。 </p>
<p>面试一开始，面试官根据简历上的项目经历问问题。</p>
<p>然后问Java语言基础，问到了泛型，有没有自己定义过泛型？（没有）</p>
<p>Java中父类对象能否强制转换为子类对象？（印象中这题并没有刷到过，就回答的没有，面试官再追问 那有没有一种可能，在某种特殊情况下父类对象能强制转换为子类对象？）此时我心里已经发凉了，他这么追问的意思是，肯定能强制转换，只是我不知道，这也不是题库里能见到的题。这题过了。</p>
<p>然后是问c语言基础，宏定义</p>
<p>再就是数据结构和算法，堆排序的实现过程，快速排序的实现过程（快速排序的实现过程用语言给他描述了，然后他再追问细节，第二轮排序的时候，数组是不是要移动？）人麻了，稀里糊涂不知道讲的什么，这题过。</p>
<p>再然后是操作系统和计算机网络。Java多线程。计算机网络的7层模型。线程和进程的区别。线程和函数的关系。创建线程需要什么参数？哪些参数是必要的？如何用函数创建一个线程？</p>
<p>然后，大学成绩怎么样？（绩点3.3）问高数，x立方的导数是多少？（3x方，很简单）如何用微积分计算圆锥体的体积？（具体过程不记得了，毕竟三年没学高数了，答的用极限的思想，把圆锥体抽象成无限个圆柱体，底面积乘高，两层类似f的符号相乘得出圆锥体的体积。）</p>
<p>然后再是概率论，如何计算数学期望？（答，数学期望类似平均值，比如在有10个点的散点图中，数学期望即这10个点的y值相加除以10）</p>
<p>最后是华为经典题，一个桶5L，另一个桶7L，如何得到6L？（答出来了）面试官立马追问，有没有一种数学理论可以给这个问题提供支持来证明，1L，2L，3L，4L，6L是不是都可以得到还是只能得到其中的某几种？（到这里，我是真的麻了，考这种题真的无从准备，面试官是啥问题都能深挖深挖再深挖）（最后一题有知道的同学可以评论区留言）</p>
<p>作者：AlaJackie</p>
<h1 id="2022百度Android面试题汇总-解析思路"><a href="#2022百度Android面试题汇总-解析思路" class="headerlink" title="2022百度Android面试题汇总+解析思路"></a>2022百度Android面试题汇总+解析思路</h1><p>1、 Activity的启动流程</p>
<p>——从Launcher到AMS——从AMS到ApplicationThread——从ApplicationThread到Activity</p>
<p>2、 handler机制的原理</p>
<p>3、 跨进程通信的几种方式</p>
<p>4、 wait 和 sleep 的区别</p>
<p>5、 String,StringBuffer,StringBuilder 的区别</p>
<p>6、 View 和 SurfaceView 的区别</p>
<p>7、 View 的绘制原理</p>
<p>8、 简述 JNI</p>
<p>9、 简述 TCP，UDP，Socket</p>
<p>10、 进程和线程的区别</p>
<p>11、 内存泄露如何查看和解决</p>
<p>12、 View 的分发机制</p>
<p>13、 RecyclerView 和 ListView 的区别</p>
<p>14、 谈 MVC ，MVP，MVVM</p>
<p>15、 Android 性能优化</p>
<p>16、 SharedPreference 跨进程使用会怎么样？如何保证跨进程 使用安全？</p>
<p>17、 activity，fragment 传值问题</p>
<p>18、 activity 与 fragment 区别</p>
<p>19、 Fragment 中 add 与 replace 的区别？</p>
<p>20、 说下 Activity 的四种启动模式、应用场景 ？</p>
<p>——standard标准模式；singleTop 栈顶复用模式；singleTask 栈内复用模式；singleInstance 单实例模式</p>
<p>21、 横竖屏切换的 Activity 生命周期变化？</p>
<p>22、 Android 线程间通信有哪几种方式</p>
<p>——1. 共享内存（变量）；2.文件，数据库；3.Handler；4.Java 里的 wait()，notify()，notifyAll()</p>
<p>23、自定义view的基本流程</p>
<p>24、 tcp和udp区别</p>
<p>25、 微信视频是用了tcp还是udp</p>
<p>26、 udp的优点</p>
<p>27、 http基于tcp还是udp</p>
<p>28、 为什么很多用https而不用http</p>
<p>29、 加密算法有了解吗</p>
<p>30、 什么是对称加密和非对称加密</p>
<p>31、 https的加密是对称的还是非对称的</p>
<p>32、 service在项目中怎么使用？</p>
<p>33、 怎么在子线程中更新UI？</p>
<h1 id="同花顺-安卓-09-23-二面-50min"><a href="#同花顺-安卓-09-23-二面-50min" class="headerlink" title="同花顺 安卓 09.23 二面 50min"></a>同花顺 安卓 09.23 二面 50min</h1><ol>
<li>   自我介绍    </li>
<li>   面向对象和面向过程的区别    </li>
<li>   面向切面编程你知道么，和面向对象的区别和细节    </li>
<li>   有无面向切面编程的案例    </li>
<li>   开闭原则的细节    </li>
<li>   设计模式的其他设计原则    </li>
<li>   synchronized了解么    </li>
<li>   ThreadLocal了解么，他有什么问题    </li>
<li>   快排的思想    </li>
<li>   快排解决topk问题（我哭死啊，我没有想到当前的会使用快排来进行解决topk，我之前都是使用堆排序）    </li>
<li>   快排和堆排来进行解决topk问题    </li>
<li>   自己手上的意向offer有那些    </li>
<li>   地点会考虑哪一些么    </li>
<li>   不知道你最近看过一些B站的虚拟人物么，你觉得当前的技术方面是怎么来进行实现的    </li>
<li>   看过那些书籍    </li>
<li>   假如说你来同花顺，你对团队怎么来看    </li>
<li>   你有那些优势和缺点    </li>
<li>   假如说同花顺给你一笔资金，你会怎么考虑来进行创业    </li>
<li>   反问：1：部门的一些情况；2：使用到的技术栈（安卓）</li>
</ol>
<p>作者：叶子与花(o-ωｑ)).oO困</p>
<h1 id="传音-Android开发-一面-二面"><a href="#传音-Android开发-一面-二面" class="headerlink" title="传音 Android开发 一面+二面"></a>传音 Android开发 一面+二面</h1><p>  09/13 一面 </p>
<p>  volatile 在Java和C++中的区别 </p>
<p>  synchronized 原理 锁的升级 </p>
<p>  JVM内存模型 </p>
<p>  NoSQL与关系型数据库区别 </p>
<p>  垃圾回收算法 </p>
<p>  内存泄露检测方法 </p>
<p>  JVM调优 </p>
<p>  09/19 二面 </p>
<p>  设计模式作用 </p>
<p>  动态代理与静态代理 </p>
<p>  线程与进程的使用场景 </p>
<p>  线程安全与不安全的例子 </p>
<p>  TCP三次握手 </p>
<p>  HTTP3 </p>
<p>  Java内存泄露场景 </p>
<p>  OOM能捕获吗 </p>
<p>  运行时异常与编译时异常 </p>
<p>  安卓相关知识</p>
<p>作者：牛客100861101<br>链接：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/?type=11023_0">https://www.nowcoder.com/?type=11023_0</a><br>来源：牛客网</p>
<h1 id="滴滴安卓客户端一二面面经"><a href="#滴滴安卓客户端一二面面经" class="headerlink" title="滴滴安卓客户端一二面面经"></a>滴滴安卓客户端一二面面经</h1><h3 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h3><p>（40min）</p>
<p><strong>算法:</strong></p>
<ol>
<li>反转链表 </li>
<li>合并两个排序的链表 </li>
</ol>
<ul>
<li>自我介绍 </li>
<li>安卓学习路线 </li>
<li>http和https的区别 </li>
<li>TCP与UDP区别 </li>
<li>TCP流量控制 </li>
<li>Cookie与Session的作用与原理 </li>
<li>进程和线程的区别 </li>
<li>进程间通信方式 </li>
<li>多线程里的关键字 </li>
<li>synchronized应用场景 </li>
<li>wait() 和 sleep() 的区别 </li>
<li>Java内存回收机制 </li>
<li>垃圾收集器有哪些 </li>
</ul>
<h3 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h3><p>（30min）</p>
<p><strong>算法:</strong></p>
<ol>
<li>合并两个有序数组 </li>
<li>合并区间 </li>
</ol>
<ul>
<li>自我介绍 </li>
<li>选择这个岗位的原因 </li>
<li>项目盘点 </li>
<li>当系统内存不足时，会存在单个 Activity 直接被系统回收的情况吗？ </li>
<li>安卓中的消息机制是什么样的 </li>
<li>分发给Handler的消息是怎么处理的 </li>
<li>消息机制中，如何更新UI </li>
<li>用过哪些安卓相关的开源框架</li>
</ul>
<p>作者：统一鲜橙多<br>链接：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/?type=11023_0">https://www.nowcoder.com/?type=11023_0</a><br>来源：牛客网</p>
<p>1.介绍RPC，RPC和其他协议HTTP有什么区别，然后扣项目细节。。。（录像都不敢看，不想写了）</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-01-06T09:37:17.000Z" title="1/6/2020, 5:37:17 PM">2020-01-06</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-05-06T11:24:51.250Z" title="5/6/2022, 7:24:51 PM">2022-05-06</time></span><span class="level-item"><a class="link-muted" href="/categories/JAVA/">JAVA</a></span><span class="level-item">10 minutes read (About 1492 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/01/06/JVM-HEAP/">JVM_HEAP</a></p><div class="content"><h3 id="堆内存细分"><a href="#堆内存细分" class="headerlink" title="堆内存细分"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC5%E7%AB%A0-%E5%A0%86?id=%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%86%E5%88%86">堆内存细分</a></h3><p>现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为：</p>
<ol>
<li>Java7 及之前堆内存逻辑上分为三部分：新生区+养老区+永久区<ul>
<li>Young Generation Space    新生区      Young/New<ul>
<li>又被划分为Eden区和Survivor区</li>
</ul>
</li>
<li>Old generation space    养老区           Old/Tenure</li>
<li>Permanent Space   永久区                   Perm</li>
</ul>
</li>
<li>Java 8及之后堆内存逻辑上分为三部分：新生区+养老区+元空间<ul>
<li>Young Generation Space 新生区，又被划分为Eden区和Survivor区</li>
<li>Old generation space 养老区</li>
<li>Meta Space 元空间 Meta</li>
</ul>
</li>
</ol>
<p>约定：新生区 &lt;–&gt; 新生代 &lt;–&gt; 年轻代 、 养老区 &lt;–&gt; 老年区 &lt;–&gt; 老年代、 永久区 &lt;–&gt; 永久代</p>
<img src="/2020/01/06/JVM-HEAP/heap0003.png">

<ol>
<li>堆空间内部结构，JDK1.8之前从永久代 替换成 元空间</li>
</ol>
<p><img src="/2020/01/06/JVM-HEAP/java80004.png"></p>
<h2 id="堆是分配对象的唯一选择么？"><a href="#堆是分配对象的唯一选择么？" class="headerlink" title="堆是分配对象的唯一选择么？"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC5%E7%AB%A0-%E5%A0%86?id=%E5%A0%86%E6%98%AF%E5%88%86%E9%85%8D%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%94%AF%E4%B8%80%E9%80%89%E6%8B%A9%E4%B9%88%EF%BC%9F">堆是分配对象的唯一选择么？</a></h2><p><strong>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：</strong></p>
<ol>
<li>随着JIT编译期的发展与<strong>逃逸分析技术</strong>逐渐成熟，<strong>栈上分配、标量替换</strong>优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</li>
<li>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是<strong>如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配</strong>。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</li>
<li>此外，前面提到的基于OpenJDK深度定制的TaoBao VM，其中创新的GCIH（GC invisible  heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</li>
</ol>
<h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC5%E7%AB%A0-%E5%A0%86?id=%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90">逃逸分析</a></h3><ol>
<li>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</li>
<li>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。</li>
<li>通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</li>
<li>逃逸分析的基本行为就是分析对象动态作用域：<ul>
<li><strong>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</strong></li>
<li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li>
</ul>
</li>
</ol>
<p><strong>逃逸分析举例</strong></p>
<p>1、没有发生逃逸的对象，则可以分配到栈（无线程安全问题）上，随着方法执行的结束，栈空间就被移除（也就无需GC）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">my_method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    V v = <span class="keyword">new</span> V();</span><br><span class="line">    <span class="comment">// use v</span></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    v = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、下面代码中的 StringBuffer sb 发生了逃逸，不能在栈上分配</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title">createStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、如果想要StringBuffer sb不发生逃逸，可以这样写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逃逸分析</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  如何快速的判断是否发生了逃逸分析，大家就看new的对象实体是否有可能在方法外被调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EscapeAnalysis</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> EscapeAnalysis obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    方法返回EscapeAnalysis对象，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EscapeAnalysis <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj == <span class="keyword">null</span>? <span class="keyword">new</span> EscapeAnalysis() : obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    为成员属性赋值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = <span class="keyword">new</span> EscapeAnalysis();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//思考：如果当前的obj引用声明为static的？仍然会发生逃逸。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对象的作用域仅在当前方法中有效，没有发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useEscapeAnalysis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EscapeAnalysis e = <span class="keyword">new</span> EscapeAnalysis();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    引用成员变量的值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useEscapeAnalysis1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EscapeAnalysis e = getInstance();</span><br><span class="line">        <span class="comment">//getInstance().xxx()同样会发生逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>逃逸分析参数设置</strong></p>
<ol>
<li>在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析</li>
<li>如果使用的是较早的版本，开发人员则可以通过：<ul>
<li>选项“-XX:+DoEscapeAnalysis”显式开启逃逸分析</li>
<li>通过选项“-XX:+PrintEscapeAnalysis”查看逃逸分析的筛选结果</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<p>开发中能使用局部变量的，就不要使用在方法外定义。</p>
<h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC5%E7%AB%A0-%E5%A0%86?id=%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96">代码优化</a></h3><p>使用逃逸分析，编译器可以对代码做如下优化：</p>
<ol>
<li><strong>栈上分配</strong>：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配</li>
<li><strong>同步省略</strong>：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li>
<li><strong>分离对象或标量替换</strong>：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-01-05T13:50:30.000Z" title="1/5/2020, 9:50:30 PM">2020-01-05</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-01-02T03:31:39.093Z" title="1/2/2023, 11:31:39 AM">2023-01-02</time></span><span class="level-item"><a class="link-muted" href="/categories/JAVA/">JAVA</a></span><span class="level-item">4 minutes read (About 573 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/01/05/List/">List</a></p><div class="content"><h4 id="Colletion"><a href="#Colletion" class="headerlink" title="Colletion"></a>Colletion</h4><p>容器继承图</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1683525-e44bb50cb9a67f49.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1008/format/webp"></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/31ed50ab01e3">https://www.jianshu.com/p/31ed50ab01e3</a></p>
<h4 id="Java-List"><a href="#Java-List" class="headerlink" title="Java List"></a>Java List</h4><p>List  &lt;– ArrayList  LinkedList</p>
<h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><ol>
<li><p>```<br>ArrayList<Integer>  arrayList = new ArrayList&lt;&gt;();</Integer></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> 得到一个object数组 &#96;private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA &#x3D; &#123;&#125;;&#96;</span><br><span class="line"></span><br><span class="line">source</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>public ArrayList() {</p>
<pre><code>this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. &#96;&#96;&#96;</span><br><span class="line">   arrayList.add(1);</span><br><span class="line">   arrayList.add(2);</span><br></pre></td></tr></table></figure>

<p> source </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    ensureCapacityInternal(size + 1);  &#x2F;&#x2F; Increments modCount!!</span><br><span class="line">    elementData[size++] &#x3D; e;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">     ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<ul>
<li><p>先看看calculateCapacity</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA &#x3D; &#123;&#125;;</span><br><span class="line">private static final int DEFAULT_CAPACITY &#x3D; 10;</span><br><span class="line"></span><br><span class="line">private static int calculateCapacity(Object[] elementData, int minCapacity) &#123;</span><br><span class="line">    if (elementData &#x3D;&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        return Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    return minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</code> minCapacity==10</p>
</li>
<li><p>ensureExplicitCapacity()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; overflow-conscious code</span><br><span class="line">    if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> private void grow(int minCapacity) &#123;</span><br><span class="line">        &#x2F;&#x2F; overflow-conscious code</span><br><span class="line">        int oldCapacity &#x3D; elementData.length;</span><br><span class="line">        int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">        if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">            newCapacity &#x3D; minCapacity;</span><br><span class="line">        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">            newCapacity &#x3D; hugeCapacity(minCapacity);</span><br><span class="line">        &#x2F;&#x2F; minCapacity is usually close to size, so this is a win:</span><br><span class="line">        elementData &#x3D; Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>添加<code>arrayList.add(1);</code>时，size 为10的数组， elementData[size++] = e; 注意size初始化值==0，程序先 执行elementData[0]=1,然后是size++;</p>
<p>当添加的数是11时，<code>        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</code>开始执行 10 + 1010&gt;&gt;1 = 10+5,申请了5个空间</p>
<p>然后get()可以获取element</p>
</li>
<li><p>源码简写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int size &#x3D;0;</span><br><span class="line">Object[] elementData&#x3D; &#123;&#125;;</span><br><span class="line">Object[] elementArr &#x3D; Arrays.copyOf(elementData, 10);</span><br><span class="line">elementArr[size++] &#x3D; 5;</span><br><span class="line">elementArr[size++] &#x3D; 7;</span><br><span class="line">for ( Object el :elementArr)&#123;</span><br><span class="line">    System.out.print(el+&quot;  &quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(elementArr[0]);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h5><p> 源码功能如图所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void linkLast(E e) &#123;</span><br><span class="line">    final Node&lt;E&gt; l &#x3D; last;</span><br><span class="line">    final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(l, e, null);</span><br><span class="line">    last &#x3D; newNode;</span><br><span class="line">    if (l &#x3D;&#x3D; null)</span><br><span class="line">        first &#x3D; newNode;</span><br><span class="line">    else</span><br><span class="line">        l.next &#x3D; newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            this.item &#x3D; element;</span><br><span class="line">            this.next &#x3D; next;</span><br><span class="line">            this.prev &#x3D; prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/01/05/List/linkedlist.png" alt="linkedlist" style="zoom:50%;">





<h5 id="List-iterator"><a href="#List-iterator" class="headerlink" title="List iterator"></a>List iterator</h5><p>  List<String> crunchifyList = <strong>new</strong> ArrayList<String>();</String></String></p>
<p>​    // add 4 different values to list</p>
<p>​    crunchifyList.add(“Facebook”);</p>
<p>​    crunchifyList.add(“Paypal”);</p>
<p>​    crunchifyList.add(“Google”);</p>
<p>​    crunchifyList.add(“Yahoo”);</p>
<p>​    // Other way to define list is - we will not use this list :)</p>
<p>​    List<String> crunchifyListNew = Arrays.asList(“Facebook”, “Paypal”, “Google”, “Yahoo”);</String></p>
<ul>
<li><p>​      Iterator - Returns an iterator over the elements in this list in proper sequence.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; crunchifyIterator &#x3D; crunchifyList.iterator();</span><br><span class="line">  </span><br><span class="line"> while(crunchifyIterator.hasNext()) &#123;</span><br><span class="line">  </span><br><span class="line">   System.out.println(crunchifyIterator.next());</span><br><span class="line">  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li><p> // ListIterator - traverse a list of elements in either forward or backward order</p>
</li>
</ul>
<p>  ​    // An iterator for lists that allows the programmer to traverse the list in either direction, modify the list during iteration,</p>
<p>  ​    // and obtain the iterator’s current position in the list.</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ListIterator&lt;String&gt; crunchifyListIterator &#x3D; crunchifyList.listIterator();</span><br><span class="line">      while (crunchifyListIterator.hasNext()) &#123;</span><br><span class="line">          System.out.println(crunchifyListIterator.next());</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Iterable.forEach() util: Returns a sequential Stream with this collection as its source</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">crunchifyList.forEach((temp) -&gt; &#123;</span><br><span class="line">  </span><br><span class="line">  System.out.println(temp);</span><br><span class="line">  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p> collection Stream.forEach() util: Returns a sequential Stream with this collection as its source</p>
</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crunchifyList.stream().forEach((crunchifyTemp) -&gt; System.out.println(crunchifyTemp));</span><br></pre></td></tr></table></figure>

<h4 id="kotlin-List"><a href="#kotlin-List" class="headerlink" title="kotlin List"></a>kotlin List</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var mPatientList &#x3D; patientList.filter &#123; it.patientCode &#x3D;&#x3D; patientCode &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">return mQnList?.let &#123; it -&gt;</span><br><span class="line">    it.filter &#123; it.type &#x3D;&#x3D; type &#125;.map &#123; it.value &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="sequence"><a href="#sequence" class="headerlink" title="sequence"></a>sequence</h4><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/38258597">https://zhuanlan.zhihu.com/p/38258597</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7022429745874731045">https://juejin.cn/post/7022429745874731045</a></p>
<p><a target="_blank" rel="noopener" href="https://winterbe.com/posts/2018/07/23/kotlin-sequence-tutorial/">https://winterbe.com/posts/2018/07/23/kotlin-sequence-tutorial/</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/38258597">https://zhuanlan.zhihu.com/p/38258597</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-01-04T14:27:53.000Z" title="1/4/2020, 10:27:53 PM">2020-01-04</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-08-19T11:11:43.988Z" title="8/19/2021, 7:11:43 PM">2021-08-19</time></span><span class="level-item"><a class="link-muted" href="/categories/JAVA/">JAVA</a></span><span class="level-item">18 minutes read (About 2706 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/01/04/JVM-METHOD/">JVM_METHOD</a></p><div class="content"><h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><p><img src="https://cdn.jsdelivr.net/gh/youthlql/lql_img_002/JVM/chapter_006/0002.png" alt="方法区"></p>
<ol>
<li>Person类的.class信息存放在 方法区中</li>
<li>person变量存放在Java栈的局部变量表中</li>
<li>Person对象存放在Java堆中</li>
<li>在Person堆中，有个指针指向方法区的person类型数据,表示person对象是方法区中的Person类New出来的.</li>
</ol>
<p><strong>内存布局总结</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">1001</span>;</span><br><span class="line">    String name;</span><br><span class="line">    Account acct;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        name = <span class="string">&quot;匿名客户&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        acct = <span class="keyword">new</span> Account();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Customer cust = <span class="keyword">new</span> Customer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图解内存布局</p>
<p><img src="/2020/01/04/JVM-METHOD/0003.png"></p>
<h4 id="原子性-Atomicity"><a href="#原子性-Atomicity" class="headerlink" title="原子性(Atomicity)"></a>原子性(Atomicity)</h4><p>​        由 J a v a 内 存 模 型 来 直 接 保 证 的 原 子 性 变 量 操 作 包 括 r e a d 、 l o a d 、 a s s i gn 、 u s e 、 s t o r e 和 w r i t e 这 六 个 ， 我们大致可以认为，基本数据类型的访问、读写都是具备原子性的(例外就是long和double的非原子性 协定，读者只要知道这件事情就可以了，无须太过在意这些几乎不会发生的例外情况)。</p>
<p>如果应用场景需要一个更大范围的原子性保证(经常会遇到)，Java内存模型还提供了lock和 unlock操作来满足这种需求，尽管虚拟机未把lock和unlock操作直接开放给用户使用，但是却提供了更 高 层 次 的 字 节 码 指 令 m o n i t o r e n t e r 和 m o n i t o r e xi t 来 隐 式 地 使 用 这 两 个 操 作 。 这 两 个 字 节 码 指 令 反 映 到 J a v a 代码中就是同步块——synchronized关键字，因此在synchronized块之间的操作也具备原子性。</p>
<h5 id="long-和-double-的原子性"><a href="#long-和-double-的原子性" class="headerlink" title="long 和 double 的原子性"></a><strong>long 和 double 的原子性</strong></h5><p>在前面，我们讲述了 long 和 double 和其他的基本类型不太一样，好像不具备原子性，这是什么原因造成的呢？</p>
<p>​    long 和 double 的值需要占用 64 位的内存空间，而对于 64 位值的写入，可以分为两个 32 位的操作来进行。</p>
<p>这样一来，本来是一个整体的赋值操作，就可能被拆分为低 32 位和高 32 位的两个操作。如果在这两个操作之间发生了其他线程对这个值的读操作，就可能会读到一个错误、不完整的值。        </p>
<h4 id="可-见-性-Vi-s-i-b-i-l-i-t-y"><a href="#可-见-性-Vi-s-i-b-i-l-i-t-y" class="headerlink" title="可 见 性 ( Vi s i b i l i t y )"></a>可 见 性 ( Vi s i b i l i t y )</h4><p>可见性就是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。上文在讲解 volat ile变量的时候我们已详细讨论过这一点。Java内存模型是通过在变量修改后将新值同步回主内 存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是 普通变量还是volat ile变量都是如此。普通变量与volat ile变量的区别是，volat ile的特殊规则保证了<u>新值 能立即同步到主内存</u>，以及每次使用前立即从主内存刷新。因此我们可以说volat ile保证了多线程操作 时变量的可见性，而普通变量则不能保证这一点。</p>
<p>能立即同步到主内存 ？？ 感觉也有问题</p>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：     演示可见性带来的问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VisibilityProblem</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">30</span>;</span><br><span class="line">        b = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;b=&quot;</span> + b + <span class="string">&quot;;a=&quot;</span> + a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            VisibilityProblem problem = <span class="keyword">new</span> VisibilityProblem();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    problem.change();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    problem.print();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会出现 <code>b = 30;a = 30 </code>          <code> b = 20;a = 10</code>      <code> b = 20;a = 30</code> </p>
<p>还会有一种情况 <code>b = 30;a = 10</code>, 这种情况就会有可见性问题,<strong>a 的值已经被第 1 个线程修改了，但是其他线程却看不到</strong>，由于 a 的最新值却没能及时同步过来，所以才会打印出 a 的旧值。</p>
<h5 id="主内存和工作内存的关系"><a href="#主内存和工作内存的关系" class="headerlink" title="主内存和工作内存的关系"></a>主内存和工作内存的关系</h5><p>CPU 有多级缓存，导致读的数据过期,由于 CPU 的处理速度很快，相比之下，内存的速度就显得很慢，所以为了提高 CPU 的整体运行效率，减少空闲时间，在 CPU 和内存之间会有 cache 层，也就是缓存层的存在。虽然缓存的容量比内存小，但是缓存的速度却比内存的速度要快得多，其中 L1 缓存的速度仅次于寄存器的速度</p>
<p><img src="/2020/01/04/JVM-METHOD/Cgq2xl54fTKALhevAAB_l3axT_o532.png"></p>
<p>越靠近核心，其容量就越小，但是速度也越快.</p>
<h6 id="线程可见性问题的实质"><a href="#线程可见性问题的实质" class="headerlink" title="线程可见性问题的实质"></a>线程可见性问题的实质</h6><p>线程间对于共享变量的可见性问题，并不是直接由多核引起的，而是由我们刚才讲到的这些 L3 缓存、L2 缓存、L1 缓存，也就是<strong>多级缓存</strong>引起的：每个核心在获取数据时，都会将数据从内存一层层往上读取，同样，后续对于数据的修改也是先写入到自己的 L1 缓存中，然后等待时机再逐层往下同步，直到最终刷回内存。</p>
<p>假设 core 1 修改了变量 a 的值，并写入到了 core 1 的 L1 缓存里，但是还没来得及继续往下同步，由于 core 1 有它自己的的 L1 缓存，core 4 是无法直接读取 core 1 的 L1 缓存的值的，那么此时对于 core 4 而言，变量 a 的值就不是 core 1 修改后的最新的值，core 4 读取到的值可能是一个<strong>过期</strong>的值，从而引起多线程时可见性问题的发生。</p>
<h6 id="什么是主内存和工作内存"><a href="#什么是主内存和工作内存" class="headerlink" title="什么是主内存和工作内存"></a>什么是主内存和工作内存</h6><p>Java 作为高级语言，屏蔽了 L1 缓存、L2 缓存、L3 缓存(可以看作 工作内存)，也就是多层缓存的这些底层细节，用 JMM 定义了一套读写数据的规范。我们不再需要关心 L1 缓存、L2 缓存、L3 缓存等多层缓存的问题，我们只需要关心 JMM 抽象出来的主内存和工作内存的概念。</p>
<img src="https://s0.lgstatic.com/i/image3/M01/00/EF/Ciqah154fUGAS19LAAGap07f1AU762.png" style="zoom:50%;">



<p>每个线程只能够直接接触到工作内存，无法直接操作主内存，而工作内存中所保存的正是主内存的共享变量的副本，主内存和工作内存之间的通信是由 JMM 控制的。</p>
<p>JMM 有以下规定：</p>
<p>（1）所有的变量都存储在主内存中，同时每个线程拥有自己独立的工作内存，而工作内存中的变量的内容是主内存中该变量的拷贝；</p>
<p>（2）线程不能直接读 / 写主内存中的变量，但可以操作自己工作内存中的变量，然后再同步到主内存中，这样，其他线程就可以看到本次修改；</p>
<p>（3） 主内存是由多个线程所共享的，但线程间不共享各自的工作内存，如果线程间需要通信，则必须借助主内存中转来完成。</p>
<p><a target="_blank" rel="noopener" href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=16#/detail/pc?id=298">https://kaiwu.lagou.com/course/courseInfo.htm?courseId=16#/detail/pc?id=298</a></p>
<h4 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h4><p>假设我们写了一个 Java 程序，包含一系列的语句，我们会默认期望这些语句的实际运行顺序和写的代码顺序一致。但实际上，编译器、JVM 或者 CPU 都有可能出于优化等目的，对于实际指令执行的顺序进行调整，这就是<strong>重排序</strong>。</p>
<h5 id="重排序的好处"><a href="#重排序的好处" class="headerlink" title="重排序的好处"></a>重排序的好处</h5><img src="https://s0.lgstatic.com/i/image3/M01/75/87/CgpOIF5vI8yAE1n_AACnC3UQ3xM235.png" style="zoom:50%;">

<p>左侧 3 行 Java 代码，右侧是这 3 行代码可能被转化成的指令。可以看出 a = 100 对应的是 Load a、Set to 100、Store a，意味着从主存中读取 a 的值，然后把值设置为 100，并存储回去，同理， b = 5 对应的是下面三行  Load b、Set to 5、Store b，最后的 a = a + 10，对应的是 Load a、Set to 110、Store a。如果你仔细观察，会发现这里有两次“Load a”和两次“Store a”，说明存在一定的重排序的优化空间。</p>
<img src="https://s0.lgstatic.com/i/image3/M01/75/87/Cgq2xl5vI8yAfRpUAACP4YXZ3sg831.png" style="zoom:50%;">

<p>重排序后， a 的两次操作被放到一起，指令执行情况变为 Load a、Set to 100、Set to 110、 Store a。下面和 b 相关的指令不变，仍对应 Load b、 Set to 5、Store b。</p>
<p>可以看出，重排序后 a 的相关指令发生了变化，节省了一次 Load a 和一次 Store a。重排序通过减少执行指令，从而提高整体的运行速度，这就是重排序带来的优化和好处。</p>
<h5 id="重排序的-3-种情况"><a href="#重排序的-3-种情况" class="headerlink" title="重排序的 3 种情况"></a><strong>重排序的 3 种情况</strong></h5><p>下面我们来看一下重排序的 3 种情况。</p>
<p>（1）编译器优化</p>
<p>编译器（包括 JVM、JIT 编译器等）出于优化的目的，例如当前有了数据 a，把对 a 的操作放到一起效率会更高，避免读取 b 后又返回来重新读取 a 的时间开销，此时在编译的过程中会进行一定程度的重排。不过重排序并不意味着可以任意排序，它需要需要保证重排序后，不改变单线程内的语义，否则如果能任意排序的话，程序早就逻辑混乱了。</p>
<p>（2）CPU 重排序</p>
<p>CPU 同样会有优化行为，这里的优化和编译器优化类似，都是通过乱序执行的技术来提高整体的执行效率。所以即使之前编译器不发生重排，CPU 也可能进行重排，我们在开发中，一定要考虑到重排序带来的后果。</p>
<p>（3） 内存的“重排序”</p>
<p>内存系统内不存在真正的重排序，但是内存会带来看上去和重排序一样的效果，所以这里的“重排序”打了双引号。由于内存有缓存的存在，在 JMM 里表现为主存和本地内存，而主存和本地内存的内容可能不一致，所以这也会导致程序表现出乱序的行为。</p>
<p><a target="_blank" rel="noopener" href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=16#/detail/pc?id=295">https://kaiwu.lagou.com/course/courseInfo.htm?courseId=16#/detail/pc?id=295</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-01-04T03:28:39.000Z" title="1/4/2020, 11:28:39 AM">2020-01-04</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-06-12T03:17:58.660Z" title="6/12/2022, 11:17:58 AM">2022-06-12</time></span><span class="level-item"><a class="link-muted" href="/categories/JAVA/">JAVA</a></span><span class="level-item">an hour read (About 11451 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/01/04/JVM-STACK/">JVM_STACK</a></p><div class="content"><p>字节码指令运行</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1PJ411n7xZ?p=49">https://www.bilibili.com/video/BV1PJ411n7xZ?p=49</a></p>
<h1 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88?id=%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88">虚拟机栈</a></h1><h3 id="虚拟机栈的出现背景"><a href="#虚拟机栈的出现背景" class="headerlink" title="虚拟机栈的出现背景"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88?id=%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E7%9A%84%E5%87%BA%E7%8E%B0%E8%83%8C%E6%99%AF">虚拟机栈的出现背景</a></h3><ol>
<li>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的【如果设计成基于寄存器的，耦合度高，性能会有所提升，因为可以对具体的CPU架构进行优化，但是跨平台性大大降低】。</li>
<li>优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</li>
</ol>
<h3 id="内存中的栈与堆"><a href="#内存中的栈与堆" class="headerlink" title="内存中的栈与堆"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88?id=%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%A0%88%E4%B8%8E%E5%A0%86">内存中的栈与堆</a></h3><ol>
<li><p>首先栈是运行时的单位，而堆是存储的单位。</p>
</li>
<li><p>即：栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放，放哪里</p>
</li>
</ol>
<h3 id="虚拟机栈基本内容"><a href="#虚拟机栈基本内容" class="headerlink" title="虚拟机栈基本内容"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88?id=%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9">虚拟机栈基本内容</a></h3><ul>
<li>Java虚拟机栈是什么？</li>
</ul>
<p>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），<strong>对应着一次次的Java方法调用</strong>，栈是线程私有的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StackTest test = <span class="keyword">new</span> StackTest();</span><br><span class="line">        test.methodA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        methodB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">40</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/01/04/JVM-STACK/0002.png"></p>
<ul>
<li>虚拟机栈的生命周期</li>
</ul>
<ul>
<li>生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了</li>
</ul>
<ul>
<li><p>虚拟机栈的作用</p>
<ul>
<li>主管Java程序的运行，它保存方法的局部变量（8 种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回。</li>
<li>局部变量，它是相比于成员变量来说的（或属性）</li>
<li>基本数据类型变量 VS 引用类型变量（类、数组、接口）</li>
</ul>
<p>​    </p>
</li>
</ul>
<h3 id="虚拟机栈的特点"><a href="#虚拟机栈的特点" class="headerlink" title="虚拟机栈的特点"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88?id=%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E7%9A%84%E7%89%B9%E7%82%B9">虚拟机栈的特点</a></h3><ul>
<li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。</li>
<li>JVM直接对Java栈的操作只有两个：<ul>
<li>每个方法执行，伴随着<strong>进栈</strong>（入栈、压栈）</li>
<li>执行结束后的<strong>出栈</strong>工作</li>
</ul>
</li>
<li>对于栈来说不存在垃圾回收问题<ul>
<li>栈不需要GC，但是可能存在OOM</li>
</ul>
</li>
</ul>
<p><img src="/2020/01/04/JVM-STACK/0003.png"></p>
<h3 id="虚拟机栈的异常"><a href="#虚拟机栈的异常" class="headerlink" title="虚拟机栈的异常"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88?id=%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E7%9A%84%E5%BC%82%E5%B8%B8">虚拟机栈的异常</a></h3><p><strong>面试题：栈中可能出现的异常？</strong></p>
<ul>
<li>Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。<ul>
<li>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个<strong>StackoverflowError</strong> 异常。</li>
<li>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 <strong>OutofMemoryError</strong> 异常。</li>
</ul>
</li>
</ul>
<h3 id="设置栈内存大小"><a href="#设置栈内存大小" class="headerlink" title="设置栈内存大小"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88?id=%E8%AE%BE%E7%BD%AE%E6%A0%88%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F">设置栈内存大小</a></h3><p>我们可以使用参数 <strong>-Xss</strong> 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。</p>
<blockquote>
<p>Sets the thread stack size (in bytes). Append the letter <code>k</code> or <code>K</code> to indicate KB, <code>m</code> or <code>M</code> to indicate MB, and <code>g</code> or <code>G</code> to indicate GB. The default value depends on the platform:</p>
<ul>
<li>Linux/x64 (64-bit): 1024 KB</li>
<li>macOS (64-bit): 1024 KB</li>
<li>Oracle Solaris/x64 (64-bit): 1024 KB</li>
<li>Windows: The default value depends on virtual memory</li>
</ul>
</blockquote>
<p>The following examples set the thread stack size to 1024 KB in different units:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Xss1m</span><br><span class="line">-Xss1024k</span><br><span class="line">-Xss1048576</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackErrorTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        count++;</span><br><span class="line">        main(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>没设置参数前</strong></p>
<p>部分输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11404</span></span><br><span class="line"><span class="number">11405</span></span><br><span class="line"><span class="number">11406</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.StackOverflowError</span><br><span class="line">    at sun.nio.cs.UTF_8$Encoder.encodeLoop(UTF_8.java:<span class="number">691</span>)</span><br></pre></td></tr></table></figure>

<p>说明栈在11406这个深度溢出了</p>
<p><img src="/2020/01/04/JVM-STACK/0004.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2474</span></span><br><span class="line"><span class="number">2475</span></span><br><span class="line"><span class="number">2476</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.StackOverflowError</span><br><span class="line">    at sun.nio.cs.UTF_8.updatePositions(UTF_8.java:<span class="number">77</span>)</span><br></pre></td></tr></table></figure>

<h2 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88?id=%E6%A0%88%E7%9A%84%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D">栈的存储单位</a></h2><h3 id="栈中存储什么？"><a href="#栈中存储什么？" class="headerlink" title="栈中存储什么？"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88?id=%E6%A0%88%E4%B8%AD%E5%AD%98%E5%82%A8%E4%BB%80%E4%B9%88%EF%BC%9F">栈中存储什么？</a></h3><ol>
<li>每个线程都有自己的栈，栈中的数据都是以<strong>栈帧</strong>（Stack Frame）的格式存在</li>
<li>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</li>
<li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</li>
</ol>
<h3 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88?id=%E6%A0%88%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86">栈运行原理</a></h3><ol>
<li>JVM直接对Java栈的操作只有两个，就是对栈帧的<strong>压栈和出栈</strong>，遵循先进后出（后进先出）原则</li>
<li>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的。这个栈帧被称为<strong>当前栈帧（Current Frame）</strong>，与当前栈帧相对应的方法就是<strong>当前方法（Current Method）</strong>，定义这个方法的类就是<strong>当前类（Current Class）</strong></li>
<li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</li>
<li>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</li>
</ol>
<p><img src="/2020/01/04/JVM-STACK/0005.png"></p>
<ol>
<li><strong>不同线程中所包含的栈帧是不允许存在相互引用的</strong>，即不可能在一个栈帧之中引用另外一个线程的栈帧。</li>
<li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</li>
<li>Java方法有两种返回函数的方式。<ul>
<li>一种是正常的函数返回，使用return指令。</li>
<li>另一种是方法执行中出现未捕获处理的异常，以抛出异常的方式结束。</li>
<li>但不管使用哪种方式，都会导致栈帧被弹出。</li>
</ul>
</li>
</ol>
<h3 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88?id=%E6%A0%88%E5%B8%A7%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84">栈帧的内部结构</a></h3><p>每个栈帧中存储着：</p>
<ul>
<li><p>局部变量表（Local Variables）</p>
</li>
<li><p>操作数栈（Operand Stack）（或表达式栈）</p>
</li>
<li><p>动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）</p>
</li>
<li><p>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</p>
</li>
<li><p>一些附加信息</p>
</li>
</ul>
<p><img src="/2020/01/04/JVM-STACK/0006.png"></p>
<p>并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表 和 操作数栈决定的</p>
<p><img src="/2020/01/04/JVM-STACK/0007.png"></p>
<h2 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88?id=%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8">局部变量表</a></h2><ol>
<li>局部变量表也被称之为局部变量数组或本地变量表</li>
<li><strong>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</strong>，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress返回值类型。</li>
<li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong></li>
<li><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性的<strong>maximum local variables</strong>数据项中。在方法运行期间是不会改变局部变量表的大小的。</li>
<li>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。<ul>
<li>对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。</li>
<li>进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</li>
</ul>
</li>
<li>局部变量表中的变量只在当前方法调用中有效。<ul>
<li>在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。</li>
<li>当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalVariablesTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalVariablesTest test = <span class="keyword">new</span> LocalVariablesTest();</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">        test.test1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//练习：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStatic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LocalVariablesTest test = <span class="keyword">new</span> LocalVariablesTest();</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        <span class="comment">//因为this变量不存在于当前方法的局部变量表中！！</span></span><br><span class="line"><span class="comment">//        System.out.println(this.count);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关于Slot的使用的理解</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LocalVariablesTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        String name1 = <span class="string">&quot;atguigu.com&quot;</span>;</span><br><span class="line">        test2(date, name1);</span><br><span class="line">        System.out.println(date + name1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">(Date dateP, String name2)</span> </span>&#123;</span><br><span class="line">        dateP = <span class="keyword">null</span>;</span><br><span class="line">        name2 = <span class="string">&quot;songhongkang&quot;</span>;</span><br><span class="line">        <span class="keyword">double</span> weight = <span class="number">130.5</span>;<span class="comment">//占据两个slot</span></span><br><span class="line">        <span class="keyword">char</span> gender = <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> dateP + name2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">            b = a + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//变量c使用之前已经销毁的变量b占据的slot的位置</span></span><br><span class="line">        <span class="keyword">int</span> c = a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/01/04/JVM-STACK/0008.png"></p>
<p>看完字节码后，可得结论：所以局部变量表所需的容量大小是在编译期确定下来的。</p>
<h4 id="部分详解"><a href="#部分详解" class="headerlink" title="部分详解"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88?id=%E9%83%A8%E5%88%86%E8%AF%A6%E8%A7%A3">部分详解</a></h4><p>为了更好讲解，我们直接用jclasslib来看字节码，以main方法为例来讲解。一些一目了然的就不讲了</p>
<p>1、0-15  也就是有16行字节码</p>
<p><img src="/2020/01/04/JVM-STACK/0009.png"></p>
<p>2、方法异常信息表</p>
<p><img src="/2020/01/04/JVM-STACK/0010.png"></p>
<p>3、Misc</p>
<p><img src="/2020/01/04/JVM-STACK/0011.png"></p>
<p>4、行号表</p>
<p>​    Java代码的行号和字节码指令行号的对应关系</p>
<p><img src="/2020/01/04/JVM-STACK/0012.png"></p>
<p>5、注意：生效行数和剩余有效行数都是针对于字节码文件的行数</p>
<p><img src="/2020/01/04/JVM-STACK/0013.png"></p>
<p>1、图中圈的东西表示该局部变量的作用域</p>
<p>2、Start PC==11表示在字节码的11行开始生效，也就是Java代码对应的第15行。而声明int num在java代码的是第14行，说明是从声明的下一行开始生效</p>
<p>3、Length== 5表示局部变量剩余有效行数，main方法字节码指令总共有16行，从11行开始生效，那么剩下就是16-11 ==5。</p>
<p>4、<code>Ljava/lang/String</code>   前面的L表示引用类型</p>
<h3 id="关于Slot的理解"><a href="#关于Slot的理解" class="headerlink" title="关于Slot的理解"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88?id=%E5%85%B3%E4%BA%8Eslot%E7%9A%84%E7%90%86%E8%A7%A3">关于Slot的理解</a></h3><ol>
<li><p>参数值的存放总是从局部变量数组索引 0 的位置开始，到数组长度-1的索引结束。</p>
</li>
<li><p>局部变量表，<strong>最基本的存储单元是Slot（变量槽）</strong>，局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</p>
</li>
<li><p>在局部变量表里，</p>
<p>32位以内的类型只占用一个slot</p>
<p>（包括returnAddress类型），</p>
<p>64位的类型占用两个slot</p>
<p>（1ong和double）。</p>
<ul>
<li>byte、short、char在储存前辈转换为int，boolean也被转换为int，0表示false，非0表示true</li>
<li>long和double则占据两个slot</li>
</ul>
</li>
<li><p>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</p>
</li>
<li><p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制</strong>到局部变量表中的每一个slot上</p>
</li>
<li><p>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问long或double类型变量）</p>
</li>
<li><p>如果当前帧是由构造方法或者实例方法创建的，那么<strong>该对象引用this将会存放在index为0的slot处</strong>，其余的参数按照参数表顺序继续排列。（this也相当于一个变量）</p>
</li>
</ol>
<p><img src="/2020/01/04/JVM-STACK/0014.png"></p>
<h3 id="Slot代码示例"><a href="#Slot代码示例" class="headerlink" title="Slot代码示例"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88?id=slot%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B">Slot代码示例</a></h3><p><strong>this 存放在 index = 0 的位置：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>局部变量表：this 存放在 index = 0 的位置</p>
<p><img src="/2020/01/04/JVM-STACK/0015.png"></p>
<p><strong>64位的类型（1ong和double）占用两个slot</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">(Date dateP, String name2)</span> </span>&#123;</span><br><span class="line">    dateP = <span class="keyword">null</span>;</span><br><span class="line">    name2 = <span class="string">&quot;songhongkang&quot;</span>;</span><br><span class="line">    <span class="keyword">double</span> weight = <span class="number">130.5</span>;<span class="comment">//占据两个slot</span></span><br><span class="line">    <span class="keyword">char</span> gender = <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> dateP + name2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>weight 为 double 类型，index 直接从 3 蹦到了 5</p>
<p><img src="/2020/01/04/JVM-STACK/0016.png"></p>
<p><strong>static 无法调用 this</strong></p>
<p>this 不存在与 static 方法的局部变量表中，所以无法调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStatic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LocalVariablesTest test = <span class="keyword">new</span> LocalVariablesTest();</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        <span class="comment">//因为this变量不存在于当前方法的局部变量表中！！</span></span><br><span class="line"><span class="comment">//        System.out.println(this.count);</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Slot的重复利用"><a href="#Slot的重复利用" class="headerlink" title="Slot的重复利用"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88?id=slot%E7%9A%84%E9%87%8D%E5%A4%8D%E5%88%A9%E7%94%A8">Slot的重复利用</a></h3><p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明新的局部变量变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        b = a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//变量c使用之前已经销毁的变量b占据的slot的位置</span></span><br><span class="line">    <span class="keyword">int</span> c = a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/01/04/JVM-STACK/0017.png"></p>
<h3 id="静态变量与局部变量的对比"><a href="#静态变量与局部变量的对比" class="headerlink" title="静态变量与局部变量的对比"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88?id=%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%AF%B9%E6%AF%94">静态变量与局部变量的对比</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">变量的分类：</span><br><span class="line"><span class="number">1</span>、按照数据类型分：① 基本数据类型  ② 引用数据类型</span><br><span class="line"><span class="number">2</span>、按照在类中声明的位置分：</span><br><span class="line">  <span class="number">2</span>-<span class="number">1</span>、成员变量：在使用前，都经历过默认初始化赋值</span><br><span class="line">       <span class="number">2</span>-<span class="number">1</span>-<span class="number">1</span>、类变量: linking的prepare阶段：给类变量默认赋值</span><br><span class="line">              ---&gt; initial阶段：给类变量显式赋值即静态代码块赋值</span><br><span class="line">       <span class="number">2</span>-<span class="number">1</span>-<span class="number">2</span>、实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值</span><br><span class="line">  <span class="number">2</span>-<span class="number">2</span>、局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过。</span><br></pre></td></tr></table></figure>

<ol>
<li>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</li>
<li>我们知道成员变量有两次初始化的机会<strong>，</strong>第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。</li>
<li>和类变量初始化不同的是，<strong>局部变量表不存在系统初始化的过程</strong>，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</li>
</ol>
<h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88?id=%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E">补充说明</a></h3><ol>
<li>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</li>
<li>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</li>
</ol>
<h2 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88?id=%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88">操作数栈</a></h2><h3 id="操作数栈的特点"><a href="#操作数栈的特点" class="headerlink" title="操作数栈的特点"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88?id=%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E7%9A%84%E7%89%B9%E7%82%B9">操作数栈的特点</a></h3><ol>
<li>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）的 操作数栈，也可以称之为<strong>表达式栈</strong>（Expression Stack）</li>
<li>操作数栈，在方法执行过程中，<strong>根据字节码指令，往栈中写入数据或提取数据</strong>，即入栈（push）和 出栈（pop）<ul>
<li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈，</li>
<li>比如：执行复制、交换、求和等操作</li>
</ul>
</li>
</ol>
<p><img src="/2020/01/04/JVM-STACK/0018.png"></p>
<h3 id="操作数栈的作用"><a href="#操作数栈的作用" class="headerlink" title="操作数栈的作用"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88?id=%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E7%9A%84%E4%BD%9C%E7%94%A8">操作数栈的作用</a></h3><ol>
<li>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong>。</li>
<li>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这时方法的操作数栈是空的。</li>
<li>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为<strong>maxstack</strong>的值。</li>
<li>栈中的任何一个元素都是可以任意的Java数据类型<ul>
<li>32bit的类型占用一个栈单位深度</li>
<li>64bit的类型占用两个栈单位深度</li>
</ul>
</li>
<li>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问。<strong>只不过操作数栈是用数组这个结构来实现的而已</strong></li>
<li>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</li>
<li>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</li>
<li>另外，<strong>我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈</strong>。</li>
</ol>
<p><img src="/2020/01/04/JVM-STACK/0020.jpg"></p>
<p>局部变量表就相当于食材</p>
<p>操作数栈就相当于做法步骤</p>
<h2 id="操作数栈代码追踪"><a href="#操作数栈代码追踪" class="headerlink" title="操作数栈代码追踪"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88?id=%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%BB%A3%E7%A0%81%E8%BF%BD%E8%B8%AA">操作数栈代码追踪</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAddOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//byte、short、char、boolean：都以int型来保存</span></span><br><span class="line">    <span class="keyword">byte</span> i = <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> k = i + j;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// int m = 800;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应字节码指令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> bipush <span class="number">15</span></span><br><span class="line"> <span class="number">2</span> istore_1</span><br><span class="line"> <span class="number">3</span> bipush <span class="number">8</span></span><br><span class="line"> <span class="number">5</span> istore_2</span><br><span class="line"> <span class="number">6</span> iload_1</span><br><span class="line"> <span class="number">7</span> iload_2</span><br><span class="line"> <span class="number">8</span> iadd</span><br><span class="line"> <span class="number">9</span> istore_3</span><br><span class="line"><span class="number">10</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/01/04/JVM-STACK/0021.png"></p>
<h3 id="一步一步看流程"><a href="#一步一步看流程" class="headerlink" title="一步一步看流程"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88?id=%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E7%9C%8B%E6%B5%81%E7%A8%8B">一步一步看流程</a></h3><p>1、首先执行第一条语句，PC寄存器指向的是0，也就是指令地址为0，然后使用bipush让操作数15入操作数栈.</p>
<p><img src="/2020/01/04/JVM-STACK/0022.png"></p>
<p>2、执行完后，PC寄存器往下移，指向下一行代码，下一行代码就是将操作数栈的元素存储到局部变量表1的位置（istore_1），我们可以看到局部变量表的已经增加了一个元素。并且操作数栈为空了.</p>
<ul>
<li>解释为什么局部变量表索引从 1 开始，因为该方法为实例方法，局部变量表索引为 0 的位置存放的是 this</li>
</ul>
<p><img src="/2020/01/04/JVM-STACK/0023.png"></p>
<p>3、然后PC下移，指向的是下一行。让操作数8也入栈，同时执行store操作，存入局部变量表中</p>
<p><img src="/2020/01/04/JVM-STACK/0024.png"></p>
<p>4、然后从局部变量表中，依次将数据放在操作数栈中，等待执行 add 操作</p>
<p>iload_1：取出局部变量表中索引为1的数据入操作数栈</p>
<p><img src="/2020/01/04/JVM-STACK/0025.png"></p>
<p>5、然后将操作数栈中的两个元素执行相加操作，并存储在局部变量表3的位置</p>
<p><img src="/2020/01/04/JVM-STACK/0026.png"></p>
<p>5、然后将操作数栈中的两个元素执行相加操作，并存储在局部变量表3的位置</p>
<p><strong>关于类型转换的说明</strong></p>
<p><img src="/2020/01/04/JVM-STACK/0027.png"></p>
<ul>
<li>m改成800之后，byte存储不了，就成了short型，sipush 800</li>
</ul>
<p><strong>如果被调用的方法带有返回值，返回值入操作数栈</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> m = <span class="number">10</span>;</span><br><span class="line">      <span class="keyword">int</span> n = <span class="number">20</span>;</span><br><span class="line">      <span class="keyword">int</span> k = m + n;</span><br><span class="line">      <span class="keyword">return</span> k;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetSum</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">//获取上一个栈桢返回的结果，并保存在操作数栈中</span></span><br><span class="line">      <span class="keyword">int</span> i = getSum();</span><br><span class="line">      <span class="keyword">int</span> j = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>getSum() 方法字节码指令：最后带着个 ireturn</p>
<p><img src="/2020/01/04/JVM-STACK/0029.png"></p>
<p>testGetSum() 方法字节码指令：一上来就加载 getSum() 方法的返回值()</p>
<p><img src="/2020/01/04/JVM-STACK/0030.png"></p>
<p>? testGetSum() 方法字节码指令：一上来就加载 getSum() 方法的返回值() </p>
<h2 id="栈顶缓存技术"><a href="#栈顶缓存技术" class="headerlink" title="栈顶缓存技术"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88?id=%E6%A0%88%E9%A1%B6%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF">栈顶缓存技术</a></h2><p><strong>栈顶缓存技术：Top Of Stack Cashing</strong></p>
<ol>
<li>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数（也就是你会发现指令很多）和导致内存读/写次数多，效率不高。</li>
<li>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，<strong>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。</strong></li>
<li>寄存器的主要优点：指令更少，执行速度快，但是指令集（也就是指令种类）很多</li>
</ol>
<p><strong>动态链接（或指向运行时常量池的方法引用）</strong></p>
<ol>
<li><p>每一个栈帧内部都包含<strong>一个指向运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的就是<strong>为了支持当前方法的代码能够实现动态链接</strong>（Dynamic Linking），比如：invokedynamic指令</p>
</li>
<li><p>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicLinkingTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodA()....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodB()....&quot;</span>);</span><br><span class="line"></span><br><span class="line">        methodA();</span><br><span class="line"></span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应字节码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">Classfile /F:/IDEAWorkSpaceSourceCode/JVMDemo/out/production/chapter05/com/atguigu/java1/DynamicLinkingTest.class</span><br><span class="line">  Last modified <span class="number">2020</span>-<span class="number">11</span>-<span class="number">10</span>; size <span class="number">712</span> bytes</span><br><span class="line">  MD5 checksum e56913c945f897c7ee6c0a608629bca8</span><br><span class="line">  Compiled from <span class="string">&quot;DynamicLinkingTest.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">atguigu</span>.<span class="title">java1</span>.<span class="title">DynamicLinkingTest</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #9.#23         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #8.#24         // com/atguigu/java1/DynamicLinkingTest.num:I</span><br><span class="line">   #3 = Fieldref           #25.#26        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #4 = String             #27            // methodA()....</span><br><span class="line">   #5 = Methodref          #28.#29        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #6 = String             #30            // methodB()....</span><br><span class="line">   #7 = Methodref          #8.#31         // com/atguigu/java1/DynamicLinkingTest.methodA:()V</span><br><span class="line">   #8 = Class              #32            // com/atguigu/java1/DynamicLinkingTest</span><br><span class="line">   #9 = Class              #33            // java/lang/Object</span><br><span class="line">  #10 = Utf8               num</span><br><span class="line">  #11 = Utf8               I</span><br><span class="line">  #12 = Utf8               &lt;init&gt;</span><br><span class="line">  #13 = Utf8               ()V</span><br><span class="line">  #14 = Utf8               Code</span><br><span class="line">  #15 = Utf8               LineNumberTable</span><br><span class="line">  #16 = Utf8               LocalVariableTable</span><br><span class="line">  #17 = Utf8               this</span><br><span class="line">  #18 = Utf8               Lcom/atguigu/java1/DynamicLinkingTest;</span><br><span class="line">  #19 = Utf8               methodA</span><br><span class="line">  #20 = Utf8               methodB</span><br><span class="line">  #21 = Utf8               SourceFile</span><br><span class="line">  #22 = Utf8               DynamicLinkingTest.java</span><br><span class="line">  #23 = NameAndType        #12:#13        // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #24 = NameAndType        #10:#11        // num:I</span><br><span class="line">  #25 = Class              #34            // java/lang/System</span><br><span class="line">  #26 = NameAndType        #35:#36        // out:Ljava/io/PrintStream;</span><br><span class="line">  #27 = Utf8               methodA()....</span><br><span class="line">  #28 = Class              #37            // java/io/PrintStream</span><br><span class="line">  #29 = NameAndType        #38:#39        // println:(Ljava/lang/String;)V</span><br><span class="line">  #30 = Utf8               methodB()....</span><br><span class="line">  #31 = NameAndType        #19:#13        // methodA:()V</span><br><span class="line">  #32 = Utf8               com/atguigu/java1/DynamicLinkingTest</span><br><span class="line">  #33 = Utf8               java/lang/Object</span><br><span class="line">  #34 = Utf8               java/lang/System</span><br><span class="line">  #35 = Utf8               out</span><br><span class="line">  #36 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #37 = Utf8               java/io/PrintStream</span><br><span class="line">  #38 = Utf8               println</span><br><span class="line">  #39 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> com.atguigu.java1.DynamicLinkingTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="number">5</span>: bipush        <span class="number">10</span></span><br><span class="line">         7: putfield      #2                  // Field num:I</span><br><span class="line">        <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">9</span>: <span class="number">4</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">11</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java1/DynamicLinkingTest;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #4                  // String methodA()....</span><br><span class="line">         5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">8</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java1/DynamicLinkingTest;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #6                  // String methodB()....</span><br><span class="line">         5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         <span class="number">8</span>: aload_0</span><br><span class="line">         9: invokevirtual #7                  // Method methodA:()V</span><br><span class="line">        <span class="number">12</span>: aload_0</span><br><span class="line">        <span class="number">13</span>: dup</span><br><span class="line">        14: getfield      #2                  // Field num:I</span><br><span class="line">        <span class="number">17</span>: iconst_1</span><br><span class="line">        <span class="number">18</span>: iadd</span><br><span class="line">        19: putfield      #2                  // Field num:I</span><br><span class="line">        <span class="number">22</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">16</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">18</span>: <span class="number">8</span></span><br><span class="line">        line <span class="number">20</span>: <span class="number">12</span></span><br><span class="line">        line <span class="number">21</span>: <span class="number">22</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">23</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java1/DynamicLinkingTest;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;DynamicLinkingTest.java&quot;</span></span><br></pre></td></tr></table></figure>



<p>1、在字节码指令中，methodB() 方法中通过 invokevirtual #7 指令调用了方法 A ，那么 #7 是个啥呢？</p>
<p>2、往上面翻，找到常量池的定义：<code>#7 = Methodref #8.#31</code></p>
<ul>
<li>先找 #8 ：<ul>
<li><code>#8 = Class #32</code> ：去找 #32</li>
<li><code>#32 = Utf8 com/atguigu/java1/DynamicLinkingTest</code></li>
<li>结论：通过 #8 我们找到了 <code>DynamicLinkingTest</code> 这个类</li>
</ul>
</li>
<li>再来找 #31：<ul>
<li><code>#31 = NameAndType #19:#13</code> ：去找 #19 和 #13</li>
<li><code>#19 = Utf8 methodA</code> ：方法名为 methodA</li>
<li><code>#13 = Utf8 ()V</code> ：方法没有形参，返回值为 void</li>
</ul>
</li>
</ul>
<p>3、结论：通过 #7 我们就能找到需要调用的 methodA() 方法，并进行调用</p>
<p>4、在上面，其实还有很多符号引用，比如 Object、System、PrintStream 等等</p>
<p><img src="/2020/01/04/JVM-STACK/0031.png"></p>
<p><strong>为什么要用常量池呢？</strong></p>
<ol>
<li>因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，然后记录其引用即可，节省了空间。</li>
<li>常量池的作用：就是为了提供一些符号和常量，便于指令的识别</li>
</ol>
<h2 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88?id=%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8">方法的调用</a></h2><h3 id="静态链接与动态链接"><a href="#静态链接与动态链接" class="headerlink" title="静态链接与动态链接"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88?id=%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5">静态链接与动态链接</a></h3><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p>
<ul>
<li><strong>静态链接</strong>：</li>
</ul>
<p>当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期确定，且运行期保持不变时，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</p>
<ul>
<li><strong>动态链接</strong>：</li>
</ul>
<p>如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。</p>
<h3 id="早期绑定与晚期绑定"><a href="#早期绑定与晚期绑定" class="headerlink" title="早期绑定与晚期绑定"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88?id=%E6%97%A9%E6%9C%9F%E7%BB%91%E5%AE%9A%E4%B8%8E%E6%99%9A%E6%9C%9F%E7%BB%91%E5%AE%9A">早期绑定与晚期绑定</a></h3><blockquote>
<p>静态链接与动态链接针对的是方法。早期绑定和晚期绑定范围更广。早期绑定涵盖了静态链接，晚期绑定涵盖了动态链接。</p>
</blockquote>
<p>静态链接和动态链接对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程</strong>，这仅仅发生一次。</p>
<ul>
<li><strong>早期绑定</strong></li>
</ul>
<p>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就<strong>可以使用静态链接的方式将符号引用转换为直接引用</strong>。</p>
<ul>
<li><strong>晚期绑定</strong></li>
</ul>
<p>如果被调用的方法在编译期无法被确定下来，<strong>只能够在程序运行期根据实际的类型绑定相关的方法</strong>，这种绑定方式也就被称之为晚期绑定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物进食&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Huntable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hunt</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Huntable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗吃骨头&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hunt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;捕食耗子，多管闲事&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Huntable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();<span class="comment">//表现为：早期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();<span class="comment">//表现为：早期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.eat();<span class="comment">//表现为：早期绑定</span></span><br><span class="line">        System.out.println(<span class="string">&quot;猫吃鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hunt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;捕食耗子，天经地义&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showAnimal</span><span class="params">(Animal animal)</span> </span>&#123;</span><br><span class="line">        animal.eat();<span class="comment">//表现为：晚期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showHunt</span><span class="params">(Huntable h)</span> </span>&#123;</span><br><span class="line">        h.hunt();<span class="comment">//表现为：晚期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>部分字节码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.atguigu.java2.AnimalTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">54</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java2/AnimalTest;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showAnimal</span><span class="params">(com.atguigu.java2.Animal)</span></span>;</span><br><span class="line">    descriptor: (Lcom/atguigu/java2/Animal;)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_1</span><br><span class="line">         1: invokevirtual #2                  // Method com/atguigu/java2/Animal.eat:()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">56</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">57</span>: <span class="number">4</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java2/AnimalTest;</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">1</span> animal   Lcom/atguigu/java2/Animal;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showHunt</span><span class="params">(com.atguigu.java2.Huntable)</span></span>;</span><br><span class="line">    descriptor: (Lcom/atguigu/java2/Huntable;)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_1</span><br><span class="line">         1: invokeinterface #3,  1            // InterfaceMethod com/atguigu/java2/Huntable.hunt:()V</span><br><span class="line">         <span class="number">6</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">60</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">61</span>: <span class="number">6</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">7</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java2/AnimalTest;</span><br><span class="line">            <span class="number">0</span>       <span class="number">7</span>     <span class="number">1</span>     h   Lcom/atguigu/java2/Huntable;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;AnimalTest.java&quot;</span></span><br></pre></td></tr></table></figure>

<p>invokevirtual 体现为晚期绑定</p>
<p>invokeinterface 也体现为晚期绑定</p>
<p>invokespecial 体现为早期绑定</p>
<h3 id="多态与绑定"><a href="#多态与绑定" class="headerlink" title="多态与绑定"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88?id=%E5%A4%9A%E6%80%81%E4%B8%8E%E7%BB%91%E5%AE%9A">多态与绑定</a></h3><ol>
<li>随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</li>
<li>Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</li>
</ol>
<h4 id="虚方法与非虚方法"><a href="#虚方法与非虚方法" class="headerlink" title="虚方法与非虚方法"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88?id=%E8%99%9A%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%9E%E8%99%9A%E6%96%B9%E6%B3%95">虚方法与非虚方法</a></h4><p><strong>虚方法与非虚方法的区别</strong></p>
<ol>
<li>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</li>
<li>静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。</li>
<li>其他方法称为虚方法。</li>
</ol>
<p><strong>子类对象的多态的使用前提：</strong></p>
<ol>
<li>类的继承关系</li>
<li>方法的重写</li>
</ol>
<p><strong>虚拟机中调用方法的指令</strong></p>
<ul>
<li><strong>普通指令：</strong></li>
</ul>
<ol>
<li>invokestatic：调用静态方法，解析阶段确定唯一方法版本</li>
<li>invokespecial：调用<code>&lt;init&gt;</code>方法、私有及父类方法，解析阶段确定唯一方法版本</li>
<li>invokevirtual：调用所有虚方法</li>
<li>invokeinterface：调用接口方法</li>
</ol>
<ul>
<li><strong>动态调用指令</strong></li>
</ul>
<p>invokedynamic：动态解析出需要调用的方法，然后执行</p>
<p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预。而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father的构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showStatic</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father &quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">showFinal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father show final&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showCommon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father 普通方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不是重写的父类的静态方法，因为静态方法不能被重写！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showStatic</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;son &quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showPrivate</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;son private&quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//invokestatic</span></span><br><span class="line">        showStatic(<span class="string">&quot;atguigu.com&quot;</span>);</span><br><span class="line">        <span class="comment">//invokestatic</span></span><br><span class="line">        <span class="keyword">super</span>.showStatic(<span class="string">&quot;good!&quot;</span>);</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        showPrivate(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        <span class="keyword">super</span>.showCommon();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//invokevirtual</span></span><br><span class="line">        showFinal();<span class="comment">//因为此方法声明有final，不能被子类重写，所以也认为此方法是非虚方法。</span></span><br><span class="line">        <span class="comment">//虚方法如下：</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        invokevirtual  你没有显示的加super.，编译器认为你可能调用子类的showCommon(即使son子类没有重写，也          会认为)，所以编译期间确定不下来，就是虚方法。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        showCommon();</span><br><span class="line">        info();</span><br><span class="line"></span><br><span class="line">        MethodInterface in = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//invokeinterface</span></span><br><span class="line">        in.methodA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Father f)</span> </span>&#123;</span><br><span class="line">        f.showCommon();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son so = <span class="keyword">new</span> Son();</span><br><span class="line">        so.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MethodInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Son 类中 show() 方法的字节码指令如下</p>
<p><img src="/2020/01/04/JVM-STACK/0032.png"></p>
<h4 id="关于-invokedynamic-指令"><a href="#关于-invokedynamic-指令" class="headerlink" title="关于 invokedynamic 指令"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88?id=%E5%85%B3%E4%BA%8E-invokedynamic-%E6%8C%87%E4%BB%A4">关于 invokedynamic 指令</a></h4><ol>
<li>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现【动态类型语言】支持而做的一种改进。</li>
<li>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。</li>
<li>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Func</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">func</span><span class="params">(String str)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lambda</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">(Func func)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Lambda lambda = <span class="keyword">new</span> Lambda();</span><br><span class="line"></span><br><span class="line">        Func func = s -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        lambda.lambda(func);</span><br><span class="line"></span><br><span class="line">        lambda.lambda(s -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/01/04/JVM-STACK/0033.png"></p>
<h3 id="动态语言和静态语言"><a href="#动态语言和静态语言" class="headerlink" title="动态语言和静态语言"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88?id=%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80%E5%92%8C%E9%9D%99%E6%80%81%E8%AF%AD%E8%A8%80">动态语言和静态语言</a></h3><ol>
<li>动态类型语言和静态类型语言两者的区别就在于<strong>对类型的检查是在编译期还是在运行期</strong>，满足前者就是静态类型语言，反之是动态类型语言。</li>
<li>说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。</li>
</ol>
<p>Java：String info = “mogu blog”;             (Java是静态类型语言的，会先编译就进行类型检查)    JS：var name = “shkstart”;    var name = 10;    （运行时才进行检查）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Python: info = <span class="number">130.5</span> (运行时才检查)</span><br></pre></td></tr></table></figure>

<h3 id="Java语言中方法重写的本质"><a href="#Java语言中方法重写的本质" class="headerlink" title="Java语言中方法重写的本质"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88?id=java%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E7%9A%84%E6%9C%AC%E8%B4%A8">Java语言中方法重写的本质</a></h3><ol>
<li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。</li>
<li>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验。<ul>
<li>如果通过则返回这个方法的直接引用，查找过程结束</li>
<li>如果不通过，则返回java.lang.IllegalAccessError 异常</li>
</ul>
</li>
<li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li>
<li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</li>
</ol>
<blockquote>
<p>上面这个过程称为<strong>动态分派</strong></p>
</blockquote>
<p><strong>IllegalAccessError介绍</strong></p>
<ol>
<li>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</li>
<li>比如，你把应该有的jar包放从工程中拿走了，或者Maven中存在jar包冲</li>
</ol>
<h3 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88?id=%E8%99%9A%E6%96%B9%E6%B3%95%E8%A1%A8">虚方法表</a></h3><ol>
<li>在面向对象的编程中，会很频繁的使用到<strong>动态分派</strong>，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，<strong>JVM采用在类的方法区建立一个虚方法表（virtual method table）来实现</strong>，非虚方法不会出现在表中。使用索引表来代替查找。【上面动态分派的过程，我们可以看到如果子类找不到，还要从下往上找其父类，非常耗时】</li>
<li>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</li>
<li>虚方法表是什么时候被创建的呢？虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的虚方法表也初始化完毕。</li>
</ol>
<p><strong>例子1</strong></p>
<p>如图所示：如果类中重写了方法，那么调用的时候，就会直接在该类的虚方法表中查找</p>
<p><img src="/2020/01/04/JVM-STACK/0034.png"></p>
<p>1、比如说son在调用toString的时候，Son没有重写过，Son的父类Father也没有重写过，那就直接调用Object类的toString。那么就直接在虚方法表里指明toString直接指向Object类。</p>
<p>2、下次Son对象再调用toString就直接去找Object，不用先找Son–&gt;再找Father–&gt;最后才到Object的这样的一个过程。</p>
<h2 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88?id=%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80">方法返回地址</a></h2><p><img src="/2020/01/04/JVM-STACK/0039.png"></p>
<blockquote>
<p>在一些帖子里，方法返回地址、动态链接、一些附加信息  也叫做帧数据区</p>
</blockquote>
<ol>
<li>存放调用该方法的pc寄存器的值。一个方法的结束，有两种方式：<ul>
<li>正常执行完成</li>
<li>出现未处理的异常，非正常退出</li>
</ul>
</li>
<li>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，<strong>调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址</strong>。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</li>
<li>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</li>
<li>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</li>
</ol>
<p><strong>方法退出的两种方式</strong></p>
<p>当一个方法开始执行后，只有两种方式可以退出这个方法，</p>
<p><strong>正常退出：</strong></p>
<ol>
<li>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称<strong>正常完成出口</strong>；</li>
<li>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</li>
<li>在字节码指令中，返回指令包含：<ul>
<li>ireturn：当返回值是boolean，byte，char，short和int类型时使用</li>
<li>lreturn：Long类型</li>
<li>freturn：Float类型</li>
<li>dreturn：Double类型</li>
<li>areturn：引用类型</li>
<li>return：返回值类型为void的方法、实例初始化方法、类和接口的初始化方法</li>
</ul>
</li>
</ol>
<p><strong>异常退出：</strong></p>
<ol>
<li>在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称<strong>异常完成出口</strong>。</li>
<li>方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码</li>
</ol>
<h2 id="一些附加信息"><a href="#一些附加信息" class="headerlink" title="一些附加信息"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88?id=%E4%B8%80%E4%BA%9B%E9%99%84%E5%8A%A0%E4%BF%A1%E6%81%AF">一些附加信息</a></h2><p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。</p>
<h2 id="栈相关面试题"><a href="#栈相关面试题" class="headerlink" title="栈相关面试题"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88?id=%E6%A0%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98">栈相关面试题</a></h2><h3 id="举例栈溢出的情况？"><a href="#举例栈溢出的情况？" class="headerlink" title="举例栈溢出的情况？"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88?id=%E4%B8%BE%E4%BE%8B%E6%A0%88%E6%BA%A2%E5%87%BA%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%9F">举例栈溢出的情况？</a></h3><p>SOF（StackOverflowError），栈大小分为固定的，和动态变化。如果是固定的就可能出现StackOverflowError。如果是动态变化的，内存不足时就可能出现OOM</p>
<h3 id="调整栈大小，就能保证不出现溢出么？"><a href="#调整栈大小，就能保证不出现溢出么？" class="headerlink" title="调整栈大小，就能保证不出现溢出么？"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88?id=%E8%B0%83%E6%95%B4%E6%A0%88%E5%A4%A7%E5%B0%8F%EF%BC%8C%E5%B0%B1%E8%83%BD%E4%BF%9D%E8%AF%81%E4%B8%8D%E5%87%BA%E7%8E%B0%E6%BA%A2%E5%87%BA%E4%B9%88%EF%BC%9F">调整栈大小，就能保证不出现溢出么？</a></h3><p>不能保证不溢出，只能保证SOF出现的几率小</p>
<h3 id="分配的栈内存越大越好么？"><a href="#分配的栈内存越大越好么？" class="headerlink" title="分配的栈内存越大越好么？"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88?id=%E5%88%86%E9%85%8D%E7%9A%84%E6%A0%88%E5%86%85%E5%AD%98%E8%B6%8A%E5%A4%A7%E8%B6%8A%E5%A5%BD%E4%B9%88%EF%BC%9F">分配的栈内存越大越好么？</a></h3><p>不是，一定时间内降低了OOM概率，但是会挤占其它的线程空间，因为整个虚拟机的内存空间是有限的</p>
<h3 id="垃圾回收是否涉及到虚拟机栈？"><a href="#垃圾回收是否涉及到虚拟机栈？" class="headerlink" title="垃圾回收是否涉及到虚拟机栈？"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88?id=%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%98%AF%E5%90%A6%E6%B6%89%E5%8F%8A%E5%88%B0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%EF%BC%9F">垃圾回收是否涉及到虚拟机栈？</a></h3><h3 id="方法中定义的局部变量是否线程安全？"><a href="#方法中定义的局部变量是否线程安全？" class="headerlink" title="方法中定义的局部变量是否线程安全？"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88?id=%E6%96%B9%E6%B3%95%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F">方法中定义的局部变量是否线程安全？</a></h3><p>具体问题具体分析</p>
<ol>
<li>如果只有一个线程才可以操作此数据，则必是线程安全的。</li>
<li>如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。</li>
</ol>
<p><strong>具体问题具体分析：</strong></p>
<ul>
<li>? 如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 面试题：</span></span><br><span class="line"><span class="comment"> * 方法中定义的局部变量是否线程安全？具体情况具体分析</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   何为线程安全？</span></span><br><span class="line"><span class="comment"> *      如果只有一个线程才可以操作此数据，则必是线程安全的。</span></span><br><span class="line"><span class="comment"> *      如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//s1的声明方式是线程安全的（只在方法内部用了）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//StringBuilder:线程不安全</span></span><br><span class="line">        StringBuilder s1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//sBuilder的操作过程：是线程不安全的（作为参数传进来，可能被其它线程操作）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(StringBuilder sBuilder)</span></span>&#123;</span><br><span class="line">        sBuilder.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        sBuilder.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//s1的操作：是线程不安全的（有返回值，可能被其它线程操作）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title">method3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuilder s1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//s1的操作：是线程安全的（s1自己消亡了，最后返回的智商s1.toString的一个新对象）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">method4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuilder s1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s1.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            s.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">            s.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        method2(s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="引用传递-值传递"><a href="#引用传递-值传递" class="headerlink" title="引用传递 值传递"></a>引用传递 值传递</h5><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016773324">https://segmentfault.com/a/1190000016773324</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-01-03T13:45:04.000Z" title="1/3/2020, 9:45:04 PM">2020-01-03</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-08-19T11:11:44.009Z" title="8/19/2021, 7:11:44 PM">2021-08-19</time></span><span class="level-item"><a class="link-muted" href="/categories/JAVA/">JAVA</a></span><span class="level-item">19 minutes read (About 2920 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/01/03/JVM-RUNTIME/">JVM_RUNTIME</a></p><div class="content"><h1 id="运行时数据区概述及线程"><a href="#运行时数据区概述及线程" class="headerlink" title="[运行时数据区概述及线程]"></a>[运行时数据区概述及线程]</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC3%E7%AB%A0-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA?id=%E5%89%8D%E8%A8%80">前言</a></h2><p>本节主要讲的是运行时数据区，也就是下图这部分，它是在类加载完成后的阶段</p>
<p><img src="/2020/01/03/JVM-RUNTIME/0001.png"></p>
<p>当我们通过前面的：类的加载 –&gt; 验证 –&gt; 准备 –&gt; 解析 –&gt; 初始化，这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区</p>
<h2 id="运行时数据区结构"><a href="#运行时数据区结构" class="headerlink" title="运行时数据区结构"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC3%E7%AB%A0-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA?id=%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E7%BB%93%E6%9E%84">运行时数据区结构</a></h2><h3 id="运行时数据区与内存"><a href="#运行时数据区与内存" class="headerlink" title="运行时数据区与内存"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC3%E7%AB%A0-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA?id=%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E4%B8%8E%E5%86%85%E5%AD%98">运行时数据区与内存</a></h3><ol>
<li>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。<strong>不同的JVM对于内存的划分方式和管理机制存在着部分差异</strong>。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</li>
<li>我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁</li>
</ol>
<p><img src="/2020/01/03/JVM-RUNTIME/0004.jpg"></p>
<h3 id="线程的内存空间"><a href="#线程的内存空间" class="headerlink" title="线程的内存空间"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC3%E7%AB%A0-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA?id=%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4">线程的内存空间</a></h3><ol>
<li>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区：其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</li>
<li>灰色的为单独线程私有的，红色的为多个线程共享的。即：<ul>
<li>线程独有：独立包括程序计数器、栈、本地方法栈</li>
<li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li>
</ul>
</li>
</ol>
<p><img src="/2020/01/03/JVM-RUNTIME/0005.png"></p>
<h3 id="Runtime类"><a href="#Runtime类" class="headerlink" title="Runtime类"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC3%E7%AB%A0-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA?id=runtime%E7%B1%BB">Runtime类</a></h3><p><strong>每个JVM只有一个Runtime实例</strong>。即为运行时环境，相当于内存结构的中间的那个框框：运行时环境。</p>
<h3 id="JVM-线程"><a href="#JVM-线程" class="headerlink" title="JVM 线程"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC3%E7%AB%A0-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA?id=jvm-%E7%BA%BF%E7%A8%8B">JVM 线程</a></h3><ol>
<li>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行</li>
<li>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射<ul>
<li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收</li>
</ul>
</li>
<li>操作系统负责将线程安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法</li>
</ol>
<blockquote>
<p>关于线程，并发可以看笔者的Java并发系列</p>
</blockquote>
<h3 id="JVM-系统线程"><a href="#JVM-系统线程" class="headerlink" title="JVM 系统线程"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC3%E7%AB%A0-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA?id=jvm-%E7%B3%BB%E7%BB%9F%E7%BA%BF%E7%A8%8B">JVM 系统线程</a></h3><ul>
<li>如果你使用jconsole或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用<code>public static void main(String[])</code>的main线程以及所有这个main线程自己创建的线程。</li>
<li>这些主要的后台系统线程在Hotspot JVM里主要是以下几个：<ol>
<li><strong>虚拟机线程</strong>：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销</li>
<li><strong>周期任务线程</strong>：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行</li>
<li><strong>GC线程</strong>：这种线程对在JVM里不同种类的垃圾收集行为提供了支持</li>
<li><strong>编译线程</strong>：这种线程在运行时会将字节码编译成到本地代码</li>
<li><strong>信号调度线程</strong>：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理</li>
</ol>
</li>
</ul>
<h1 id="程序计数器-PC寄存器"><a href="#程序计数器-PC寄存器" class="headerlink" title="程序计数器(PC寄存器)"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC3%E7%AB%A0-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA?id=%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8pc%E5%AF%84%E5%AD%98%E5%99%A8">程序计数器(PC寄存器)</a></h1><h2 id="PC寄存器介绍"><a href="#PC寄存器介绍" class="headerlink" title="PC寄存器介绍"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC3%E7%AB%A0-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA?id=pc%E5%AF%84%E5%AD%98%E5%99%A8%E4%BB%8B%E7%BB%8D">PC寄存器介绍</a></h2><p>官方文档网址：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></p>
<p><img src="/2020/01/03/JVM-RUNTIME/0007.png"></p>
<ol>
<li>JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，<strong>寄存器存储指令相关的现场信息</strong>。CPU只有把数据装载到寄存器才能够运行。</li>
<li>这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。<strong>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟</strong>。</li>
<li>它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。</li>
<li>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</li>
<li>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefned）。</li>
<li>它是<strong>程序控制流</strong>的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li>
<li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</li>
<li>它是<strong>唯一一个</strong>在Java虚拟机规范中没有规定任何OutofMemoryError情况的区域。</li>
</ol>
<h2 id="PC寄存器的作用"><a href="#PC寄存器的作用" class="headerlink" title="PC寄存器的作用"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC3%E7%AB%A0-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA?id=pc%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8">PC寄存器的作用</a></h2><p>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令，并执行该指令。</p>
<p><img src="/2020/01/03/JVM-RUNTIME/0008.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PCRegisterTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">int</span> k = i + j;</span><br><span class="line"></span><br><span class="line">        String s = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(k);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看字节码的方法：<a target="_blank" rel="noopener" href="https://blog.csdn.net/21aspnet/article/details/88351875">https://blog.csdn.net/21aspnet/article/details/88351875</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">Classfile /F:/IDEAWorkSpaceSourceCode/JVMDemo/out/production/chapter04/com/atguigu/java/PCRegisterTest.class</span><br><span class="line">  Last modified <span class="number">2020</span>-<span class="number">11</span>-<span class="number">2</span>; size <span class="number">675</span> bytes</span><br><span class="line">  MD5 checksum 53b3ef104479ec9e9b7ce5319e5881d3</span><br><span class="line">  Compiled from <span class="string">&quot;PCRegisterTest.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">atguigu</span>.<span class="title">java</span>.<span class="title">PCRegisterTest</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #6.#26         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = String             #27            // abc</span><br><span class="line">   #3 = Fieldref           #28.#29        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #4 = Methodref          #30.#31        // java/io/PrintStream.println:(I)V</span><br><span class="line">   #5 = Class              #32            // com/atguigu/java/PCRegisterTest</span><br><span class="line">   #6 = Class              #33            // java/lang/Object</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Lcom/atguigu/java/PCRegisterTest;</span><br><span class="line">  #14 = Utf8               main</span><br><span class="line">  #15 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #16 = Utf8               args</span><br><span class="line">  #17 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #18 = Utf8               i</span><br><span class="line">  #19 = Utf8               I</span><br><span class="line">  #20 = Utf8               j</span><br><span class="line">  #21 = Utf8               k</span><br><span class="line">  #22 = Utf8               s</span><br><span class="line">  #23 = Utf8               Ljava/lang/String;</span><br><span class="line">  #24 = Utf8               SourceFile</span><br><span class="line">  #25 = Utf8               PCRegisterTest.java</span><br><span class="line">  #26 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #27 = Utf8               abc</span><br><span class="line">  #28 = Class              #34            // java/lang/System</span><br><span class="line">  #29 = NameAndType        #35:#36        // out:Ljava/io/PrintStream;</span><br><span class="line">  #30 = Class              #37            // java/io/PrintStream</span><br><span class="line">  #31 = NameAndType        #38:#39        // println:(I)V</span><br><span class="line">  #32 = Utf8               com/atguigu/java/PCRegisterTest</span><br><span class="line">  #33 = Utf8               java/lang/Object</span><br><span class="line">  #34 = Utf8               java/lang/System</span><br><span class="line">  #35 = Utf8               out</span><br><span class="line">  #36 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #37 = Utf8               java/io/PrintStream</span><br><span class="line">  #38 = Utf8               println</span><br><span class="line">  #39 = Utf8               (I)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.atguigu.java.PCRegisterTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java/PCRegisterTest;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">5</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">         <span class="number">2</span>: istore_1</span><br><span class="line">         <span class="number">3</span>: bipush        <span class="number">20</span></span><br><span class="line">         <span class="number">5</span>: istore_2</span><br><span class="line">         <span class="number">6</span>: iload_1</span><br><span class="line">         <span class="number">7</span>: iload_2</span><br><span class="line">         <span class="number">8</span>: iadd</span><br><span class="line">         <span class="number">9</span>: istore_3</span><br><span class="line">        10: ldc           #2                  // String abc</span><br><span class="line">        <span class="number">12</span>: astore        <span class="number">4</span></span><br><span class="line">        14: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        <span class="number">17</span>: iload_1</span><br><span class="line">        18: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">        21: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        <span class="number">24</span>: iload_3</span><br><span class="line">        25: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">        <span class="number">28</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">11</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">12</span>: <span class="number">6</span></span><br><span class="line">        line <span class="number">14</span>: <span class="number">10</span></span><br><span class="line">        line <span class="number">15</span>: <span class="number">14</span></span><br><span class="line">        line <span class="number">16</span>: <span class="number">21</span></span><br><span class="line">        line <span class="number">18</span>: <span class="number">28</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">29</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">3</span>      <span class="number">26</span>     <span class="number">1</span>     i   I</span><br><span class="line">            <span class="number">6</span>      <span class="number">23</span>     <span class="number">2</span>     j   I</span><br><span class="line">           <span class="number">10</span>      <span class="number">19</span>     <span class="number">3</span>     k   I</span><br><span class="line">           <span class="number">14</span>      <span class="number">15</span>     <span class="number">4</span>     s   Ljava/lang/String;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;PCRegisterTest.java&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>左边的数字代表<strong>指令地址（指令偏移）</strong>，即 PC 寄存器中可能存储的值，然后执行引擎读取 PC 寄存器中的值，并执行该指令</li>
</ul>
<p><img src="/2020/01/03/JVM-RUNTIME/0009.png"></p>
<h2 id="两个面试题"><a href="#两个面试题" class="headerlink" title="两个面试题"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC3%E7%AB%A0-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA?id=%E4%B8%A4%E4%B8%AA%E9%9D%A2%E8%AF%95%E9%A2%98">两个面试题</a></h2><p><strong>使用PC寄存器存储字节码指令地址有什么用呢？</strong>或者问<strong>为什么使用 PC 寄存器来记录当前线程的执行地址呢？</strong></p>
<ol>
<li>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行</li>
<li>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令</li>
</ol>
<p><img src="/2020/01/03/JVM-RUNTIME/0010.png"></p>
<p><strong>PC寄存器为什么被设定为私有的？</strong></p>
<ol>
<li>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？<strong>为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器</strong>，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</li>
<li>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</li>
<li>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</li>
</ol>
<blockquote>
<p>注意并行和并发的区别，笔者的并发系列有讲</p>
</blockquote>
<h2 id="CPU-时间片"><a href="#CPU-时间片" class="headerlink" title="CPU 时间片"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC3%E7%AB%A0-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA?id=cpu-%E6%97%B6%E9%97%B4%E7%89%87">CPU 时间片</a></h2><ol>
<li><p>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</p>
</li>
<li><p>在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</p>
</li>
<li><p>但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，<strong>每个程序轮流执行</strong>。</p>
</li>
</ol>
<p><img src="/2020/01/03/JVM-RUNTIME/0011.png"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-01-03T02:48:45.000Z" title="1/3/2020, 10:48:45 AM">2020-01-03</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-06-12T03:17:58.630Z" title="6/12/2022, 11:17:58 AM">2022-06-12</time></span><span class="level-item"><a class="link-muted" href="/categories/JAVA/">JAVA</a></span><span class="level-item">32 minutes read (About 4848 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/01/03/JVM-Overview/">JVM_Overview</a></p><div class="content"><p>Mark word</p>
<p>虚拟机是通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。</p>
<p>JVM分类</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/29265430/answer/43818804">https://www.zhihu.com/question/29265430/answer/43818804</a></p>
<p>元空间寸哪些数据?</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/duanxz/p/3520829.html">https://www.cnblogs.com/duanxz/p/3520829.html</a></p>
<p>JVM整体结构</p>
<p><img src="/2020/01/03/JVM-Overview/j_20220607223724.jpg" alt="j_20220607223724"></p>
<p><img src="/2020/01/03/JVM-Overview/j_image-20200704183436495.png"></p>
<p>Java代码执行流程</p>
<p><img src="/2020/01/03/JVM-Overview/j_image-20200704210429535.png"></p>
<p>​    详细图</p>
<p><img src="/2020/01/03/JVM-Overview/j_jvm0002.jpg"></p>
<h2 id="JVM的架构模型"><a href="#JVM的架构模型" class="headerlink" title="JVM的架构模型"></a>JVM的架构模型</h2><p>Java编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。具体来说：这两种架构之间的区别：</p>
<p>基于栈式架构的特点</p>
<ul>
<li>设计和实现更简单，适用于资源受限的系统；</li>
<li>避开了寄存器的分配难题：使用零地址指令方式分配。</li>
<li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现。</li>
<li>不需要硬件支持，可移植性更好，更好实现跨平台</li>
</ul>
<p>基于寄存器架构的特点</p>
<ul>
<li>典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。</li>
<li>指令集架构则完全依赖硬件，可移植性差</li>
<li>性能优秀和执行更高效</li>
<li>花费更少的指令去完成一项操作。</li>
<li>在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主方水洋</li>
</ul>
<p>总结</p>
<p>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p>
<p>时至今日，尽管嵌入式平台已经不是Java程序的主流运行平台了（准确来说应该是HotSpotVM的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？</p>
<p>栈</p>
<ul>
<li>跨平台性</li>
<li>指令集小</li>
<li>指令多</li>
<li>执行性能比寄存器差</li>
</ul>
<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC2%E7%AB%A0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F?id=%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B">类加载过程</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;谢谢ClassLoader加载我....&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;你的大恩大德，我下辈子再报！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的加载过程是怎么样的呢?</p>
<ul>
<li>执行 main() 方法（静态方法）就需要先加载main方法所在类 HelloLoader</li>
<li>加载成功，则进行链接、初始化等操作。完成后调用 HelloLoader 类中的静态方法 main</li>
<li>加载失败则抛出异常</li>
</ul>
<p><img src="/2020/01/03/JVM-Overview/j_jvm0006.png"></p>
<p>完整的流程图如下所示：</p>
<p><img src="/2020/01/03/JVM-Overview/j_0007.png"></p>
<h3 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC2%E7%AB%A0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F?id=%E5%8A%A0%E8%BD%BD%E9%98%B6%E6%AE%B5">加载阶段</a></h3><p><strong>加载：</strong></p>
<ol>
<li>通过一个类的全限定名获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li><strong>在内存中生成一个代表这个类的java.lang.Class对象</strong>，作为方法区这个类的各种数据的访问入口</li>
</ol>
<p><strong>加载class文件的方式：</strong></p>
<ol>
<li>从本地系统中直接加载</li>
<li>通过网络获取，典型场景：Web Applet</li>
<li>从zip压缩包中读取，成为日后jar、war格式的基础</li>
<li>运行时计算生成，使用最多的是：动态代理技术</li>
<li>由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见</li>
<li>从加密文件中获取，典型的防Class文件被反编译的保护措施</li>
</ol>
<h3 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC2%E7%AB%A0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F?id=%E9%93%BE%E6%8E%A5%E9%98%B6%E6%AE%B5">链接阶段</a></h3><p>链接分为三个子阶段：验证 -&gt; 准备 -&gt; 解析</p>
<ol>
<li>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全</li>
<li>主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</li>
</ol>
<p><strong>举例</strong></p>
<p>使用 BinaryViewer软件查看字节码文件，其开头均为 CAFE BABE ，如果出现不合法的字节码文件，那么将会验证不通过。</p>
<h4 id="准备-Prepare"><a href="#准备-Prepare" class="headerlink" title="准备(Prepare)"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC2%E7%AB%A0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F?id=%E5%87%86%E5%A4%87prepare">准备(Prepare)</a></h4><ol>
<li>为类变量（static变量）分配内存并且设置该类变量的默认初始值，即零值</li>
<li>这里不包含用final修饰的static，因为final在编译的时候就会分配好了默认值，准备阶段会显式初始化</li>
<li>注意：这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中</li>
</ol>
<p>代码：变量a在准备阶段会赋初始值，但不是1，而是0，在初始化阶段会被赋值为 1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;<span class="comment">//prepare：a = 0 ---&gt; initial : a = 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解析-Resolve"><a href="#解析-Resolve" class="headerlink" title="解析(Resolve)"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC2%E7%AB%A0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F?id=%E8%A7%A3%E6%9E%90resolve">解析(Resolve)</a></h4><ol>
<li><strong>将常量池内的符号引用转换为直接引用的过程</strong></li>
<li>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行</li>
<li>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</li>
<li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等</li>
</ol>
<p><strong>符号引用</strong></p>
<ul>
<li>反编译 class 文件后可以查看符号引用</li>
</ul>
<h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC2%E7%AB%A0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F?id=%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5">初始化阶段</a></h3><h4 id="类的初始化时机"><a href="#类的初始化时机" class="headerlink" title="类的初始化时机"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC2%E7%AB%A0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F?id=%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E6%9C%BA">类的初始化时机</a></h4><ol>
<li>创建类的实例</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射（比如：Class.forName(“com.atguigu.Test”)）</li>
<li>初始化一个类的子类</li>
<li>Java虚拟机启动时被标明为启动类的类</li>
<li>JDK7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化</li>
</ol>
<p>除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化，即不会执行初始化阶段（不会调用 clinit() 方法和 init() 方法）</p>
<h3 id="clinit"><a href="#clinit" class="headerlink" title="clinit()"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC2%E7%AB%A0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F?id=clinit">clinit()</a></h3><ol>
<li>初始化阶段就是执行类构造器方法<code>&lt;clinit&gt;()</code>的过程</li>
<li>此方法不需定义，是javac编译器自动收集类中的所有<strong>类变量</strong>的赋值动作和静态代码块中的语句合并而来。也就是说，当我们代码中包含static变量的时候，就会有clinit方法</li>
<li><code>&lt;clinit&gt;()</code>方法中的指令按语句在源文件中出现的顺序执行</li>
<li><code>&lt;clinit&gt;()</code>不同于类的构造器。（关联：构造器是虚拟机视角下的<code>&lt;init&gt;()</code>）</li>
<li>若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕</li>
<li>虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁</li>
</ol>
<blockquote>
<p>IDEA 中安装 JClassLib Bytecode viewer 插件，可以很方便的看字节码。安装过程可以自行百度</p>
</blockquote>
<p><img src="/2020/01/03/JVM-Overview/0010.png"></p>
<h4 id="5说明"><a href="#5说明" class="headerlink" title="5说明"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC2%E7%AB%A0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F?id=_5%E8%AF%B4%E6%98%8E">5说明</a></h4><p>若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕</p>
<p><img src="/2020/01/03/JVM-Overview/j_0013.png"></p>
<p>如上代码，加载流程如下：</p>
<ul>
<li>首先，执行 main() 方法需要加载 ClinitTest1 类</li>
<li>获取 Son.B 静态变量，需要加载 Son 类</li>
<li>Son 类的父类是 Father 类，所以需要先执行 Father 类的加载，再执行 Son 类的加载</li>
</ul>
<h4 id="6说明"><a href="#6说明" class="headerlink" title="6说明"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC2%E7%AB%A0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F?id=_6%E8%AF%B4%E6%98%8E">6说明</a></h4><p>虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable r = () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始&quot;</span>);</span><br><span class="line">            DeadThread dead = <span class="keyword">new</span> DeadThread();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r,<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r,<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeadThread</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;初始化当前类&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">线程2开始</span><br><span class="line">线程1开始</span><br><span class="line">线程2初始化当前类</span><br><span class="line"></span><br><span class="line">&#x2F;然后程序卡死了</span><br></pre></td></tr></table></figure>

<p>程序卡死，分析原因：</p>
<ul>
<li>两个线程同时去加载 DeadThread 类，而 DeadThread 类中静态代码块中有一处死循环</li>
<li>先加载 DeadThread 类的线程抢到了同步锁，然后在类的静态代码块中执行死循环，而另一个线程在等待同步锁的释放</li>
<li>所以无论哪个线程先执行 DeadThread 类的加载，另外一个类也不会继续执行。（一个类只会被加载一次）</li>
</ul>
<h2 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC2%E7%AB%A0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F?id=%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB">类加载器的分类</a></h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC2%E7%AB%A0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F?id=%E6%A6%82%E8%BF%B0-1">概述</a></h3><ol>
<li>JVM严格来讲支持两种类型的类加载器 。分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）</li>
<li>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是<strong>将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</strong></li>
<li>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示</li>
</ol>
<p><img src="/2020/01/03/JVM-Overview/j_0014.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取系统类加载器</span></span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取其上层：扩展类加载器</span></span><br><span class="line">        ClassLoader extClassLoader = systemClassLoader.getParent();</span><br><span class="line">        System.out.println(extClassLoader);<span class="comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取其上层：获取不到引导类加载器</span></span><br><span class="line">        ClassLoader bootstrapClassLoader = extClassLoader.getParent();</span><br><span class="line">        System.out.println(bootstrapClassLoader);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//对于用户自定义类来说：默认使用系统类加载器进行加载</span></span><br><span class="line">        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//String类使用引导类加载器进行加载的。---&gt; Java的核心类库都是使用引导类加载器进行加载的。</span></span><br><span class="line">        ClassLoader classLoader1 = String.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader1);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们尝试获取引导类加载器，获取到的值为 null ，这并不代表引导类加载器不存在，<strong>因为引导类加载器右 C/C++ 语言，我们获取不到</strong></li>
<li>两次获取系统类加载器的值都相同：sun.misc.Launcher$AppClassLoader@18b4aac2 ，这说明<strong>系统类加载器是全局唯一的</strong></li>
</ul>
<h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC2%E7%AB%A0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F?id=%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6">双亲委派机制</a></h2><h3 id="双亲委派机制原理"><a href="#双亲委派机制原理" class="headerlink" title="双亲委派机制原理"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC2%E7%AB%A0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F?id=%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86">双亲委派机制原理</a></h3><p>ava虚拟机对class文件采用的是<strong>按需加载</strong>的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式</p>
<ol>
<li><p>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</p>
</li>
<li><p>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</p>
</li>
<li><p>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</p>
</li>
<li><p>父类加载器一层一层往下分配任务，如果子类加载器能加载，则加载此类，如果将加载任务分配至系统类加载器也无法加载此类，则抛出异常</p>
<p><img src="/2020/01/03/JVM-Overview/j_0020.png"></p>
</li>
</ol>
<h3 id="双亲委派机制代码演示"><a href="#双亲委派机制代码演示" class="headerlink" title="双亲委派机制代码演示"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC2%E7%AB%A0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F?id=%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA">双亲委派机制代码演示</a></h3><h4 id="举例1"><a href="#举例1" class="headerlink" title="举例1"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC2%E7%AB%A0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F?id=%E4%B8%BE%E4%BE%8B1">举例1</a></h4><p>1、我们自己建立一个 java.lang.String 类，写上 static 代码块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是自定义的String类的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、在另外的程序中加载 String 类，看看加载的 String 类是 JDK 自带的 String 类，还是我们自己编写的 String 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        java.lang.String str = <span class="keyword">new</span> java.lang.String();</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,atguigu.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        StringTest test = <span class="keyword">new</span> StringTest();</span><br><span class="line">        System.out.println(test.getClass().getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello,atguigu.com</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br></pre></td></tr></table></figure>

<p>程序并没有输出我们静态代码块中的内容，可见仍然加载的是 JDK 自带的 String 类。</p>
<p>把刚刚的类改一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是自定义的String类的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//错误: 在类 java.lang.String 中找不到 main 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,String&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/01/03/JVM-Overview/j_0021.png"></p>
<p>由于双亲委派机制一直找父类，所以最后找到了Bootstrap ClassLoader，Bootstrap ClassLoader找到的是 JDK 自带的 String 类，在那个String类中并没有 main() 方法，所以就报了上面的错误。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShkStart</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">java.lang.SecurityException: Prohibited <span class="keyword">package</span> name: java.lang</span><br><span class="line">    at java.lang.ClassLoader.preDefineClass(ClassLoader.java:<span class="number">662</span>)</span><br><span class="line">    at java.lang.ClassLoader.defineClass(ClassLoader.java:<span class="number">761</span>)</span><br><span class="line">    at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:<span class="number">142</span>)</span><br><span class="line">    at java.net.URLClassLoader.defineClass(URLClassLoader.java:<span class="number">467</span>)</span><br><span class="line">    at java.net.URLClassLoader.access$<span class="number">100</span>(URLClassLoader.java:<span class="number">73</span>)</span><br><span class="line">    at java.net.URLClassLoader$<span class="number">1.</span>run(URLClassLoader.java:<span class="number">368</span>)</span><br><span class="line">    at java.net.URLClassLoader$<span class="number">1.</span>run(URLClassLoader.java:<span class="number">362</span>)</span><br><span class="line">    at java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">    at java.net.URLClassLoader.findClass(URLClassLoader.java:<span class="number">361</span>)</span><br><span class="line">    at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">424</span>)</span><br><span class="line">    at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:<span class="number">335</span>)</span><br><span class="line">    at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">357</span>)</span><br><span class="line">    at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:<span class="number">495</span>)</span><br><span class="line">Error: A JNI error has occurred, please check your installation and <span class="keyword">try</span> again</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> </span><br><span class="line">Process finished with exit code <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>即使类名没有重复，也禁止使用java.lang这种包名。这是一种保护机制</p>
<h4 id="举例3"><a href="#举例3" class="headerlink" title="举例3"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC2%E7%AB%A0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F?id=%E4%B8%BE%E4%BE%8B3">举例3</a></h4><p>当我们加载jdbc.jar 用于实现数据库连接的时候</p>
<ol>
<li>我们现在程序中需要用到SPI接口，而SPI接口属于rt.jar包中Java核心api</li>
<li>然后使用双清委派机制，引导类加载器把rt.jar包加载进来，而rt.jar包中的SPI存在一些接口，接口我们就需要具体的实现类了</li>
<li>具体的实现类就涉及到了某些第三方的jar包了，比如我们加载SPI的实现类jdbc.jar包【首先我们需要知道的是 jdbc.jar是基于SPI接口进行实现的】</li>
<li>第三方的jar包中的类属于系统类加载器来加载</li>
<li>从这里面就可以看到SPI核心接口由引导类加载器来加载，SPI具体实现类由系统类加载器来加载</li>
</ol>
<p><img src="/2020/01/03/JVM-Overview/j_0022.png"></p>
<h3 id="双亲委派机制优势"><a href="#双亲委派机制优势" class="headerlink" title="双亲委派机制优势"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC2%E7%AB%A0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F?id=%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E4%BC%98%E5%8A%BF">双亲委派机制优势</a></h3><p>通过上面的例子，我们可以知道，双亲机制可以</p>
<ol>
<li><p>避免类的重复加载</p>
</li>
<li><p>保护程序安全，防止核心API被随意篡改</p>
<ul>
<li><p>自定义类：自定义java.lang.String 没有被加载。</p>
</li>
<li><p>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）</p>
</li>
</ul>
</li>
</ol>
<h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC2%E7%AB%A0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F?id=%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6">沙箱安全机制</a></h2><ol>
<li>自定义String类时：在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java.lang.String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。</li>
<li>这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC2%E7%AB%A0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F?id=%E5%85%B6%E4%BB%96">其他</a></h2><h3 id="如何判断两个class对象是否相同？"><a href="#如何判断两个class对象是否相同？" class="headerlink" title="如何判断两个class对象是否相同？"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC2%E7%AB%A0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F?id=%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AAclass%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E7%9B%B8%E5%90%8C%EF%BC%9F">如何判断两个class对象是否相同？</a></h3><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p>
<ol>
<li>类的完整类名必须一致，包括包名</li>
<li><strong>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同</strong></li>
<li>换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的</li>
</ol>
<h3 id="对类加载器的引用"><a href="#对类加载器的引用" class="headerlink" title="对类加载器的引用"></a><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/docs/Java/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC2%E7%AB%A0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F?id=%E5%AF%B9%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%BC%95%E7%94%A8">对类加载器的引用</a></h3><ol>
<li>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的</li>
<li><strong>如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</strong></li>
<li>当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的（后面讲）</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/javayouth/#/?id=java">https://youthlql.gitee.io/javayouth/#/?id=java</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-08-30T02:00:40.000Z" title="8/30/2019, 10:00:40 AM">2019-08-30</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-08-19T11:11:44.252Z" title="8/19/2021, 7:11:44 PM">2021-08-19</time></span><span class="level-item"><a class="link-muted" href="/categories/JAVA/">JAVA</a></span><span class="level-item">a few seconds read (About 11 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/08/30/ThreadStop/">ThreadStop</a></p><div class="content"><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000007961347">https://segmentfault.com/a/1190000007961347</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xingele0917/p/3994468.html">https://www.cnblogs.com/xingele0917/p/3994468.html</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2018-11-03T01:48:09.000Z" title="11/3/2018, 9:48:09 AM">2018-11-03</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-08-19T11:11:44.302Z" title="8/19/2021, 7:11:44 PM">2021-08-19</time></span><span class="level-item"><a class="link-muted" href="/categories/JAVA/">JAVA</a></span><span class="level-item">a few seconds read (About 67 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2018/11/03/mina/">mina</a></p><div class="content"><p>MINA配置</p>
<ul>
<li>下载 <a target="_blank" rel="noopener" href="http://mina.apache.org/mina-project/downloads.html">http://mina.apache.org/mina-project/downloads.html</a>   <a target="_blank" rel="noopener" href="http://mirrors.shu.edu.cn/apache/mina/mina/2.0.19/apache-mina-2.0.19-bin.zip"><strong>apache-mina-2.0.19-bin.zip</strong></a> 解压</li>
<li>下载 <a target="_blank" rel="noopener" href="https://www.slf4j.org/download.html">https://www.slf4j.org/download.html</a>   slf4j-1.7.25.zip解压</li>
</ul>
<p>在MineUtil项目中有demo实现</p>
<p>IM键盘</p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5ef850c9f265da231019f6e4">https://juejin.im/post/5ef850c9f265da231019f6e4</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2018-07-11T06:23:20.000Z" title="7/11/2018, 2:23:20 PM">2018-07-11</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-08-19T11:11:44.095Z" title="8/19/2021, 7:11:44 PM">2021-08-19</time></span><span class="level-item"><a class="link-muted" href="/categories/JAVA/">JAVA</a></span><span class="level-item">a few seconds read (About 74 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2018/07/11/Lambda/">Lambda</a></p><div class="content"><p><a target="_blank" rel="noopener" href="http://blog.oneapm.com/apm-tech/226.html">http://blog.oneapm.com/apm-tech/226.html</a></p>
<p>android </p>
<p><a target="_blank" rel="noopener" href="https://maxwell-nc.github.io/android/retrolambda.html">https://maxwell-nc.github.io/android/retrolambda.html</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1526621">https://cloud.tencent.com/developer/article/1526621</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903668592934925">https://juejin.im/post/6844903668592934925</a></p>
<p>kotlin  lambda</p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903604613021703">https://juejin.im/post/6844903604613021703</a></p>
<p>Video</p>
<h4 id="Java-lambda"><a href="#Java-lambda" class="headerlink" title="Java lambda"></a>Java lambda</h4><p>函数式编程</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av54941486/">https://www.bilibili.com/video/av54941486/</a></p>
<p><a target="_blank" rel="noopener" href="http://www.chilangedu.com/sectionq/2132352424">http://www.chilangedu.com/sectionq/2132352424</a></p>
<h5 id="map"><a href="#map" class="headerlink" title="map"></a>map</h5><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; Stream&lt;R&gt; <span class="keyword">map</span>(<span class="built_in">Function</span>&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> R&gt; mapper);</span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">Function</span>&lt;<span class="symbol">T</span>, <span class="symbol">R</span>&gt; &#123;</span><br><span class="line">	    R apply(T t); <span class="comment">//将T类型转为R</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/categories/JAVA/">Previous</a></div><div class="pagination-next"><a href="/categories/JAVA/page/3/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/categories/JAVA/">1</a></li><li><a class="pagination-link is-current" href="/categories/JAVA/page/2/">2</a></li><li><a class="pagination-link" href="/categories/JAVA/page/3/">3</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Your name"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Your name</p><p class="is-size-6 is-block">Your title</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Your location</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">221</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">18</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">31</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/ANDROID/"><span class="level-start"><span class="level-item">ANDROID</span></span><span class="level-end"><span class="level-item tag">58</span></span></a></li><li><a class="level is-mobile" href="/categories/BLE/"><span class="level-start"><span class="level-item">BLE</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/DataStructure/"><span class="level-start"><span class="level-item">DataStructure</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/DesignPatterns/"><span class="level-start"><span class="level-item">DesignPatterns</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/ENGLISH/"><span class="level-start"><span class="level-item">ENGLISH</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/JAVA/"><span class="level-start"><span class="level-item">JAVA</span></span><span class="level-end"><span class="level-item tag">27</span></span></a></li><li><a class="level is-mobile" href="/categories/Jetpack/"><span class="level-start"><span class="level-item">Jetpack</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Kotlin/"><span class="level-start"><span class="level-item">Kotlin</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/LINUX/"><span class="level-start"><span class="level-item">LINUX</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Mathematics/"><span class="level-start"><span class="level-item">Mathematics</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/OS/"><span class="level-start"><span class="level-item">OS</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Organization/"><span class="level-start"><span class="level-item">Organization</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/SOURCE/"><span class="level-start"><span class="level-item">SOURCE</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/TEST/"><span class="level-start"><span class="level-item">TEST</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/TOOL/"><span class="level-start"><span class="level-item">TOOL</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/VIEW/"><span class="level-start"><span class="level-item">VIEW</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/anim/"><span class="level-start"><span class="level-item">anim</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/flutter/"><span class="level-start"><span class="level-item">flutter</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-10-21T15:18:58.000Z">2023-10-21</time></p><p class="title"><a href="/2023/10/21/proxy/">proxy</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-09-04T07:54:57.000Z">2023-09-04</time></p><p class="title"><a href="/2023/09/04/Android_interview%20organize/">Android_itnerview_organize</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-09-03T07:54:57.000Z">2023-09-03</time></p><p class="title"><a href="/2023/09/03/Android-itnerview-algorithm/">Android_itnerview_algorithm</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-08-20T13:41:06.000Z">2023-08-20</time></p><p class="title"><a href="/2023/08/20/compose-layout/">compose_layout</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-08-19T09:16:56.000Z">2023-08-19</time></p><p class="title"><a href="/2023/08/19/compose/">compose</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/"><span class="level-start"><span class="level-item">2022</span></span><span class="level-end"><span class="level-item tag">33</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/"><span class="level-start"><span class="level-item">2021</span></span><span class="level-end"><span class="level-item tag">23</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/"><span class="level-start"><span class="level-item">2020</span></span><span class="level-end"><span class="level-item tag">46</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/"><span class="level-start"><span class="level-item">2019</span></span><span class="level-end"><span class="level-item tag">21</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/"><span class="level-start"><span class="level-item">2018</span></span><span class="level-end"><span class="level-item tag">32</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/"><span class="level-start"><span class="level-item">2017</span></span><span class="level-end"><span class="level-item tag">57</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/ANDROID/"><span class="tag">ANDROID</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AOSP/"><span class="tag">AOSP</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Activity/"><span class="tag">Activity</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AndroidNewFeatures/"><span class="tag">AndroidNewFeatures</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Assembly/"><span class="tag">Assembly</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BLOG/"><span class="tag">BLOG</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ConstraintLayout/"><span class="tag">ConstraintLayout</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DB/"><span class="tag">DB</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Drawer/"><span class="tag">Drawer</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Fragment/"><span class="tag">Fragment</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JVM/"><span class="tag">JVM</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LEETCODE/"><span class="tag">LEETCODE</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Operators/"><span class="tag">Operators</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Performance/"><span class="tag">Performance</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RecyclerView/"><span class="tag">RecyclerView</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RxJava/"><span class="tag">RxJava</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/THINK/"><span class="tag">THINK</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TOOL/"><span class="tag">TOOL</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TabLayout/"><span class="tag">TabLayout</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Test/"><span class="tag">Test</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TouchEvent/"><span class="tag">TouchEvent</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/VIEW/"><span class="tag">VIEW</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/XML/"><span class="tag">XML</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/anim/"><span class="tag">anim</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/compose/"><span class="tag">compose</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/concurrency/"><span class="tag">concurrency</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/coroutie/"><span class="tag">coroutie</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/inter/"><span class="tag">inter</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/keyboard/"><span class="tag">keyboard</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/proguard/"><span class="tag">proguard</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe for updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Hexo" height="28"></a><p class="is-size-7"><span>&copy; 2023 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>