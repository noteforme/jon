{"meta":{"title":"Jon's Blog","subtitle":"Cease to struggle and you cease to live. - Thomas Carlyle","description":null,"author":"Jon","url":"http://noteforme.github.io.com"},"pages":[{"title":"categories","date":"2017-08-01T05:08:13.000Z","updated":"2021-08-19T11:11:44.326Z","comments":true,"path":"categories/index.html","permalink":"http://noteforme.github.io.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-08-08T02:14:45.000Z","updated":"2021-08-19T11:11:44.326Z","comments":true,"path":"tags/index.html","permalink":"http://noteforme.github.io.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"kotlin-senior2","slug":"kotlin-senior2","date":"2021-09-11T10:04:06.000Z","updated":"2021-09-11T10:17:04.083Z","comments":true,"path":"2021/09/11/kotlin-senior2/","link":"","permalink":"http://noteforme.github.io.com/2021/09/11/kotlin-senior2/","excerpt":"","text":"函数类型函数类型的书写格式所有函数类型都有一个圆括号括起来的参数类型列表，以及一个返回类型：(A, B) -&gt; C ，参数列表与返回值类型之间通过 -&gt; 符号连接。(A, B) -&gt; C表示接收类型分别为 A 与 B 两个参数并返回一个 C 类型值的函数类型。 1val f: (Int) -&gt; String (Int) -&gt; String这就是一个函数类型。另外需要注意的是，即使函数类型的参数列表为空，也必须保留小括号，例如() -&gt; String；即使函数类型的返回值类型为Unit，也不可省略Unit不写，例如：(Int) -&gt; Unit。 函数类型的对象使用sum(1, 2)这我可以理解，毕竟sum是一个函数，但是block(1, 2)这样也行？block可是一个函数类型的对象啊，函数类型的对象后面可以加括号调用？ 没错，只有函数类型的对象可以，其实这是Kotlin为我们提供的一个语法糖，它本质上还是会去调用invoke函数，也就是说 12345val block: (Int, Int) -&gt; Int = ::sumfun sum(firstNumber: Int, secondNumber: Int): Int &#123; return firstNumber + secondNumber&#125; 12345678910val block: (Int, Int) -&gt; Int = ::sum// 以下调用都是有返回值的,因为(Int, Int) -&gt; Int这个函数类型是有返回值的block(1, 2)// 等价于block.invoke(1, 2)// 等价于(::sum)(1, 2)// 等价于(::sum).invoke(1, 2) Kotlin使用这种（函数类型对象能够使用括号访问）语法让我们感觉，嗯，block就是sum函数的替身，而实际上它是一个对象，一个函数类型的对象。 高阶函数什么是高阶函数12345btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125;&#125;); 有没有想过为什么需要传一个匿名类过去？因为Framework会在该View被点击的时候调用我们在匿名类中实现的那个onClick方法，以便于执行我们自己的处理逻辑。 要是我们能直接将方法传过去就好了…梦该醒了，这是Java，只能通过接口 + 匿名内部类这种折中的方案来实现这样的需求。 而Kotlin有了函数类型，又有了高阶函数，意味着我们可以传入一段代码给函数了，函数可以在适当的时候执行我们传入的那段代码，完美的解决了这一痛点。 高阶函数的使用案例虽然都是过滤找出符合要求的苹果，但是条件是不一样的。这个怎么做呢？最简单的方法就是写三个循环，每个循环中针对不同的条件对苹果集合进行筛选。但是我们完全可以使用高阶函数和函数类型优雅的实现这个功能： 123456789private fun filterApple(appleList: List&lt;AppleBean&gt;, predicate: (AppleBean) -&gt; Boolean): List&lt;AppleBean&gt; &#123; val destination = mutableListOf&lt;AppleBean&gt;() for (appleBean in appleList) &#123; if (predicate(appleBean))&#123; destination.add(appleBean) &#125; &#125; return destination&#125; ，filterApple函数主要的功能只是遍历集合，以及把符合条件的苹果添加到新的集合中返回，至于筛选的条件，filterApple函数并不知道，而是完全取决于predicate这个函数类型的参数，只要predicate返回true，则符合条件。这样我们可以在调用函数时动态地传入不同的过滤规则 123456789101112131415161718192021fun main() &#123; filterApple(appleList, ::filterColorPredicate) filterApple(appleList, ::filterWeightPredicate) filterApple(appleList, ::filterColorAndWeightPredicate)&#125;private fun filterColorPredicate(appleBean: AppleBean): Boolean = appleBean.color == 0xFF0000private fun filterWeightPredicate(appleBean: AppleBean): Boolean = appleBean.weight &gt; 6private fun filterColorAndWeightPredicate(appleBean: AppleBean): Boolean = appleBean.color == 0xFF0000 &amp;&amp; appleBean.weight &gt; 6private fun filterApple(appleList: List&lt;AppleBean&gt;, predicate: (AppleBean) -&gt; Boolean): List&lt;AppleBean&gt; &#123; val destination = mutableListOf&lt;AppleBean&gt;() for (appleBean in appleList) &#123; if (predicate(appleBean)) &#123; destination.add(appleBean) &#125; &#125; return destination&#125; 这…太麻烦了吧，我每次调用高阶函数，传入函数类型的时候，还必须要先定义一个函数，然后再使用::函数名传入吗？其实不必这么麻烦的，现在我们学习的只不过是其中的一种方式而已。下面我们就要来学习更加简单的方式：匿名函数。 Lambda表达式Lambda表达式、匿名函数、双冒号+函数名这三个东西，都是函数类型的对象，他们都能够赋值给变量以及当作函数的参数传递！ Lambda表达式的格式 Lambda表达式被大括号包围着 Lambda表达式的参数在-&gt;的左边，如果没有参数，则只保留函数体 Lambda表达式的函数体在-&gt;的后面 Lambda表达式的返回类型值总为函数体最后一行代码的返回值类型 无参数，无返回值的Lambda表达式123val test01Lambda = &#123; print(&quot;无参数,无返回值&quot;)&#125; 我们同样将Lambda表达式赋值给了变量，这个变量是函数类型（() -&gt; Unit）的对象。 有参数，无返回值的Lambda表达式123val test02Lambda = &#123; name: String -&gt; print(&quot;有参数,无返回值，参数值为：$name&quot;)&#125; 这个变量是函数类型（(String) -&gt; Unit）的对象。 如果我们手动给这个变量指明了类型，那么Lambda的参数类型还可以不写： 123val test02Lambda: (String) -&gt; Unit = &#123; name -&gt; print(&quot;有参数,无返回值，参数值为：$name&quot;)&#125; 这个时候，Kotlin可以自动为我们推断出Lambda中这个参数的类型是String类型。 如果Lambda表达式的参数只有一个，我们甚至连这个参数都可以省略不写，那…我想使用这个参数的时候怎么办呢？我们可以用it来代替： 123val test02Lambda: (String) -&gt; Unit = &#123; print(&quot;有参数,无返回值，参数值为：$it&quot;)&#125; 有参数，有返回值的Lambda表达式12345val test03Lambda = &#123; doubleValue: Double -&gt; print(&quot;parameter is Double,Value is:$doubleValue&quot;) print(&quot;now parse Double into String&quot;) doubleValue.toString()&#125; Lambda表达式的最后一行代码将作为返回值，因此它对应的函数类型为：(Double) -&gt; String。同样，如果变量已经确切的指定了类型，则Lambda表达式的参数类型可以省略，又由于只有一个参数，所以连参数都可以省略，Kotlin将使用it代替这个参数名。 123456789101112131415161718192021222324252627val method: (String, String) -&gt; Unit = &#123; aStr, bStr -&gt; println(&quot;a : $aStr, b:$bStr&quot;) &#125;method(&quot;john&quot;,&quot;男&quot;)val method02 = &#123; println(&quot;john&quot;)&#125;val method03:(String)-&gt;Unit=&#123; println(&quot;传入的是:$it&quot;)&#125;method03(&quot;Jon&quot;)val method04:(Int)-&gt;Unit=&#123; when(it)&#123; 1-&gt; println(&quot;等于1&quot;) in 20.. 30 -&gt; println(&quot;20 - 30的数字&quot;) else -&gt; println(&quot;都不满足&quot;) &#125;&#125;method04(1)val method05 : (Int,Int)-&gt; Unit = &#123;aNumber,bNumber-&gt; println(&quot;第一个: $aNumber, 第二个 : $bNumber&quot;)&#125;method05(1,9)val method06 : (Int,Int)-&gt; Unit = &#123;aNumber,_-&gt; println(&quot;第一个: $aNumber&quot;)&#125;method06(99,88)val method07 : (String)-&gt;String = &#123;str -&gt; str&#125;println(method07(&quot;Jon&quot;)) 项目实例Login01.kt123456789101112131415161718//传入一个具名函数，被调用后，获取参数fun test(resModel: ResModel)&#123; println(resModel.int)&#125;class LoginModelImpl &#123; fun loginOptions( mobileNo: String, metaInfo: String, block: (model: ResModel) -&gt; Unit ) &#123; val model = ResModel(8) block(model) // block.invoke(model) 这样写也可以 &#125;&#125;class ResModel(val int: Int) 1234567 val loginModelImpl = LoginModelImpl() val responseModel = ResModel(0) loginModelImpl.loginOptions(&quot;&quot;,&quot;&quot;,::test) // 可以看到 fun test(resModel: ResModel)也被调用,可以理解被回调// loginModelImpl.loginOptions(&quot;&quot;,&quot;&quot;,&#123;model: ResModel -&gt; model.toString() &#125;)// loginModelImpl.loginOptions(&quot;&quot;,&quot;&quot;,&#123;model -&gt; model.toString() &#125;) loginModelImpl.loginOptions(&quot;&quot;,&quot;&quot;,&#123;println(it.int)&#125;) //lambda只有一个参数，传入参数也可以省略,&#123;&#125;里面用it代替// loginModelImpl.loginOptions(&quot;&quot;,&quot;&quot;,&#123;&#125;) // it可以用也可以不用 Login02.kt1234567891011121314151617181920fun main() &#123; loginAction(&quot;Jo1n&quot;, &quot;123456&quot;) &#123; if (it) &#123; println(&quot;登录成功&quot;) &#125; else println(&quot;登录失败&quot;) &#125;&#125;fun loginAction(userName: String, pwd: String, loginResponseResult: (Boolean) -&gt; Unit) &#123; if (userName == null || pwd == null) return loginEngine(userName, pwd, loginResponseResult)&#125;fun loginEngine(userName: String, pwd: String, loginResponseResult: (Boolean) -&gt; Unit) &#123; if (&quot;Jon&quot; == userName &amp;&amp; &quot;123456&quot; == pwd) &#123; loginResponseResult(true) &#125; else loginResponseResult(false)&#125; https://www.bilibili.com/video/BV1xv411k7Dd?p=3&amp;spm_id_from=pageDriver Lambda表达式与高阶函数现在大家已经对Lambda表达式的写法了如指掌了，现在是时候来看看Lambda表达式如何与高阶函数配合使用了。还记得之前的那个筛选苹果的例子吗？我们定义了一个高阶函数，它的名字叫：filterApple，代码如下： 123456789private fun filterApple(appleList: List&lt;AppleBean&gt;, predicate: (AppleBean) -&gt; Boolean): List&lt;AppleBean&gt; &#123; val destination = mutableListOf&lt;AppleBean&gt;() for (appleBean in appleList) &#123; if (predicate(appleBean)) &#123; destination.add(appleBean) &#125; &#125; return destination&#125; 这个高阶函数的第二个参数接收了一个函数类型的参数，在之前，我们分别使用了两种方式进行调用： 双冒号的方式： 12345fun main() &#123; filterApple(appleList, ::filterColorPredicate)&#125;private fun filterColorPredicate(appleBean: AppleBean): Boolean = appleBean.color == 0xFF0000 匿名函数的方式： 1filterApple(appleList, fun(appleBean: AppleBean): Boolean = appleBean.weight &gt; 6) 完整的写法 1filterApple(appleList, &#123; appleBean: AppleBean -&gt; appleBean.weight &gt; 6 &#125;) 简化的写法 我们怎么知道哪个参数需要传入Lambda表达式呢？当然是看被调用的这个高阶函数的定义啊，还记的这个高阶函数的样子吗？ 我们怎么知道哪个参数需要传入Lambda表达式呢？当然是看被调用的这个高阶函数的定义啊，还记的这个高阶函数的样子吗？ 123private fun filterApple(appleList: List&lt;AppleBean&gt;, predicate: (AppleBean) -&gt; Boolean): List&lt;AppleBean&gt; &#123; // ...&#125; 显然第二个形参是一个函数类型的参数，并且已经明确的指出了形参的函数类型：(AppleBean) -&gt; Boolean（实际上也必须明确指出，否则报错）。根据我们前面所学习的知识，这种情况下，我们可以直接省略Lambda表达式中的参数类型，Kotlin会根据上下文自动推断： 1filterApple(appleList, &#123; appleBean -&gt; appleBean.weight &gt; 6 &#125;) 再简化的写法 由于这个函数类型只需要一个参数，因此我们还可以省略参数的名字，Kotlin会使用it代替，这在之前的Lambda讲解中，都是讲过的： 1filterApple(appleList, &#123; it.weight &gt; 6 &#125;) 再再简化的写法 第一个是：如果Lambda表达式作为函数的最后一个参数传入，那么它可以单独放在调用函数的括号后面： 1filterApple(appleList) &#123; it.weight &gt; 6 &#125; 第二个是：如果函数只接收一个函数类型的参数，我们传入Lambda表达式时，连函数调用的括号都可以去掉： 123456789fun main() &#123; test &#123; num1, num2 -&gt; // ... &#125;&#125;private fun test(block: (Int, Int) -&gt; Unit) &#123; // ...&#125; ​ 作者：HurryYu_YZH​ 链接：https://www.jianshu.com/p/8eb0623f08c6","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://noteforme.github.io.com/categories/Kotlin/"}],"tags":[],"keywords":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://noteforme.github.io.com/categories/Kotlin/"}]},{"title":"Leetcode_Linklist","slug":"Leetcode-Linklist","date":"2021-08-30T13:03:37.000Z","updated":"2021-08-30T13:09:19.967Z","comments":true,"path":"2021/08/30/Leetcode-Linklist/","link":"","permalink":"http://noteforme.github.io.com/2021/08/30/Leetcode-Linklist/","excerpt":"","text":"160. 相交链表给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。 图示两个链表在节点 c1 开始相交： 123456789101112public class Solution_160 &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; ListNode la = headA; ListNode lb = headB; while(la!=lb)&#123; la = (la==null) ? headB : la.next; lb = (lb==null) ? headA : lb.next ; &#125; return la; &#125;&#125; 先走自己的路，再走对方的路，最终路程一样 可以这么理解，a，b两个链表，变更为 a+b 和 b+a，长度就相等了，然后等步遍历判断是否相等就行了 原始的数据 修改后的数据示意图 !()","categories":[{"name":"DataStructure","slug":"DataStructure","permalink":"http://noteforme.github.io.com/categories/DataStructure/"}],"tags":[],"keywords":[{"name":"DataStructure","slug":"DataStructure","permalink":"http://noteforme.github.io.com/categories/DataStructure/"}]},{"title":"Dagger","slug":"Dagger","date":"2021-08-29T12:45:53.000Z","updated":"2021-08-30T01:54:10.617Z","comments":true,"path":"2021/08/29/Dagger/","link":"","permalink":"http://noteforme.github.io.com/2021/08/29/Dagger/","excerpt":"","text":"依赖注入 构造方法注入 Setter注入(字段注入) IOC框架 基于反射的方式实现： Spring IOC(动态的进行依赖关系的建立) 静态方式 ： 程序在编译时就已经提供好了建立依赖关系的类 两种注入方式 Dagger注入构造方法注入构造方法构造实例注入0 使用 @Inject注解在构造方法上；就是告知Dagger可以通过构造方法来创建并获取到User的实例 1234567public class User &#123; // 1.使用 @Inject注解在构造方法上；就是告知Dagger可以通过构造方法来创建并获取到User的实例 @Inject public User() &#123; //构造方法构造实例 &#125;&#125; 当作IOC容器,把对象注入到目标类中 12345// 2. 当作IOC容器,把对象注入到目标类中@Componentpublic interface ApplicationComponent &#123; void inject(DaggerActivity daggerActivity);//指定目标类&#125; 设置Inject注解 DaggerActivity.java 123//3.设置Inject注解@InjectUser user; 执行注入动作 12345678 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_dagger2);//4.执行注入动作 DaggerApplicationComponent.create().inject(this);//DaggerApplicationComponent相当于DaggerApplication的实现类 Log.i(TAG, &quot;user: &quot; + user); &#125; 针对第三方库 第二种方式告知Dagger,可以通过调用该方法来获取到注入对象的实例 1234567891011@Modulepublic class NetModule &#123; //第二种方式告知Dagger,可以通过调用该方法来获取到注入对象的实例 @Provides public Retrofit provideRetrofit()&#123; return new Retrofit.Builder() .baseUrl(&quot;http://www.google.com&quot;) .build(); &#125;&#125; compoent 1234// 2. 当作IOC容器,把对象注入到目标类中@Component(modules = &#123;NetModule.class&#125;)public interface ApplicationComponent &#123;&#125; DaggerActivity.java 1234567891011public class DaggerActivity extends AppCompatActivity &#123; String TAG = &quot;DaggerActivity&quot;; //3.设置Inject注解 @Inject Retrofit retrofit; Log.i(TAG, &quot;retrofit: &quot; + retrofit);&#125; 复杂使用场景​ 12345public interface ApiService &#123; @GET(&quot;/user/info&quot;) Call&lt;String&gt; requestInfo();&#125; 12345678//Module已经知道怎么获取retrofit实例//接着同一个Module中的方法，就可以作为参数直接传入 使用// 比如provideApiService需要Retrofit实例，会从当前容器查找是否已经有Retrofit实例// 然后从当前容器直接获取@Providespublic ApiService provideApiService(Retrofit retrofit)&#123; return retrofit.create(ApiService.class);&#125; 12345@InjectApiService apiService;Log.i(TAG, &quot;apiService: &quot; +apiService); Module已经知道怎么获取retrofit实例接着同一个Module中的方法，就可以作为参数直接传入 使用// 比如provideApiService需要Retrofit实例，会从当前容器查找是否已经有Retrofit实例// 然后从当前容器直接获取 123456789101112131415161718192021222324252627@Modulepublic class NetModule &#123; //第二种方式告知Dagger,可以通过调用该方法来获取到注入对象的实例 @Provides public Retrofit provideRetrofit()&#123; return new Retrofit.Builder() .baseUrl(&quot;http://www.google.com&quot;) .build(); &#125; //Module已经知道怎么获取retrofit实例 //接着同一个Module中的方法，就可以作为参数直接传入 使用 // 比如provideApiService需要Retrofit实例，会从当前容器查找是否已经有Retrofit实例 // 然后从当前容器直接获取 @Provides public ApiService provideApiService(Retrofit retrofit)&#123; return retrofit.create(ApiService.class); &#125; @Provides public OkHttpClient provideOkHttpClient() &#123; return new OkHttpClient.Builder().build(); &#125;&#125; 局部单例实现 3个对象实例指定了作用域是 @Singleton,这个作用域和使用了@Singleton组件的生命周期一致。 局部实例112345678910111213141516171819202122232425262728293031@Modulepublic class NetModule &#123; //第二种方式告知Dagger,可以通过调用该方法来获取到注入对象的实例 @Singleton @Provides public Retrofit provideRetrofit()&#123; return new Retrofit.Builder() .baseUrl(&quot;http://www.google.com&quot;) .build(); &#125; //Module已经知道怎么获取retrofit实例 //接着同一个Module中的方法，就可以作为参数直接传入 使用 // 比如provideApiService需要Retrofit实例，会从当前容器查找是否已经有Retrofit实例 // 然后从当前容器直接获取 @Singleton @Provides public ApiService provideApiService(Retrofit retrofit)&#123; return retrofit.create(ApiService.class); &#125; //@Singleton是Dagger提供的一种作用域 // 作用域就是用来管理Component来获取对象实例的生命周期 @Singleton @Provides public OkHttpClient provideOkHttpClient() &#123; return new OkHttpClient.Builder().build(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435public class DaggerActivity extends AppCompatActivity &#123; String TAG = &quot;DaggerActivity&quot;; //3.设置Inject注解 @Inject User user; @Inject User user2; @Inject Retrofit retrofit; @Inject ApiService apiService; @Inject ApiService apiService2; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_dagger2); //4.执行注入动作 DaggerApplicationComponent.create().inject(this);//DaggerApplicationComponent相当于DaggerApplication的实现类 Log.i(TAG, &quot;user: &quot; + user); Log.i(TAG, &quot;user2: &quot; + user2); Log.i(TAG, &quot;retrofit: &quot; + retrofit); Log.i(TAG, &quot;apiService: &quot; +apiService); Log.i(TAG, &quot;apiService2: &quot; +apiService2); &#125;&#125; 运行结构 123452092-2092/com.comm.util I/DaggerActivity: user: com.comm.util.dagger.dn.di.User@2129cef2092-2092/com.comm.util I/DaggerActivity: user2: com.comm.util.dagger.dn.di.User@d97d3fc2092-2092/com.comm.util I/DaggerActivity: retrofit: retrofit2.Retrofit@d243a852092-2092/com.comm.util I/DaggerActivity: apiService: retrofit2.Retrofit$1@a1fa0da2092-2092/com.comm.util I/DaggerActivity: apiService2: retrofit2.Retrofit$1@a1fa0da 可以看到 user 是2个实例 retorift用了同一个对象实例,所以可以看到和DaggerApplicationComponent组件生命周期一致。 局部实例2添加一个Activity 1234567891011121314151617public class SecondActivity extends AppCompatActivity &#123; String TAG = &quot;SecondActivity&quot;; @Inject ApiService apiService3; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_second2); //DaggerApplicationComponent相当于DaggerApplication的实现类 DaggerApplicationComponent.create().inject(this); Log.i(TAG, &quot;apiService3: &quot; + apiService3); &#125;&#125; 1void inject(SecondActivity secondActivity); 1startActivity(new Intent(this,SecondActivity.class)); 1237410-7410/com.comm.util I/DaggerActivity: apiService: retrofit2.Retrofit$1@a1fa0da7410-7410/com.comm.util I/DaggerActivity: apiService2: retrofit2.Retrofit$1@a1fa0da2021-08-29 22:28:35.812 7410-7410/com.comm.util I/SecondActivity: apiService3: retrofit2.Retrofit$1@84eb79a 不同的DaggerApplicationComponent组件，不同的实例 全局实例保证组件全局实例 MyApplication.java 12345static ApplicationComponent applicationComponent = DaggerApplicationComponent.create();public static ApplicationComponent getApplicationComponent() &#123; return applicationComponent;&#125; 1MyApplication.getApplicationComponent().inject(this); 1238044-8044/com.comm.util I/DaggerActivity: apiService: retrofit2.Retrofit$1@516190b8044-8044/com.comm.util I/DaggerActivity: apiService2: retrofit2.Retrofit$1@516190b8044-8044/com.comm.util I/SecondActivity: apiService3: retrofit2.Retrofit$1@516190b 作用域规则 组件ApplicationComponent指定了作用域,组件中的模块modules = {NetModule.class}，也要指定相同的作用域。 1234567@Singleton // 设置作用域和ApplicationComponent组件的生命周期一致@Component(modules = &#123;NetModule.class&#125;)public interface ApplicationComponent &#123; void inject(DaggerActivity daggerActivity);//指定目标类 void inject(SecondActivity secondActivity);&#125; 第07课 https://www.bilibili.com/video/BV1Ki4y1A7hA?p=07","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"kotlin-senior","slug":"kotlin-senior","date":"2021-08-22T05:27:15.000Z","updated":"2021-09-09T14:49:05.690Z","comments":true,"path":"2021/08/22/kotlin-senior/","link":"","permalink":"http://noteforme.github.io.com/2021/08/22/kotlin-senior/","excerpt":"","text":"拓展函数 1234567891011//给字符串追加若干个 !fun String.addExt(amount:Int=1)= this + &quot; !&quot;.repeat(amount)fun Any.easyPrint() = println(this) //默认是public//fun Any.easyPrint() = println(this) //不能定义两次fun main() &#123; println(&quot;abc&quot;.addExt(2)) &quot;abc&quot;.easyPrint() 15.easyPrint()&#125; 泛型拓展函数![](kotlin-senior/ 2021-08-22 _1.42.27_generic_extends.png) 1234567891011121314//给字符串追加若干个 !fun String.addExt(amount:Int=1)= this + &quot; !&quot;.repeat(amount)fun &lt;T&gt; T.easyPrint():T&#123; println(this) return this&#125;fun main() &#123; &quot;abc&quot;.addExt(2).easyPrint() 15.easyPrint() 15.also &#123; &#125; val let = &quot;abc&quot;.let &#123; 50 &#125;&#125; Let源码12345678// &quot;abc&quot;调用let，传进来参数就是&quot;abc&quot;类型T为String// let返回lambda表达式执行的结果 50 类型R为Intpublic inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R &#123; contract &#123; callsInPlace(block, InvocationKind.EXACTLY_ONCE) &#125; return block(this)&#125; 拓展属性给String类添加一个拓展 12345678910111213141516//给字符串追加若干个 !fun String.addExt(amount: Int = 1) = this + &quot; !&quot;.repeat(amount)val String.numVowels get() = count &#123; &quot;aeiou&quot;.contains(it) &#125;fun &lt;T&gt; T.easyPrint(): T &#123; println(this) return this&#125;fun main() &#123; &quot;abc&quot;.addExt(2).easyPrint() &quot;The people&#x27;s Republic of China&quot;.numVowels.easyPrint()&#125; 可空类拓展可以定义拓展函数用于可空类型，在可空类型上定义拓展函数，你可以直接在拓展函数体内借鉴可能出现的空值问题。 1234567fun String?.printWithDefault(default:String) =print(this ?: default) //null打印默认值,不为null 打印自身fun main() &#123;// val nullableString:String? = null val nullableString:String? = &quot;hehe&quot; nullableString.printWithDefault(&quot;abc&quot;) // nullableString?就不会设置默认值&#125; Infix 12345678910infix fun String?.printWithDefault(default:String) =print(this ?: default) //null打印默认值,不为null 打印自身fun main() &#123;// val nullableString:String? = null val nullableString:String? = &quot;hehe&quot; nullableString.printWithDefault(&quot;abc&quot;) // nullableString?就不会设置默认值 nullableString printWithDefault &quot;abc&quot; &quot;girl&quot;.to(18) mapOf(&quot;girl&quot; to 18)&#125; 12//to是拓展函数，返回 Pair&lt;A,B&gt;public infix fun &lt;A, B&gt; A.to(that: B): Pair&lt;A, B&gt; = Pair(this, that) 定义拓展文件1234567891011package com.util.kotin.extensionfun &lt;T&gt; Iterable&lt;T&gt;.randomTake(): T = this.shuffled().first()fun main() &#123; var list = listOf(&quot;Jack&quot;, &quot;Json&quot;, &quot;John&quot;) var set = listOf(&quot;Jack&quot;, &quot;Json&quot;, &quot;John&quot;) list.shuffled().first() list.randomTake()&#125; 重命名拓展123456789import com.util.kotin.extension.randomTake as Randomizerfun main() &#123; var list = listOf(&quot;Jack&quot;, &quot;Json&quot;, &quot;John&quot;) var set = listOf(&quot;Jack&quot;, &quot;Json&quot;, &quot;John&quot;) list.shuffled().first()// list.randomTake() list.Randomizer()&#125; Apply源码带接收者的函数字面量 apply函数是如何做到支持接收者对象的隐式调用 1234public inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T &#123; block() return this&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.io.File//fun String.addExt(amount: Int = 1) = this + &quot; !&quot;.repeat(amount)fun String.addExt() = &quot; !&quot;.repeat(this.count())// 泛型的拓展函数fun &lt;T&gt; T.easyPrint(): Unit = println(this)// T.apply 返回的还是T// T.() -&gt; Unit 传入拓展函数(泛型), 而不是普通的匿名函数 ???// 拓展函数里自带了接收者对象的this隐式调用// 匿名函数，也可以是 拓展函数//普通的匿名函数 ()-&gt;Unit//匿名函数内部this指向一个File对象,隐式调用，File.() -&gt; Unitpublic inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T &#123; block() return this&#125;/*public inline fun &lt;File&gt; File.apply(block: File.() -&gt; Unit): File &#123; block() return this&#125;*/fun main() &#123; val file = File(&quot;xx&quot;).apply &#123; this.setReadable(true) //默认又一个对象指向File &#125; //这里分解一下 //1. 定义拓展函数 fun File.ext(): Unit &#123; setReadable(true) &#125; //2.给block变量赋值 val block = File::ext //3.传入apply函数 File(&quot;xxx&quot;).apply &#123; block &#125; doSomething &#123; goFix() &#125; &quot;abcefg&quot;.addExt().easyPrint() // &quot;abcefg&quot;调用addExt() ,addExt()有一个对象指向&quot;abcefg&quot; &quot;abc&quot;.apply &#123; &#125;&#125;fun doSomething(fix: () -&gt; Unit) &#123; fix&#125;fun goFix(): Unit &#123; &quot;goFxi&quot;&#125; 案例LoginModel.kt1234RpcExpress.pack &#123; request.mobileNo = mobileNo request.metaInfo = metaInfo&#125; 12345678inline fun &lt;reified T : RpcRequest, reified R : RpcResult, reified E : RpcTask&gt; pack( build: RpcPackage&lt;T, R, E&gt;.() -&gt; Unit): RpcExecutor&lt;T, R, E&gt; &#123; val rpcPackage = RpcPackage&lt;T, R, E&gt;(T::class.java.newInstance(), R::class.java, E::class.java) build(rpcPackage) // 也可以写成 rpcPackage?.build() , 给rpcPackage赋值 return this.pack(rpcPackage)&#125; 函数式编程 函数类别 Map变换 123456789val animals = listOf(&quot;zebra&quot;, &quot;giraffe&quot;, &quot;elephant&quot;, &quot;rat&quot;)val banies = animals.map &#123; animal -&gt; &quot;A baby $animal&quot;&#125;.map &#123; baby -&gt; &quot;$baby , with the cutest little tail ever!&quot;&#125;println(animals)println(banies) 12val animalsLength = animals.map &#123; it.length &#125;println(animalsLength) flatMapfaltMap函数操作一个集合的集合，将其中多个集合中的元素的合并后返回一个包含所有元素的单一集合。 12val result = listOf(listOf(1, 2, 3), listOf(4, 5, 6)).flatMap &#123; it &#125;println(result) 过滤 1234val result = listOf(&quot;Jack&quot;,&quot;Jimmy&quot;,&quot;Rose&quot;,&quot;Tom&quot;).filter &#123; it.contains(&quot;J&quot;)&#125;println(result) 1234567val items = listOf( listOf(&quot;rea apple&quot;, &quot;green apple&quot;, &quot;blue apple&quot;), listOf(&quot;red fish&quot;, &quot;blue fish&quot;), listOf(&quot;yellow banana&quot;, &quot;teal banana&quot;))val redItems = items.flatMap &#123; it.filter &#123; it.contains(&quot;red&quot;) &#125; &#125;println(redItems) 找素数找素数，除了1和它本身，不能被任何数整除的数。 1234567// 除了1和它本身， 不梦被任何数整除的数// 取模等于0，说明能够整除，如果没有一个是等于0的，说明是素数。val numbers = listOf(7, 4, 8, 4, 3, 22, 18, 11)val primes = numbers.filter &#123; number -&gt; (2 until number).map &#123; number % it &#125;.none &#123; it == 0 &#125;&#125;println(primes) 合并合并是函数式编程的第三大类函数，合并能将不同的集合合并成一个新的集合。这个接收者是包含集合的的集合的flatmap函数不同。 zip12345val list1 = listOf(&quot;jon&quot;, &quot;john1&quot;, &quot;john2&quot;)val list2 = listOf(&quot;l1&quot;, &quot;l2&quot;, &quot;l3&quot;)val toMap = list1.zip(list2).toMap()println(toMap) {jon=l1, john1=l2, john2=l3} Fold可以用来合并值的合并函数是fold，这个合并函数接受一个初始累加器值，随后会根据匿名函数的结构更新。 fold(0) accumulator从0开始 123456//将每个元素值 乘以3后累加起来val foldedValue = listOf(1, 2, 3, 4).fold(0) &#123; accumulator, number -&gt; println(&quot;Accmulator value: $accumulator&quot;) accumulator + (number * 3)&#125;println(&quot;Find value: $foldedValue&quot;) Accmulator value: 0Accmulator value: 3Accmulator value: 9Accmulator value: 18Find value: 30 序列 123456789101112131415161718192021//判断是否是素数fun Int.isPrime(): Boolean &#123; (2 until this).map &#123; if (this % it == 0) &#123; return false &#125; &#125; return true&#125;fun main() &#123; //产生头1000个元素 //假定 0 - 5000之内，可以找到1000个元素 val toList = (1..5009).toList().filter &#123; it.isPrime() &#125;.take(1000) println(toList.size) val oneThousandPrimes = generateSequence(2) &#123; value -&gt; value + 1 &#125;.filter &#123; it.isPrime() &#125;.take(1000) println(oneThousandPrimes.toList().size)&#125; 互操作性与可空性 1234567891011121314151617181920212223public class Jhava &#123; private int hitPoints = 3232320; public int getHitPoints() &#123; System.out.println(&quot;----hitPoints-----&quot;); return hitPoints; &#125; public String utterGreeting() &#123; return &quot;HELLO&quot;; &#125; public static void main(String[] args) &#123;// System.out.println(HeroKt.makeProclamation()); &#125; @Nullable public String determineFriends() &#123; return null; &#125;&#125; 123456789fun main() &#123; val adversary = Jhava() println(adversary.utterGreeting()) // determineFriends String! 平台类型// val level = adversary.determineFriends().toLong()// level?.toLong() println(adversary.hitPoints)&#125; HELLO—-hitPoints—–3232320 @JvmName注解指定编译类的名字​ 12345@file:JvmName(&quot;Hero&quot;)import senior.Jhavafun makeProclamation() = &quot;Greetings , beast!&quot; @JvmField 123456class SpellBook &#123; val spells = listOf(&quot;Magic Ms . L&quot;, &quot;Lay onHans&quot;) @JvmField val spells1 = listOf(&quot;Magic Ms . L&quot;, &quot;Lay onHans&quot;)&#125; 1234SpellBook spellBook = new SpellBook();List&lt;String&gt; spells = spellBook.getSpells();List&lt;String&gt; spells1 = spellBook.spells1; // 直接用这个属性名，不用加get前缀 @JvmOverloads12345//调用者可以指定英雄左手或右手拿什么食物，或者使用默认的配置 - 左手拿浆果，右手拿牛肉@JvmOverloadsfun handoverFood(leftHand: String = &quot;berries&quot;, rightHand: String = &quot;beef&quot;) &#123; println(&quot;Mmmm... you hand over some delicious $leftHand and $rightHand&quot;)&#125; 可以看到编译器默认对类添加了重载 123456789@JvmOverloadspublic static final void handoverFood(@NotNull String leftHand) &#123; handoverFood$default(leftHand, (String)null, 2, (Object)null);&#125;@JvmOverloadspublic static final void handoverFood() &#123; handoverFood$default((String)null, (String)null, 3, (Object)null);&#125; 但是代码中我获取不到 Herokt 类。 https://www.bilibili.com/video/BV1wf4y1s7TG?p=144&amp;spm_id_from=pageDriver @JvmStatic@JvmField注解还能用来以静态方式提供伴生对象里定义的值 @JvmStatic注解的作用类似于@JvmField, 允许你直接调用伴生对象里的函数 12345678class SpellBook &#123; companion object&#123; @JvmField val MAX_SPELL_COUNT = 10 fun getSpellbookGreeting() = println(&quot;I am the Great man!&quot;) &#125;&#125; 加了@JvmField注解 就不用加 Companion调用 12345//伴生对象SpellBook.Companion.getSpellbookGreeting();//添加@JvmField 支持静态调用int maxSpellCount = SpellBook.MAX_SPELL_COUNT; @Throws ​ 123456public class Jhava &#123; public void extendHandInFriendship() throws IOException &#123; throw new IOException(); &#125;&#125; Java异常 java处理123456try &#123; //在java里面强制 在编译器处理的异常 new Jhava().extendHandInFriendship();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; Java异常 kotlin处理Hero.kt 12345try &#123; adversary.extendHandInFriendship()&#125;catch (e:Exception)&#123; println(&quot;exception&quot;)&#125; kotlin异常Java处理 Hero.kt 123fun acceptApology() &#123; throw IOException()&#125; 12345try &#123; HeroKt.acceptApology();&#125; catch (IOException e) &#123; //报错 Exception &#x27;java.io.IOException&#x27; is never thrown in the corresponding try block e.printStackTrace();&#125; 编译器把kotlin转成了Throwable 123public static final void acceptApology() &#123; throw (Throwable)(new IOException());&#125; 所以catch Throwable异常没问题 12345try &#123; HeroKt.acceptApology();&#125; catch (Throwable e) &#123; e.printStackTrace();&#125; 添加throws注解处理1234@Throws(IOException::class)fun acceptApology1() &#123; throw IOException()&#125; 12345try &#123; HeroKt.acceptApology1();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; Function 12345//添加一个translator的函数，接收一个字符串//将其改为小写字面，再大写第一个字符，最后打印结构var translator : (String)-&gt;Unit = &#123; utterance: String -&gt; println(utterance.toLowerCase().capitalize())&#125; 12Function1&lt;String, Unit&gt; translator = HeroKt.getTranslator();translator.invoke(&quot;TRUECE&quot;);","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://noteforme.github.io.com/categories/Kotlin/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://noteforme.github.io.com/tags/Kotlin/"}],"keywords":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://noteforme.github.io.com/categories/Kotlin/"}]},{"title":"kotlin-object","slug":"kotlin-object","date":"2021-08-21T13:02:57.000Z","updated":"2021-09-13T03:11:21.747Z","comments":true,"path":"2021/08/21/kotlin-object/","link":"","permalink":"http://noteforme.github.io.com/2021/08/21/kotlin-object/","excerpt":"","text":"object目录下 对象相关继承类默认是封闭的，要让某个类开放继承，必须使用opem关键字修饰它 123456789101112open class Product(val name:String) &#123; fun description() = &quot;Product: $name&quot; open fun load() = &quot;Nothing..&quot;&#125;class LuxuryProduct : Product(&quot;Luxury&quot;)&#123; override fun load() =&quot; LuxuryProduct loading&quot;&#125;fun main() &#123; val p : Product = LuxuryProduct() println(p.load())&#125; 类型检测 智能类型转换 12345678println(p is Product)println(p is LuxuryProduct)println(p is File)if (p is LuxuryProduct)&#123; println((p as LuxuryProduct).special()) println(p.special()) //只要转换一次，后面就直接可以使用，不用转换&#125; Kotlin层次无须在代码里显示指定，每一个类都会继承一个共同的叫做Any的超类。 Object关键字定义一个能产生一个实例的类- 单例 Object关键字有三种方式 对象声明 有利于组织代码和管理状态，尤其是管理整个应用运行生命周期内的某些一致性状态 对象表达式 1234567891011open class Player &#123; open fun load() = &quot;loading nothing..&quot;&#125;fun main() &#123; //匿名内部类，实例p对象 val p = object : Player()&#123; override fun load()= &quot;anonymous nothing..&quot; &#125; println(p.load())&#125; 伴生对象 123456789101112131415/** * 只要调用load() 或者实例化ConfigMap, 这个companion object才会被实例化 * 而且也是单例的 */class ConfigMap &#123; companion object&#123; private const val PATH = &quot;xxxx&quot; fun load() = File(PATH).readBytes() &#125;&#125;fun main() &#123; // 类似于Java static ConfigMap.load()&#125; 类相关嵌套类 123456789101112class InnerClassTest &#123; class Equipment(var name:String)&#123; fun show() = println(&quot;equipment:$name&quot;) &#125; fun battle()&#123; &#125;&#125;fun main() &#123; InnerClassTest.Equipment(&quot;shap knife&quot;).show()&#125; 数据类 数据类使用条件 12345678data class Coordinate(var x:Int,var y:Int) &#123; val isInBounds = x &gt; 0 &amp;&amp; y &gt; 0&#125;fun main() &#123; println(Coordinate(10,20)) println(Coordinate(10,20)==Coordinate(10,20)) //data默认重写equals方法&#125; 结果 Coordinate(x=10, y=20) // 说明默认提供了toString方法 重写了equals方法 123456789101112131415 public boolean equals(@Nullable Object var1) &#123; if (this != var1) &#123; if (var1 instanceof Coordinate) &#123; Coordinate var2 = (Coordinate)var1; if (this.x == var2.x &amp;&amp; this.y == var2.y) &#123; return true; &#125; &#125; return false; &#125; else &#123; return true; &#125; &#125;&#125; Copy 注意:次构造函数数据不会copy过来 1234567891011121314151617181920212223242526272829data class Student( var name: String, val age: Int //age 主构造函数里声明的属性)&#123; private val hobby = &quot;music&quot; val subject:String var score = 0 init &#123; println(&quot;initializing student&quot;) subject = &quot;english&quot; //Init初始化块里的属性赋值和函数调用 &#125; constructor(_name: String):this(_name,10)&#123; score = 10; //次构造函数数据不会copy过来 &#125; override fun toString(): String &#123; return &quot;Student(name=&#x27;$name&#x27;, age=$age, hobby=&#x27;$hobby&#x27;, subject=&#x27;$subject&#x27;, score=$score)&quot; &#125;&#125;fun main() &#123; val s = Student(&quot;Jon&quot;) val copy = s.copy(&quot;girl&quot;) var s2 = s.copy(name = &quot;girl2&quot;, age = 18) println(s) println(s2) println(copy)&#125; 解构声明 普通类 123456789class PlayerScore(val experience:Int,val level:Int) &#123; operator fun component1() = experience operator fun component2() = level&#125;fun main() &#123; val (x,y) = PlayerScore(10, 20) println(&quot;$x, $y&quot;)&#125; Data数据类 数据类自动生成解构语法 1234567891011data class Coordinate(var x:Int,var y:Int) &#123; val isInBounds = x &gt; 0 &amp;&amp; y &gt; 0&#125;fun main() &#123; println(Coordinate(10,20)) println(Coordinate(10,20)==Coordinate(10,20)) val(x,y) = Coordinate(10,20) //数据类自动生成解构语法 println(&quot;$x , $y&quot;)&#125; 运算符重载如果要将内置运算符应用在自定义类身上，你必须重写运算符函数，告诉编译器该如何操作自定义类 1234567891011data class Coordinate2(var x:Int,var y:Int) &#123; val isInBounds = x &gt; 0 &amp;&amp; y &gt; 0 operator fun plus(other:Coordinate2) = Coordinate2(x + other.x,y+other.y)&#125;fun main() &#123; val c1=Coordinate2(10, 20) val c2=Coordinate2(10, 20) println(c1 + c2)&#125; 枚举类用来定义常量集合特殊的类 枚举类是一个实例 1234567891011enum class Direction &#123; EAST, WEST, SOUTH, NORTH&#125;fun main() &#123; println(Direction.EAST) println(Direction.EAST is Direction)&#125; 枚举类定义函数1234567891011121314enum class Direction2(private val coordinate: Coordinate) &#123; EAST(Coordinate(1, 0)), //EAST()是Direction2的实例 WEST(Coordinate(-1, 0)), SOUTH(Coordinate(-1, 0)), NORTH(Coordinate(1, 0)); //定义函数 fun updateCoordinate(playerCoordinate: Coordinate) = Coordinate(playerCoordinate.x + coordinate.x, playerCoordinate.y + coordinate.y)&#125;fun main() &#123; println(Direction2.EAST.updateCoordinate(Coordinate(10, 20)))&#125; 代数数据类型可以用来表示一组子类型的闭集，枚举类就是一种简单的ADT 密封类 1234567891011121314151617181920212223//密封类sealed class LicenseStatus2 &#123; object UnQualified:LicenseStatus2() object Learning:LicenseStatus2() class Qualified(val licenseId:String):LicenseStatus2() //用来保存数据&#125;class Driver2(var status: LicenseStatus2)&#123; fun checkLicense():String&#123; return when(status)&#123; is LicenseStatus2.UnQualified -&gt; &quot;没资格&quot; is LicenseStatus2.Learning -&gt; &quot;在学&quot; is LicenseStatus2.Qualified -&gt; &quot;有资格，驾驶证编号: $&#123;((this.status as LicenseStatus2.Qualified).licenseId)&#125;&quot; &#125; &#125;&#125;fun main() &#123; val status1 = LicenseStatus2.Learning val status = LicenseStatus2.Qualified(&quot;2333003&quot;) val driver = Driver2(status) println(driver.checkLicense())&#125; 接口 InterfaceTest.kt 123456789101112131415interface Movable&#123; var maxSpeed:Int var wheels:Int fun move(movable:Movable):String&#125;class Car(_name:String,override var wheels:Int=4):Movable&#123; override var maxSpeed: Int get() = TODO(&quot;Not yet implemented&quot;) set(value) &#123;&#125; override fun move(movable: Movable): String &#123; TODO(&quot;Not yet implemented&quot;) &#125;&#125; 默认实现可以在接口里提供默认属性getter方法和函数实现 123456789101112131415161718interface Movable&#123; val maxSpeed:Int get() = (1..500).shuffled().last() var wheels:Int fun move(movable:Movable):String&#125;class Car(_name:String,override var wheels:Int=4):Movable&#123; override var maxSpeed: Int get() = super.maxSpeed set(value) &#123;&#125; override fun move(movable: Movable): String &#123; TODO(&quot;Not yet implemented&quot;) &#125;&#125; 抽象类 123456789101112abstract class Gun(val range: Int) &#123; abstract fun pullTrigger(): String protected fun doSomething() &#123; println(&quot;doSomething&quot;) &#125;&#125;class AK47(val price: Int) : Gun(range = 500)&#123; override fun pullTrigger(): String &#123; TODO() &#125;&#125; 泛型定义泛型类 magicBox1.kt 12345678910class MagicBox&lt;T&gt;(item:T)&#123; protected var subject:T = item&#125;class Boy(val name:String,val age:Int)class Dog(val weight:Int)fun main() &#123; val box1 = MagicBox(Boy(&quot;John&quot;, 20)) val box2 = MagicBox(Dog( 20))&#125; 泛型函数 泛型参数也可以用于函数。 定义一个函数用于获取元素，当且仅当MagicBox可用时，才能获取元素。 magicBox2.kt 12345678910111213141516171819class MagicBox&lt;T&gt;(item: T) &#123; var available = false protected var subject: T = item fun fetch(): T? &#123; return subject.takeIf &#123; available &#125; //当available =true，返回接收者对象 &#125;&#125;class Boy(val name: String, val age: Int)class Dog(val weight: Int)fun main() &#123; val box1 = MagicBox(Boy(&quot;John&quot;, 20)) val box2 = MagicBox(Dog(20)) box1.available = true box1.fetch()?.run &#123; println(&quot;you find $name&quot;) &#125;&#125; 多泛型参数magicBox3.kt 12345678910111213141516171819202122232425262728293031class MagicBox&lt;T&gt;(item: T) &#123; var available = false protected var subject: T = item fun fetch(): T? &#123; return subject.takeIf &#123; available &#125; //当available =true，返回接收者对象 &#125; // return R缩写 // 业务，把元素进行修改，魔盒里放的是男孩，取出来，变成男人 //传入subjectModfunction是匿名函数类型 (T)-&gt;(R), 这个匿名函数传入的是 T 返回的是R,fetch执行返回的是R类型 fun &lt;R&gt; fetch(subjectModFunction: (T) -&gt; R): R? &#123; return subjectModFunction(subject).takeIf &#123; available &#125; &#125;&#125;class Boy(val name: String, val age: Int)class Man(val name: String, val age: Int)class Dog(val weight: Int)fun main() &#123; val box1 = MagicBox(Boy(&quot;John&quot;, 20)) val box2 = MagicBox(Dog(20)) box1.available = true box1.fetch()?.run &#123; println(&quot;you find $name&quot;) &#125; val fetch = box1.fetch &#123; Man(it.name, it.age.plus(15)) &#125;&#125; 泛型类型约束确保MagicBox只能装指定类型的物品， 如Human类型，咋弄? magicBox4.kt 1234567891011121314151617181920212223242526272829303132class MagicBox4&lt;T:Human&gt;(item: T) &#123; //这里添加约束 var available = false protected var subject: T = item fun fetch(): T? &#123; return subject.takeIf &#123; available &#125; //当available =true，返回接收者对象 &#125; // return R缩写 // 业务，把元素进行修改，魔盒里放的是男孩，取出来，变成男人 //传入subjectModfunction是匿名函数类型 (T)-&gt;(R), 这个匿名函数传入的是 T 返回的是R,fetch执行返回的是R类型 fun &lt;R&gt; fetch(subjectModFunction: (T) -&gt; R): R? &#123; return subjectModFunction(subject).takeIf &#123; available &#125; &#125;&#125;open class Human(val age: Int)class Boy(val name: String, age: Int) : Human(age)class Man(val name: String, age: Int):Human(age)class Dog(val weight: Int)fun main() &#123; val box1 = MagicBox4(Boy(&quot;John&quot;, 20))// val box2 = MagicBox4(Dog(20)) //因为约束类型，导致这里会报错 box1.available = true box1.fetch()?.run &#123; println(&quot;you find $name&quot;) &#125; val fetch = box1.fetch &#123; Man(it.name, it.age.plus(15)) &#125;&#125; vararg关键字与get函数MagicBox能存放任何类型的Human实例，但一次只能放一个，如果要存放多个实例呢？ 12345678910111213141516171819202122232425262728293031class MagicBox&lt;T : Human&gt;(vararg item: T) &#123; var available = false protected var subject: Array&lt;out T&gt; = item //可变参数 必须写out fun fetch(index: Int): T? &#123; return subject[index].takeIf &#123; available &#125; //当available =true，返回接收者对象 &#125; // return R缩写 // 业务，把元素进行修改，魔盒里放的是男孩，取出来，变成男人 //传入subjectModfunction是匿名函数类型 (T)-&gt;(R), 这个匿名函数传入的是 T 返回的是R,fetch执行返回的是R类型 fun &lt;R&gt; fetch(index: Int, subjectModFunction: (T) -&gt; R): R? &#123; return subjectModFunction(subject[index]).takeIf &#123; available &#125; &#125;&#125;open class Human(val age: Int)class Boy(val name: String, age: Int) : Human(age)class Man(val name: String, age: Int) : Human(age)class Dog(val weight: Int)fun main() &#123; val box1 = MagicBox(Boy(&quot;John&quot;, 20), Boy(&quot;Jack&quot;, 20), Boy(&quot;Jon&quot;, 20)) box1.available = true box1.fetch(1)?.run &#123; println(&quot;you find $name&quot;) &#125; val fetch = box1.fetch(2) &#123; Man(it.name, it.age.plus(15)) &#125;&#125; []操作符运算符重载 12345678910111213141516171819202122232425262728293031323334class MagicBox&lt;T : Human&gt;(vararg item: T) &#123; var available = false protected var subject: Array&lt;out T&gt; = item //可变参数 必须写out fun fetch(index: Int): T? &#123; return subject[index].takeIf &#123; available &#125; //当available =true，返回接收者对象 &#125; // return R缩写 // 业务，把元素进行修改，魔盒里放的是男孩，取出来，变成男人 //传入subjectModfunction是匿名函数类型 (T)-&gt;(R), 这个匿名函数传入的是 T 返回的是R,fetch执行返回的是R类型 fun &lt;R&gt; fetch(index: Int, subjectModFunction: (T) -&gt; R): R? &#123; return subjectModFunction(subject[index]).takeIf &#123; available &#125; &#125; operator fun get(index: Int): T? = subject[index]?.takeIf &#123; available &#125;&#125;open class Human(val age: Int)class Boy(val name: String, age: Int) : Human(age)class Man(val name: String, age: Int) : Human(age)class Dog(val weight: Int)fun main() &#123; val box1 = MagicBox(Boy(&quot;John&quot;, 20), Boy(&quot;Jack&quot;, 20), Boy(&quot;Jon&quot;, 20)) box1.available = true box1.fetch(1)?.run &#123; println(&quot;you find $name&quot;) &#125; val fetch = box1.fetch(2) &#123; Man(it.name, it.age.plus(15)) &#125; box1[0] //重写get&#125; Out In invariant（不变） 如果泛型类即将泛型类型作为函数参数，又将泛型类型作为函数的输出，那么即不用out也不用in. 为什么需要in out 如果泛型有继承关系，可以直接用,Java只能用具体类 12345public class GenericTypeTest &#123; public static void main(String[] args) &#123;// ArrayList&lt;CharSequence&gt; list = new ArrayList&lt;String&gt;(); &#125;&#125; 父类泛型对象可以赋值给子类泛型对象 ， 用in. 类似super 子类泛型对象可以赋值给父类泛型对象， 用out 类似extends 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// outinterface Production&lt;out T&gt; &#123; fun product(): T&#125;// ininterface Consumer&lt;in T&gt; &#123; // fun consume(item:T):T //Type parameter T is declared as &#x27;in&#x27; but occurs in &#x27;out&#x27; position in type T fun consume(item: T)&#125;//不变interface ProductionConsumer&lt;T&gt; &#123; fun product(): T fun consume(item: T)&#125;open class Foodopen class FastFood:Food()open class Burger :FastFood()//生产者class FoodStore : Production&lt;Food&gt;&#123; override fun product(): Food &#123; println(&quot;Product food&quot;) return Food() &#125;&#125;class FastFoodStore : Production&lt;FastFood&gt;&#123; override fun product(): FastFood &#123; println(&quot;Product FastFood&quot;) return FastFood() &#125;&#125;class BurgerFoodStore : Production&lt;Burger&gt;&#123; override fun product(): Burger &#123; println(&quot;Product Burger&quot;) return Burger() &#125;&#125;//消费者class EveryBody : Consumer&lt;Food&gt;&#123; override fun consume(item: Food) &#123; println(&quot;Eat food.&quot;) &#125;&#125;class ModernPeople : Consumer&lt;FastFood&gt;&#123; override fun consume(item: FastFood) &#123; println(&quot;Eat fastFood&quot;) &#125;&#125;class AmericanPeople : Consumer&lt;Burger&gt;&#123; override fun consume(item: Burger) &#123; println(&quot;Eat Burger&quot;) &#125;&#125;fun main() &#123; val production1 : Production&lt;Food&gt; = FoodStore() // 理解时，别看方法只看类就可以了，父子类关系 //子类泛型对象可以复制给负累泛型对象，用out val production2 : Production&lt;Food&gt; = FastFoodStore() // 就是因为有 out，out删除就报错 //父类泛型对象可以赋值给子类泛型对象 ， 用in val consumer1:Consumer&lt;Burger&gt; = EveryBody()// val consumer2:Consumer&lt;Food&gt; = ModernPeople()//Required:Consumer&lt;Food&gt; Found : ModernPeople val consumer2:Consumer&lt;Burger&gt; = ModernPeople() consumer2.consume(Burger())// consumer2.consume(Food()) val consumer3:Consumer&lt;Burger&gt; = AmericanPeople()&#125; Reified 1234567891011121314151617181920212223242526272829303132333435363738394041424344class MagicBox&lt;T : Human&gt;() &#123; //随机产生一个对象，如果不是指定类型的对象，就通过backup函数生成一个指定类型的对象 /* fun &lt;T&gt; randomOrBackup(backup: () -&gt; T): T &#123; // backup: ()-&gt;T 函数 和randomOrBackup返回的都是T类型 val items = listOf(Boy(&quot;jocnk&quot;, 20), Man(&quot;john&quot;, 20)) val random = items.shuffled().first() return if (random is T) &#123; random &#125; else &#123; backup() &#125; &#125; */ // backup: ()-&gt;T 函数 和randomOrBackup返回的都是T类型 //inline reified一起使用 inline fun &lt;reified T&gt; randomOrBackup(backup: () -&gt; T): T &#123; val items = listOf(Boy(&quot;jocnk&quot;, 20), Man(&quot;john&quot;, 20)) val random = items.shuffled().first() println(random) return if (random is T) &#123; random &#125; else &#123; backup() &#125; &#125;&#125;open class Human(val age: Int)class Boy(val name: String, age: Int) : Human(age)&#123; override fun toString(): String &#123; return &quot;Boy(name=&#x27;$name&#x27;)&quot; &#125;&#125;class Man(val name: String, age: Int) : Human(age)&#123; override fun toString(): String &#123; return &quot;Man(name=&#x27;$name&#x27;)&quot; &#125;&#125;fun main() &#123; val box1: MagicBox&lt;Man&gt; = MagicBox() // 由backup函数推断出来T的类型 val subject = box1.randomOrBackup &#123; Man(&quot;Jimmy&quot;, 28) &#125; //Man推断T类型 println(subject)&#125;","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://noteforme.github.io.com/categories/Kotlin/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://noteforme.github.io.com/tags/Kotlin/"}],"keywords":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://noteforme.github.io.com/categories/Kotlin/"}]},{"title":"kotlin-medium","slug":"kotlin-medium","date":"2021-08-21T08:48:52.000Z","updated":"2021-09-07T02:01:41.063Z","comments":true,"path":"2021/08/21/kotlin-medium/","link":"","permalink":"http://noteforme.github.io.com/2021/08/21/kotlin-medium/","excerpt":"","text":"集合ListList.kt List创建与元素获取 1234val list = listOf(&quot;girl1&quot;, &quot;girl2&quot;, &quot;girl3&quot;)println(list.getOrElse(3) &#123; &quot;Unknown&quot; &#125;)println(list.getOrNull(3))println(list.getOrNull(3) ?: &quot;Unknown&quot;) 可变列表 1234567val mutableList = mutableListOf(&quot;Jason&quot;, &quot;Jack&quot;, &quot;girl1&quot;)mutableList.add(&quot;Jimmy&quot;)mutableList.remove(&quot;Jack&quot;)println(mutableList)list.toMutableList() // 不可变转可变mutableList.toList() // 可变转不可变 mutator函数 1234mutableList += &quot;John&quot;mutableList -= &quot;girl1&quot;mutableList.removeIf&#123;it.contains(&quot;Jack&quot;)&#125; //包含Jack就把 Jack移除println(mutableList) 集合遍历 for in forEach forEachIndexed遍历时要获取索引 123456789for (s in list)&#123; println(s)&#125;list.forEach&#123; println(it)&#125;list.forEachIndexed&#123;index,item-&gt; println(&quot;$index $item&quot;)&#125; 解构通过_符号过滤不想要的元素 12// val(girl1,girl2,girl3) = list val(girl1,_,girl3) = list //如果不需要girl2,用_，这个字节码也不会取出 Set集合elementAt获取元素12345val set = setOf(&quot;girl1&quot;, &quot;girl2&quot;, &quot;girl3&quot;, &quot;girl1&quot;)println(set.elementAt(2))val mutableSet = mutableSetOf(&quot;girl1&quot;, &quot;girl2&quot;, &quot;girl3&quot;, &quot;girl1&quot;)mutableSet += &quot;girl5&quot; List去重通过toSet去重 12345val list = mutableSetOf(&quot;girl1&quot;, &quot;girl2&quot;, &quot;girl3&quot;, &quot;girl1&quot;).toSet().toList()println(list)val distinct = mutableSetOf(&quot;girl1&quot;, &quot;girl2&quot;, &quot;girl3&quot;, &quot;girl1&quot;).distinct()println(distinct) 数组类型 kotlin提供了各种Array,虽然是引用类型，但最终编译成Java基本数据类型 123val intArray = intArrayOf(10, 30, 40)listOf(10, 30, 40).toIntArray()val array = arrayOf(File(&quot;xxx&quot;), File(&quot;yyyy&quot;)) Map集合 map获取1234println(map[&quot;lucy1&quot;])println(map.getValue(&quot;lucy2&quot;))println(map.getOrElse(&quot;Jon&quot;)&#123;&quot;Unknown&quot;&#125;) //没有Jon，返回Unknownprintln(map.getOrDefault(&quot;Jon&quot;,0)) //没有Jon，返回默认值0 map遍历123456map.forEach&#123; println(&quot;$&#123;it.key&#125;, $&#123;it.value&#125;&quot;)&#125;map.forEach&#123;(key:String,value:Int)-&gt; println(&quot;$&#123;key&#125;, $&#123;value&#125;&quot;)&#125; mutableMap12345val mutableMap = mutableMapOf(&quot;lucy1&quot; to 18, &quot;lucy2&quot; to 19, &quot;lucy3&quot; to 20)mutableMap += &quot;jon&quot; to 22mutableMap.put(&quot;jon2&quot;,35)mutableMap.getOrPut(&quot;Rose&quot;)&#123;30&#125; // 如果没有Rose,就添加进来println(mutableMap) 定义类 12345678Class Player&#123; var name:String? = &quot;jack&quot; // 编译后生成了get. set方法&#125;fun main()&#123; var p = Player() p.name = &quot;rose&quot; //编译生成了 setName方法&#125; 计算属性12345678910111213class Player &#123; var name: String = &quot;jack&quot; get() = field.capitalize() set(value) &#123; field = value.trim() &#125; //计算属性是通过一个覆盖的get或set运算符来定义，这时field就不需要了。 val rolledValue get() = (1..6).shuffled().first() &#125; 防范竞态条件1234567// 如果一个类属性即可空又可变，那么引用它之前必须保证它非空，一个办法是用also标准函数 var words:String? = &quot;hello&quot; fun saySomething()&#123; words?.also &#123; println(&quot;Hello $&#123;it.uppercase()&#125;&quot;) &#125; &#125; 构造函数12345678910111213141516171819202122class Student( _name: String, _age: Int, _isNormal: Boolean) &#123; var name = _name //临时变量用 _表示 只用一次 get() = field.capitalize() private set(value) &#123; value.trim() &#125; var age = _age //临时变量用 _表示 只用一次 get() = age.absoluteValue set(value) &#123; field = value.absoluteValue &#125; var isNormal = _isNormal&#125;fun main() &#123; val p = Student(&quot;john&quot;, 19, true)// p.name = &quot;rose&quot; //Cannot assign to &#x27;name&#x27;: the setter is private in &#x27;Student&#x27;&#125; 主构造函数里定义属性12345678910111213141516class Student2( _name: String, val age: Int, val isNormal: Boolean) &#123; var name = _name //临时变量用 _表示 只用一次 get() = field.capitalize() private set(value) &#123; value.trim() &#125;&#125;fun main() &#123; val p = Student2(&quot;john&quot;, 19, true)// p.name = &quot;rose&quot; //Cannot assign to &#x27;name&#x27;: the setter is private in &#x27;Student&#x27;&#125; 次构造函数Student2.kt 123456789constructor(_name:String):this(_name,age=100,isNormal = false)constructor(_name:String,age: Int):this(_name,age=100,isNormal = false)&#123; //定义初始化代码逻辑 this.name = name.uppercase()&#125;fun main()&#123; val p2 = Student2(&quot;Rose&quot;) val p3 = Student2(&quot;Rose&quot;,20)&#125; 构造函数给默认值123456789101112131415class Student3( _name: String, val age: Int = 20, val isNormal: Boolean) &#123; var name = _name //临时变量用 _表示 只用一次 get() = field.capitalize() private set(value) &#123; value.trim() &#125;&#125;fun main() &#123; Student3(isNormal = false, _name = &quot;Jon&quot;)&#125; 初始化块初始化块可以设置变量或值，以及执行有效性检查，如果检查传给某构造函数的值是否有效，初始化块代码会在构造类实例时执行。 12345678910111213141516171819202122class Student3( _name: String, val age: Int = 20, val isNormal: Boolean) &#123; var name = _name //临时变量用 _表示 只用一次 get() = field.capitalize() private set(value) &#123; value.trim() &#125; init&#123; require(age&gt;0)&#123;&quot;age must be positive&quot;&#125; require(name.isNotBlank())&#123;&quot;player must have a name.&quot;&#125; &#125;&#125;fun main() &#123; Student3(isNormal = false, _name = &quot;Jon&quot;) Student3(isNormal = false, _name = &quot;&quot;)&#125; 初始化顺序 主构造函数里声明的属性 类级别的属性赋值 Init初始化块里的属性赋值和函数调用 次构造函数里的属性赋值和函数调用 123456789101112131415161718192021class Student4( _name: String, val age: Int //age 主构造函数里声明的属性)&#123; var name = _name //类级别的属性赋值 name , score, hobby var score = 10; private val hobby = &quot;music&quot; val subject:String init &#123; println(&quot;initializing student&quot;) subject = &quot;english&quot; //Init初始化块里的属性赋值和函数调用 &#125; constructor(_name: String):this(_name,10)&#123; score = 20 //次构造函数里的属性赋值和函数调用 &#125;&#125;fun main()&#123; Student4(&quot;jon&quot;)&#125; 反编译字节码后 123456789101112131415161718public Student4(@NotNull String _name, int age) &#123; Intrinsics.checkNotNullParameter(_name, &quot;_name&quot;); super(); this.age = age; //主构造函数里声明的属性 this.name = _name; //类级别的属性赋值 name , score, hobby this.score = 10; this.hobby = &quot;music&quot;; String var3 = &quot;initializing student&quot;; //Init初始化块里的属性赋值和函数调用 boolean var4 = false; System.out.println(var3); this.subject = &quot;english&quot;; &#125;public Student4(@NotNull String _name) &#123; //调用这个构造方法 Intrinsics.checkNotNullParameter(_name, &quot;_name&quot;); this(_name, 10); this.score = 20; //次构造函数里的属性赋值和函数调用&#125; 延迟初始化 123456789101112131415class Player4 &#123; lateinit var equipment:String fun ready()&#123; equipment = &quot;sharp knife&quot; &#125; fun battle()&#123; if (::equipment.isInitialized) println(equipment) &#125;&#125;fun main() &#123; val p = Player4() p.ready() p.battle()&#125; 惰性初始化延迟初始化并不是推后初始化的唯一方式，也可以暂时不初始化某个变量，直到首次使用它才初始化，这个叫做惰性初始化。 1234567891011121314151617class Player5(_name: String) &#123; var name = _name val config by lazy &#123; loadConfig() &#125; // 懒汉式// val config = loadConfig() //饿汉式 private fun loadConfig(): String &#123; println(&quot;loading...&quot;) return &quot;beauty girl&quot; &#125;&#125;fun main() &#123; val p = Player5(&quot;girl&quot;) Thread.sleep(5000) println(p.config)&#125; Java不会有这种陷阱 初始化陷阱1顺序非常重要，必须保证块中的所有属性已完成初始化 1234init &#123; val bloodBonus = blood.times(4)&#125;val blood = 100 //必须保证块中的所有属性已完成初始化 初始化陷阱2123456789101112class Player7 &#123; val name:String //类级别属性 private fun firstLetter() = name[0] init &#123; println(firstLetter()) name= &quot;john&quot; //初始化块代码排第三 &#125;&#125;fun main() &#123; Player7()&#125; 初始化陷阱3initPlayerName() 初始化 playerName时，name属性还未完初始化。 123456789class InitTrapTest3(_name:String) &#123; val playerName:String = initPlayerName() val name:String = _name //这个要放第一句 private fun initPlayerName() = name&#125;fun main() &#123; println(InitTrapTest3(&quot;John&quot;).playerName)&#125;","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://noteforme.github.io.com/categories/Kotlin/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://noteforme.github.io.com/tags/Kotlin/"}],"keywords":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://noteforme.github.io.com/categories/Kotlin/"}]},{"title":"kotlin_elementary","slug":"kotlin-elementary","date":"2021-08-19T14:29:06.000Z","updated":"2021-09-11T10:08:00.220Z","comments":true,"path":"2021/08/19/kotlin-elementary/","link":"","permalink":"http://noteforme.github.io.com/2021/08/19/kotlin-elementary/","excerpt":"","text":"https://www.jianshu.com/p/8eb0623f08c6 类型Kotlin内置数据类型 类型推断对于已经声明并赋值的变量，它允许你省略类型定义. 编译时常量编译时常量只能再函数外定义，因为编译时常量必须在编译时赋值，而函数时在运行时才调用，函数内的变量也是在运行时赋值，编译时常量要在这些变量赋值前就已存在。 1234const val MAX =200;fun main() &#123; const val MAX =200;//报错 Modifier &#x27;const&#x27; is not applicable to &#x27;local variable&#x27;&#125; 基本表达式age表达式1234567891011val score = 6;if (score in 9..10)&#123; println(&quot;Big美女&quot;)&#125;else if (score in 6..8)&#123; println(&quot;美女&quot;)&#125;else&#123; println(&quot;who knows&quot;)&#125;if(score !in 1..5)&#123; println(&quot;good&quot;)&#125; 美女good when123456789val school = &quot;0小学&quot;;val level = when (school) &#123; &quot;幼儿园&quot; -&gt; &quot;幼儿&quot; &quot;小学&quot; -&gt; &quot;少儿&quot; &quot;中学&quot; -&gt; &quot;青少年&quot; else -&gt; &#123; &quot;未知&quot; &#125;&#125; String模版12val flag = falseprintln(&quot;Answer is : $&#123;if (flag) &quot;我可以&quot; else &quot;I can play&quot;&#125;&quot;) 函数,函数参数12345printUser(&quot;Jon&quot;)printUser(name = &quot;john&quot;)fun printUser(name:String,age:Int=2)&#123; println(name+age)&#125; Nothing类型终止代码运行 1TODO(&quot;nothing&quot;) 反引号 ``可以用来测试 某一段代码 123fun `**~ special function with test util ~**`()&#123;&#125; Kotlin和Java保留不同的关键字，使用反引号括住函数名能避免任何冲突 12345public class KeyWordJava &#123; public static void is()&#123; //is时关键字 System.out.println(&quot;is invoked&quot;); &#125;&#125; 1KeyWordJava.`is`() 匿名函数匿名函数可以当作变量赋值给函数类型变量。函数的类型，由传入的参数和返回值类型决定。 和具名函数不一样，除极少情况外，匿名函数不需要return关键字，来返回数据，匿名函数会隐式或自动返回函数体最后一行语句的结果。 通过匿名函数给标准函数 制定规则 1234567val total = &quot;Mississippi&quot;.count()//通过匿名函数给标准函数 制定规则val totalS = &quot;Mississippi&quot;.count(&#123;letter-&gt; //letter变量 letter ==&#x27;s&#x27;//函数体&#125;)println(total)println(totalS) 123456789101112131415//变量的类型是一个匿名函数,一个函数类型的变量val helloFunction:()-&gt;String //任意函数 无传入参数，返回类型String ,都可以 =helloFunctionhelloFunction = &#123; val greet = &quot; how is going. &quot; &quot;hello girl , $greet &quot; //默认返回这行语句的结果&#125;val helloFunction1:()-&gt;String = &#123;//任意函数 无传入参数，返回类型String ,都可以 =helloFunction val greet = &quot; how is going. &quot; val hah = &quot;haha&quot; &quot;hello beauty girl, $greet &quot; //默认返回这行语句的结果&#125;println(helloFunction())println(helloFunction1()) hello girl , how is going.hello beauty girl, how is going. 匿名函数参数12345val helloFunction2:(String)-&gt;String = &#123;name-&gt; // name传入参数,String参数类型 val hah = &quot;haha&quot; &quot;hello beauty girl, I am $&#123;name&#125; &quot; //默认返回这行语句的结果&#125;println(helloFunction2(&quot;Jon&quot;)) it关键字定义只有一个参数的匿名函数时，可以用it来表示参数名。当需要传入两个值参，就不能用了。 12345val helloFunction3:(String)-&gt;String = &#123; // name传入参数,String参数类型, 只有一个参数name可以省略，用it替代 val hah = &quot;haha&quot; &quot;hello beauty girl, I am $&#123;it&#125; &quot; //默认返回这行语句的结果&#125;println(helloFunction3(&quot;John&quot;)) 类型推断定义一个变量时，如果已把匿名函数作为变量赋值给它, 就不需要显示指明变量类型了。 12345val helloFunction4 = &#123; val holiday = &quot;New Year&quot; &quot;Happy $holiday&quot;&#125;println(helloFunction4()) 类型推断也支持带参数的匿名函数，但为了帮助编译器更准确的推断变量类型，匿名函数的参数名和参数类型必须有。 123456789101112val helloFunction5:(String,Int) -&gt; String = &#123;name,year -&gt; val holiday = &quot;New Year&quot; &quot;$name Happy $holiday $year&quot;&#125;println(helloFunction5(&quot;jon&quot;,2023))//使用类型推断val helloFunction6 = &#123;name:String,year:Int -&gt; val holiday = &quot;New Year&quot; &quot;$name Happy $holiday $year&quot;&#125;println(helloFunction6(&quot;jon&quot;,2023)) 匿名函数成为lambda,将它的定义成为lambda表达式，它返回的数据成为lambda结果。 lambda由来：在定义匿名函数时，使用了lambda演算记法。 一个函数作为另一个函数的参数123456789101112131415fun main() &#123; //定义参数是函数 的函数 val disCountWord = &#123; goodsName: String, hour: Int -&gt; val currentYear = 2023; &quot;$&#123;currentYear&#125;年, 双11 $&#123;goodsName&#125;促销倒计时: $hour 小时&quot; &#125; showOnBoard(&quot;小玩具&quot;, disCountWord)&#125;//getDiscountWord是第二个参数,类型时是(String, Int) -&gt; String 函数类型fun showOnBoard(goodsName: String, getDiscountWords: (String, Int) -&gt; String) &#123; val hour = (1..24).shuffled().last(); print(getDiscountWords(goodsName, hour))&#125; java实现传递函数1234567891011121314public static void main(String[] args) &#123; showOnBoard(&quot;牙膏&quot;,((goodsName, hour) -&gt; &#123; int currentYear = 2023; return String.format(&quot;%s年，双11 %s 促销倒计时 %d小时 &quot;,currentYear,goodsName,hour); &#125;));&#125;public interface DiscountWords&#123; String getDiscountWords(String goodsName,int hour);&#125;public static void showOnBoard(String goodsName,DiscountWords discountWords)&#123; int hour = new Random().nextInt(24); System.out.println(discountWords.getDiscountWords(goodsName,hour));&#125; 简略写法如果一个函数的lambda函数排在最后，或者是唯一的参数，那么括住的lambda值参的一对圆括号就可以省略. 唯一的参数 AnonymousFunc2.kt 1234567val totalS = &quot;Mississippi&quot;.count(&#123;letter-&gt; //letter变量 letter ==&#x27;s&#x27;//函数体&#125;)val totalS1 = &quot;Mississippi&quot;.count&#123;letter-&gt; //letter变量 letter ==&#x27;s&#x27;//函数体&#125; AnonymousFunc2.kt 排在最后,一对圆括号就可以省略 123456789showOnBoard(&quot;小玩具&quot;, &#123; goodsName: String, hour: Int -&gt; val currentYear = 2023; &quot;$&#123;currentYear&#125;年, 双11 $&#123;goodsName&#125;促销倒计时: $hour 小时&quot;&#125;)showOnBoard(&quot;小玩具&quot;) &#123; goodsName: String, hour: Int -&gt; val currentYear = 2023; &quot;$&#123;currentYear&#125;年, 双11 $&#123;goodsName&#125;促销倒计时: $hour 小时&quot;&#125; 内联函数 1234567891011121314151617fun main() &#123; //定义参数是函数 的函数 val disCountWord = (&#123; goodsName: String, hour: Int -&gt; val currentYear = 2023; &quot;$&#123;currentYear&#125;年, 双11 $&#123;goodsName&#125;促销倒计时: $hour 小时&quot; &#125;) showOnBoard(&quot;小玩具&quot;, disCountWord)&#125;//getDiscountWord是第二个参数,类型时是(String, Int) -&gt; String 函数类型 fun showOnBoard(goodsName: String, getDiscountWords: (String, Int) -&gt; String) &#123; val hour = (1..24).shuffled().last(); println(getDiscountWords(goodsName, hour))&#125; 123456789101112131415161718192021public final class AnonymousFunc2Kt &#123; public static final void main() &#123; Function2 disCountWord = (Function2)null.INSTANCE; showOnBoard(&quot;小玩具&quot;, disCountWord); &#125; // $FF: synthetic method public static void main(String[] var0) &#123; main(); &#125; public static final void showOnBoard(@NotNull String goodsName, @NotNull Function2 getDiscountWords) &#123; Intrinsics.checkNotNullParameter(goodsName, &quot;goodsName&quot;); Intrinsics.checkNotNullParameter(getDiscountWords, &quot;getDiscountWords&quot;); byte var3 = 1; int hour = ((Number)CollectionsKt.last(CollectionsKt.shuffled((Iterable)(new IntRange(var3, 24))))).intValue(); Object var5 = getDiscountWords.invoke(goodsName, hour); boolean var4 = false; System.out.println(var5); &#125;&#125; 内联后，代码直接替换 12345678910111213141516171819202122232425262728public final class AnonymousFunc2Kt &#123; public static final void main() &#123; Function2 disCountWord = (Function2)null.INSTANCE; String goodsName$iv = &quot;小玩具&quot;; int $i$f$showOnBoard = false; byte var3 = 1; //这里开始 后面代码直接复制过来了 int hour$iv = ((Number)CollectionsKt.last(CollectionsKt.shuffled((Iterable)(new IntRange(var3, 24))))).intValue(); Object var6 = disCountWord.invoke(goodsName$iv, hour$iv); boolean var5 = false; System.out.println(var6); &#125; // $FF: synthetic method public static void main(String[] var0) &#123; main(); &#125; public static final void showOnBoard(@NotNull String goodsName, @NotNull Function2 getDiscountWords) &#123; int $i$f$showOnBoard = 0; Intrinsics.checkNotNullParameter(goodsName, &quot;goodsName&quot;); Intrinsics.checkNotNullParameter(getDiscountWords, &quot;getDiscountWords&quot;); byte var4 = 1; int hour = ((Number)CollectionsKt.last(CollectionsKt.shuffled((Iterable)(new IntRange(var4, 24))))).intValue(); Object var6 = getDiscountWords.invoke(goodsName, hour); boolean var5 = false; System.out.println(var6); &#125;&#125; 函数引用12345678910111213141516//函数引用fun main() &#123; showOnBoard(&quot;小玩具&quot;,::getDiscountWords)&#125;//普通 具名函数private fun getDiscountWords(goodsName: String, hour: Int): String &#123; val currentYear = 2023; return &quot;$&#123;currentYear&#125;年, 双11 $&#123;goodsName&#125;促销倒计时: $hour 小时&quot;&#125;//getDiscountWord是第二个参数,类型时是(String, Int) -&gt; String 函数类型private fun showOnBoard(goodsName: String, getDiscountWords: (String, Int) -&gt; String) &#123; val hour = (1..24).shuffled().last(); println(getDiscountWords(goodsName, hour))&#125; 函数类型作为返回类型 函数类型也是有效的返回类型，也就是说可以定义一个能返回函数的函数。 123456789101112fun main() &#123; val getDiscountWords = configDiscountWords() println(getDiscountWords(&quot;小玩具&quot;))&#125;fun configDiscountWords(): (String) -&gt; String &#123;//返回一个传入字符串 返回类型也是函数的字符串,的返回类型 val currentYear = 2023; val hour = (1..24).shuffled().last(); return &#123; goodsName: String -&gt; &quot;$&#123;currentYear&#125;年, 双11 $&#123;goodsName&#125;促销倒计时: $hour 小时&quot; &#125;&#125; 闭包作用: 控制作用域 匿名函数引用着定义自身函数里的变量 kotlin中的lambda就是闭包,上面 currentYear,hour 在configDiscountWords()中定义 { goodsName: String -&gt; “${currentYear}年, 双11 ${goodsName}促销倒计时: $hour 小时} 也在configDiscountWords()定义 2 引用了currentYear,hour变量. 所以形成闭包 https://www.bilibili.com/video/BV1wf4y1s7TG?p=34&amp;spm_id_from=pageDriver Null编译时出错的方式，提前在编译期强迫开发者重视起来，而不是等到运行时报错。 ?变量为null，不会执行后面的方法 let匿名函数，返回lambda最后一行 可以支持函数链式调用 12345678910 var str:String? = &quot;butterfly&quot;// var str=&quot;&quot; str = str?.let &#123; if (it.isNotBlank())&#123; it.capitalize() &#125;else&#123; &quot;butterfly&quot; &#125; &#125; println(str) !!当变量为null,会抛出KotlinNullPointerException 空合并操作符 ?:类似三目运算符 1234str=nullstr=&quot;guy&quot;str = str?.let &#123; it.capitalize()&#125; ?:&quot;butterfly&quot; //和let一起使用println(str ?: &quot;girl&quot;) // str=null,就是girl,不为null就是自己 异常执行之前，先进行检查，可以自定义异常 123456789101112131415fun main() &#123; var number: Int? = null try &#123; checkOperation(number) number!!.plus(1) &#125; catch (e: Exception) &#123; println(e) &#125;&#125;fun checkOperation(number: Int?) &#123; number ?: throw UnskilledException()&#125;//自定义异常class UnskilledException : IllegalArgumentException(&quot;操作不当&quot;) 先决条件函数kotlin标准库 提供了一些便利函数，使用这些内置函数，可以跑出带自定义信息的异常，这些便利函数叫做先决条件函数。也可以用它定义先决条件，条件必须满足，目标代码才能执行。 1234fun checkOperation(number: Int?) &#123;// number ?: throw UnskilledException() checkNotNull(number,&#123;&quot;Something is no good.&quot;&#125;)&#125; 字符串String.kt substringsubstring支持IntRange类型的参数，until创建的范围不包括上限值。 1234567const val NAME =&quot;Jimmy&#x27;s friend&quot;fun main() &#123; val index = NAME.indexOf(&#x27;\\&#x27;&#x27;) // \\转义 &#x27; NAME.substring(0,index) // java写法 val str = NAME.substring(0 until index) println(str)&#125; spiltsiilt返回的是List集合数据，List集合又支持解构语法特性，它允许你在一个表达式里给多个变量赋值，解构常用来简化变量的赋值。 123val data = NAMES.split(&quot;,&quot;)val (girl1,girl2,girl3,girl4) = NAMES.split(&quot;,&quot;)println(&quot;$girl1 $girl2 $girl3 $girl4 &quot;) replcae123456789101112131415161718 /** * 加密替换一个字符串 */val str1 = &quot;The people&#x27;s Republic of China.&quot; //第一个参数是正则表达式，用来决定要替换哪些字符 //第二个参数是匿名函数，用来确定如何替换正则表达式搜索到的字符val str2 = str1.replace(Regex(&quot;[aeiou]&quot;)) &#123; when (it.value) &#123; &quot;a&quot; -&gt; &quot;8&quot; &quot;e&quot; -&gt; &quot;6&quot; &quot;i&quot; -&gt; &quot;9&quot; &quot;o&quot; -&gt; &quot;1&quot; &quot;u&quot; -&gt; &quot;3&quot; else -&gt; it.value &#125;&#125;println(str1)println(str2) 结果 The people’s Republic of China.Th6 p61pl6’s R6p3bl9c 1f Ch9n8. 字符串的比较用 == 检查两个字符串中的字符是否匹配， 用 === 检查两个变量是否指向内存堆上的同一对象， 而在Java中 ==做引用比较，做结构比较时用equals方法. 1234567val str3 = &quot;Jason&quot;val str4 = &quot;Jason&quot;println(str3==str4)println(str3===str4) //相同字符串的字符串，使用字符串常量池中相同的对象val str5 = &quot;jason&quot;.capitalize() //这种情况会创建新的对象，why?println(str3===str5) 结果 truetruefalse 字符串遍历123str1.forEach &#123; print(&quot;$it &quot;)&#125; 数字类型kotlin所有的数字类型都是有符号的，也就是既可以表示正数，也可以表示负数。 安全转换函数NumberConvert toDoubleOrNull和toIntOrNull这样的安全转换函数，如果数值不能正确转换，与其触发异常不如干脆返回null值。 12345678// val number1 = &quot;6.66&quot;.toInt() val number1:Int? = &quot;6.66&quot;.toIntOrNull() println(number1) println(8.956765.toInt()) println(8.956765.roundToInt()) //四舍五入 val s = &quot;%.2f&quot;.format(8.956765) println(s) 结果 null898.96 标准库函数StandLibFunc.kt applyapply函数可看作一个配置函数，传入一个接收者，然后调用一系列的函数来配置它以便使用，如果提供lambda给apply函数执行，它会返回配置好的接收者。 配置file对象，传入file对象配置它，配置完file对象返回. 123456789101112// 配置一个File实例val file = File(&quot;E// I have a dream.txt&quot;)file.setReadable(true)file.setWritable(true)file.setExecutable(false)//使用applyval file1 = File(&quot;E// I have a dream.txt&quot;).apply &#123; setReadable(true) setWritable(true) setExecutable(false)&#125; Lambda表达式里，apply能让每个配置函数都作用于接收者，这种行为又叫相关作用于，因为lambda表达式里的所有函数调用都是针对接收者的，或者说他们是针对接收者的隐式调用。 letlet函数能是某个便利作用于lambda表达式里，让it关键字能引用它。let与apply比较，let会把接收者传给lambda，而apply什么都不传，匿名函数执行完，apply会发挥当前接收者，而let会返回lambda的最后一行。 12345678910111213141516171819202122 var result = listOf(3, 2, 1).first().let &#123; it * it &#125; // val firstElement = listOf(3, 2, 1).first() //java 方式 // val result = firstElement * firstElement println(formatGreeting(null)) println(formatGreeting(&quot;Jack&quot;)) fun formatGreeting(guestNmae: String?): String &#123; return guestNmae?.let &#123; &quot;Welcom, $it&quot; &#125; ?: &quot;What&#x27;s your name&quot;&#125;// Java方式fun formatGreeting2(guestNmae: String?): String &#123; return if (guestNmae != null) &#123; &quot;Welcom, $guestNmae&quot; &#125; else &#123; &quot;What&#x27;s your name&quot; &#125;&#125; run 光看作用域行为， run和apply差不多，但与apply不同，run函数不返回接收者，run返回的是lambda结果. run也能用来执行函数引用å 12345678910111213141516171819202122232425var file = File(&quot;THINKKOTLIN/I have a dream.txt&quot;)val result = file.run &#123; readText().contains(&quot;great&quot;) //最后一行执行结果返回 &quot;xxx&quot;&#125;println(result)val result2 = &quot;The people&#x27;s Republic of china.&quot;.run(::isLong)println(result2)&quot;The people&#x27;s Republic of china.&quot; .run(::isLong) .run(::showMessage) .run(::println)fun isLong(name: String) = name.length&gt;10fun showMessage(isLong: Boolean): String &#123; return if(isLong)&#123; &quot;Name is too long.&quot; &#125;else&#123; &quot;Please rename.&quot; &#125;&#125; withwith函数是run的变体，他们的功能行为是一样的，但with的调用方式不同，调用with时需要值参作为其第一个参数传入。 12var result3 = &quot;The people&#x27;s Republic of china.&quot;.run &#123; length &gt; 10 &#125;val result4 = with(&quot;The people&#x27;s Republic of china.&quot;) &#123; length &gt;= 10 &#125; also​ also和let类似，和let一样，also也是把接收者作为值参传给lambda,但是有点不同: also返回接收者对象，而let返回lambda结果。因此also适合针对同一原始对象，利用副作用做事，肌肉also返回的是接收者对象，就可以基于原始接收者对象执行额外的链式调用。 12345678var fileContents: List&lt;String&gt;File(FILE_DREAM) .also &#123; println(it.name) &#125;.also &#123; fileContents = it.readLines() &#125;println(fileContents) takeif 123456//如果 it.exists() &amp;&amp; it.canRead() 返回true,返回file对象，接着执行后面语句。// 如果为false，就返回null,就不会执行后面的语句。val readText = File(FILE_DREAM) .takeIf &#123; it.exists() &amp;&amp; it.canRead() &#125; ?.readText()println(readText) takeUnless和takeif是反的 takeUnless, 只有判断你给定的条件结果是 false 时，takeUnless才会返回原始接收者对象。 1234val result5 = File(FILE_DREAM) .takeUnless &#123; it.isHidden &#125; //不是 不可见的，所以是false ?.readText()println(result5)","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://noteforme.github.io.com/categories/Kotlin/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://noteforme.github.io.com/tags/Kotlin/"}],"keywords":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://noteforme.github.io.com/categories/Kotlin/"}]},{"title":"kmp","slug":"kmp","date":"2021-06-17T14:44:42.000Z","updated":"2021-08-19T11:11:44.300Z","comments":true,"path":"2021/06/17/kmp/","link":"","permalink":"http://noteforme.github.io.com/2021/06/17/kmp/","excerpt":"","text":"蛮力算法 i++ j++ 12345678910111213141516171819/****************************************************************************************** * Text : 0 1 2 . . . i-j . . . . i . . n-1 * ------------------------|-------------------|------------ * Pattern : 0 . . . . j . . * |-------------------| ******************************************************************************************/int match ( char* P, char* T ) &#123; //串匹配算法（Brute-force-1） size_t n = strlen ( T ), i = 0; //文本串长度、当前接受比对字符的位置 size_t m = strlen ( P ), j = 0; //模式串长度、当前接受比对字符的位置 while ( j &lt; m &amp;&amp; i &lt; n ) //自左向右逐个比对字符 /*DSA*/&#123;// /*DSA*/showProgress ( T, P, i - j, j ); getchar(); if ( T[i] == P[j] ) //若匹配 &#123; i ++; j++; &#125; //则转到下一对字符 else //否则 &#123; i -= (j - 1); j = 0; &#125; //文本串回退、模式串复位 // i j 都在往右走， i -= (j - 1) 相当于i在初始位置 又往右走了一步 /*DSA*/&#125; return i - j; //如何通过返回值，判断匹配结果？&#125; i , j++ 123456789101112131415161718/****************************************************************************************** * Text : 0 1 2 . . . i i+1 . . . i+j . . n-1 * ------------------------|-------------------|------------ * Pattern : 0 1 . . . j . . * |-------------------| ******************************************************************************************/int match ( char* P, char* T ) &#123; //串匹配算法（Brute-force-2） size_t n = strlen ( T ), i = 0; //文本串长度、与模式串首字符的对齐位置 size_t m = strlen ( P ), j; //模式串长度、当前接受比对字符的位置 for ( i = 0; i &lt; n - m + 1; i++ ) &#123; //文本串从第i个字符起，与 for ( j = 0; j &lt; m; j++ ) //模式串中对应的字符逐个比对 /*DSA*/&#123;showProgress ( T, P, i, j ); getchar(); if ( T[i + j] != P[j] ) break; //若失配，模式串整体右移一个字符，再做一轮比对 /*DSA*/&#125; if ( j &gt;= m ) break; //找到匹配子串 &#125; return i; //如何通过返回值，判断匹配结果？&#125; KMP算法 算法主体 1234567891011121314151617int match ( char* P, char* T ) &#123; //KMP算法 int* next = buildNext ( P ); //构造next表 int n = ( int ) strlen ( T ), i = 0; //文本串指针 int m = ( int ) strlen ( P ), j = 0; //模式串指针 while ( j &lt; m &amp;&amp; i &lt; n ) //自左向右逐个比对字符 /*DSA*/&#123; /*DSA*/showProgress ( T, P, i - j, j ); /*DSA*/printNext ( next, i - j, strlen ( P ) ); /*DSA*/getchar(); printf ( &quot;\\n&quot; ); if ( 0 &gt; j || T[i] == P[j] ) //若匹配，或P已移出最左侧（两个判断的次序不可交换） &#123; i ++; j ++; &#125; //则转到下一字符 else //否则 j = next[j]; //模式串右移（注意：文本串不用回退） /*DSA*/&#125; delete [] next; //释放next表 return i - j;&#125; 构建next表 1234567891011121314int* buildNext ( char* P ) &#123; //构造模式串P的next表 size_t m = strlen ( P ), j = 0; //“主”串指针 int* N = new int[m]; //next表 int t = N[0] = -1; //模式串指针 while ( j &lt; m - 1 ) if ( 0 &gt; t || P[j] == P[t] ) &#123; //匹配 j ++; t ++; N[j] = t; //此句可改进... &#125; else //失配 t = N[t]; /*DSA*/printString ( P ); printf ( &quot;\\n&quot; ); /*DSA*/printNext ( N, 0, m ); return N;&#125; https://www.bilibili.com/video/av3246487/","categories":[{"name":"DataStructure","slug":"DataStructure","permalink":"http://noteforme.github.io.com/categories/DataStructure/"}],"tags":[],"keywords":[{"name":"DataStructure","slug":"DataStructure","permalink":"http://noteforme.github.io.com/categories/DataStructure/"}]},{"title":"Assembly","slug":"Assembly","date":"2021-05-21T03:13:41.000Z","updated":"2021-08-19T11:11:43.686Z","comments":true,"path":"2021/05/21/Assembly/","link":"","permalink":"http://noteforme.github.io.com/2021/05/21/Assembly/","excerpt":"","text":"8086 14个寄存器AX , BX , CX , DX , SI , DI , SP , BP, IP , CS , SS, DS ,ES ,PSW 实验环境搭建 https://github.com/froginwell/assembly https://www.bilibili.com/s/video/BV1254y1B75r CS:IP 他们指示了CPU当前要读取指令的地址。 CS为代码段地址 IP 指令指针寄存器 jmp ax ,含义上类似 ： mov IP , ax 第三章DS和addressdebug中，内存单元从左到右是地址从低到高顺序排列的。 8086CPU自动取ds中的数据为内存单元的段地址 move , add , sub [0] ， 0表示内存单元的偏移地址 SS:SP 指向栈顶元素，栈顶的段地址存放在栈顶，偏移地址存放在SP中。 Loop5.3 在Debug中跟踪用loop指令实现的循环程序 ​ 实验四 向内存0:200H0:23fH依次传送数据063（3FH） 内存0:200H~0:23fH空间与0020:0-0020:3f内存空间是一样的 (0:200 0020:0物理地址相同) 答案 https://www.cnblogs.com/Base-Of-Practice/category/1005745.html https://blackdragonf.github.io/2017/03/09/%E7%8E%8B%E7%88%BD%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%B8%89%E7%89%88%E5%AE%9E%E9%AA%8C/ 视频 小甲鱼","categories":[],"tags":[{"name":"Assembly","slug":"Assembly","permalink":"http://noteforme.github.io.com/tags/Assembly/"}],"keywords":[]},{"title":"Data_LinkedList","slug":"Data-LinkedList","date":"2021-04-19T13:49:19.000Z","updated":"2021-08-19T11:11:43.769Z","comments":true,"path":"2021/04/19/Data-LinkedList/","link":"","permalink":"http://noteforme.github.io.com/2021/04/19/Data-LinkedList/","excerpt":"","text":"链表 首节点 第一个有效节点 尾节点 最后一个有效节点 头节点 头节点的数据类型和首节点类型一样 第一个有效节点之前的那个节点，只存放了 首节点 的地址 头节点并不存在有效数据 加头节点的目的主要是为了方便对链表的操作 头指针 ​ 指向头节点的指针变量 ​ 只占用4个byte,比头节点占用空间小. 尾指针 指向尾节点的指针变量 栈123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;printf.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;typedef struct Node &#123; int data; struct Node *pNext;&#125; NODE, *PNODE;typedef struct Stack &#123; PNODE pTop; PNODE pBottom;&#125; STACK, *PSTACK; //PSTACK等价于 stuct STACK *void init(PSTACK);void push(STACK *pStack, int i);void traverse(STACK *pStack);bool pop(PSTACK pS, int *pVal);void clear(PSTACK ps);bool empty(PSTACK pStack);int main() &#123; STACK S; //等价于 struct Stack init(&amp;S); push(&amp;S, 1); push(&amp;S, 22); push(&amp;S, 88); traverse(&amp;S); int val;// if (pop(&amp;S, &amp;val)) &#123;// printf(&quot;出栈成功\\n&quot;);// printf(&quot;出栈的数据 %d \\n&quot;, val);// &#125; else &#123;// printf(&quot;出栈失败\\n&quot;);// &#125; clear(&amp;S); printf(&quot;清空数据\\n&quot;); traverse(&amp;S);&#125;void push(STACK *pStack, int val) &#123; PNODE pNew = (PNODE) malloc(sizeof(NODE)); pNew-&gt;data = val; pNew-&gt;pNext = pStack-&gt;pTop; //如果是空可以用pBottom，但是后面不为空 pStack-&gt;pTop = pNew;&#125;void init(PSTACK pS) &#123; pS-&gt;pTop = (PNODE) malloc(sizeof(NODE)); if (NULL == pS-&gt;pTop) &#123; printf(&quot;动态内存分配失败!\\n&quot;); exit(-1); &#125; else &#123; pS-&gt;pBottom = pS-&gt;pTop; pS-&gt;pTop-&gt;pNext = NULL; &#125;&#125;void traverse(PSTACK pS) &#123; PNODE p = pS-&gt;pTop; while (p != pS-&gt;pBottom) &#123; printf(&quot;%d &quot;, p-&gt;data); p = p-&gt;pNext; &#125;&#125;//把pS所指向的栈出栈一次，并把出栈的元素存入pVal形参所指向的变量中，如果出栈失败，返回false,否则返回true,bool pop(PSTACK pS, int *pVal) &#123; *pVal = pS-&gt;pTop-&gt;data; PNODE p = pS-&gt;pTop; if (pS-&gt;pTop != pS-&gt;pBottom) &#123; //或者写个方法 isEmpty() pS-&gt;pTop = pS-&gt;pTop-&gt;pNext; return true; &#125; free(p); return false;&#125;//清空void clear(PSTACK pS)&#123; if(empty(pS))&#123; return; &#125; else&#123; PNODE p = pS-&gt;pTop; PNODE q = NULL; while(p!=pS-&gt;pBottom)&#123; q = p-&gt;pNext; free(p); p = q; &#125; pS-&gt;pTop = pS-&gt;pBottom; &#125;&#125;bool empty(PSTACK pS) &#123; if(pS-&gt;pTop==pS-&gt;pBottom)&#123; return true; &#125; return false;&#125; 应用 函数调用 中断 表达式求值 内存分配 缓冲处理 迷宫 链表队列队列 ： 一种可以实现先进先出的存储结构 队列链式队列 – 用链表实现。 静态队列 – 用数组实现。 循环队列（数组）定义 队列初始化 front和rear的值都是0。 队列非空 front代表队列的第一个元素。 rear代表队列的最后一个有效 元素的下一个元素。 队列空 front和rear的值相等，但他们的值不一定时0。 操作入队: 将值存入r所代表的位置，接着r后移一位。 出队:f后移一位。 如何判断循环队列是否已满​ r==f时候，可能为空，页可能满的。 多增加一个标识参数，存放元素个数 少用一个元素 (r+1)%数组的长度 = f ![](Data-LinkedList/Screenshot from 2021-04-22 17-48-04_circleLinkedList.png) CircleQueue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;#include &lt;stdlib.h&gt;typedef struct Queue &#123; int *pBase; int front; int rear;&#125; QUEUE;void init(QUEUE *);bool en_queue(QUEUE *, int val); //入队void traverse_queue(QUEUE *);bool full_queue(QUEUE *pQueue);//队列是否已满bool out_queue(QUEUE *pQueue, int *pInt); //出队bool empty_queue(QUEUE *pQueue);int main() &#123; QUEUE Q; init(&amp;Q); en_queue(&amp;Q, 2); en_queue(&amp;Q, 7); en_queue(&amp;Q, 33); en_queue(&amp;Q, 4); en_queue(&amp;Q, 9); traverse_queue(&amp;Q); //执行这句 pQ-&gt;front会变，所以出队列失败// int pVal;// if(out_queue(&amp;Q,&amp;pVal))&#123;// printf(&quot;出队成功，出队元素是 %d \\n&quot;,pVal);// &#125; else&#123;// printf(&quot;出队失败\\n&quot;);// &#125;// traverse_queue(&amp;Q);&#125;void init(QUEUE *pQ) &#123; pQ-&gt;pBase = malloc(sizeof(int) * 6); pQ-&gt;front = 0; pQ-&gt;rear = 0;&#125;bool full_queue(QUEUE *pQ) &#123; if ((pQ-&gt;rear + 1) % 6 == pQ-&gt;front) &#123; return true; &#125; return false;&#125;bool en_queue(QUEUE *pQ, int val) &#123; if (full_queue(pQ)) &#123; return false; &#125; else &#123; pQ-&gt;pBase[pQ-&gt;rear] = val; pQ-&gt;rear = (pQ-&gt;rear + 1) % 6; return true; &#125;&#125;//void traverse_queue(QUEUE *pQ) &#123;// int q = pQ-&gt;front;// while ((q) % 6 != pQ-&gt;rear) &#123;// printf(&quot; %d &quot;, pQ-&gt;pBase[(pQ-&gt;front++) % 6]);// q++;// &#125;// return;//&#125;//或者下面方式void traverse_queue(QUEUE *pQ) &#123; int i = pQ-&gt;front; while (i!=pQ-&gt;rear)&#123; printf(&quot;%d &quot;,pQ-&gt;pBase[i]); i = (i+1)%6; &#125; printf(&quot;\\n&quot;); return;&#125;bool out_queue(QUEUE *pQ, int *pInt) &#123; if(empty_queue(pQ))&#123; return false; &#125; else&#123; *pInt = pQ-&gt;pBase[pQ-&gt;front]; pQ-&gt;front=(pQ-&gt;front+1)%6; return true; &#125;&#125;bool empty_queue(QUEUE *pQ) &#123; if(pQ-&gt;front==pQ-&gt;rear)&#123; return true; &#125; return false;&#125;","categories":[{"name":"DataStructure","slug":"DataStructure","permalink":"http://noteforme.github.io.com/categories/DataStructure/"}],"tags":[],"keywords":[{"name":"DataStructure","slug":"DataStructure","permalink":"http://noteforme.github.io.com/categories/DataStructure/"}]},{"title":"Data_Tree","slug":"Data-Tree","date":"2021-03-24T13:46:39.000Z","updated":"2021-08-19T11:11:43.778Z","comments":true,"path":"2021/03/24/Data-Tree/","link":"","permalink":"http://noteforme.github.io.com/2021/03/24/Data-Tree/","excerpt":"","text":"树分类 满二叉树 : ​ 在不增加树的层数的前提下，无法再多添加一个节点的二叉树就是满二叉树。 完全二叉树 : ​ 如果只是删除了满二叉树最底层最右边的连续若干个节点，这样形成的二叉树是完全二叉树。 树的存储二叉树表示法 ​ 先把一般树转化为二叉树，再存储二叉树。 ​ 一般树转化为二叉树的方法是:设法保证任意一个节点的 左指针域指向它的第一个孩子 右指针域指向它的下一个兄弟 只要能满足此条件，就可以把一个普通树转化为二叉树来存储。 BST树- Binary search tree删除 1234567891011121314151617181920212223template&lt;typename T&gt;static BinNodePosi&lt;T&gt; removeAt(BinNodePosi&lt;T&gt; &amp;x, BinNodePosi&lt;T&gt; &amp;hot) &#123; printf(&quot; x %d \\n&quot;,x-&gt;data); BinNodePosi&lt;T&gt; w = x; //实际被摘除的节点，初值同x BinNodePosi&lt;T&gt; succ = NULL; //实际被删除节点的接替者 if (!HasLChild (*x)) //若*x的左子树为空，则可 succ = x = x-&gt;rc; //直接将*x替换为其右子树 else if (!HasRChild (*x)) //若右子树为空，则可 succ = x = x-&gt;lc; //对称地处理——注意：此时succ != NULL else &#123; //若左右子树均存在，则选择x的直接后继作为实际被摘除节点，为此需要 w = w-&gt;succ(); //（在右子树中）找到*x的直接后继*w swap(x-&gt;data, w-&gt;data); //交换*x和*w的数据元素 BinNodePosi&lt;T&gt; u = w-&gt;parent; printf(&quot;u %d x %d \\n&quot;,u-&gt;data,x-&gt;data); ((u == x) ? u-&gt;rc : u-&gt;lc) = succ = w-&gt;rc; //隔离节点*w // (u == x)感觉没作用呀 ??? &#125; hot = w-&gt;parent; //记录实际被删除节点的父亲 if (succ) succ-&gt;parent = hot; //并将被删除节点的接替者与hot相联 release(w-&gt;data); release(w); return succ; //释放被摘除节点，返回接替者&#125; //rele ​ 树的遍历 ​ M N 作为根节点 先序遍历[先访问根节点] 先访问根节点 再先序访问左子树 再先序访问右子树 A B Q M N L C D H K E F 中序遍历[中间访问根节点] 中序遍历左子树 再访问根节点 再中遍历右子树 M Q N B L A H D K C E F 后序遍历[最后访问根节点] 先中序遍历左子树 再中序遍历右子树 再访问根节点 M N Q L B H K D F E C A 推导通过先序和中序或者 中序和后序可以还原出 原始的二叉树. 示例1 先序: ABCDEFGH 中序:BDCEAFHG 求后序: DECBHGFA 示例2 先序: ABDGHCEFI 中序:GDHBAECIF 求后序 : G H D B E I F C A 二叉树遍历示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;zconf.h&gt;#include &lt;malloc.h&gt;struct BTNode &#123; int data; struct BTNode *pLchild; struct BTNode *pRchild;&#125;;struct BTNode *createBTree();void preTraverseBTree(struct BTNode *pNode);int main() &#123; struct BTNode *pT = createBTree();// preTraverseBTree(pT);// inTraverseBTree(pT); postTraverseBTree(pT); return 0;&#125;void preTraverseBTree(struct BTNode *pNode) &#123; if (pNode-&gt;data != NULL) &#123; printf(&quot;%c\\n&quot;, pNode-&gt;data); if (pNode-&gt;pLchild != NULL) &#123; preTraverseBTree(pNode-&gt;pLchild); &#125; if (pNode-&gt;pRchild != NULL) &#123; preTraverseBTree(pNode-&gt;pRchild); &#125; &#125;&#125;void inTraverseBTree(struct BTNode *pNode) &#123; if (pNode-&gt;data != NULL) &#123; if (pNode-&gt;pLchild != NULL) &#123; inTraverseBTree(pNode-&gt;pLchild); &#125; printf(&quot;%c\\n&quot;, pNode-&gt;data); if (pNode-&gt;pRchild != NULL) &#123; inTraverseBTree(pNode-&gt;pRchild); &#125; &#125;&#125;void postTraverseBTree(struct BTNode *pNode) &#123; if (pNode-&gt;data != NULL) &#123; if (pNode-&gt;pLchild != NULL) &#123; postTraverseBTree(pNode-&gt;pLchild); &#125; if (pNode-&gt;pRchild != NULL) &#123; postTraverseBTree(pNode-&gt;pRchild); &#125; printf(&quot;%c\\n&quot;, pNode-&gt;data); &#125;&#125;struct BTNode *createBTree() &#123; struct BTNode *pA = (struct BTNode *) malloc(sizeof(struct BTNode)); struct BTNode *pB = (struct BTNode *) malloc(sizeof(struct BTNode)); struct BTNode *pC = (struct BTNode *) malloc(sizeof(struct BTNode)); struct BTNode *pD = (struct BTNode *) malloc(sizeof(struct BTNode)); struct BTNode *pE = (struct BTNode *) malloc(sizeof(struct BTNode)); pA-&gt;data = &#x27;A&#x27;; pB-&gt;data = &#x27;B&#x27;; pC-&gt;data = &#x27;C&#x27;; pD-&gt;data = &#x27;D&#x27;; pE-&gt;data = &#x27;E&#x27;; pA-&gt;pLchild = pB; pA-&gt;pRchild = pC; pB-&gt;pLchild = pB-&gt;pRchild = NULL; pC-&gt;pLchild = pD; pC-&gt;pRchild = NULL; pD-&gt;pLchild = NULL; pD-&gt;pRchild = pE; pE-&gt;pLchild = pE-&gt;pRchild = NULL; return pA;&#125; AVL树左右子树的高度差 不超过1 通过左旋或者右旋(左旋右旋后一定不会破坏二叉搜索树的查找规则 zig zagzig 顺时针 zag 逆时针 g : grandparent节点 p : parent节点 zigzig zigzag节点 类似工人组装魔方，确定好 G P V 所对应的 a b c ,何 0 1 2 3 所对应的 T0 T1 T2 T3,直接组装程图1的树 1234567891011121314151617181920template &lt;typename T&gt; BinNodePosi&lt;T&gt; BST&lt;T&gt;::rotateAt ( BinNodePosi&lt;T&gt; v ) &#123; //v为非空孙辈节点 /*DSA*/if ( !v ) &#123; printf ( &quot;\\a\\nFail to rotate a null node\\n&quot; ); exit ( -1 ); &#125; BinNodePosi&lt;T&gt; p = v-&gt;parent; BinNodePosi&lt;T&gt; g = p-&gt;parent; //视v、p和g相对位置分四种情况 if ( IsLChild ( *p ) ) /* zig */ if ( IsLChild ( *v ) ) &#123; /* zig-zig */ //*DSA*/printf(&quot;\\tzIg-zIg: &quot;); p-&gt;parent = g-&gt;parent; //向上联接 return connect34 ( v, p, g, v-&gt;lc, v-&gt;rc, p-&gt;rc, g-&gt;rc ); &#125; else &#123; /* zig-zag */ //*DSA*/printf(&quot;\\tzIg-zAg: &quot;); v-&gt;parent = g-&gt;parent; //向上联接 return connect34 ( p, v, g, p-&gt;lc, v-&gt;lc, v-&gt;rc, g-&gt;rc ); &#125; else /* zag */ if ( IsRChild ( *v ) ) &#123; /* zag-zag */ //*DSA*/printf(&quot;\\tzAg-zAg: &quot;); p-&gt;parent = g-&gt;parent; //向上联接 return connect34 ( g, p, v, g-&gt;lc, p-&gt;lc, v-&gt;lc, v-&gt;rc ); &#125; else &#123; /* zag-zig */ //*DSA*/printf(&quot;\\tzAg-zIg: &quot;); v-&gt;parent = g-&gt;parent; //向上联接 return connect34 ( g, v, p, g-&gt;lc, v-&gt;lc, v-&gt;rc, p-&gt;rc ); &#125;&#125; 伸缩树 B-TreeB树解决 一段一段从IO读取数据 地址 B树插入因为新节点的插入，导致所属节点的分支数超过B树阶次m的情况称作overflow ​ m=5时，每个节点的分支数不超过5，一般节点分支树不少于是3, (3,5) ​ m=6 对于6阶B树，分支树的上限是6，下限是3。 (3,6) B树上溢分裂 A[n/2]节点中点分裂 ​ 插入37，然后上溢分裂 下溢 先从兄弟树借节点，借不到的话就合并 2-3-4树特点 所有叶子节点都拥有相同的深度。 节点只能是 2-节点、3-节点、4-节点之一。 2-节点:包含 1 个元素的节点，有 2 个子节点; 3-节点:包含 2 个元素的节点，有 3 个子节点; 4-节点:包含 3 个元素的节点，有 4 个子节点; 所有节点必须至少包含1个元素 元素始终保持排序顺序，整体上保持二叉查找树的性质，即父结点大于左子结点，小于右子结点; 而且结点有多个元素时，每个元素必须大于它左边的和它的左子树中元素。 2-3树的生长和标准的二叉查找树由上向下生长不同，2-3树的生长是由下向上的。 红黑二叉查找树2-3-4树与红黑树的等价关系 ​ ​ 裂变状态 9先从黑节点(从4节点)变成红节点，10、12先从红节点变成黑节点。 2-3-4 树新增操作，从叶子节点开始 红黑树 性质红黑树是一种结点带有颜色属性的二叉查找树，但它在二叉查找树之外，还有以下5大性质: 节点是红色或黑色。 根是黑色。 所有叶子都是黑色(叶子是NIL节点，这类节点不可以忽视，否则代码会看不懂)。 每个红色节点必须有两个黑色的子节点。(从每个叶子到根的所有路径上不能有两个连续的红色节点。) 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点(黑色平衡)。// 2-3-4树层级相等. https://www.cs.usfca.edu/~galles/visualization/RedBlack.html 红黑树 新增都是红色节点 根据上面的等价关系，把2-3-4树转换成下面的红黑树。 https://www.bilibili.com/video/BV135411h7wJ?p=4 旋转 12345678910111213141516171819202122232425262728293031/** * 围绕p左旋 * pf pf * / / * p pr(r) * / \\ ==&gt; / \\ * pl pr(r) p rr * / \\ / \\ * rl rr pl rl * * @param p */ private void leftRotate(RBNode p) &#123; if (p != null) &#123; RBNode r = p.right; p.right = r.left; if (r.left != null) &#123; r.left.parent = p; &#125; r.parent = p.parent; if (p.parent == null) &#123; root = r; &#125; else if (p.parent.left == p) &#123; p.parent.left = r; &#125; else &#123; p.parent.right = r; &#125; r.left = p; p.parent = r; &#125; &#125; 12345678910111213141516171819202122232425262728293031/** * 右旋 * pf pf * \\ \\ * p (l)pl * / \\ =&gt; / \\ *(l)pl pr ll p * / \\ / \\ * ll lr lr pr * * @param p */ private void rightRotate(RBNode p) &#123; if (p != null) &#123; RBNode l = p.left; p.left = l.right; if (l.right != null) &#123; l.right.parent = p; &#125; l.parent = p.parent; if (p.parent == null) &#123; root = l; &#125; else if (p.parent.right == p) &#123; p.parent.right = l; &#125; else &#123; p.parent.left = l; &#125; l.right = p; p.parent = l; &#125; &#125; 新增红黑树新增，第一个节点 是红节点 新增的节点都是红节点 红黑树形成过程，忘了怎么形成，包括旋转 ， 节点颜色是怎么变化的。 删除https://www.cs.usfca.edu/~galles/visualization/RedBlack.html 图找到最优路径","categories":[{"name":"DataStructure","slug":"DataStructure","permalink":"http://noteforme.github.io.com/categories/DataStructure/"}],"tags":[],"keywords":[{"name":"DataStructure","slug":"DataStructure","permalink":"http://noteforme.github.io.com/categories/DataStructure/"}]},{"title":"Data_Sort","slug":"Data-Sort","date":"2021-03-21T05:04:53.000Z","updated":"2021-08-19T11:11:43.770Z","comments":true,"path":"2021/03/21/Data-Sort/","link":"","permalink":"http://noteforme.github.io.com/2021/03/21/Data-Sort/","excerpt":"","text":"排序冒泡 1234567891011public static void bubbleSort(int[] arr) &#123; for (int i = arr.length - 1; i &gt; 0; i--) &#123; //剩余需要排序的长度 for (int j = 0; j &lt; i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int t = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = t; &#125; &#125; &#125;&#125; 思路1: 第一次遍历最大的元素放到最右边，第二遍放倒数第二个位置，… 一开始的想法是i 也递增，j&lt; arr.length - 1 - i 。但是这样可读性就不如 i 递减的方式，还要注意数组越界的问题，所以int i = arr.length - 1 思路2 还可以通过增加 swap，遍历后判断是否有序,当前一轮没有进行交换时，说明数组已经有序，没有必要再进行下一轮的循环了，直接退出 1234567891011121314151617public static void bubbleSort2(int[] arr) &#123; boolean swap; for (int i = arr.length - 1; i &gt; 0; i--) &#123; //剩余需要排序的长度 swap = false; for (int j = 0; j &lt; i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int t = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = t; swap = true; &#125; &#125; if (!swap) &#123; break; &#125; &#125; &#125; 选择排序通过比较找到当前的最大元素M,并通过交换使值就位 12345678910111213141516//选择排序 public static void selectionSort(int[] arr) &#123; int maxIndex; //知道下标就能得到值 int tmp; for (int i = arr.length - 1; i &gt; 0; i--) &#123; maxIndex = 0; for (int j = 1; j &lt;= i; j++) &#123; if (arr[j] &gt; arr[maxIndex]) &#123; maxIndex = j; &#125; &#125; tmp = arr[i]; arr[i] = arr[maxIndex]; arr[maxIndex] = tmp; &#125; &#125; 快速排序思想： 前一序列的元素 都小于等于后一序列的元素，递归后 只剩单个元素时，自身就是有序的，可以作为递归基。 快速排序1 初始情况U是整个序列， L G是空,然后 lo hi都向内侧移动，最终hi lo指向同一个位置m,也就是最终的轴点。 L &lt;= pivot &lt;= G; U = [lo,hi]中，[lo]和[hi]交替空闲 当_elem[hi]&gt;pivot时，hi向左移动，自序列G跟着拓展。 当_elem[hi]&lt;pivot时，把_elem[hi]移动到lo位置上。 向右移动lo,拓展子序列lo。 当elem[lo] &gt; pivot时，把elem[lo] 移动到hi位置上。 最终hi lo指向同一个位置m,也就是最终的轴点pivot。 123456789101112131415161718public static void quickSort(int[] arr, int lo, int hi) &#123; if (lo&gt;=hi) return; int mi = partition(arr, lo, hi); quickSort(arr, lo, mi-1); quickSort(arr, mi + 1, hi);&#125;private static int partition(int[] elem, int lo, int hi) &#123; int pivot = elem[lo]; while (lo &lt; hi) &#123; while (lo&lt;hi&amp;&amp;elem[hi] &gt;= pivot) hi--; elem[lo] = elem[hi]; while (lo&lt;hi&amp;&amp;elem[lo] &lt; pivot) lo++; elem[hi] = elem[lo]; &#125; elem[lo]= pivot; return lo;&#125; 快速排序2快速排序变种 插入排序 希尔排序 https://www.bilibili.com/video/BV1LT4y137cK?from=search&amp;seid=6852216660251002525 归并排序代码不太理解(学堂在线) 符号表的各种实现的优缺点 堆排序结合了数组与链表的特性 自下而上 2 1 6 3 9 7 4 8 5 最末尾的内部节点所对应的秩开始 floor(9/2)-1=3,也就是第三个位置，接下来是堆6 1 2进行下滤操作 一开始很不理解为什么是 floor(9/2)-1，因为前面有 parent(i) = (i-1)&gt;&gt;1 其实这个9就是 arr.length,这里的 i是下标,也就是 arr.length-1,这样就很好理解为什么-1可以移出来 建堆 按照树的层序遍历顺序，从左到右开始建堆。 接着根据floyd算法开始调整， 5/2 - 1 = 1,第一个位置对应的是3，3上移 接着是5,上移， 上面左下图是调整之后的，完全二叉堆 上面的数字太小，https://www.youtube.com/watch?v=WsNQuCa_-PU 这个视频有两次调整的情况 选取与调整 类似于选择排序 选取根节点5和末尾元素2交换,放到向量末尾，5放到 已排序序列，从完全二叉堆中移出。 对根节点2下滤 选取根节点4和末位置1交换，4放到已排序序列，下面依次操作 123456789101112131415161718192021222324252627282930313233343536public static void heapSort(int[] arr) &#123; buildHeap(arr, arr.length); //建堆 selectSorted(arr); // 交换 下滤&#125;private static void buildHeap(int[] arr, int length) &#123; for (int k = (length - 1) &gt;&gt; 1; k &gt;= 0; k--) &#123; //最后的内部节点 往前遍历 addJustHeap(arr, k, length); &#125;&#125;private static void addJustHeap(int[] arr, int k, int length) &#123; for (int i = 2 * k + 1; i &lt;= length; i = 2 * i + 1) &#123; // 上面节点调整后，可能比子节点还小，需要继续调整 if ((i + 1) &lt; length &amp;&amp; arr[i] &lt; arr[i + 1]) &#123; i++; // 左子树比右子树小，用右子树比较 &#125; if (i &lt; length &amp;&amp; arr[k] &lt; arr[i]) &#123; swap(arr, k, i); k = i; &#125; &#125;&#125;private static void selectSorted(int[] arr) &#123; for (int j = 0; j &lt; arr.length - 1; j++) &#123; swap(arr, 0, arr.length - 1 - j); //交换到已排序位置 addJustHeap(arr, 0, arr.length - 1 - j); //继续调整 &#125;&#125;private static void swap(int[] arr, int k, int i) &#123; int tmp = arr[i]; arr[i] = arr[k]; arr[k] = tmp;&#125; https://zhuanlan.zhihu.com/p/42586566","categories":[{"name":"DataStructure","slug":"DataStructure","permalink":"http://noteforme.github.io.com/categories/DataStructure/"}],"tags":[],"keywords":[{"name":"DataStructure","slug":"DataStructure","permalink":"http://noteforme.github.io.com/categories/DataStructure/"}]},{"title":"Concurrency_SychronizedVolatile","slug":"Concurrency-SychronizedVolatile","date":"2021-03-08T07:37:45.000Z","updated":"2021-08-19T11:11:43.756Z","comments":true,"path":"2021/03/08/Concurrency-SychronizedVolatile/","link":"","permalink":"http://noteforme.github.io.com/2021/03/08/Concurrency-SychronizedVolatile/","excerpt":"","text":"MESI为什么需要MESI协议 : CPU的高度运算需要高速的数据,然而内存和硬盘的发展速度远远不及CPU 一个CPU的变量发生改变，其他拥有这个变量CPU需要同步. 查看如下链接的 多核缓存协同操作流程图 https://www.bilibili.com/video/BV1fK4y1E7NC视频讲解了这个状态图的各个情况. https://www.cnblogs.com/yanlong300/p/8986041.html https://www.codenong.com/cs106520859/ Memory Barriers 通过 Store Forwarding 解决了单个 CPU 执行顺序性和内存可见性问题，但是在全局多 CPU 的环境下，这种内存可见性恐怕就很难保证了。 1234567891011void foo(void)&#123; a = 1; b = 1;&#125;void bar(void)&#123; while (b == 0) continue; assert(a == 1);&#125; 假设上面的 foo 方法被 CPU 0 执行，bar 方法被 CPU 1 执行，也就是我们常说的多线程环境。试想，即便在多线程环境下，foo 和 bar 如若严格按照理想的顺序执行，是无论如何都不会出现 assert failed 的情况的。但往往事与愿违，这种看似很诡异的且有一定几率发生的 assert failed ，结合上面所说的 Store Buffer 就一点都不难理解了。 我们来还原 assert failed 的整个过程，假设 a,b 初始值为 0 ，a 被 CPU0 和 CPU1 共同持有，b 被 CPU0 独占； CPU0 处理 a=1 之前发送 Invalidate 消息给 CPU1 ，并将其放入 Store Buffer ，尚未及时刷入缓存； CPU 0 转而处理 b=1 ，此时 b=1 直接被刷入缓存； CPU 1 发出 Read 消息读取 b 的值，发现 b 为 1 ，跳出 while 语句； CPU 1 发出 Read 消息读取 a 的值，发现 a 却为旧值 0，assert failed。 在日常开发过程中也是完全有可能遇到上面的情况，由于 a 的变更对 CPU1 不可见，虽然执行指令的时序没有真正被打乱，但对于 CPU1 来说，这造成了 b=1 先于 a=1 执行的假象，这种看是乱序的问题，通常称为 “重排序”。当然上面所说的情况，只是指令重排序的一种可能。 Java内存模型 工作内存与主内存之间的原子操作lock( 锁定 )：作用于主内存的变量，把一个变量标识为一条线程独占的状态。 unlock（解锁）：作用于主内存的变量，把一个处于锁定的变量释放出来，释放变量才可以被其他线程锁定。 read（读取）：作用于主内存的变量，把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。 load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。 use（使用）：作用于工作内存种的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。 assign（赋值）：作用于工作内存中的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用 write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的值放入主内存的变量中。 深入理解java虚拟机(12.3.2 内存间交互操作) 总线上传递的消息首先不同CPU之间也是需要沟通的，这里的沟通是通过在消息总线上传递message实现的。 Read: sent if CPU needs to read from an address Read Response: response to a read message, carries the data at the requested address Invalidate: asks others to evict a cache line Invalidate Acknowledge: reply indicating that an Read Invalidate: like Read + Invalidate (also called “read with intend to modify”) ​ Writeback: info on what data has been sent to main memory ​ 该消息包含一个物理内存地址和数据内容，目的是把这块数据通过总线写回内存里。 Read：当CPU在自己的cache中没有发现需要的物理地址，就会发送一条“READ”消息，该消息包括缓存行需要读的物理地址。 Read Response: 顾名思义，”Read Response”消息是回复“Read”消息的。“Read Response”消息是由内存或者其他CPU缓存提供的。如果其他缓存请求一个处于“modified”状态的数据，则本地缓存必须提供“Read Response”消息。这个很容易理解，别的CPU在请求本地缓存中的数据，而这份数据还没有刷新到内存，所以必须告诉其他CPU该数据的最新值。接收到”Read Response”消息后，该数据的缓存状态就由”invalid”变成了”share”或者”exclusive”，这取决于”Read Response”的提供者是内存还是其他CPU缓存。 Invalidate：“ invalidate” 消息包含要使无效的缓存行的物理地址。其他的缓存必须从它们的缓存中移除相应的数据并且响应此消息。当CPU要对一个变量进行写操作，而此变量处于只读状态(share)，就需要发送“invalid”消息。由于一个变量被多个CPU缓存，所以单个CPU的改写会造成缓存不一致，所以在写之前必须告诉其他CPU你们缓存的值马上就要过时了。接受到”invalidate”消息的CPU就会把本地缓存中的对应数据无效掉。 Invalidate Acknowledge：一个接收到“invalidate”消息的 CPU必须在移除指定数据后响应一个“invalidate acknowledge”消息。这个消息就是告诉“invalidate”消息的提供者“我已经知道你要更改这个数据了，我放弃使用自己缓存中的拷贝！” Read Invalidate：”read invalidate”消息包含要缓存行读取的物理地址。同时指示其他缓存移除数据。因此，它包含一个”read”和一个”invalidate”。“read invalidate”也需要“read response”以及”invalidate acknowledge”消息集。 “Read Invalidate”消息的发送时机有两个：第一个是CPU对一个数据进行原子读写操作，但是该数据没有在本地CPU的缓存中，在其他CPU缓存中可能有该数据的拷贝。所以它需要发送一条“Read Invalidate”消息，它不仅需要读取该数据的最新值，还要无效掉其他的CPU缓存(它马上就要改写该数据)。 Writeback：“writeback”消息包含要回写到内存的地址和数据。这个消息允许缓存在必要时换出“modified”状态的数据以腾出空间。消息的发送时机是，CPU把本地缓存中的数据刷新到内存中，而该数据是share状态(只读)，它需要告诉其他CPU”我不再使用这些缓存数据了” http://intheworld.win/2015/07/16/%E5%A4%9A%E6%A0%B8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AEmesi/ MESI为什么还需要volatile?volatile 和MESI 中间差了好几层抽象，中间会经历java编译器，java虚拟机和JIT，操作系统，CPU核心。 volatile 是Java 中标识变量可见性的关键字，说直接点：使用volatile 修饰的变量是有内存可见性的，这是Java 语法定的，Java 不关心你底层操作系统、硬件CPU 是如何实现内存可见的，我的语法规定就是volatile 修饰的变量必须是具有可见性的。 CPU 有X86（复杂指令集）、ARM（精简指令集）等体系架构，版本类型也有很多种，CPU 可能通过锁总线、MESI 协议实现多核心缓存的一致性。因为有硬件的差异以及编译器和处理器的指令重排优化的存在，所以Java 需要一种协议来规避硬件平台的差异，保障同一段代表在所有平台运行效果一致，这个协议叫做Java 内存模型（Java Memory Model）。 https://www.wwwbuild.net/java3y/5614.html 可见性问题存在的主要原因就是，Store Buffer ，尚未及时刷入缓存，然后其他CPU还是从内存里面取出旧值.为了提高CPU效率，MESI引入了缓存失效机制. https://www.cnblogs.com/xmzJava/p/11417943.html 这篇文章很好 而对于JAVA而言，他必须要屏蔽各个处理器的差异，所以才有了java内存模型(JMM),volatile只是内存模型的一小部分，实现了变量的可见性和禁止指令重排序优化的功能。整个内存模型必须要实现可见性，原子性，和有序性。而volatile实现了其中的可见性和有序性。 思考上面说的意思是volitle是上层实现，不管底层是什么，其实MESI volatile还是没搞懂，但是MESI是CPU具体存在的，而且MESI也和可见性差不多原理，如果不用volatile就没有MESI了？ https://www.scss.tcd.ie/jeremy.jones/VivioJS/caches/MESI.htm 各种文章人云亦云，要么直接回避上面问题，有的还说volatile保障MESI,自己相信吗? https://www.youtube.com/watch?v=q8r7b1KMUlE 看了这个视频感觉能说通了，volatile是在MESI基础上，禁止指令重排序(加了栅栏),来保障可见性。 有空看看其他几个视频链接，该删的删. CPU代码执行顺序1234567891011121314151617181920212223242526public class VisibilityThread &#123; private static volatile boolean initFlag = true; public static void main(String[] args) throws InterruptedException &#123; new Thread(() -&gt; &#123; System.out.println(&quot;waiting data...&quot;); while (!initFlag) &#123; &#125; System.out.println(&quot;=========success&quot;); &#125;).start(); Thread.sleep(2000); initFlag = false; new Thread(()-&gt;prepareData()).start(); &#125; private static void prepareData() &#123; System.out.println(&quot;prepareData&quot;); initFlag = true; System.out.println(&quot;prepare data end..&quot;); &#125;&#125; 流程图 https://www.bilibili.com/video/BV1XZ4y157Pj?p=4 Volatile禁止重排序单个线程中，只要重排序不会对结果产生影响，就不能保证其中的操作一定按照程序写定的顺序执行——即使重排序对于其他线程会产生影响。java并发编程实战3.1 这个视频讲了 Volatile重排序的实现，没讲可见性 https://www.bilibili.com/video/BV1UD4y127Kw?p=4 https://blog.csdn.net/reliveIT/article/details/50450136 第五章 Cache - 处理器的肚量(大话处理器-处理器基础知识读本) https://zhuanlan.zhihu.com/p/148772753 https://www.bilibili.com/video/BV1tE411o7oj?p=2 https://wudaijun.com/2019/04/cpu-cache-and-memory-model/#valine-comments Sychronized三种应用方式 修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁 修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁 修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。 作用于实例方法 123public synchronized void increase()&#123; i++;&#125; 示例 12345678910111213141516171819202122232425262728293031public class AccountingSync implements Runnable&#123; //共享资源(临界资源) static int i=0; /** * synchronized 修饰实例方法 */ public synchronized void increase()&#123; i++; &#125; @Override public void run() &#123; for(int j=0;j&lt;1000000;j++)&#123; increase(); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; AccountingSync instance=new AccountingSync(); Thread t1=new Thread(instance); Thread t2=new Thread(instance); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(i); &#125; /** * 输出结果: * 2000000 */ 当一个线程正在访问一个对象的 synchronized 实例方法，那么其他线程不能访问该对象的其他 synchronized 方法，毕竟一个对象只有一把锁。 如果是一个线程 A 需要访问实例对象 obj1 的 synchronized 方法 f1(当前对象锁是obj1)，另一个线程 B 需要访问实例对象 obj2 的 synchronized 方法 f2(当前对象锁是obj2)，这样是允许的，因为两个实例对象锁并不同相同 synchronized作用于静态方法 12345678910111213141516171819202122232425262728293031323334public class synchronized_01 implements Runnable &#123; static int i = 0; /** * 对于全局 */ public static synchronized void increase() &#123; i++; &#125; @Override public void run() &#123; for (int j = 0; j &lt; 1000000; j++) &#123; increase(); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; //new新实例 Thread t1 = new Thread(new AccountingSyncBad()); t1.start(); for (int j = 0; j &lt; 1000000; j++) &#123; increase(); &#125; TimeUnit.SECONDS.sleep(2); System.out.println(i); &#125;&#125; /** * 输出结果: * 2000000 */ 其锁对象是当前类的class对象. 可以看到主线程和自线程发生互斥。 synchronized同步代码块 1234567891011121314151617181920212223public class synchronized_03 implements Runnable &#123; static synchronized_03 instance=new synchronized_03(); static int i=0; @Override public void run() &#123; //省略其他耗时操作.... //使用同步代码块对变量i进行同步操作,锁对象为instance synchronized(instance)&#123; for(int j=0;j&lt;1000000;j++)&#123; i++; &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; //new新实例 Thread t1 = new Thread(new synchronized_03()); t1.start(); System.out.println(i); &#125;&#125; 将synchronized作用于一个给定的实例对象instance，即当前实例对象就是锁对象.当然除了instance作为对象外，我们还可以使用this对象(代表当前实例)或者当前类的class对象作为锁 //this,当前实例对象锁 123456789101112synchronized(this)&#123; for(int j=0;j&lt;1000000;j++)&#123; i++; &#125;&#125;//class对象锁synchronized(AccountingSync.class)&#123; for(int j=0;j&lt;1000000;j++)&#123; i++; &#125;&#125; https://blog.csdn.net/javazejian/article/details/72828483 Sychronized volatile区别？ Sychronized 保证原子性和可见性 synchronized可见性，线程加锁时，必须清空工作内存中共享变量的值，从而使用共享变量时需要从主内存重新读取；线程在解锁时，需要把工作内存中最新的共享变量的值写入到主存，以此来保证共享变量的可见性 volatile 只能保证可见性 CAS原理CAS操作流程 CPU1发现 待修改的变量值是100，期望值100，启动修改 Cpu2发现不是100了，修改失败 CAS缺点 ABA问题 从上一次看到这个值以来到现在，这个值是否发生过变化,从 A 变成了 B，再由 B 变回了 A,CAS 并不能检测出在此期间值是不是被修改过，它只能检查出现在的值和最初的值是不是一样。 通过添加版本号解决,A→B→A 变成了 1A→2B→3A,atomic 包中提供了 AtomicStampedReference 这个类，它是专门用来解决 ABA 问题的 自旋时间过长 CAS 往往是配合着循环来实现的，有的时候甚至是死循环，不停地进行重试，直到线程竞争不激烈的时候，才能修改成功 范围不能灵活控制 执行 CAS 的时候，是针对某一个，而不是多个共享变量的，这个变量可能是 Integer 类型，也有可能是 Long 类型、对象类型等等，但是我们不能针对多个共享变量同时进行 CAS 操作，因为这多个变量之间是独立的，简单的把原子操作组合到一起，并不具备原子性. 解决方案:那就是利用一个新的类，来整合刚才这一组共享变量，这个新的类中的多个成员变量就是刚才的那多个共享变量，然后再利用 atomic 包中的 AtomicReference 来把这个新对象整体进行 CAS 操作，这样就可以保证线程安全。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}],"tags":[{"name":"concurrency","slug":"concurrency","permalink":"http://noteforme.github.io.com/tags/concurrency/"}],"keywords":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}]},{"title":"Concurrency_thread","slug":"Concurrency-thread","date":"2021-02-26T13:57:48.000Z","updated":"2021-08-20T05:10:09.195Z","comments":true,"path":"2021/02/26/Concurrency-thread/","link":"","permalink":"http://noteforme.github.io.com/2021/02/26/Concurrency-thread/","excerpt":"","text":"用户态 : 应用程序运行 内核态 ：操作系统运行 线程的6中状态 New（新创建） Runnable（可运行） Blocked（被阻塞） Waiting（等待） Timed Waiting（计时等待） Terminated（被终止） 状态分析 New ​ 当我们用 new Thread() 新建一个线程时，如果线程没有开始运行 start() 方法，所以也没有开始执行 run() 方法里面的代码，那么此时它的状态就是 New。而一旦线程调用了 start()，它的状态就会从 New 变成 Runnable 如果一个正在运行的线程是 Runnable 状态，当它运行到任务的一半时，执行该线程的 CPU 被调度去做其他事情，导致该线程暂时不运行，它的状态依然不变，还是 Runnable，因为它有可能随时被调度回来继续执行任务。 Blocked ​ 从 Runnable 状态进入 Blocked 状态只有一种可能，就是进入 synchronized 保护的代码时没有抢到 monitor 锁，无论是进入 synchronized 代码块，还是 synchronized 方法，都是一样。 Waiting 等待 没有设置 Timeout 参数的 Object.wait() 方法。 没有设置 Timeout 参数的 Thread.join() 方法。 LockSupport.park() 方法。 Blocked 仅仅针对 synchronized monitor 锁，可是在 Java 中还有很多其他的锁，比如 ReentrantLock，如果线程在获取这种锁时没有抢到该锁就会进入 Waiting 状态，因为本质上它执行了 LockSupport.park() 方法，所以会进入 Waiting 状态。同样，Object.wait() 和 Thread.join() 也会让线程进入 Waiting 状态。 Blocked 与 Waiting 的区别是 Blocked 在等待其他线程释放 monitor 锁，而 Waiting 则是在等待某个条件，比如 join 的线程执行完毕，或者是 notify()/notifyAll() 。 Timed Waiting 限期等待在 Waiting 上面是 Timed Waiting 状态，这两个状态是非常相似的，区别仅在于有没有时间限制，Timed Waiting 会等待超时，由系统自动唤醒，或者在超时前被唤醒信号唤醒。 以下情况会让线程进入 Timed Waiting 状态。 设置了时间参数的 Thread.sleep(long millis) 方法； 设置了时间参数的 Object.wait(long timeout) 方法； 设置了时间参数的 Thread.join(long millis) 方法； 设置了时间参数的 LockSupport.parkNanos(long nanos) 方法和 LockSupport.parkUntil(long deadline) 方法。 想要从 Blocked 状态进入 Runnable 状态，要求线程获取 monitor 锁，而从 Waiting 状态流转到其他状态则比较特殊，因为首先 Waiting 是不限时的，也就是说无论过了多长时间它都不会主动恢复。 如果其他线程调用 notify() 或 notifyAll()来唤醒它，它会直接进入 Blocked 状态，这是为什么呢？因为唤醒 Waiting 线程的线程如果调用 notify() 或 notifyAll()，要求必须首先持有该 monitor 锁，所以处于 Waiting 状态的线程被唤醒时拿不到该锁，就会进入 Blocked 状态，直到执行了 notify()/notifyAll() 的唤醒它的线程执行完毕并释放 monitor 锁，才可能轮到它去抢夺这把锁，如果它能抢到，就会从 Blocked 状态回到 Runnable 状态。 同样在 Timed Waiting 中执行 notify() 和 notifyAll() 也是一样的道理，它们会先进入 Blocked 状态，然后抢夺锁成功后，再回到 Runnable 状态。 Terminated run() 方法执行完毕，线程正常退出。 出现一个没有捕获的异常，终止了 run() 方法，最终导致意外终止。 多线程方法notify()只能叫醒别人 状态实例WAITINGwait()WAITING.java 123456789101112final Object lock = new Object(); threadA = new Thread(() -&gt; &#123; synchronized (lock) &#123; System.out.println(Thread.currentThread().getName() + &quot; &quot; + threadA.getState()); try &#123; lock.wait(); &#125; catch (InterruptedException e) &#123;&#125; &#125; &#125;, &quot;Thread-A&quot;); threadA.start(); Thread.sleep(2000L); System.out.println(Thread.currentThread().getName() + &quot; 线程A的状态 &quot; + threadA.getState()); joinWaitJOIN.java 12345678910111213141516171819202122232425262728final Object lock = new Object();threadA = new Thread(() -&gt; &#123; synchronized (lock) &#123; try &#123; System.out.println(Thread.currentThread().getName() + &quot; &quot; + threadA.getState()); threadB.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;, &quot;Thread-A&quot;);threadB = new Thread(() -&gt; &#123; synchronized (lock) &#123; System.out.println(Thread.currentThread().getName() + &quot; &quot; + threadB.getState()); try &#123; Thread.sleep(1000l); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;, &quot;Thread-B&quot;);threadA.start();threadB.start();Thread.sleep(2000);System.out.println(Thread.currentThread().getName() + &quot;运行 线程A的状态 &quot; + threadA.getState()); 运行结果 Thread-A RUNNABLEmain运行 线程A的状态 WAITING waitWaitState.java 123456789101112131415161718192021222324final Object lock = new Object(); threadA = new Thread(() -&gt; &#123; synchronized (lock) &#123; try &#123; System.out.println(Thread.currentThread().getName() + &quot; &quot; + threadA.getState()); lock.wait(); Thread.sleep(5000l); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;, &quot;BLOCKED-Thread-A&quot;); threadB = new Thread(() -&gt; &#123; synchronized (lock) &#123; System.out.println(Thread.currentThread().getName() + &quot; &quot; + threadB.getState()); System.out.println(Thread.currentThread().getName() + &quot; 线程A的状态 &quot; + threadA.getState()); try &#123; Thread.sleep(5000l); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;, &quot;BLOCKED-Thread-B&quot;); 结果 BLOCKED-Thread-A RUNNABLEBLOCKED-Thread-B RUNNABLEBLOCKED-Thread-B 线程A的状态 WAITING 从结果可以得到两个结论: 线程A调用 lock.wait()后 A出于WAITING状态。 线程A调用 lock.wait()后，立马释放锁，线程B获得锁开始执行。 park12345678910111213141516171819202122char[] aI = &quot;1234567&quot;.toCharArray();char[] aC = &quot;ABCDEFG&quot;.toCharArray();t1 = new Thread(() -&gt; &#123; for(char c : aI) &#123; System.out.print(c); LockSupport.unpark(t2); //叫醒T2 LockSupport.park(); //T1阻塞 &#125;&#125;, &quot;t1&quot;);t2 = new Thread(() -&gt; &#123; for(char c : aC) &#123; LockSupport.park(); //t2阻塞 System.out.print(c); LockSupport.unpark(t1); //叫醒t1 &#125;&#125;, &quot;t2&quot;); 轮流打印数字和字母 TIMED_WAITINGwait(5000)WAITING_TIMEOUT.java 12345678910111213final Object lock = new Object();threadA = new Thread(() -&gt; &#123; synchronized (lock) &#123; System.out.println(Thread.currentThread().getName() + &quot; &quot; + threadA.getState()); try &#123; lock.wait(5000); &#125; catch (InterruptedException e) &#123; &#125; &#125;&#125;, &quot;Thread-A&quot;);threadA.start();Thread.sleep(2000L);System.out.println(Thread.currentThread().getName() + &quot; 线程A的状态 &quot; + threadA.getState()); 运行结果: Thread-A RUNNABLEmain 线程A的状态 TIMED_WAITING sleep(5000)TIMED_WAITING.java 12345678910threadA = new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + &quot; &quot; + threadA.getState()); try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; &#125;&#125;, &quot;Thread-A&quot;);threadA.start();Thread.sleep(2000L);System.out.println(Thread.currentThread().getName() + &quot; 线程A的状态 &quot; + threadA.getState()); 调用了 Thread.sleep(5000l); 运行结果: Thread-A RUNNABLEmain 线程A的状态 TIMED_WAITING BLOCKED123456789101112131415161718192021222324final Object lock = new Object(); threadA = new Thread(() -&gt; &#123; synchronized (lock) &#123; try &#123; System.out.println(Thread.currentThread().getName() + &quot; 线程A的状态 &quot; + threadA.getState()); System.out.println(Thread.currentThread().getName() + &quot; 线程B的状态 &quot; + threadB.getState()); Thread.sleep(10000l); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;Thread-A&quot;); threadB = new Thread(() -&gt; &#123; synchronized (lock) &#123; System.out.println(Thread.currentThread().getName() + &quot; 线程A的状态 &quot; + threadA.getState()); System.out.println(Thread.currentThread().getName() + &quot; 线程B的状态 &quot; + threadB.getState()); try &#123; Thread.sleep(10000l); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;Thread-B&quot;); 运行结果:线程A得到锁，线程B进入阻塞状态。 Thread-A 线程A的状态 RUNNABLEThread-A 线程B的状态 BLOCKEDThread-B 线程A的状态 TERMINATEDThread-B 线程B的状态 RUNNABLE 注意 线程的状态是需要按照箭头方向来走的，比如线程从 New 状态是不可以直接进入 Blocked 状态的，它需要先经历 Runnable 状态。 线程生命周期不可逆：一旦进入 Runnable 状态就不能回到 New 状态；一旦被终止就不可能再有任何状态的变化。所以一个线程只能有一次 New 和 Terminated 状态，只有处于中间状态才可以相互转换。 Thread sleep() yield()结束后，回到就绪状态. https://www.geeksforgeeks.org/lifecycle-and-states-of-a-thread-in-java/ https://fangjian0423.github.io/2016/06/04/java-thread-state/ 让步(yield) 如果已经完成了run()方法循环的一次迭代过程所需的工作，可以给线程调度机制一个暗示：你的工作已经做的差不多了，可以让别的线程使用CPU了，这个暗示將通过调用yield()来做做出(不过这只是一个暗示，没有任何机制保证它將被采纳)，也只是建议相同优先级的其他线程运行。 -ThinkInJava P661 加入一个线程 (join) 在Joiner线程里面调用Sleeper线程 的join() , Joiner任务必须等Sleeper任务结束活被打断或结束 才恢复 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Sleeper extends Thread &#123; private int duration; public Sleeper(String name, int sleepTime) &#123; super(name); duration = sleepTime; start(); &#125; @Override public void run() &#123; super.run(); try &#123; sleep(duration);// Print.print(getName()+&quot;执行了&quot;); &#125; catch (InterruptedException e) &#123; Print.print(getName() + &quot; 被打断&quot; + &quot;isInterrupted() &quot; + isInterrupted()); return; &#125; Print.print(getName() + &quot; has awakened&quot;); &#125;&#125;class Joiner extends Thread &#123; private Sleeper sleeper; public Joiner(String name, Sleeper sleeper) &#123; super(name); this.sleeper = sleeper; start(); &#125; @Override public void run() &#123; super.run(); try &#123; sleeper.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Print.print(getName() + &quot; join completed&quot;); &#125;&#125;public class Joining &#123; public static void main(String[] args) &#123; Sleeper sleepy = new Sleeper(&quot;Sleepy&quot;, 1500), grumpy = new Sleeper(&quot;Grumpy&quot;, 1500); Joiner dopey = new Joiner(&quot;Dopey&quot;, sleepy), doc = new Joiner(&quot;Doc&quot;, grumpy); grumpy.interrupt(); 其他对象上同步 有时候必须在另一个对象上同步，如果需要这样，必须确保所有相关的任务都是在同一个对象上同步。 123456789101112131415161718192021222324252627282930313233class DualSynch &#123; private Object syncObject = new Object(); public synchronized void f() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.print(&quot; f() &quot;); Thread.yield(); &#125; &#125; public void g() &#123; synchronized (syncObject) &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.print(&quot; g() &quot;); Thread.yield(); &#125; &#125; &#125;&#125;public class SyncObject &#123; public static void main(String[] args) &#123; DualSynch ds = new DualSynch(); new Thread() &#123; @Override public void run() &#123; super.run(); ds.f(); &#125; &#125;.start(); ds.g(); &#125;&#125; 这两个方式在同时运行，任何一个方法都没有对另一个方法同步而阻塞 线程间的协作 wait() : 在wait期间 对象锁是释放的,而Sleep期间是没有的 线程的停止方法原因通常情况下，我们不会手动停止一个线程，而是允许线程运行到结束， 贸然强制停止线程就可能会造成一些安全的问题，为了避免造成问题就需要给对方一定的时间来整理收尾工作。比如：线程正在写入一个文件，这时收到终止信号，它就需要根据自身业务判断，是选择立即停止，还是将整个文件写入成功后停止，而如果选择立即停止就可能造成数据不完整，不管是中断命令发起者，还是接收者都不希望数据出现问题。 正确的停止方式对于 Java 而言，最正确的停止线程的方式是使用 interrupt。但 interrupt 仅仅起到通知被停止线程的作用。而对于被停止的线程而言，它拥有完全的自主权，它既可以选择立即停止，也可以选择一段时间后停止，也可以选择压根不停止。首先通过 Thread.currentThread().isInterrupt() 判断线程是否被中断，随后检查是否还有工作要做。&amp;&amp; 逻辑表示只有当两个判断条件同时满足的情况下，才会去执行下面的工作。 123while (!Thread.currentThread().isInterrupted() &amp;&amp; cout&lt;1000) &#123; do more work&#125; 例子1 1234567891011121314151617public class StopThread implements Runnable &#123; @Override public void run() &#123; int count = 0; while (!Thread.currentThread().isInterrupted() &amp;&amp; count &lt; 1000) &#123; System.out.println(&quot;count = &quot; + count++); &#125; System.out.println(&quot;sleep isInterrupted &quot; + Thread.currentThread().isInterrupted()); &#125; public static void main(String[] args) throws InterruptedException &#123; Thread thread = new Thread(new StopThread()); thread.start(); Thread.sleep(5); thread.interrupt(); &#125;&#125; 运行结果 123456789count = 0count = 1count = 2..count = 304count = 305count = 306sleep isInterrupted true sleep 期间能否感受到中断 try catch在while外面 1234567891011121314151617181920public class StopDuringSleep &#123; public static void main(String[] args) throws InterruptedException &#123; Runnable runnable = () -&gt; &#123; int num = 0; try &#123; while (!Thread.currentThread().isInterrupted() &amp;&amp; num &lt;= 1000) &#123; System.out.println(num); num++; Thread.sleep(1000000); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;; Thread thread = new Thread(runnable); thread.start(); Thread.sleep(5); thread.interrupt(); &#125;&#125; 在还没打印完1000个数的时候就会停下来，这种就属于通过 interrupt 正确停止线程的情况。 输出 0 try catch在while里面 外层设置标志中断 123456789101112131415161718192021222324public class StopDuringSleep_answer01 &#123; public static void main(String[] args) throws InterruptedException &#123; Runnable runnable = () -&gt; &#123; while (!Thread.currentThread().isInterrupted()) &#123; try &#123; subTas2(); &#125; catch (InterruptedException e) &#123;// Thread.currentThread().interrupt(); 注释2 &#125; &#125; System.out.println(&quot;thread isInterrupted &quot; + Thread.currentThread().isInterrupted()); &#125;; Thread thread = new Thread(runnable); thread.start(); Thread.sleep(50); thread.interrupt(); &#125; private static void subTas2() throws InterruptedException &#123; System.out.println(&quot;subTas2 isInterrupted &quot; + Thread.currentThread().isInterrupted()); Thread.sleep(1000); &#125;&#125; 输出 subTas2 isInterrupted falsesubTas2 isInterrupted falsesubTas2 isInterrupted falsesubTas2 isInterrupted false 把注释打开输出 subTas2 isInterrupted falsethread isInterrupted true 结论 ：如果 sleep、wait 等可以让线程进入阻塞的方法使线程休眠了，而处于休眠中的线程被中断，那么线程是可以感受到中断信号的，并且会抛出一个 InterruptedException 异常，同时清除中断信号，将中断标记位设置成 false。这样一来就不用担心长时间休眠中线程感受不到中断了，因为即便线程还在休眠，仍然能够响应中断通知，并抛出异常。 我们先来看下 try/catch 的处理逻辑。如上面的代码所示，catch 语句块里代码是空的，它并没有进行任何处理。假设线程执行到这个方法，并且正在 sleep，此时有线程发送 interrupt 通知试图中断线程，就会立即抛出异常，并清除中断信号。抛出的异常被 catch 语句块捕捉。 但是，捕捉到异常的 catch 没有进行任何处理逻辑，相当于把中断信号给隐藏了，这样做是非常不合理的，那么究竟应该怎么处理呢？首先，可以选择在方法签名中抛出异常。 另一种处理方式类似 123456789101112131415161718192021222324252627282930public class StopDuringSleep_answer01 &#123; public static void main(String[] args) throws InterruptedException &#123; Runnable runnable = () -&gt; &#123; while (!Thread.currentThread().isInterrupted()) &#123; subTas1(); &#125; System.out.println(&quot;thread isInterrupted &quot; + Thread.currentThread().isInterrupted()); &#125;; Thread thread = new Thread(runnable); thread.start(); Thread.sleep(50); thread.interrupt(); &#125; private static void subTas2() throws InterruptedException &#123; System.out.println(&quot;subTas2 isInterrupted &quot; + Thread.currentThread().isInterrupted()); Thread.sleep(1000); &#125; private static void subTas1() &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; // 在这里不处理该异常是非常不好的 Thread.currentThread().interrupt(); &#125; &#125;&#125; 再次中断方式 设置标志,在方法中处理，上一种是抛出上一层,在上一层设置标志中断 volatile 修饰标记位不适用的场景生产者/消费者模式的案例来演示为什么说 volatile 标记位的停止方法是不完美的。生产者 1234567891011121314151617181920212223242526public class Producer implements Runnable &#123; public volatile boolean canceled = false; BlockingQueue storage; public Producer(BlockingQueue storage) &#123; this.storage = storage; &#125; @Override public void run() &#123; int num = 0; try &#123; while (num &lt;= 100000 &amp;&amp; !canceled) &#123; if (num % 50 == 0) &#123; storage.put(num); System.out.println(num + &quot;是50的倍数,被放到仓库中了。&quot;); &#125; num++; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(&quot;生产者结束运行&quot;); &#125; &#125;&#125; 消费者 1234567891011121314public class Consumer &#123; BlockingQueue storage; public Consumer(BlockingQueue storage) &#123; this.storage = storage; &#125; public boolean needMoreNums() &#123; if (Math.random() &gt; 0.97) &#123; return false; &#125; return true; &#125;&#125; 1234567891011121314151617181920212223242526272829ArrayBlockingQueue storage = new ArrayBlockingQueue(8);Producer producer = new Producer(storage);Thread producerThread = new Thread(producer);producerThread.start();try &#123; Thread.sleep(500);&#125; catch (InterruptedException e) &#123; e.printStackTrace();&#125;Consumer consumer = new Consumer(storage);while (consumer.needMoreNums()) &#123; try &#123; System.out.println(consumer.storage.take() + &quot;被消费了&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125;System.out.println(&quot;消费者不需要更多数据了。&quot;);//一旦消费不需要更多数据了，我们应该让生产者也停下来，但是实际情况却停不下来producer.canceled = true;System.out.println(producer.canceled); 当 producer.canceled = true时,生产者Producer跳出循环 while (num &lt;= 100000 &amp;&amp; !canceled) ,来到运行 1System.out.println(&quot;生产者结束运行&quot;); 然而结果却不是我们想象的那样，尽管已经把 canceled 设置成 true，但生产者仍然没有停止，这是因为在这种情况下，生产者在执行 storage.put(num) 时发生阻塞，在它被叫醒之前是没有办法进入下一次循环判断 canceled 的值的，所以在这种情况下用 volatile 是没有办法让生产者停下来的，相反如果用 interrupt 语句来中断，即使生产者处于阻塞状态，仍然能够感受到中断信号，并做响应处理。 修复版本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class WrongWayVolatileFixed &#123; public static void main(String[] args) throws InterruptedException &#123; ArrayBlockingQueue storage = new ArrayBlockingQueue(10); WrongWayVolatileFixed body = new WrongWayVolatileFixed(); Producer producer = body.new Producer(storage); Thread producerThread = new Thread(producer); producerThread.start(); Thread.sleep(1000); Consumer consumer = body.new Consumer(storage); while (consumer.needMoreNums()) &#123; System.out.println(storage.take()+&quot;被消费&quot;); Thread.sleep(100); &#125; System.out.println(&quot;消费者不需要更多数据了&quot;); /** * 一旦消费不需要更多数据了，我们应该让生产者也停下来， * 但是实际情况,在 storage.put(num);处被阻塞了，无法进入新的一层while()循环中判断，!Canceled 的值也就无法判断 */ producerThread.interrupt(); &#125; class Producer implements Runnable&#123; BlockingQueue storage; public Producer(BlockingQueue storage) &#123; this.storage = storage; &#125; @Override public void run() &#123; int num = 0; try &#123; //canceled为true，则无法进入 while (num &lt;= 100000 &amp;&amp; !Thread.currentThread().isInterrupted()) &#123; if (num % 100 == 0) &#123; storage.put(num); System.out.println(num + &quot;是100的倍数,被放到仓库中了。&quot;); &#125; num++; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(&quot;生产者结束运行&quot;); &#125; &#125; &#125; class Consumer &#123; BlockingQueue storage; public Consumer(BlockingQueue storage) &#123; this.storage = storage; &#125; public boolean needMoreNums() &#123; if (Math.random() &gt; 0.95) &#123; return false; &#125; return true; &#125; &#125;&#125; producerThread.interrupt();去打断 线程池关闭方式1234567891011121314151617181920212223242526272829303132public class ShutdownTest &#123; public static void main(String[] args) &#123; ExecutorService exec = Executors.newCachedThreadPool(); exec.submit(new ShutDownThread()); try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; exec.shutdownNow(); &#125; static class ShutDownThread implements Runnable &#123; static int taskId = 0; @Override public void run() &#123; while (!Thread.currentThread().isInterrupted())&#123; try &#123; Thread.sleep(5000); System.out.println(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); Thread.currentThread().interrupt(); &#125; System.out.println(&quot;taskId Terminated&quot; + taskId++); &#125; System.out.println(&quot;&quot;); &#125; &#125;&#125; 为什么 wait 必须在 synchronized 保护的同步代码中使用? 不在synchronized就不能保证原子性，执行wait之前的代码后，被其他线程抢占执行了notifiy(此时没起作用，wait方法还没调用)，回来继续执行wait，这样该线程就得不到唤醒. https://kaiwu.lagou.com/course/courseInfo.htm?courseId=16#/detail/pc?id=242 https://github.com/Lvshujia/JUC","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}],"tags":[{"name":"concurrency","slug":"concurrency","permalink":"http://noteforme.github.io.com/tags/concurrency/"}],"keywords":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}]},{"title":"Activity","slug":"ACTIVITY","date":"2021-01-16T09:49:32.000Z","updated":"2021-08-19T11:11:43.480Z","comments":true,"path":"2021/01/16/ACTIVITY/","link":"","permalink":"http://noteforme.github.io.com/2021/01/16/ACTIVITY/","excerpt":"","text":"https://developer.android.com/reference/android/app/Activity.html ActivityAn activity is a single, focused thing that the user can do. Almost all activities interact with the user, so the Activity class takes care of creating a window for you in which you can place your UI with setContentView(View).Acitivty和用户交互，所以也是用的最多的 lifecycle onCreate(): Activity创建的时候调用，绑定数据。 onStart() : 当Activity对用户变得可见的时候调用. onResume() : activity开始和用户交互的时候调用，这时候activity处于栈顶，伴随着用户的输入. onPause() : 当activity失去前台状态，开始进入stopped/hidden or destroyed状态，不能再获取焦点，此时activity对用户可见，但是更新的UI的操作要快。 onStop() : 当activity不再可见，可能是新的activity来到栈顶，或者当前activity正在被destroy. onDestory(): 当前activity正在离开。 想到一个问题:界面Ａ到界面Ｂ，是Ａ的onStop()先执行 还是Ｂ的onResume()先走先用事实说话吧 I/BaseActivity: MainActivity -- onCreate() -- I/BaseActivity: MainActivity -- onStart() -- I/BaseActivity: MainActivity -- onResume() -- I/BaseActivity: MainActivity -- onPause() -- I/BaseActivity: StopResumeActivity -- onCreate() -- I/BaseActivity: StopResumeActivity -- onStart() -- I/BaseActivity: StopResumeActivity -- onResume() -- I/BaseActivity: MainActivity -- onStop() -- 从打印结果可以看到StopResumeActivity.onResume()先执行,然后是MainActivity的onStop onStop() :大概知道原因，但是还是不够说服力，因为onStart()方法已经对用户可见了，为什么MainActivity – onStop()不在 StopResumeActivity – onStart()后面呢？ 可能是onResume()调用后，新activity位于栈顶，之前的再onStop() Activity luanch mode4种启动模式 standard 在不同的Task中打开同一个Activity，Activity会被创建多个实例。分别放进打开它的Task中。 例如: 点开短信中的电话号码， 新的 打电话的Activity会存在于 短信Task中。 singleTop singleTask The system creates a new task and instantiates the activity at the root of the new task. However, if an instance of the activity already exists in a separate task, the system routes the intent to the existing instance through a call to its onNewIntent() method, rather than creating a new instance. Only one instance of the activity can exist at a time. 只会在一个Task出现,这个Task里只有一个这个Activity，全局唯一 singleInstance Same as &quot;singleTask&quot;, except that the system doesn’t launch any other activities into the task holding the instance. The activity is always the single and only member of its task; any activities started by this one open in a separate task. 除了全局唯一，还会独占一个Task taskAffinity每个Activity都有一个taskAffinity，默认取自Activity所在的Application的taskAffinity,而后者又默认取自app包名. 每个Task也有它自己的taskAffinity，它取自栈底的Activity的taskAffinity 默认情况下，Activity会直接进入当前的Task 但对于设置了 launchMode = “singleTask”的Activity,系统会先比对Activity和当前Task的taskAffinity是否相同 如果相同，依然正常入栈. 如果不同，新Activity会去寻找和它 taskAffinity相同的Task后入栈。 如果找不到，系统就为它创建一个新的Task,或者创建一个新的Task. MainActivity启动FirstActivity 123&lt;activity android:name=&quot;.component.launchmode.FirstActivity&quot; android:taskAffinity=&quot;com.comm.mytask&quot; /&gt; TaskRecord&#123;dff3f0b #4947 A=com.comm.util U=0 StackId=1 sz=2&#125; Run #4: ActivityRecord&#123;e52ebf7 u0 com.comm.util/.component.launchmode.FirstActivity t4947&#125; Run #3: ActivityRecord&#123;cd6b037 u0 com.comm.util/.MainActivity t4947&#125; 1234&lt;activity android:name=&quot;.component.launchmode.FirstActivity&quot; android:launchMode=&quot;singleTask&quot; android:taskAffinity=&quot;com.comm.mytask&quot; /&gt; 1234TaskRecord&#123;3713c1e #4946 A=com.comm.mytask U=0 StackId=1 sz=1&#125; Run #4: ActivityRecord&#123;3d3bd58 u0 com.comm.util/.component.launchmode.FirstActivity t4946&#125; TaskRecord&#123;273cacc #4945 A=com.comm.util U=0 StackId=1 sz=1&#125; Run #3: ActivityRecord&#123;77277e0 u0 com.comm.util/.MainActivity t4945&#125; 添加完 android:launchMode=&quot;singleTask&quot;后 多了个task com.comm.mytask TaskAffinity和最近任务列表最近任务列表会列出现有的Task 但他们的taskAffinity需要不一样 当多个Task具有相同的taskAffinity额时候，最近任务列表只有显示最新展示过的那一个. 除了 singleInstance 不好验证 所在task是否只有唯一的activity ，其他的启动模式比较清晰? 查看运行的activity 1adb shell dumpsys activity activities | sed -En -e &#x27;/Running activities/,/Run #0/p&#x27; remote: Compressing objects: 100% (3780/3780), done. 两种方式 AndroidMenifest 123456remote: Compressing objects: 100% (378. remote: Compressing objects: 100% (3780/3780), done.0/3780), done. &lt;activity android:name = &quot;com.ryg.chapter_1.SecondActivity&quot; android:launchMode=&quot;singleTask&quot; /&gt; Intent设置 1intent.addFlasg(Intent.FLAG_ACTIVITY_NEW_TASK) 2优先级高于1级 SingleInstance 不设置taskAffinitySingleInstance会创建一个新的任务栈 12345678910111213&lt;activity android:name=&quot;.component.launchmode.FirstActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt;&lt;/activity&gt;&lt;activity android:name=&quot;.component.launchmode.SecondActivity&quot; android:launchMode=&quot;singleInstance&quot; /&gt;&lt;activity android:name=&quot;.component.launchmode.ThirdActivity&quot; /&gt; 1234567891011121314151617D/FirstActivity LaunchModeActivity: onCreate() taskId 86D/FirstActivity LaunchModeActivity: onStart()D/FirstActivity LaunchModeActivity: onResume()D/FirstActivity LaunchModeActivity: onPause()D/SecondActivity LaunchModeActivity: onCreate() taskId 85D/SecondActivity LaunchModeActivity: onStart()D/SecondActivity LaunchModeActivity: onRestoreInstanceState()D/SecondActivity LaunchModeActivity: onNewIntent(Intent intent)D/SecondActivity LaunchModeActivity: onResume()D/FirstActivity LaunchModeActivity: onSaveInstanceState()D/FirstActivity LaunchModeActivity: onStop()D/SecondActivity LaunchModeActivity: onPause()D/ThirdActivity LaunchModeActivity: onCreate() taskId 86D/ThirdActivity LaunchModeActivity: onStart()D/ThirdActivity LaunchModeActivity: onResume()D/SecondActivity LaunchModeActivity: onSaveInstanceState()D/SecondActivity LaunchModeActivity: onStop() 可以看到 FirstActivity 、ThirdActivity在同一个栈中，SecondActivity单独在一个栈中 所以按返回键盘，先到 FirstActivity，然后到SecondActivity . 栈内Activity查看，设置taskAffinity123456789101112131415&lt;activity android:name=&quot;.component.launchmode.SerachActivity&quot; /&gt; &lt;activity android:name=&quot;.component.onactivityresult.SecondActivity&quot; android:launchMode=&quot;singleTask&quot; android:taskAffinity=&quot;&quot; /&gt; &lt;activity android:name=&quot;.component.launchmode.FirstActivity&quot; android:configChanges=&quot;orientation&quot; android:launchMode=&quot;singleTask&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; adb shell dumpsys activity ![](Activity/Screen Shot 2021-01-23 at 3.31.08 PM.png) taskAffinity属性的值为字符串，且中间必须含有分隔符”.” standard模式，taskAffinity继承自Application的taskAffinity，而Application默认taskAffinity为包名，所以MainActivity的taskAffinity为包名。 https://developer.android.com/guide/components/activities/tasks-and-back-stack https://blog.csdn.net/mynameishuangshuai/article/details/51491074 https://blog.csdn.net/zhangjg_blog/article/details/10923643 OnNewIntent()onNewIntent added in API level 1 1void onNewIntent (Intent intent) if the Activity was already created and a new Intent is being delivered to onNewIntent(android.content.Intent) This is called for activities that set launchMode to “singleTop” in their package, or if a client used the FLAG_ACTIVITY_SINGLE_TOP flag when calling startActivity(Intent). In either case, when the activity is re-launched while at the top of the activity stack instead of a new instance of the activity being started, onNewIntent() will be called on the existing instance with the Intent that was used to re-launch it. An activity will always be paused before receiving a new intent, so you can count on onResume() being called after this method. Note that getIntent() still returns the original Intent. You can use setIntent(Intent) to update it to this new Intent. Parameters intent Intent: The new intent that was started for the activity. 这个方法用于singleTop singleTask两种启动模式 先看看 singleTask方式：FirstActivity 12&lt;activity android:name=&quot;.launchmode.FirstActivity&quot; android:launchMode=&quot;singleTask&quot;/&gt; ​ 从 FirstActivity –&gt; LaunchActivity –&gt; FirstActivity 生命周期方法 04-24 11:49:14.602 26674-26674/com.jonzhou.mineutils D/FirstActivity LaunchMode: onCreate() 04-24 11:49:14.672 26674-26674/com.jonzhou.mineutils D/FirstActivity LaunchMode: onStart() 04-24 11:49:14.679 26674-26674/com.jonzhou.mineutils D/FirstActivity LaunchMode: onResume() 04-24 11:49:32.085 26674-26674/com.jonzhou.mineutils D/FirstActivity LaunchMode: onPause() 04-24 11:49:32.099 26674-26674/com.jonzhou.mineutils D/LaunchActivity LaunchMode: onCreate() 04-24 11:49:32.127 26674-26674/com.jonzhou.mineutils D/LaunchActivity LaunchMode: onStart() 04-24 11:49:32.132 26674-26674/com.jonzhou.mineutils D/LaunchActivity LaunchMode: onResume() 04-24 11:49:32.462 26674-26674/com.jonzhou.mineutils D/FirstActivity LaunchMode: onStop() 04-24 11:49:53.681 26674-26674/com.jonzhou.mineutils D/LaunchActivity LaunchMode: onPause() 04-24 11:49:53.701 26674-26674/com.jonzhou.mineutils D/FirstActivity LaunchMode: onNewIntent(Intent intent) 04-24 11:49:53.702 26674-26674/com.jonzhou.mineutils D/FirstActivity LaunchMode: onStart() 04-24 11:49:53.703 26674-26674/com.jonzhou.mineutils D/FirstActivity LaunchMode: onResume() 04-24 11:49:54.049 26674-26674/com.jonzhou.mineutils D/LaunchActivity LaunchMode: onStop() 04-24 11:49:54.049 26674-26674/com.jonzhou.mineutils D/LaunchActivity LaunchMode: onDestroy() 然后可以通过 onNewIntent(Intent intent);获取传回来的数据 12345String data1 = intent.getStringExtra(newIntent);String data2 = getIntent().getStringExtra(newIntent); //这种方式获取不到setIntent(intent); //通过这种设置获取String data3 = getIntent().getStringExtra(newIntent);Timber.d(&quot;onNewIntent &quot; + data3); 为什么要设置 setIntent(intent) 我们在多次启动同一个栈唯一模式下的activity时，在onNewIntent()里面的getIntent()得到的intent感觉都是第一次的那个数据。对，这里就是这个陷阱。因为它就是会返回第一个intent的数据 https://blog.csdn.net/qq_16628781/article/details/51539715 生命周期视图 http://yhz61010.iteye.com/blog/2389877 https://blog.csdn.net/qq_16628781/article/details/51539715 然而 ANDROID 4.4 启动模式会出现问题http://www.jianshu.com/p/2a9fcf3c11e4 http://blog.csdn.net/mynameishuangshuai/article/details/51491074 https://www.youtube.com/watch?v=r4T9zkhpmII","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"Exception","slug":"Exception","date":"2021-01-14T09:29:14.000Z","updated":"2021-08-19T11:11:43.803Z","comments":true,"path":"2021/01/14/Exception/","link":"","permalink":"http://noteforme.github.io.com/2021/01/14/Exception/","excerpt":"","text":"异常结构图 https://www.cnblogs.com/aspirant/p/10790803.html","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}],"tags":[],"keywords":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}]},{"title":"DesignPattern_Proxy","slug":"DesignPattern-Proxy","date":"2021-01-14T03:41:21.000Z","updated":"2021-08-19T11:11:43.801Z","comments":true,"path":"2021/01/14/DesignPattern-Proxy/","link":"","permalink":"http://noteforme.github.io.com/2021/01/14/DesignPattern-Proxy/","excerpt":"","text":"静态代理静态代理实现编译的时候就已经存在 代理模式 代理类与委托类有同样的接口 代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。 一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。 kotlin 委托的作用1234567891011121314interface Base &#123; fun print()&#125;class BaseImpl(val x: Int) : Base &#123; override fun print() &#123; print(x) &#125;&#125;class Derived(b: Base) : Base by bfun main() &#123; val b = BaseImpl(10) Derived(b).print()&#125; 12345678910public interface ZyxInterface &#123; void sayHello();&#125;public class ZhangYuXin implements ZyxInterface &#123; @Override public void sayHello() &#123; System.out.println(&quot;Hello from zyx&quot;); &#125;&#125; 代理类 1234567891011121314public class ZhangYuXinProxy implements ZyxInterface &#123; private ZhangYuXin zhangYuXin; public ZhangYuXinProxy(ZhangYuXin zhangYuXin) &#123; this.zhangYuXin = zhangYuXin; &#125; @Override public void sayHello() &#123; System.out.println(&quot;拍电影前的准备工作&quot;); zhangYuXin.sayHello(); System.out.println(&quot;拍电影后的收尾工作&quot;); &#125;&#125; 123ZhangYuXin zyxHello = new ZhangYuXin();ZhangYuXinProxy zhangYuXin = new ZhangYuXinProxy(zyxHello);zhangYuXin.sayHello(); 运行结果 拍电影前的准备工作Hello from zyx拍电影后的收尾工作 动态代理 通过反射机制生成的代理对象 动态代理原理生成的动态代理Class文件 12345678910byte[] classFile = ProxyGenerator.generateProxyClass(&quot;BinInterface$0&quot;, new Class[]&#123;ZyxInterface.class&#125;);try &#123; FileOutputStream out = new FileOutputStream( &quot;BinInterface$0.class&quot;); out.write(classFile); out.flush();&#125; catch (FileNotFoundException e) &#123; e.printStackTrace();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; BinInterface$0.class 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public final class BinInterface$0 extends Proxy implements ZyxInterface &#123; private static Method m1; private static Method m3; private static Method m2; private static Method m0; public BinInterface$0(InvocationHandler var1) throws &#123; super(var1); &#125; public final boolean equals(Object var1) throws &#123; try &#123; return (Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; //调用接口的方法就会调用sayHello方法 public final void sayHello() throws &#123; try &#123; super.h.invoke(this, m3, (Object[])null); //h就是create方法传进来的InvocationHandler,然后回调invoke方法 &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final String toString() throws &#123; try &#123; return (String)super.h.invoke(this, m2, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final int hashCode() throws &#123; try &#123; return (Integer)super.h.invoke(this, m0, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; static &#123; try &#123; m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, Class.forName(&quot;java.lang.Object&quot;)); m3 = Class.forName(&quot;pattern.proxy.xiangxue.ZyxInterface&quot;).getMethod(&quot;sayHello&quot;); m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;); m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;); &#125; catch (NoSuchMethodException var2) &#123; throw new NoSuchMethodError(var2.getMessage()); &#125; catch (ClassNotFoundException var3) &#123; throw new NoClassDefFoundError(var3.getMessage()); &#125; &#125;&#125; 动态代理实现1234567891011121314151617181920212223242526272829public class DoSomeThingDynamic &#123; Object object; public DoSomeThingDynamic(Object object) &#123; this.object = object; &#125; /** * * @param say 需要代理执行的接口类 * @param &lt;T&gt; * @return 动态代理 运行时生成的一个say对应类型的类，用于调用say接口的时候 运行 */ public &lt;T&gt; T create(final Class&lt;T&gt; say)&#123; return (T) Proxy.newProxyInstance(say.getClassLoader(), new Class&lt;?&gt;[]&#123;say&#125;, new InvocationHandler() &#123; //method这个函数是 反射的函数， method具体代表的是 代理在执行的当前的函数 @Override public Object invoke(Object o, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;拍电影前的准备工作&quot;); Object result = method.invoke(object, args); //等价于 zhangYuXin.sayHello(); System.out.println(&quot;拍电影后的收尾工作&quot;); return result; &#125; &#125; ); &#125;&#125; 12345678910DoSomeThingDynamic say1 = new DoSomeThingDynamic(zyxHello); //动态生成代理类ZyxInterface zyxProxy = say1.create(ZyxInterface.class);zyxProxy.sayHello();System.out.println(&quot;---------------------\\n&quot;);BinBin binBye = new BinBin();DoSomeThingDynamic say2 = new DoSomeThingDynamic(binBye); //动态生成代理类BinInterface bbProxy = say2.create(BinInterface.class);bbProxy.sayBye(); 运行结果 拍电影前的准备工作Hello from zyx 拍电影后的收尾工作 拍电影前的准备工作Bye Bye from BinBin拍电影后的收尾工作 https://www.bilibili.com/video/BV1ib4y1f7S1?p=10&amp;spm_id_from=pageDriver https://www.bilibili.com/video/BV1uQ4y1Z7gA?p=23 https://juejin.cn/post/6844903520919879694 https://juejin.cn/post/6844903978342301709 https://time.geekbang.org/column/article/201823","categories":[{"name":"DesignPatterns","slug":"DesignPatterns","permalink":"http://noteforme.github.io.com/categories/DesignPatterns/"}],"tags":[],"keywords":[{"name":"DesignPatterns","slug":"DesignPatterns","permalink":"http://noteforme.github.io.com/categories/DesignPatterns/"}]},{"title":"JVM_GC","slug":"JVM-GC","date":"2021-01-05T03:49:01.000Z","updated":"2021-08-19T11:11:43.981Z","comments":true,"path":"2021/01/05/JVM-GC/","link":"","permalink":"http://noteforme.github.io.com/2021/01/05/JVM-GC/","excerpt":"","text":"垃圾回收可达性分析​ 从GC Roots向下追溯、搜索，会产生一个叫做Refrence Chain的链条。当一个对象不能和任何一个GC Root产生关系时，就会被回收。 ​ 如图所示，Obj5、Obj6、Obj7，由于不能和 GC Root 产生关联，发生 GC 时，就会被摧毁。 垃圾回收就是围绕着 GC Roots 去做的。同时，它也是很多内存泄露的根源，因为其他引用根本没有这样的权利。 那么，什么样的对象，才会是 GC Root 呢？这不在于它是什么样的对象，而在于它所处的位置。 https://kaiwu.lagou.com/course/courseInfo.htm?courseId=31#/detail/pc?id=1029 GC Roots 有哪些GC Roots 是一组必须活跃的引用。用通俗的话来说，就是程序接下来通过直接引用或者间接引用，能够访问到的潜在被使用的对象。 GC Roots 包括： Java 线程中，当前所有正在被调用的方法的引用类型参数、局部变量、临时值等。也就是与我们栈帧相关的各种引用。 所有当前被加载的 Java 类。 Java 类的引用类型静态变量。 运行时常量池里的引用类型常量（String 或 Class 类型）。 JVM 内部数据结构的一些引用，比如 sun.jvm.hotspot.memory.Universe 类。 用于同步的监控对象，比如调用了对象的 wait() 方法。 JNI handles，包括 global handles 和 local handles。 这些 GC Roots 大体可以分为三大类，下面这种说法更加好记一些： 活动线程相关的各种引用。 类的静态变量的引用。 JNI 引用。 ​ 注意 我们这里说的是活跃的引用，而不是对象，对象是不能作为 GC Roots 的。 GC 过程是找出所有活对象，并把其余空间认定为“无用”；而不是找出所有死掉的对象，并回收它们占用的空间。所以，哪怕 JVM 的堆非常的大，基于 tracing 的 GC 方式，回收速度也会非常快。 引用计数算法(忽略)当前主流的商用程序语言(Java、C#，上溯至前面提到的古老的Lisp)的内存管理子系统，都是 通过可达性分析(Reachability Analysis)算法来判定对象是否存活的。这个算法的基本思路就是通过 一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过 程所走过的路径称为“引用链”(Reference Chain)，如果某个对象到GC Roots间没有任何引用链相连， 或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。 12345678910111213141516/*** testGC()方法执行后，objA和objB会不会被GC呢? * @author zzm*/public class ReferenceCountingGC &#123; public Object instance = null; private static final int _1MB = 1024 * 1024;/*** 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否有回收过 */ private byte[] bigSize = new byte[2 * _1MB]; public static void testGC() &#123; ReferenceCountingGC objA = new ReferenceCountingGC(); ReferenceCountingGC objB = new ReferenceCountingGC(); objA.instance = objB; objB.instance = objA; objA = null; objB = null; // 假设在这行发生GC，objA和objB是否能被回收? System.gc(); &#125; &#125; 能够找到 Reference Chain 的对象，就一定会存活么？引用级别 将引用分为强引用(Strongly Re-ference)、软 引用(Soft Reference)、弱引用(Weak Reference)和虚引用(Phantom Reference)4种，这4种引用强 度依次逐渐减弱。 ·强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj=new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回 收掉被引用的对象。 软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内 存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存， 才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。 123456// 伪代码Object object = new Object();SoftReference&lt;Object&gt; softRef = new SoftReference(object); 弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只 能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只 被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。 123456// 伪代码Object object = new Object();WeakReference&lt;Object&gt; softRef = new WeakReference(object); 虚引用也称为“幽灵引用”或者“幻影引用”，这是一种形同虚设的引用，在现实场景中用的不是很多。虚引用必须和引用队列（ReferenceQueue）联合使用。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。 虚引用主要用来跟踪对象被垃圾回收的活动。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://noteforme.github.io.com/tags/JVM/"}],"keywords":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}]},{"title":"OS","slug":"OS","date":"2020-12-28T07:32:28.000Z","updated":"2021-08-19T11:11:44.183Z","comments":true,"path":"2020/12/28/OS/","link":"","permalink":"http://noteforme.github.io.com/2020/12/28/OS/","excerpt":"","text":"学习计划MIT6.S081实验 + 操作系统导论 https://github.com/woai3c/MIT6.828 https://pdos.csail.mit.edu/6.828/2018/index.html https://www.zhihu.com/question/40973610 RISC-V 微处理器 xv6 实验环境配置https://zhuanlan.zhihu.com/p/343655412 https://zhuanlan.zhihu.com/p/272199762 https://zhuanlan.zhihu.com/p/331492444 https://www.bilibili.com/video/BV11K4y127Qk?from=search&amp;seid=8628043749223720261 错误1 1234ERROR: glib-2.48 gthread-2.0 is required to compile QEMU处理sudo apt-get install libglib2.0-dev 错误2 12345ERROR: pixman &gt;= 0.21.8 not present. Please install the pixman devel package. 处理sudo apt-get install libpixman-1-dev 实验 在user目录下创建copy.c 在Makefile 152行添加配置 测试添加程序 启动xv6后，执行copy https://blog.csdn.net/u013577996/article/details/108680888 课程学习3.4内核执行任何内核指令3.4 之前提到，设置处理器中kernel mode的bit位的指令是一条特殊权限指令，那么一个用户程序怎么才能让内核执行任何内核指令？因为现在切换到kernel mode的指令都是一条特殊权限指令了，对于用户程序来说也没法修改那个bit位 用户程序会通过系统调用来切换到kernel mode。当用户程序执行系统调用，会通过ECALL触发一个软中断（software interrupt），软中断会查询操作系统预先设定的中断向量表，并执行中断向量表中包含的中断处理程序。中断处理程序在内核中，这样就完成了user mode到kernel mode的切换，并执行用户程序想要执行的特殊权限指令？ 针对这个回答，我的疑问是，怎么确保恶意程序不走这种系统调用呢 3.9 断点调试12345678一个窗口make CPUS=1 qemu-gdb新开窗口 gdb-multiarch kernel/kerneltarget remote localhost:26000 https://zhuanlan.zhihu.com/p/331492444 GDB简单使用 1234ctrl x a 显示代码 b 断点 r运行 https://www.bilibili.com/video/BV1ei4y1V758?from=search&amp;seid=4972450432119771986 4.3页表 在最高级的page directory中的PPN，包含了下一级page directory的物理内存地址， 第二个9bit用来索引中间级的page directory，第三个9bit用来索引最低级的page directory。在最低级page directory，我们还是可以得到44bit的PPN，这里包含了我们实际上想要翻译的物理page地址，然后再加上虚拟内存地址的12bit offset，就得到了56bit物理内存地址。 第一个level1有了Level2页表的物理地址，Level2的 PPN就是页表的偏移量,指向Level3的物理地址. https://www.bilibili.com/video/BV1zt4y1U7rq?from=search&amp;seid=11572648099017443360 启动概览 ​ 简单来说 就是加电后，1。启动主板BIOS 》 2. BIOS初始化从磁盘中把加载程序bootloader 加载到内存中 》3.把磁盘镜像操作系统加载到内存中运行 为什么不在第二步直接加载操作系统呢? 1. 为了兼容不同的文件系统 2. bootloader只能存 512字节，系统远大于它。 https://objectkuan.gitbooks.io/ucore-docs/content/lab1/lab1_3_booting.html BIOS初始化 硬件自检POST,检测系统中（内存和显卡，软盘 ，影片 光盘 USB)等关键部件的存在和工作状态查找并执行显卡等接口卡BIOS,并进行设备初始化； 加载上述设备的第一个扇区（主引导扇区，Master Boot Record,or MBR）的512字节的内容读到内存固定地址0x7c00，这个内容就是bootloader,等待对Ucore操作系统的加载. bootloader做的事情 从实模式切换到保护模式(protection mdoe) ，为后续操作系统的执行做准备。 从硬盘上读取kernel in ELF格式的ucore kernel(就是系统代码，跟在MBR后面的扇区)并放到内存中固定位置。 跳转到ucore OS的入口点(entry point)执行，这时候控制器交给了 ucore. 第二部细节 加载程序![](OS\\2021-04-13at1.36.29 PM.png) ​ 计算机可能有不止一个分区，每个分区有不同的系统，主引导记录来确定去哪个文件系统读加载程序 BIOS启动过程 当计算机加电后，一般不直接执行操作系统，而是执行系统初始化软件完成基本IO初始化和引导加载功能(BIOS)。简单地说，系统初始化软件就是在操作系统内核运行之前运行的一段小软件。通过这段小软件，我们可以初始化硬件设备、建立系统的内存空间映射图，从而将系统的软硬件环境带到一个合适的状态，以便为最终调用操作系统内核准备好正确的环境。最终引导加载程序把操作系统内核映像加载到RAM中，并将系统控制权传递给它。 对于绝大多数计算机系统而言，操作系统和应用软件是存放在磁盘（硬盘/软盘）、光盘、EPROM、ROM、Flash等可在掉电后继续保存数据的存储介质上。计算机启动后，CPU一开始会到一个特定的地址开始执行指令，这个特定的地址存放了系统初始化软件，负责完成计算机基本的IO初始化，这是系统加电后运行的第一段软件代码。对于Intel 80386的体系结构而言，PC机中的系统初始化软件由BIOS (Basic Input Output System，即基本输入/输出系统，其本质是一个固化在主板Flash/CMOS上的软件)和位于软盘/硬盘引导扇区中的OS Boot Loader（在ucore中的bootasm.S和bootmain.c）一起组成。BIOS实际上是被固化在计算机ROM（只读存储器）芯片上的一个特殊的软件，为上层软件提供最底层的、最直接的硬件控制与支持。更形象地说，BIOS就是PC计算机硬件与上层软件程序之间的一个”桥梁”，负责访问和控制硬件。 以Intel 80386为例，计算机加电后，CPU从物理地址0xFFFFFFF0（由初始化的CS：EIP确定，此时CS和IP的值分别是0xF000和0xFFF0)）开始执行。在0xFFFFFFF0这里只是存放了一条跳转指令，通过跳转指令跳到BIOS例行程序起始点。BIOS做完计算机硬件自检和初始化后，会选择一个启动设备（例如软盘、硬盘、光盘等），并且读取该设备的第一扇区(即主引导扇区或启动扇区)到内存一个特定的地址0x7c00处，然后CPU控制权会转移到那个地址继续执行。至此BIOS的初始化工作做完了，进一步的工作交给了ucore的bootloader。 bootloader启动过程 BIOS将通过读取硬盘主引导扇区到内存，并转跳到对应内存中的位置执行bootloader。bootloader完成的工作包括： 切换到保护模式，启用分段机制 读磁盘中ELF执行文件格式的ucore操作系统到内存 显示字符串信息 把控制权交给ucore操作系统 对应其工作的实现文件在lab1中的boot目录下的三个文件asm.h、bootasm.S和bootmain.c。下面从原理上介绍完成上述工作的计算机系统硬件和软件背景知识。 操作系统启动过程 当bootloader通过读取硬盘扇区把ucore在系统加载到内存后，就转跳到ucore操作系统在内存中的入口位置（kern/init.c中的kern_init函数的起始地址），这样ucore就接管了整个控制权。当前的ucore功能很简单，只完成基本的内存管理和外设中断管理。ucore主要完成的工作包括： 初始化终端； 显示字符串； 显示堆栈中的多层函数调用关系； 切换到保护模式，启用分段机制； 初始化中断控制器，设置中断描述符表，初始化时钟中断，使能整个系统的中断机制； 执行while（1）死循环。 以后的实验中会大量涉及各个函数直接的调用关系，以及由于中断处理导致的异步现象，可能对大家实现操作系统和改正其中的错误有很大影响。而理解好函数调用关系的建立机制和中断处理机制，对后续实验会有很大帮助。下面就练习5涉及的函数栈调用关系和练习6中的中断机制的建立进行阐述。 https://objectkuan.gitbooks.io/ucore-docs/content/lab1/lab1_3_booting.html 系统调用POSIXPortable Operating System Interface of Unix(IEEE制定的一个标准族) 操作系统给上层提供的接口，macos,Linux都遵循这个接口。 内核态 0 ， 用户态 3 GDT表存了DPL为0，用户访问CPL为3， 3 &gt; 0 没法访问。 0x80到内核中 中断、异常和系统调用 中断 硬件设对操作系统备的处理请求（缓存区里有数据，需要内核读走。或者缓冲区里数据用完了，需要内核补充新的数据） 异常 非法指令或者其他原因导致当前指令执行失败（程序出错后的处理请求） 系统调用 应用程序主动向操作系统发出的服务请求 物理内存管理： 连续内存分配最先匹配（First Fit Allocation）： 空闲分区列表按地址顺序排序 分配过程时，搜索第一个合适的分区，如果有剩下的空闲分区，继续把空闲分区切割出来，所以会产生碎片。 释放分区时，检查是否可与临近的空闲分区合并 最佳匹配（Best Fit Allocation） 空闲分区列表按照 小到大排序 分配时，查找比需要分区大的最小的分区，可避免大的空闲分区被拆分，减少碎片大小。 释放时，超找并且合并临近地址的空闲分区（如果找到） Screenshot from 最差匹配(WORST Fit Allocation) 空闲分区列表按大到小排序 分配时，选最大的分区，后续找大分区比较难。 释放时，检查是否可与临近的空闲分区合并，进行可能的合并并调整空闲分区列表顺序。 伙伴系统 非连续内存分配 虚拟地址和物理地址的转换 软件实现 硬件实现 非连续分配的硬件辅助记者 段式存储管理（segmentation）: 分的比较大 页式存储管理 （paging） 把物理地址空间划分为大小相同的基本分配单位，2的n次方，如512,4096 linux启动 http://c.biancheng.net/view/1013.html linux目录结构 目录 描述 /bin 存放二进制可执行文件(ls,cat,mkdir等)，常用命令一般都在这里 /etc 存放系统管理和配置文件 /home 存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是 /home/user /usr 用于存放系统应用程序，比较重要的目录/usr/local 本地系统管理员软件安装目录 /opt 额外安装的可选应用程序包所放置的位置 /proc 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息。 /root 超级用户(系统管理员)的主目录 /sbin 存放二进制可执行文件，只有root才能访问 /dev 用于存放设备文件 /mnt 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系 统。 /boot 存放用于系统引导时使用的各种文件 /lib 存放跟文件系统中的程序运行所需要的共享库及内核模块 /var 用于存放运行时需要改变数据的文件 进程进程调度 : FIFO , Priority 进程切换进程当前的状态存放到PCB(Process Control Block)中，获取下一个需要执行进程的PCB信息，切换进程。 线程 线程 指令的切换，映射表不用切换 2个线程用一个栈的情况 1234567891011//第一个Yieldvoid Yield()&#123; 找到300； jmp 300;&#125;//第二个Yieldvoid Yield()&#123; 找到 ? ; 204 jmp ? ;&#125; 按照 (1) -&gt; (2) -&gt; (3)的顺序执行，执行玩D()中的Yield()回到B()中，到了 右括号ret 出栈，出去的是404,正确的情况时时出204 两个线程 两个栈 jmp 204去掉：否则会执行两次 用户程序 内核程序调用 多核处理 多核情况共用一个MMU,减少切换资源调用。 进程线程区别 进程 : 有很大的独立性 线程 : 所有线程都有完全一样的地址空间,意味着它们也共享同样的全局变量。由于线程可以访问进程地址空间的每一个内存地址，所以一个线程可以读、写甚至清除另一个线程的堆栈。 每个进程中的内容 : 地址空间 全局变量 打开文件 子进程 即将发生的定时器 信号与信号处理程序 每个线程中的内容：程序计数器、寄存器、堆栈、状态. 同步原子性 原子性是指一系列操作不可被中断的特性,这一系列操作要么全部执行完成，要么全部没有执行,不存在部分执行部分未执行的情况 互斥量​ 互斥量是最简单的线程同步的方法,处于两态之一的变量:解锁和加锁,两个状态可以保证资源访问的串行 自旋锁与自适应自旋 自旋锁 ​ 自旋锁的线程会反复检查锁变量是否可用,自旋锁不会让出CPU，是一种忙等待状态, ​ 自旋锁避免了进程或线程上下文切换的开销 ​ 自旋锁不适合在单核CPU使用 ​ 自旋锁的线程会反复检查锁变量是否可用 自适应自旋 提到了互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢 复线程的操作都需要转入内核态中完成，这些操作给Java虚拟机的并发性能带来了很大的压力。同 时，虚拟机的开发团队也注意到在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了 这段时间去挂起和恢复线程并不值得。现在绝大多数的个人电脑和服务器都是多路(核)处理器系 统，如果物理机器有一个以上的处理器或者处理器核心，能让两个或以上的线程同时并行执行，我们 就可以让后面请求锁的那个线程“稍等一会”，但不放弃处理器的执行时间，看看持有锁的线程是否很 快就会释放锁。为了让线程等待，我们只须让线程执行一个忙循环(自旋)，这项技术就是所谓的自 旋锁。 自旋锁在JDK 1.4.2中就已经引入，只不过默认是关闭的，可以使用-XX:+UseSpinning参数来开 启，在JDK 6中就已经改为默认开启了。自旋等待不能代替阻塞，且先不说对处理器数量的要求，自 旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，所以如果锁被占用的时间很 短，自旋等待的效果就会非常好，反之如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理 器资源，而不会做任何有价值的工作，这就会带来性能的浪费。因此自旋等待的时间必须有一定的限 度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程。自旋次数 的默认值是十次，用户也可以使用参数-XX:PreBlockSp in来自行更改。 不过无论是默认值还是用户指定的自旋次数，对整个Java虚拟机中所有的锁来说都是相同的。在 JDK 6中对自旋锁的优化，引入了自适应的自旋。自适应意味着自旋的时间不再是固定的了，而是由 前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。如果在同一个锁对象上，自旋等待刚 刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成 功，进而允许自旋等待持续相对更长的时间，比如持续100次忙循环。另一方面，如果对于某个锁，自 旋很少成功获得过锁，那在以后要获取这个锁时将有可能直接省略掉自旋过程，以避免浪费处理器资 源。有了自适应自旋，随着程序运行时间的增长及性能监控信息的不断完善，虚拟机对程序锁的状况 预测就会越来越精准，虚拟机就会变得越来越“聪明”了。 读写锁​ 读写锁是一种特殊的自旋锁, ​ 允许多个读者同时访问资源以提高读性能 ​ 对于写操作则是互斥的 条件变量​ 条件变量是一种相对复杂的线程同步方法 ​ 条件变量允许线程睡眠，直到满足某种条件 ​ 当满足条件时，可以向该线程信号，通知唤醒 mooc-os-lab[现代操作系统] 示例 p55 先学习(现代操作系统) 陈渝 向勇 https://www.bilibili.com/video/BV1js411b7vg?from=search&amp;seid=2361361014547524697 配套书： 操作系统概念(第七版) ， 操作系统-精髓与设计原理（第七版）william stallings 实验环境配置https://www.bilibili.com/video/BV1Zz4y1d7BK?from=search&amp;seid=14777231705696776183 http://os.cs.tsinghua.edu.cn/oscourse/OS2020spring ucore实验基准源代码 https://www.bilibili.com/s/video/BV1Zz4y1d7BK ubuntu窗口调整 device -&gt; Insert Guest addtions CD Image https://blog.csdn.net/u012631731/article/details/79548621 修改Ubuntu硬盘大小 https://my.oschina.net/u/4388335/blog/3321852 windows ubuntu文件夹共享 https://www.jianshu.com/p/4e73fd1c0c74?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation 并发 : 多个事件在分段被单个CPU分段执行。 并行： 多个CPU同时处理多个任务。 汇编操作系统https://fishc.com.cn/forum-39-1.html https://www.bilibili.com/video/av22872043/?p=2&amp;spm_id_from=pageDriver GCC内联汇编C语言中加入 汇编代码","categories":[{"name":"OS","slug":"OS","permalink":"http://noteforme.github.io.com/categories/OS/"}],"tags":[],"keywords":[{"name":"OS","slug":"OS","permalink":"http://noteforme.github.io.com/categories/OS/"}]},{"title":"ComputerOrganization","slug":"ComputerOrganization","date":"2020-12-10T14:42:44.000Z","updated":"2021-08-19T11:11:43.751Z","comments":true,"path":"2020/12/10/ComputerOrganization/","link":"","permalink":"http://noteforme.github.io.com/2020/12/10/ComputerOrganization/","excerpt":"","text":"组成原理 CPU 运算器 控制器 高速缓存 主存储器= 内存 控制器 程序计数器: 用于提供其他控制单元，当前要执行的指令地址 时序发生器: 用于发送时序脉冲， 依据不同的时序脉冲有节奏的进行工作 寄存器 指令寄存器 :从主存或高速缓存取计算机指令 主存地址寄存器：保存当前CPU正要访问的内存单元的地址 主存地址寄存器： 保存当前CPU正要读或写的主存数据 通用寄存器: 用于暂存或传送数据或指令 可保存ALU的运算中间结果 容量比一般专用寄存器要大 ​ 运算器 数据缓冲器​ 分为输入缓冲和输出缓冲 ​ 输入缓冲暂时存放外设送过来的数据 ​ 输出缓冲暂时存放送往外设的数据 ALU​ ALU:算术逻辑单元，是运算器的主要组成 ​ 常见的位运算(左右移、与或非等) ​ 算术运算(加减乘除等) 通用寄存器​ 用于暂时存放或传送数据或指令 ​ 可保存ALU的运算中间结果 ​ 容量比一般专用寄存器要大 状态字寄存器​ 存放运算状态(条件码、进位、溢出、结果正负等) ​ 存放运算控制信息(调试跟踪标记位、允许中断位等) 高速缓存指令执行过程 高速缓存命中率 ![](ComputerOrganization/Screen Shot 2021-03-03 at 10.10.02 PM.png) 不在缓存的数据需要去主存拿 4GB是寻址空间为什么是4G ,byte而不是 bit现在的内存可以看作一个很长的，每项宽度8位（即1Bit）的很长的数列,既然是数列，那么每一项便对应一个序号，这个序号便是地址，就如同你家在一条大街的第几号一样 https://www.zhihu.com/question/61974351","categories":[{"name":"Organization","slug":"Organization","permalink":"http://noteforme.github.io.com/categories/Organization/"}],"tags":[],"keywords":[{"name":"Organization","slug":"Organization","permalink":"http://noteforme.github.io.com/categories/Organization/"}]},{"title":"TouchEvent3","slug":"TouchEvent3","date":"2020-11-25T06:12:50.000Z","updated":"2021-08-19T11:11:44.255Z","comments":true,"path":"2020/11/25/TouchEvent3/","link":"","permalink":"http://noteforme.github.io.com/2020/11/25/TouchEvent3/","excerpt":"","text":"Button TextViewbutton clickable=true,所以 默认消费事件,TextView不会 value.xml 123456789&lt;style name=&quot;Base.Widget.AppCompat.Button&quot; parent=&quot;android:Widget&quot;&gt; &lt;item name=&quot;android:background&quot;&gt;@drawable/abc_btn_default_mtrl_shape&lt;/item&gt; &lt;item name=&quot;android:textAppearance&quot;&gt;?android:attr/textAppearanceButton&lt;/item&gt; &lt;item name=&quot;android:minHeight&quot;&gt;48dip&lt;/item&gt; &lt;item name=&quot;android:minWidth&quot;&gt;88dip&lt;/item&gt; &lt;item name=&quot;android:focusable&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:clickable&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:gravity&quot;&gt;center_vertical|center_horizontal&lt;/item&gt;&lt;/style&gt; 处理开篇问题 处理方法外部拦截法:​ 需要在父ViewGroup，重写onInterceptTouchEvent( [ˌɪntərˈsept])方法，根据业务需要，判断哪些事件是父Viewgroup需要的，需要的话就对该事件进行拦截，然后交由onTouchEvent方法处理，若不需要，则不拦截，然后传递给子view或子viewGroup。 内部拦截法主要由子view控制事件，配合requestDisallowInterceptTouchEvent(),父View不拦截任何down事件 ,思路是这样的，在ViewGroupA的Action_Down动作中设置requestDisallowInterceptTouchEvent(true),这样RootView不会走拦截方法，保证Action_Move,能进入ViewGroupA,然后在ViewGroupA的move事件中，根据需要控制RootView发送过来的后续Action_Move事件. 代码 ViewGroupA 12345678910111213141516171819202122232425@Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; Logger.d(ev.getAction(), TAG, Static.dispatchTouchEvent + &quot;老板要做淘宝,下周上线?&quot;); int x = (int) ev.getX(); int y = (int) ev.getY(); switch (ev.getAction()) &#123; case MotionEvent.ACTION_DOWN: getParent().requestDisallowInterceptTouchEvent(true); break; case MotionEvent.ACTION_MOVE: int deltaX = x - mLastX; int deltaY = y - mLastY; if (Math.abs(deltaX) &gt; Math.abs(deltaY)) &#123; getParent().requestDisallowInterceptTouchEvent(false); &#125; else &#123; getParent().requestDisallowInterceptTouchEvent(true); &#125; break; &#125; mLastX = x; mLastY = y; return super.dispatchTouchEvent(ev); &#125; RootView 123456789@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; Logger.d(ev.getAction(), TAG, Static.onInterceptTouchEvent + &quot;(老板可能疯了,但又不是我做.)&quot;); if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; return false; &#125;else &#123; return true; &#125;&#125; 内部拦截ViewGroupA消费事件 运行结果 D/MainActivity [老板] ACTION_DOWN: dispatchTouchEvent 经理,我准备发展一下电商业务,下周之前做一个淘宝出来.D/RootView [经理] ACTION_DOWN: dispatchTouchEvent 呼叫技术部,老板要做淘宝,下周上线.D/RootView [经理] ACTION_DOWN: onInterceptTouchEvent (老板可能疯了,但又不是我做.)D/ViewGroupA [组长] ACTION_DOWN: dispatchTouchEvent 老板要做淘宝,下周上线?D/ViewGroupA [组长] ACTION_DOWN: onInterceptTouchEvent (看着不太靠谱,先问问小王怎么看)D/ViewGroupA [组长] ACTION_DOWN: onTouchEvent 小王说做不了 D/MainActivity [老板] ACTION_MOVE: dispatchTouchEvent 经理,我准备发展一下电商业务,下周之前做一个淘宝出来.D/RootView [经理] ACTION_MOVE: dispatchTouchEvent 呼叫技术部,老板要做淘宝,下周上线.D/ViewGroupA [组长] ACTION_MOVE: dispatchTouchEvent 老板要做淘宝,下周上线?D/ViewGroupA [组长] ACTION_MOVE: onTouchEvent 小王说做不了 D/MainActivity [老板] ACTION_MOVE: dispatchTouchEvent 经理,我准备发展一下电商业务,下周之前做一个淘宝出来.D/RootView [经理] ACTION_MOVE: dispatchTouchEvent 呼叫技术部,老板要做淘宝,下周上线.D/ViewGroupA [组长] ACTION_MOVE: dispatchTouchEvent 老板要做淘宝,下周上线?D/ViewGroupA [组长] ACTION_MOVE: onTouchEvent 小王说做不了 代码流程 Action_down都会被ViewGroupA消费,所以主要分析Action_Move事件流程,由于Action_down requestDisallowInterceptTouchEvent(true)那么 disallowIntercept =true, 第1次 Action_Move 分发 RootView : dispatchTouchEvent() 29 =&gt; 32=&gt;36 intercepted = false =&gt; 58 =&gt; ViewGroupA: dispatchTouchEvent() 29=&gt; 设置 getParent().requestDisallowInterceptTouchEvent(true) =&gt;view =&gt; dispatchTouchEvent被消费 第2次Action_Move 分发 RootView : dispatchTouchEvent() 29 =&gt; 32=&gt;36 intercepted = false =&gt; 58 =&gt; ViewGroupA: dispatchTouchEvent() 29=&gt; 设置y&gt;x getParent().requestDisallowInterceptTouchEvent(true) =&gt;view =&gt; dispatchTouchEvent被消费 运行结果 225 24328-24328/ D/MainActivity [老板] ACTION_DOWN: dispatchTouchEvent 经理,我准备发展一下电商业务,下周之前做一个淘宝出来.226 24328-24328/ D/RootView [经理] ACTION_DOWN: dispatchTouchEvent 呼叫技术部,老板要做淘宝,下周上线.226 24328-24328/ D/RootView [经理] ACTION_DOWN: onInterceptTouchEvent (老板可能疯了,但又不是我做.)227 24328-24328/ D/ViewGroupA [组长] ACTION_DOWN: dispatchTouchEvent 老板要做淘宝,下周上线?227 24328-24328/ D/ViewGroupA [组长] ACTION_DOWN: onInterceptTouchEvent (看着不太靠谱,先问问小王怎么看)228 24328-24328/ D/ViewGroupA [组长] ACTION_DOWN: onTouchEvent 小王说做不了 237 24328-24328/ D/MainActivity [老板] ACTION_MOVE: dispatchTouchEvent 经理,我准备发展一下电商业务,下周之前做一个淘宝出来.237 24328-24328/ D/RootView [经理] ACTION_MOVE: dispatchTouchEvent 呼叫技术部,老板要做淘宝,下周上线.237 24328-24328/ D/ViewGroupA [组长] ACTION_MOVE: dispatchTouchEvent 老板要做淘宝,下周上线?237 24328-24328/ D/ViewGroupA [组长] ACTION_MOVE: dispatchTouchEvent dx:0 dy:0238 24328-24328/ D/ViewGroupA [组长] ACTION_MOVE: dispatchTouchEvent Math.abs(deltaX) &gt; Math.abs(deltaY) false238 24328-24328/ D/ViewGroupA [组长] ACTION_MOVE: onTouchEvent 小王说做不了 287 24328-24328/ D/MainActivity [老板] ACTION_MOVE: dispatchTouchEvent 经理,我准备发展一下电商业务,下周之前做一个淘宝出来.287 24328-24328/ D/RootView [经理] ACTION_MOVE: dispatchTouchEvent 呼叫技术部,老板要做淘宝,下周上线.287 24328-24328/ D/ViewGroupA [组长] ACTION_MOVE: dispatchTouchEvent 老板要做淘宝,下周上线?288 24328-24328/ D/ViewGroupA [组长] ACTION_MOVE: dispatchTouchEvent dx:2 dy:0288 24328-24328/ D/ViewGroupA [组长] ACTION_MOVE: dispatchTouchEvent Math.abs(deltaX) &gt; Math.abs(deltaY) true288 24328-24328/ D/ViewGroupA [组长] ACTION_MOVE: onTouchEvent 小王说做不了 304 24328-24328/ D/MainActivity [老板] ACTION_MOVE: dispatchTouchEvent 经理,我准备发展一下电商业务,下周之前做一个淘宝出来.305 24328-24328/ D/RootView [经理] ACTION_MOVE: dispatchTouchEvent 呼叫技术部,老板要做淘宝,下周上线.305 24328-24328/ D/RootView [经理] ACTION_MOVE: onInterceptTouchEvent (老板可能疯了,但又不是我做.) 320 24328-24328/ D/MainActivity [老板] ACTION_MOVE: dispatchTouchEvent 经理,我准备发展一下电商业务,下周之前做一个淘宝出来.321 24328-24328/ D/RootView [经理] ACTION_MOVE: dispatchTouchEvent 呼叫技术部,老板要做淘宝,下周上线.321 24328-24328/ D/RootView [经理] ACTION_MOVE: onTouchEvent 报告老板, 技术部说做不了 338 24328-24328/ D/MainActivity [老板] ACTION_MOVE: dispatchTouchEvent 经理,我准备发展一下电商业务,下周之前做一个淘宝出来.338 24328-24328/ D/RootView [经理] ACTION_MOVE: dispatchTouchEvent 呼叫技术部,老板要做淘宝,下周上线.338 24328-24328/ D/RootView [经理] ACTION_MOVE: onTouchEvent 报告老板, 技术部说做不了 代码流程 百思不得其姐， RootView dispatchTouchEvent 后面的onInterceptTouchEvent() 方法日志为什么没打印，其他都能通 1MotionEvent.ACTION_DOWN requestDisallowInterceptTouchEvent(true),必须设置,否则后续的Action_Move无法进入 ViewGroupA https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650237941&amp;idx=1&amp;sn=40bca69abe10015cc469132f8c76a910&amp;chksm=88639a9abf14138cae7409adec85c5496486a044d7f4ef102e513d9c052aaa30017fb37e3439&amp;scene=38#wechat_redirect","categories":[{"name":"VIEW","slug":"VIEW","permalink":"http://noteforme.github.io.com/categories/VIEW/"}],"tags":[{"name":"TouchEvent","slug":"TouchEvent","permalink":"http://noteforme.github.io.com/tags/TouchEvent/"}],"keywords":[{"name":"VIEW","slug":"VIEW","permalink":"http://noteforme.github.io.com/categories/VIEW/"}]},{"title":"DesignPattern","slug":"DesignPattern","date":"2020-11-19T09:12:03.000Z","updated":"2021-09-12T10:46:04.808Z","comments":true,"path":"2020/11/19/DesignPattern/","link":"","permalink":"http://noteforme.github.io.com/2020/11/19/DesignPattern/","excerpt":"","text":"设计原则单一职责​ 一个类应该只负责一项职责。 接口隔离​ 客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。 依赖倒置 高层模块不应该依赖低层模块，二者都应该依赖其抽象。 抽象不应该依赖细节，细节应该依赖抽象。 依赖倒置的中心思想是面向接口编程。 里氏替换 所有使用基类的地方必须能透明的使用其子类。 使用继承时，遵循里氏替换原则，子类尽量不要重写父类的方法。继承实际上让两个类耦合性增强了，适当情况下可以通过 聚合 组合 依赖来解决问题。 ​ 通用做法是： 原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖，聚合，组合等关系代替。 之前的方案 123456789101112131415161718192021222324252627282930public class Liskov &#123; public static void main(String[] args) &#123; A a = new A(); System.out.println(&quot;11-3=&quot; + a.func1(11, 3)); System.out.println(&quot;1-8=&quot; + a.func1(1, 8)); System.out.println(&quot;---------------&quot;); B b = new B(); System.out.println(&quot;11-3=&quot; + b.func1(11, 3)); System.out.println(&quot;1-8=&quot; + b.func1(1, 8)); System.out.println(&quot;11+3+9=&quot; + b.func2(11, 3)); &#125;&#125;class A &#123; public int func1(int num1, int num2) &#123; return num1 - num2; &#125;&#125;class B extends A &#123; //没意识到 重写了该方法 public int func1(int num1, int num2) &#123; return num1 + num2; &#125; public int func2(int a, int b) &#123; return func1(a, b) - 9; &#125;&#125; 改进后的方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Liskov &#123; public static void main(String[] args) &#123; A a = new A(); System.out.println(&quot;11-3=&quot; + a.func1(11, 3)); System.out.println(&quot;1-8=&quot; + a.func1(1, 8)); System.out.println(&quot;---------------&quot;); B b = new B(); //因为B类不再继承A类，因此调用者，不会再func1求减法 System.out.println(&quot;11+3=&quot; + b.func1(11, 3)); System.out.println(&quot;1+8=&quot; + b.func1(1, 8)); System.out.println(&quot;11+3+9=&quot; + b.func2(11, 3)); //使用组合仍然可以使用A类相关方法 System.out.println(&quot;11-3=&quot; + b.func3(11, 3)); &#125;&#125; class Base&#123; //把更基础的方法和成员写到Base类中&#125;class A extends Base &#123; public int func1(int num1, int num2) &#123; return num1 - num2; &#125;&#125;class B extends Base &#123; //如果B需要使用A类的方法，使用组合关系 private A a = new A(); //没意识到 重写了该方法 public int func1(int num1, int num2) &#123; return num1 + num2; &#125; public int func2(int a, int b) &#123; return func1(a, b) +9; &#125; public int func3(int a,int b)&#123; return this.a.func1(a,b); &#125;&#125; 开闭原则 ocpopen closed principle 不适用该原则的方案 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class GraphicEditor &#123; public static void main(String[] args) &#123; GraphicEditor graphicEditor = new GraphicEditor(); graphicEditor.drawShape(new Rectangle()); graphicEditor.drawShape(new Circle()); graphicEditor.drawShape(new Triangle()); &#125; //添加一个图形需要修改 public void drawShape(Shape s) &#123; if (s.m_type == 1) drawRectangle(s); else if (s.m_type == 2) drawCircle(s); else if (s.m_type == 3) drawTriangle(s); &#125; private void drawCircle(Shape s) &#123; System.out.println(&quot;绘制圆形&quot;); &#125; private void drawRectangle(Shape s) &#123; System.out.println(&quot;绘制矩形&quot;); &#125; //添加一个图形需要修改 private void drawTriangle(Shape s) &#123; System.out.println(&quot;绘制三角形&quot;); &#125;&#125;class Shape &#123; public int m_type;&#125;class Rectangle extends Shape &#123; public Rectangle() &#123; super.m_type = 1; &#125;&#125;class Circle extends Shape &#123; public Circle() &#123; super.m_type = 2; &#125;&#125;//新增图形class Triangle extends Shape &#123; public Triangle() &#123; super.m_type = 3; &#125;&#125; 可以看到改动很多 使用ocp原则改进后 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class GraphicEditor &#123; public static void main(String[] args) &#123; GraphicEditor graphicEditor = new GraphicEditor(); graphicEditor.drawShape(new Rectangle()); graphicEditor.drawShape(new Circle()); graphicEditor.drawShape(new Triangle()); graphicEditor.drawShape(new OtherGraphic()); &#125; public void drawShape(Shape s) &#123; s.drawShape(); &#125;&#125;abstract class Shape &#123; public int m_type; abstract void drawShape();&#125;class Rectangle extends Shape &#123; @Override void drawShape() &#123; System.out.println(&quot;绘制矩形&quot;); &#125;&#125;class Circle extends Shape &#123; @Override void drawShape() &#123; System.out.println(&quot;绘制圆形&quot;); &#125;&#125;class Triangle extends Shape &#123; @Override void drawShape() &#123; System.out.println(&quot;绘制三角形&quot;); &#125;&#125;//新增一个图形class OtherGraphic extends Shape &#123; @Override void drawShape() &#123; System.out.println(&quot;新增一个图形&quot;); &#125;&#125; 实现代码没有任何改动 迪米特法则 一个对象应该对其他对象保持最少的了解 Demeter Principle又叫最少知道原则， 即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外出了提供的public方法，不泄漏任何信息 只与直接的朋友通信。 直接的朋友: 每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多， 依赖 关联，组合，聚合等。 其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。 ​ 改进前 ​ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class Demeter1 &#123; public static void main(String[] args) &#123; SchoolManager schoolManager = new SchoolManager(); schoolManager.printAllEmployee(new CollegeManger()); &#125;&#125;//学校总部员工的类class SchollEmployee &#123; private String id; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125;&#125;//学院的员工class CollegeEmployee &#123; private String id; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125;&#125;//管理学院员工的管理类class CollegeManger &#123; public List&lt;CollegeEmployee&gt; getAllEmployee() &#123; ArrayList&lt;CollegeEmployee&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; CollegeEmployee collegeEmployee = new CollegeEmployee(); collegeEmployee.setId(&quot;学院员工id= &quot; + i); list.add(collegeEmployee); &#125; return list; &#125;&#125;// SchollEmployee , CollegeManger 是直接朋友// CollegeEmployee 不是直接朋友，而是一个陌生类，这样违反了 迪米特法则。class SchoolManager &#123; public List&lt;SchollEmployee&gt; getAllEmployee() &#123;//方法返回值:直接朋友 ArrayList&lt;SchollEmployee&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) &#123; SchollEmployee schollEmployee = new SchollEmployee(); // CollegeEmployee 不是直接朋友，以局部变量出现在SchoolManager schollEmployee.setId(&quot;学校总部员工id= &quot; + i); list.add(schollEmployee); &#125; return list; &#125; //该方法完成输出学校总部和学院员工ID void printAllEmployee(CollegeManger sub) &#123;//方法参数:直接朋友 List&lt;CollegeEmployee&gt; list1 = sub.getAllEmployee(); System.out.println(&quot;-----------学院员工--------&quot;); for (CollegeEmployee e : list1) &#123; System.out.println(e.getId()); &#125; List&lt;SchollEmployee&gt; list2 = this.getAllEmployee(); System.out.println(&quot;-----------学校总部员工--------&quot;); for (SchollEmployee e : list2) &#123; System.out.println(e.getId()); &#125; &#125;&#125; 改进后 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public class Demeter2 &#123; public static void main(String[] args) &#123; System.out.println(&quot;使用迪米特法则的改进&quot;); SchoolManager schoolManager = new SchoolManager(); schoolManager.printAllEmployee(new CollegeManger()); &#125;&#125;//学校总部员工的类class SchollEmployee &#123; private String id; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125;&#125;//学院的员工class CollegeEmployee &#123; private String id; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125;&#125;//管理学院员工的管理类class CollegeManger &#123; public List&lt;CollegeEmployee&gt; getAllEmployee() &#123; ArrayList&lt;CollegeEmployee&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; CollegeEmployee collegeEmployee = new CollegeEmployee(); collegeEmployee.setId(&quot;学院员工id= &quot; + i); list.add(collegeEmployee); &#125; return list; &#125; // 输出学院员工的信息 void printCollegeEmployee() &#123; //改进方法： 将输出学院员工的方法，封装到CollegeManager中。 List&lt;CollegeEmployee&gt; list1 = getAllEmployee(); System.out.println(&quot;-----------学院员工--------&quot;); for (CollegeEmployee e : list1) &#123; System.out.println(e.getId()); &#125; &#125;&#125;// SchollEmployee , CollegeManger 是直接朋友// CollegeEmployee 不是直接朋友，而是一个陌生类，这样违反了 迪米特法则。class SchoolManager &#123; public List&lt;SchollEmployee&gt; getAllEmployee() &#123;//方法返回值:直接朋友 ArrayList&lt;SchollEmployee&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) &#123; SchollEmployee schollEmployee = new SchollEmployee(); // CollegeEmployee 不是直接朋友，以局部变量出现在SchoolManager schollEmployee.setId(&quot;学校总部员工id= &quot; + i); list.add(schollEmployee); &#125; return list; &#125; //该方法完成输出学校总部和学院员工ID void printAllEmployee(CollegeManger sub) &#123;//方法参数:直接朋友 /* List&lt;CollegeEmployee&gt; list1 = sub.getAllEmployee(); System.out.println(&quot;-----------学院员工--------&quot;); for (CollegeEmployee e : list1) &#123; System.out.println(e.getId()); &#125;*/ //改进方法： 将输出学院员工的方法，封装到CollegeManager中。 sub.printCollegeEmployee(); List&lt;SchollEmployee&gt; list2 = this.getAllEmployee(); System.out.println(&quot;-----------学校总部员工--------&quot;); for (SchollEmployee e : list2) &#123; System.out.println(e.getId()); &#125; &#125;&#125; 创见型: 对象的创建 单例模式 、工厂模式 、原型模式 结构型: 类或对象的组合或组装 代理模式 : 代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。 还需要理解动态代理? 桥接模式: 有两种理解方式。第一种理解方式是“将抽象和实现解耦，让它们能独立开发” 装饰器 : 装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类 装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点。 代理模式中，代理类附加的是跟原始类无关的功能，而在装饰器模式中，装饰器类附加的是跟原始类相关的增强功能。 对于为什么必须继承装饰器父类 FilterInputStream的思考：装饰器如BufferedInputStream等，本身并不真正处理read()等方法，而是由构造函数传入的被装饰对象：InputStream（实际上是FileInputStream或者ByteArrayInputStream等对象）来完成的。如果不重写默认的read()等方法，则无法完成如FileInputStream或者ByteArrayInputStream等对象所真正实现的read功能。所以必须重写对应的方法，代理给这些被装饰对象进行处理（这也是类似于代理模式的地方）。如果像DataInputStream和BufferedInputStream等每个装饰器都重写的这些方法话，会存在大量重复的代码。所以让它们都继承FilterInputStream提供的默认实现，可以减少代码重复，让装饰器只聚焦在它自己的装饰功能上即可。 https://noteforme.github.io/2017/09/12/JavaIo/ 适配器模式： 适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。 类适配器: 通过继承关系 对象适配器：通过组合关系 门面模式 门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。这个定义很简洁，我再进一步解释一下。假设有一个系统 A，提供了 a、b、c、d 四个接口。系统 B 完成某个业务功能，需要调用 A 系统的 a、b、d 接口。利用门面模式，我们提供一个包裹 a、b、d 接口调用的门面接口 x，给系统 B 直接使用 组合模式 将一组对象组织（Compose）成树形结构，以表示一种“部分 - 整体”的层次结构。组合让客户端（在很多设计模式书籍中，“客户端”代指代码的使用者。）可以统一单个对象和组合对象的处理逻辑。 组合模式的设计思路，与其说是一种设计模式，倒不如说是对业务场景的一种数据结构和算法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算法来实现。 享元模式 如果这些重复的对象是不可变对象，我们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这样可以减少内存中对象的数量，起到节省内存的目的. 实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段）提取出来，设计成享元，让这些大量相似对象引用这些享元。 思考: 提取相同对象，最终还是要创建相同的数量的对象，只是字段省略了 行为型:类或对象之间的交互 模板模式 模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。 回调基于组合关系来实现，把一个对象传递给另一个对象，是一种对象之间的关系；模板模式基于继承关系来实现，子类重写父类的抽象方法，是一种类之间的关系。 策略模式 包含一组策略可选，客户端代码如何选择使用哪个策略，有两种确定方法：编译时静态确定和运行时动态确定。其中，“运行时动态确定”才是策略模式最典型的应用场景。 类似于面向接口编程,策略模式包含策略的定义、创建和使用三部分，从代码结构上来，它非常像工厂模式。它们的区别在于，策略模式侧重“策略”或“算法”这个特定的应用场景，用来解决根据运行时状态从一组策略中选择不同策略的问题，而工厂模式侧重封装对象的创建过程，这里的对象没有任何业务场景的限定，可以是策略，但也可以是其他东西。从设计意图上来，这两个模式完全是两回事儿 职责链模式 将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止。 分析在retrofit filter上的应用 状态模式 迭代器模式 一般会涉及容器 List 和容器迭代器 iterator 两部分内容 迭代器模式 访问者模式 在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态 备忘录模式 这个模式理解、掌握起来不难，代码实现比较灵活，应用场景也比较明确和有限，主要是用来防丢失、撤销、恢复等 命令模式 命令模式将请求（命令）封装为一个对象，这样可以使用不同的请求参数化其他对象（将不同请求依赖注入到其他对象），并且能够支持请求（命令）的排队执行、记录日志、撤销等（附加控制）功能 在策略模式中，不同的策略具有相同的目的、不同的实现、互相之间可以替换。比如，BubbleSort、SelectionSort 都是为了实现排序的，只不过一个是用冒泡排序算法来实现的，另一个是用选择排序算法来实现的。而在命令模式中，不同的命令具有不同的目的，对应不同的处理逻辑，并且互相之间不可替换 中介模式 将一组对象之间的交互关系（或者依赖关系）从多对多（网状关系）转换为一对多（星状关系 https://www.bilibili.com/video/BV1G4411c7N4?p=44&amp;spm_id_from=pageDriver https://github.com/mxg133/learnforJava_DesignPattern","categories":[{"name":"DesignPatterns","slug":"DesignPatterns","permalink":"http://noteforme.github.io.com/categories/DesignPatterns/"}],"tags":[],"keywords":[{"name":"DesignPatterns","slug":"DesignPatterns","permalink":"http://noteforme.github.io.com/categories/DesignPatterns/"}]},{"title":"base64","slug":"base64","date":"2020-10-22T06:49:37.000Z","updated":"2021-08-19T11:11:44.298Z","comments":true,"path":"2020/10/22/base64/","link":"","permalink":"http://noteforme.github.io.com/2020/10/22/base64/","excerpt":"","text":"https://www.jianshu.com/p/313b73ee7d6f","categories":[{"name":"flutter","slug":"flutter","permalink":"http://noteforme.github.io.com/categories/flutter/"}],"tags":[],"keywords":[{"name":"flutter","slug":"flutter","permalink":"http://noteforme.github.io.com/categories/flutter/"}]},{"title":"flutter_paint","slug":"flutter-paint","date":"2020-10-14T05:53:46.000Z","updated":"2021-08-19T11:11:44.298Z","comments":true,"path":"2020/10/14/flutter-paint/","link":"","permalink":"http://noteforme.github.io.com/2020/10/14/flutter-paint/","excerpt":"","text":"1Offset(size.width*0.5, size.height) //坐标 https://codewithandrea.com/videos/2020-01-27-flutter-custom-painting-do-not-fear-canvas/ https://flutter.dev/docs/development/ui/widgets/painting","categories":[{"name":"flutter","slug":"flutter","permalink":"http://noteforme.github.io.com/categories/flutter/"}],"tags":[],"keywords":[{"name":"flutter","slug":"flutter","permalink":"http://noteforme.github.io.com/categories/flutter/"}]},{"title":"flutter_layout","slug":"flutter-layout","date":"2020-09-24T07:43:26.000Z","updated":"2021-08-19T11:11:44.298Z","comments":true,"path":"2020/09/24/flutter-layout/","link":"","permalink":"http://noteforme.github.io.com/2020/09/24/flutter-layout/","excerpt":"","text":"https://jspang.com/detailed?id=43 https://book.flutterchina.club/chapter4/row_and_column.html 主轴和纵轴对于线性布局，有主轴和纵轴之分，如果布局是沿水平方向(Row),那么主轴就是指水平方向，而纵轴即垂直方向. 如果布局沿垂直方向(Colomn)，那么主轴就是指垂直方向，而纵轴就是水平方向 MainAxisAlignment 表示子组件在Row所占用的水平空间内对齐方式，如果mainAxisSize值为MainAxisSize.min，则此属性无意义 crossAxisAlignment 表示子组件在纵轴方向的对齐方式，Row的高度等于子组件中最高的子元素高度 TextDirection : 字体方向 CrossAxisAlignment : 表示Row纵轴（垂直）的对齐方向，默认是VerticalDirection.down，表示从上到下. Row和Column都只会在主轴方向占用尽可能大的空间，而纵轴的长度则取决于他们最大子元素的长度 特殊情况 : 如果Row里面嵌套Row，或者Column里面再嵌套Column，那么只有最外面的Row或Column会占用尽可能大的空间，里面Row或Column所占用的空间为实际大小，下面以Column为例说明","categories":[{"name":"flutter","slug":"flutter","permalink":"http://noteforme.github.io.com/categories/flutter/"}],"tags":[],"keywords":[{"name":"flutter","slug":"flutter","permalink":"http://noteforme.github.io.com/categories/flutter/"}]},{"title":"flutterdev","slug":"flutterdev","date":"2020-08-26T03:56:46.000Z","updated":"2021-08-19T11:11:44.299Z","comments":true,"path":"2020/08/26/flutterdev/","link":"","permalink":"http://noteforme.github.io.com/2020/08/26/flutterdev/","excerpt":"","text":"​ https://flutter.dev/docs/development/ui/layout Aligning widgetsMainAxisAlignmenthttps://blog.csdn.net/BINGXIHEART/article/details/95077098 可以接着完善 row 12345678Row( mainAxisAlignment: MainAxisAlignment.spaceEvenly, children: [ Image.asset(&#x27;images/pic1.jpg&#x27;), Image.asset(&#x27;images/pic2.jpg&#x27;), Image.asset(&#x27;images/pic3.jpg&#x27;), ],); Column 12345678Widget buildRow() =&gt; Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Image.asset(&#x27;images/pic1.jpg&#x27;), Image.asset(&#x27;images/pic2.jpg&#x27;), Image.asset(&#x27;images/pic3.jpg&#x27;), ], ); constraintsConstrainedBox The ConstrainedBox imposes additional constraints from its constraints parameter onto its child . UnconstrainedBoxThe screen forces the UnconstrainedBox to be exactly the same size as the screen. However, the UnconstrainedBox lets its child Container be any size it wants https://resocoder.com/2019/08/15/flutter-custom-icons-automatic-manual-way-icon-font-or-svg/ https://www.fluttericon.com/ json and serializtion1234567891011dependencies: json_annotation: ^2.2.0dev_dependencies: flutter_test: sdk: flutter build_runner: ^1.0.0 json_serializable: ^2.0.0 json_model: flutter packages pub run json_model 123456789101112131415161718192021import &#x27;dart:convert&#x27;;import &#x27;dart:io&#x27;;import &#x27;package:flutteruse/models/user.dart&#x27;;void main() &#123; final jsonString = File(&#x27;jsons/user.json&#x27;).readAsStringSync(); print(jsonString); // var jsonString = &#x27;&#123;&quot;name&quot;: &quot;John Smith&quot;,&quot;email&quot;: &quot;john@example.com&quot;&#125;&#x27;; // Map&lt;String, dynamic&gt; user = jsonDecode(jsonString) as Map&lt;String, dynamic&gt;; // print(&#x27;Howdy, $&#123;user[&#x27;name&#x27;]&#125;!&#x27;); // print(&#x27;We sent the verification link to $&#123;user[&#x27;email&#x27;]&#125;.&#x27;); Map userMap = jsonDecode(jsonString); var user = User.fromJson(userMap); print(&#x27;Howdy, $&#123;user.name&#125;!&#x27;); print(&#x27;We sent the verification link to $&#123;user.email&#125;.&#x27;); print(user.toJson());&#125; 项目中采用第三种方法 使用json_model自动生成 1.在项目根目录新建jsons文件夹并将json数据新建成为文件，在lib目录下新建包名为models 注意：这两个文件夹的名字都必须为jsons和models 2、加入依懒 注意：这里添加完json_serializable相关依赖之后还添加了json_model的依赖，这就是快捷生成的关键，还有如果json中引用了其他model可以使用如下方式 { “name”:”wendux”, “father”:”$user”,//可以通过”$”符号引用其它model类 “friends”:”$[]user”,//可以通过”$[]”来引用数组 “keywords”:”$[]String”,//同上 “age”:20 } 3.完成上面的操作之后 在当前项目的根目录执行如下命令：flutter packages pub run json_model 控制台打印如下日志就成功了 注意：如果json文件中加了注释可能会报错，需要删除注释，错误信息如下 其实，我们也可以不使用命令行的方式自动生成， 用run([‘src=jsons’])的方法也可以，run方法为json_model暴露的方法 https://www.jianshu.com/p/f37d8546ab8f 修改包名后 pubspec.yaml target file “lib/main_dev.dart” not found 12345plugin: platforms: android: package: com.casanube.flutter_ble //记得修改这个包名 要不然爆出上面的错误 pluginClass: FlutterBlePlugin flutter自定义控件 https://mp.weixin.qq.com/s/aVvos5iWYVmiVZRv4hMQMQ https://juejin.im/post/6874061694491721736","categories":[{"name":"flutter","slug":"flutter","permalink":"http://noteforme.github.io.com/categories/flutter/"}],"tags":[],"keywords":[{"name":"flutter","slug":"flutter","permalink":"http://noteforme.github.io.com/categories/flutter/"}]},{"title":"OS_PROCESS","slug":"OS-PROCESS","date":"2020-08-17T02:55:14.000Z","updated":"2021-08-19T11:11:44.181Z","comments":true,"path":"2020/08/17/OS-PROCESS/","link":"","permalink":"http://noteforme.github.io.com/2020/08/17/OS-PROCESS/","excerpt":"","text":"进程进程有很大的独立性 为了实现进程模型，操作系统维护着一张表格，进程表。每个进程占用一个进程表项。 进程通信进程通信方式文件 AIDL （基于 Binder） Android 进阶：进程通信之 AIDL 的使用 Android 进阶：进程通信之 AIDL 解析 Binder Android 进阶：进程通信之 Binder 机制浅析 Messenger （基于 Binder） Android 进阶：进程通信之 Messenger 使用与解析 ContentProvider （基于 Binder） Android 进阶：进程通信之 ContentProvider 内容提供者 Socket Android 进阶：进程通信之 Socket （顺便回顾 TCP UDP） 原文链接：https://blog.csdn.net/u011240877/article/details/72863432 管道通信 无名管道， 有名管道:文件系统中有这样一个文件名 信号通信： 进程通信的思想 共享内存 共享存储允许不相关的进程访问同一片物理内存 共享内存是两个进程之间共享和传递数据最快的方式 共享内存未提供同步机制，需要借助其他机制管理访问 共享存储是两个进程之间共享和传递数据最快的一种方式 共享内存未提供同步机制，需要借助其他机制管理访问 Unix域套接字 域套接字是一种高级的进程间通信的方法 Unix域套接字可以用于同一机器进程间通信 https://www.bilibili.com/video/BV1tJ41117ty?from=search&amp;seid=13006387505737298314","categories":[{"name":"OS","slug":"OS","permalink":"http://noteforme.github.io.com/categories/OS/"}],"tags":[],"keywords":[{"name":"OS","slug":"OS","permalink":"http://noteforme.github.io.com/categories/OS/"}]},{"title":"AutoDispose","slug":"AutoDispose","date":"2020-08-14T02:18:28.000Z","updated":"2021-08-19T11:11:43.695Z","comments":true,"path":"2020/08/14/AutoDispose/","link":"","permalink":"http://noteforme.github.io.com/2020/08/14/AutoDispose/","excerpt":"","text":"https://uber.github.io/AutoDispose/","categories":[],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"http://noteforme.github.io.com/tags/RxJava/"}],"keywords":[]},{"title":"ViewGroup","slug":"ViewGroup","date":"2020-08-12T23:36:27.000Z","updated":"2021-08-19T11:11:44.266Z","comments":true,"path":"2020/08/13/ViewGroup/","link":"","permalink":"http://noteforme.github.io.com/2020/08/13/ViewGroup/","excerpt":"","text":"生命周期 每次onMeasure，onLayout用到的值都不能在构造方法里面初始化。 ViewGroup测量 ![](/Users/john/Documents/noteforme.github.io/source/_posts/ViewGroup/Screen Shot 2021-08-13 at 6.21.59 PM.png) MeasureSpecMeasureSpec创建规则 子View为精确宽高，无论父容器的MeasureSpec，子View的MeasureSpec都为精确值且遵循LayoutParams中的值。 子View为match_parent时，如果父容器是精确模式，则子View也为精确模式且为父容器的剩余空间大小；如果父容器是最大模式，则子View也是最大模式且不会超过父容器的剩余空间。 子View为wrap_content时，无论父View是精确还是最大模式，子View的模式总是最大模式，且不会超过父容器的剩余空间。 艺术探索 https://www.jianshu.com/p/cb529ed03597 https://juejin.cn/post/6844904094205739016 MeasureSpec表示 MeasureSpec用int表示,总共32位，高2位代表SpecMode，低30位代表SpecSize,SpecMode是指测量模式，而SpecSize是指在某种测量模式下的规格大小。MeasureSpec通过将SpecMode和SpecSize打包成一个int值来避免过多的对象内存分配.打包makeMeasureSpec。 高2位 00 , 01, 10, 分别对应UNSPECIFIED, EXACTLY,AT_MOST。 UNSPECIFIED 父容器不对View有任何限制，要多大给多大，这种情况一般用于系统内部，表示一种测量的状态。 EXACTLY 父容器已经检测出View所需要的精确大小，这个时候View的最终大小就是SpecSize所指定的值。它对应于LayoutParams中的match_parent和具体的数值这两种模式。 AT_MOST 父容器指定了一个可用大小即SpecSize,View的大小不能大于这个值，具体是什么值要看不同View的具体实现。它对应于LayoutParams中的wrap_content。 ​ getMeasuredWidth 在measure()过程结束后就可以获取到对应的值。通过setMeasuredDimension()方法来进行设置。 getWidth区别 在view.layout()过程结束后才能获取到； 通过视图右边的坐标-左边的左边计算出来的 123456789101112131415final int childHeightMeasureSpec;if (lp.height == LayoutParams.MATCH_PARENT) &#123; final int height = Math.max(0, getMeasuredHeight() - getPaddingTopWithForeground() - getPaddingBottomWithForeground() - lp.topMargin - lp.bottomMargin); childHeightMeasureSpec = MeasureSpec.makeMeasureSpec( height, MeasureSpec.EXACTLY);&#125; else &#123; childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec, getPaddingTopWithForeground() + getPaddingBottomWithForeground() + lp.topMargin + lp.bottomMargin, lp.height);&#125;child.measure(childWidthMeasureSpec, childHeightMeasureSpec); Frame layout 子节点重新绘制，为什么 Framelayout边界怎么算的 1234567891011121314switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123; case Gravity.CENTER_HORIZONTAL: childLeft = parentLeft + (parentRight - parentLeft - width) / 2 + lp.leftMargin - lp.rightMargin; break; case Gravity.RIGHT: if (!forceLeftGravity) &#123; childLeft = parentRight - width - lp.rightMargin; break; &#125; case Gravity.LEFT: default: childLeft = parentLeft + lp.leftMargin;&#125; Inflate解析过程 https://www.bilibili.com/video/BV1Ka4y1j7HA?p=4&amp;spm_id_from=pageDriver https://www.youtube.com/watch?v=aOb4Hvqbeu4","categories":[{"name":"VIEW","slug":"VIEW","permalink":"http://noteforme.github.io.com/categories/VIEW/"}],"tags":[],"keywords":[{"name":"VIEW","slug":"VIEW","permalink":"http://noteforme.github.io.com/categories/VIEW/"}]},{"title":"WMS","slug":"WMS","date":"2020-08-09T15:05:02.000Z","updated":"2021-08-19T11:11:44.282Z","comments":true,"path":"2020/08/09/WMS/","link":"","permalink":"http://noteforme.github.io.com/2020/08/09/WMS/","excerpt":"","text":"AMS启动activity Activity启动流程 window作用单一职责:解藕activity view View是生命周期哪个方法绘制 window负责管理UI,因为window是在 onCreate()之后产生的，所以view绘制一定在onCreate()之后。 onResume() decorview和Activity进行绑定，所以也是 onCreate()能在子线程刷新UI的原因 , 接着在 onResume()调用 performMeasure() performLayout(), performDraw() 1234textView = findViewById(R.id.tv_thread);new Handler().post(() -&gt; &#123; Log.i(&quot;GlideActivity&quot;, &quot;onResume: &quot; + textView.getWidth());&#125;); 运行结果 I/GlideActivity: onResume: 0 OnResume()也是一个消息，虽然post消息放在后面，但是是因为建立了消息屏障。所以还是先执行，然后获取宽度为0; https://www.bilibili.com/video/BV1FK4y1R7Nw?from=search&amp;seid=12068296586023469576","categories":[],"tags":[{"name":"AOSP","slug":"AOSP","permalink":"http://noteforme.github.io.com/tags/AOSP/"}],"keywords":[]},{"title":"PMS","slug":"PMS","date":"2020-08-07T14:05:02.000Z","updated":"2021-08-19T11:11:44.196Z","comments":true,"path":"2020/08/07/PMS/","link":"","permalink":"http://noteforme.github.io.com/2020/08/07/PMS/","excerpt":"","text":"PMS PMS服务是干什么的 管理 加载 缓存APK文件，把APK文件加载成package对象，缓存到mPackages中 当AMS需要加载Activity时，PMS提供对应的信息(javabean) PMS是谁启动的SystemServer PMS扫描是为了什么以空间换时间 PMS启动应用，会发生什么 通过包名，找到对应的apk文件 解压apk文件 经过dom解析，找到Launcher对应的activity 再反射加载 app启动成功。","categories":[],"tags":[{"name":"AOSP","slug":"AOSP","permalink":"http://noteforme.github.io.com/tags/AOSP/"}],"keywords":[]},{"title":"AMS","slug":"AMS","date":"2020-08-07T14:04:13.000Z","updated":"2021-08-19T11:11:43.480Z","comments":true,"path":"2020/08/07/AMS/","link":"","permalink":"http://noteforme.github.io.com/2020/08/07/AMS/","excerpt":"","text":"系统启动![](AMS/2021-07-31 at 7.53_start1.png) ​ AMSAMS属于SystemServer进程,主要是为了加载Activity 管理Activity生命周期 . Launcher请求AMS创建根Activity所在进程（如果之前没有该进程），AMS请求Zygote进程fork应用进程。 android启动流程 https://www.bilibili.com/video/BV1DQ4y197oX?from=search&amp;seid=14802265503756746151 https://www.bilibili.com/video/BV1Pi4y1A7Sr?from=search&amp;seid=17031756056912732811 一般 https://www.bilibili.com/video/BV1K541177GU?p=3 应用启动流程Launcher请求AMS阶段","categories":[],"tags":[{"name":"AOSP","slug":"AOSP","permalink":"http://noteforme.github.io.com/tags/AOSP/"}],"keywords":[]},{"title":"RxJava","slug":"RxJava","date":"2020-08-04T03:16:40.000Z","updated":"2021-08-19T11:11:44.218Z","comments":true,"path":"2020/08/04/RxJava/","link":"","permalink":"http://noteforme.github.io.com/2020/08/04/RxJava/","excerpt":"","text":"观察者模式观察者模式使用 最主要的是Observable里面持有observer引用，就可以给observer发消息，其他的都是拓展。 Rxjava2会有Flower等背压类继承ObservableSource，所以 Observable 从ObservableSource分离出来，让ObservableCreate实现subscribeAcutal(Observer) 本来可以在ObservableCreate中直接发消息，因为emmit也可能变，现在把调用流程放到了ObservableOnSubscribe,并且传了emmit,最终ObservableOnSubscribe打包给了了ObservableCreate 观察者模式应用12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 具体的被观察者 */public class ObservableCreate&lt;T&gt; extends Observable&lt;T&gt; &#123; ObservableOnSubscribe&lt;T&gt; source; public ObservableCreate(ObservableOnSubscribe&lt;T&gt; source) &#123; this.source = source; &#125; @Override protected void subscribeActual(Observer observer) &#123; observer.onSubscribe(); //订阅成功，回调给观察者 //创建发射器 CreateEmitter createEmitter = new CreateEmitter(observer); //发射器和观察者建立关联 source.subscribe(createEmitter); //发射器与被观察者建立关联 &#125; static final class CreateEmitter&lt;T&gt; implements Emitter&lt;T&gt; &#123; final Observer&lt;T&gt; observer; public CreateEmitter(Observer&lt;T&gt; observer) &#123; this.observer = observer; &#125; @Override public void onNext(T t) &#123; observer.onNext(t); &#125; @Override public void onError(Throwable e) &#123; observer.onError(e); &#125; @Override public void onComplete() &#123; observer.onComplete(); &#125; &#125;&#125; 装饰器模式装饰器模式使用RxJava观察者模式最主要是这个方法 subscribeActual(Observer observer) ，通过发射器与 观察者、被观察者建立关联，接着通过发射器发送事件给观察者。 !(RxJava/2021-07-12_RXJAVA.png) 红色方框中用到了 装饰器模式。 应用实例WriteRxJavaActivity.java 1234567891011121314151617181920212223242526272829Observable.create(new ObservableOnSubscribe&lt;Object&gt;() &#123; @Override public void subscribe(Emitter&lt;Object&gt; emitter) &#123; Log.i(TAG, &quot;subscribe: &quot;); emitter.onNext(&quot;aaaa&quot;); emitter.onNext(&quot;bbb&quot;); emitter.onNext(&quot;12312&quot;); emitter.onComplete(); &#125;&#125;) .map(new Function&lt;Object, Object&gt;() &#123; @Override public Object apply(Object o) &#123; return (&quot;apply 后 1 &quot; + o); &#125; &#125;) .map(new Function&lt;Object, Object&gt;() &#123; @Override public Object apply(Object o) &#123; return (&quot;apply 后 2 &quot; + o); &#125; &#125;) .subscribe(new Observer() &#123; @Override public void onNext(Object o) &#123; Log.i(TAG, &quot;onNext: &quot; + o); &#125; &#125;); 调用结构图上面代码的调用结构可以用下图表示 上面三条流，可以看到每一条流的结束会启动另一条流的开端。 N0持有source引用，自己又创建Observable,订阅了O4。 链式构建流 订阅流 观察者回调流（事件回调流） ObservableMap其中关键代码在ObservableMap.java ,subscribeActual方法。 Observalbe.java 123public &lt;R&gt; ObservableMap&lt;T, R&gt; map(Function&lt;T,R&gt; function)&#123; return new ObservableMap(this,function); //上层Observable传入 ObservableMap&#125; ObservableMap.java 123protected void subscribeActual(Observer observer) &#123; // source上层Observable, source.subscribe(new MapObserver(observer, function)); //传入的observer是下游的observer,可以从最后往前看&#125; 调用流程 第一遍 把 Observable传入下一层的Observable中。 可以理解为 调用结构图 -&gt;向右建立关联 直至调用到最后的观察者subscribe(new Observer())，开始把下一级的Observer传入Observable(被观察者)，可以理解为向左建立关联。 1，2完成后可以理解为建立双向链表，上游一直持有下游的Observer,开始发送emitter.onNext(“aaaa”);事件。 ​ 除了最后手动建立观察者，中间也建立了观察者，不停的向下发送事件。 ​ observable observer都在套娃。 ObservableFlatMap接收事件后，创建新的事件发送。 问题RxJava的subscribeOn只有第一次生效?​ subscribeOn对subscribe订阅进行处理，针对是订阅流，从后向前流动，所以最前面的一次生效。 RxJava的observeOn多次调用哪个有效?​ observeOn在事件发送的 onNext(T t)进行处理，针对的是观察者流，从前向后流动，所以最后一次生效。 匿名内部类和lambda区别[https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/2-Lambda%20and%20Anonymous%20Classes(II).md](https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/2-Lambda and Anonymous Classes(II).md) 匿名内部类仍然是一个类，只是不需要程序员显示指定类名，编译器会自动为该类取名。因此如果有如下形式的代码，编译之后将会产生两个class文件 Lambda表达式通过*invokedynamic*指令实现，书写Lambda表达式不会产生新的类 推论，this引用的意义 既然Lambda表达式不是内部类的简写，那么Lambda内部的this引用也就跟内部类对象没什么关系了。在Lambda表达式中this的意义跟在表达式外部完全一样。因此下列代码将输出两遍Hello Hoolee，而不是两个引用地址。 Java 函数式接口 java接口 只有一个方法 传统方法123456789101112private static void log(int level, String msg) &#123; if (level == 1) &#123; //如果不是1 msg已经拼接 所以造成浪费 System.out.println(msg); &#125;&#125;public static void main(String[] args) &#123; String msgA = &quot;Hello&quot;; String msgB = &quot;World&quot;; String msgC = &quot;Java&quot;; log(1, msgA + msgB + msgC);&#125; lambda1234567891011121314151617181920212223242526272829303132333435@FunctionalInterfaceinterface MessageBuilder &#123; String builderMessage();&#125;private static void showLog(int level, MessageBuilder msg) &#123; if (level == 1) &#123; System.out.println(msg.builderMessage()); &#125;&#125;public static void main(String[] args) &#123; String msgA = &quot;Hello&quot;; String msgB = &quot;World&quot;; String msgC = &quot;Java&quot;; showLog(1, () -&gt; msgA + msgB + msgC); //使用lambda表达式只是作为参数传递，仅仅吧参数传到showLog()中 //只有日志等级是1时 才会调用builderMessage 拼接字符串 showLog(1, () -&gt; &#123; System.out.println(&quot;1 是否执行&quot;); return msgA + msgB + msgC; &#125; ); showLog(2, () -&gt; &#123; System.out.println(&quot;2 是否执行&quot;); return msgA + msgB + msgC; &#125; );&#125; 这样看来 lambda: (左边是参数) -&gt; {右边是方法体} 方法体是 接口中唯一方法的实现 https://www.bilibili.com/video/BV1U4411V7Sv?p=5 RxJava操作符Consumer123456789101112131415@FunctionalInterfacepublic interface Consumer&lt;T&gt; &#123; /** * Performs this operation on the given argument. * * @param t the input argument */ void accept(T t); default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) &#123; Objects.requireNonNull(after); return (T t) -&gt; &#123; accept(t); after.accept(t); &#125;; &#125;&#125; accept123public static void method(String name,Consumer&lt;String&gt; con)&#123; con.accept(name);&#125; 123method(&quot;john&quot;,(String name)-&gt;&#123; System.out.println(name);&#125;); andThen示例1 123public static void method3(String s, Consumer1 con1, Consumer1 con2) &#123; con1.andThen3(con2).accept(s);&#125; 等价于 示例2 1234public static void method(String s, Consumer&lt;String&gt; con1, Consumer&lt;Double&gt; con2) &#123; con1.accept(s); con2.accept(Double.parseDouble(s));&#125; 12345method3(&quot;3.14&quot;, (t) -&gt; &#123; System.out.println(t + &quot;15926&quot;);&#125;, (t) -&gt; &#123; System.out.println(t + &quot;jj&quot;);&#125;); 一开始 纳闷 con1.andThen3(con2).accept(s); 为啥还调用一个accept(s) 自定义的Consumer1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@FunctionalInterfacepublic interface Consumer1 &#123; /** * Performs this operation on the given argument. * * @param t the input argument */ void accept(String t); default Consumer1 andThen(Consumer1 after) &#123; Objects.requireNonNull(after); return (String t) -&gt; &#123; accept(t); after.accept(t); &#125;; &#125; default Consumer1 andThen1(Consumer1 after) &#123; Objects.requireNonNull(after); return (String t) -&gt; &#123; accept(t); after.accept(t); &#125;; &#125; default Consumer1 andThen2(Consumer1 after) &#123; Objects.requireNonNull(after); return (String t) -&gt; &#123; accept(t); accept(t); after.accept(t); after.accept(t); &#125;; &#125; default Consumer1 andThen3(Consumer1 after) &#123; Consumer1 m = (String t) -&gt; &#123; System.out.println(&quot;接收参数 t : &quot;+t); after.accept(t); accept(t); &#125;; return m; &#125;&#125; 我的理解 ： 可以看 lambda 延迟调用的示例，当调用accept(s)方法 才开始调用方法体 &#123; accept(t); after.accept(t); &#125;的方法， 返回lambda,可以当作匿名内部类的语法糖, accept(s)当作匿名内部类的方法， s作为参数 传入到 (T t) -&gt; &#123; accept(t); after.accept(t); &#125; t中 通过下面这个示例可以验证 1234@FunctionalInterfaceinterface MessageBuilder1 &#123; String builderMessage(int param);&#125; 123456private static void showLog1(int level, MessageBuilder1 msg) &#123; if (level == 1) &#123; System.out.println(msg.builderMessage(5)); &#125;&#125; 1234showLog1(1, (t) -&gt; &#123; System.out.println(t); return msgA + msgB + msgC;&#125;); 输出 5HelloWorldJava Function1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package java.util.function;/** * Represents a function that accepts one argument and produces a result. * * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html&quot;&gt;functional interface&lt;/a&gt; * whose functional method is &#123;@link #apply(Object)&#125;. * * @param &lt;T&gt; the type of the input to the function * @param &lt;R&gt; the type of the result of the function * * @since 1.8 */@FunctionalInterfacepublic interface Function&lt;T, R&gt; &#123; /** * Applies this function to the given argument. * * @param t the function argument * @return the function result */ R apply(T t); /** * Returns a composed function that first applies the &#123;@code before&#125; * function to its input, and then applies this function to the result. * If evaluation of either function throws an exception, it is relayed to * the caller of the composed function. * * @param &lt;V&gt; the type of input to the &#123;@code before&#125; function, and to the * composed function * @param before the function to apply before this function is applied * @return a composed function that first applies the &#123;@code before&#125; * function and then applies this function * @throws NullPointerException if before is null * * @see #andThen(Function) */ default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) &#123; Objects.requireNonNull(before); return (V v) -&gt; apply(before.apply(v)); &#125; /** * Returns a composed function that first applies this function to * its input, and then applies the &#123;@code after&#125; function to the result. * If evaluation of either function throws an exception, it is relayed to * the caller of the composed function. * * @param &lt;V&gt; the type of output of the &#123;@code after&#125; function, and of the * composed function * @param after the function to apply after this function is applied * @return a composed function that first applies this function and then * applies the &#123;@code after&#125; function * @throws NullPointerException if after is null * * @see #compose(Function) */ default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) &#123; Objects.requireNonNull(after); return (T t) -&gt; after.apply(apply(t)); &#125; /** * Returns a function that always returns its input argument. * * @param &lt;T&gt; the type of the input and output objects to the function * @return a function that always returns its input argument */ static &lt;T&gt; Function&lt;T, T&gt; identity() &#123; return t -&gt; t; &#125;&#125; 1234public int compute(int a, Function&lt;Integer,Integer&gt; function)&#123; int reuslt = function.apply(a); // 相当于 2 * value 操作 return reuslt;&#125; 1234567FunctionTest functionTest = new FunctionTest();functionTest.compute(1,value-&gt;&#123;return 2 * value ;&#125;);Function&lt;Integer,Integer&gt; function = value -&gt; value *2;functionTest.compute(1,function);function.compose(function); RxJava 思考 https://gank.io/post/560e15be2dca930e00da1083#toc_31 https://juejin.im/post/6844903670203547656 https://juejin.im/post/6844903711416778765 https://www.jianshu.com/p/7fce2955f2db https://juejin.im/post/6844903838978146317","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"http://noteforme.github.io.com/tags/RxJava/"}],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"LifeCycle","slug":"LifeCycle","date":"2020-08-02T12:47:59.000Z","updated":"2021-08-19T11:11:44.124Z","comments":true,"path":"2020/08/02/LifeCycle/","link":"","permalink":"http://noteforme.github.io.com/2020/08/02/LifeCycle/","excerpt":"","text":"&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADLifeCycle应用 解藕页面与组件 解藕Service与组件 ProcessLifecycleOwner监听应用程序生命周期 解藕页面与组件123456789101112131415161718public class MyChronometer extends Chronometer implements LifecycleObserver &#123; private long elapseTime; public MyChronometer(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) private void startMeter() &#123; setBase(SystemClock.elapsedRealtime() - elapseTime); start(); &#125; @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE) private void stopMeter() &#123; elapseTime = SystemClock.elapsedRealtime() - getBase(); stop(); &#125;&#125; 12chronometer = (MyChronometer)findViewById(R.id.chronometer);getLifecycle().addObserver(chronometer); 解藕Service与组件======= d7906d4909f312e25743be4a4c56ad1539df1ea6","categories":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://noteforme.github.io.com/categories/Jetpack/"}],"tags":[],"keywords":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://noteforme.github.io.com/categories/Jetpack/"}]},{"title":"DesignPattern_Chain","slug":"DesignPattern-Chain","date":"2020-07-22T14:43:57.000Z","updated":"2021-09-13T01:37:21.160Z","comments":true,"path":"2020/07/22/DesignPattern-Chain/","link":"","permalink":"http://noteforme.github.io.com/2020/07/22/DesignPattern-Chain/","excerpt":"","text":"传统方案OA系统审批问题 职责链模式介绍 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连城一条链，并沿着这条传递该请求。直到有一个对象处理它为止。 ![2021-09-12_7.11.21_ class](DesignPattern-Chain/2021-09-12_7.11.21_ class.png) 大话示例chain of Responsibility Pattern 12345public class Request &#123; public String requestType; public String requestContent; public int number;&#125; 123456789101112131415public class CommonManager extends Manager &#123; public CommonManager(String name) &#123; super(name); &#125; @Override void requestApplications(Request request) &#123; if (&quot;请假&quot;.equals(request.requestType)&amp;&amp;request.number&lt;2)&#123; System.out.println(name+&quot; &quot;+ request.requestContent+ &quot; 数量 &quot;+ request.number+&quot; 被批准&quot;); &#125;else &#123; if (superior!=null) superior.requestApplications(request); &#125; &#125;&#125; 123456789101112131415public class MajorDomo extends Manager &#123; public MajorDomo(String name) &#123; super(name); &#125; @Override void requestApplications(Request request) &#123; if (&quot;请假&quot;.equals(request.requestType)&amp;&amp;request.number&lt;5)&#123; System.out.println(name+&quot; &quot;+ request.requestContent+ &quot; 数量 &quot;+ request.number+&quot; 被批准&quot;); &#125;else &#123; if (superior!=null) superior.requestApplications(request); &#125; &#125;&#125; 12345678910111213141516public class GeneralManager extends Manager &#123; public GeneralManager(String name) &#123; super(name); &#125; @Override void requestApplications(Request request) &#123; if (&quot;请假&quot;.equals(request.requestType) &amp;&amp; request.number &lt; 5) &#123; System.out.println(name + &quot; &quot; + request.requestContent + &quot; 数量 &quot; + request.number + &quot; 被批准&quot;); &#125; else if (&quot;加薪&quot;.equals(request.requestType) &amp;&amp; request.number &lt; 500) &#123; System.out.println(name + &quot; &quot; + request.requestContent + &quot; 数量 &quot; + request.number + &quot; 被批准&quot;); &#125;else if (&quot;加薪&quot;.equals(request.requestType) &amp;&amp; request.number &gt; 500) &#123; System.out.println(name + &quot; &quot; + request.requestContent + &quot; 数量 &quot; + request.number + &quot; 再说吧&quot;); &#125; &#125;&#125; 1234567891011121314151617181920CommonManager commonManager = new CommonManager(&quot;经理&quot;);MajorDomo majorDomo = new MajorDomo(&quot;总监&quot;);GeneralManager generalManager = new GeneralManager(&quot;总经理&quot;);commonManager.setSuperior(majorDomo);//设置上级majorDomo.setSuperior(generalManager);Request request = new Request();request.requestType = &quot;请假&quot;;request.number = 4;request.requestContent = &quot;去找小姐姐&quot;;commonManager.requestApplications(request);Request request1 = new Request();request1.requestType = &quot;加薪&quot;;request1.number = 888;request1.requestContent = &quot;给哥加薪&quot;;commonManager.requestApplications(request1); 责任链模式作用 https://www.bilibili.com/video/BV1G4411c7N4?p=149&amp;spm_id_from=pageDriver","categories":[{"name":"DesignPatterns","slug":"DesignPatterns","permalink":"http://noteforme.github.io.com/categories/DesignPatterns/"}],"tags":[],"keywords":[{"name":"DesignPatterns","slug":"DesignPatterns","permalink":"http://noteforme.github.io.com/categories/DesignPatterns/"}]},{"title":"Regular","slug":"Regular","date":"2020-07-20T09:07:08.000Z","updated":"2021-08-19T11:11:44.217Z","comments":true,"path":"2020/07/20/Regular/","link":"","permalink":"http://noteforme.github.io.com/2020/07/20/Regular/","excerpt":"","text":"https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md https://www.jb51.net/shouce/jquery1.82/regexp.html https://regexr.com/","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}],"tags":[],"keywords":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}]},{"title":"resume","slug":"resume","date":"2020-07-15T02:29:39.000Z","updated":"2021-08-20T03:06:20.543Z","comments":true,"path":"2020/07/15/resume/","link":"","permalink":"http://noteforme.github.io.com/2020/07/15/resume/","excerpt":"","text":"https://juejin.im/post/5e801a49e51d45470e2bc8bf https://wanandroid.com/blog/show/2754 https://mp.weixin.qq.com/s/AJ4QUqdYMeQWgWEQAFPsww https://juejin.im/post/6876968255597051917 APP模式 MVC MVP. MVVM:面试题 mvp与mvvm的区别，mvvm怎么更新UI 讲讲mvc,mvp模式，presenter内存泄漏的问题 代理模式与装饰模式的区别，手写一个静态代理，一个动态代理 MVP怎么处理内存泄漏 Mvp与Mvvm有什么区别? mvvm双向数据绑定的原理是怎样的？ViewModel 你在项目中有用到什么设计模式吗？ 单例模式有什么缺点？ 动画里面用到了什么设计模式？ OkHttp里面用到了什么设计模式？ 谈谈设计模式，你了解多少，运用了多少？ MVP Presenter 的作用类似于MVC中的Controller,但是其会反作用与View层，Model层的数据更新会被首先反馈到 Presenter,由Presenter优先处理并决定是否刷新以及刷新哪个View,也就是说Presenter完全将View层与Model层 隔离开，充当一个名副其实的中间人角色. MVVM MVVM则是思想的完全变革。它是将“数据模型数据双向绑定”的思想作为核心，因此在View和Model之间没有联系，通过ViewModel进行交互，而且Model和ViewModel之间的交互是双向的，因此视图的数据的变化会同时修改数据源，而数据源数据的变化也会立即反应到View上 缺点 1、过于简单的图形界面不适用，或说牛刀杀鸡。2、对于大型的图形应用程序，视图状态较多，ViewModel的构建和维护的成本都会比较高。3、数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的。 设计模式原则 设计模式六大原则1-单一职责原则 设计模式六大原则2-里氏替换原则 子类必须实现父类的抽象方法，但不得重写（覆盖）父类的非抽象（已实现）方法，里氏替换原则规定，子类不能覆写父类已实现的方法。父类中已实现的方法其实是一种已定好的规范和契约，如果我们随意的修改了它，那么可能会带来意想不到的错误。 子类完美继承父类的设计初衷，并做了增强 https://www.jianshu.com/p/cf9f3c7c0df5 设计模式六大原则3-依赖倒置原则 高层模块不应该依赖于底层模块，两者都应该依赖于抽象，抽象不应该依赖于细节，细节应该依赖于抽象 设计模式六大原则4-接口隔离原则 接口隔离原则:Clients should not be forced to depend upon interfaces that they do not use.与外部关系上只依赖需要的抽象 接口隔离原则的关键是接口以及这个接口要小，如何小呢，也就是我们要为专门的类创建专门的接口，这个接口只对它有效，不要试图让一个接口包罗万象，要建立最小的依赖关系 https://blog.csdn.net/dingshuo168/article/details/103531805 设计模式六大原则5-迪米特法则 减少依赖 Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers 一个类应该应该对其他类尽可能了解得最少；类只与直接的朋友通信等等。但是其最终目的只有一个，就是让类间解耦。 https://tianweili.github.io/2015/02/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/ 设计模式六大原则6-开闭原则 控制反转 在使用框架之后，整个程序的执行流程通过框架来控制。流程的控制权从程序员“反转”给了框架。 谈一谈自己对依赖、关联、聚合和组合之间区别的理解 http://blog.itpub.net/69952849/viewspace-2672009/ 设计模式之美迪米特法则的描述为：不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。 https://www.jianshu.com/p/35f76e87ac45 https://juejin.im/post/6844903591686176776 https://github.com/Meng997998/AndroidJX https://juejin.im/post/6864252499466354701 https://github.com/JsonChao/Awesome-Android-Interview https://juejin.im/post/6878902981400625160 并发单例为什么使用volatile修饰 https://juejin.im/post/6844903605292498958 http://static.kancloud.cn/alex_wsc/mianshi/1811436 https://mp.weixin.qq.com/s/eCotdGOWvSMki062eLjS8g https://mp.weixin.qq.com/s/7DvReHYugl1KClKFGBwSfg 平常有用到什么锁，synchronized底层原理是什么 锁之间的区别 线程间同步的方法 阿里编程规范不建议使用线程池，为什么？ RXJava怎么切换线程 平常有用到什么锁，synchronized底层原理是什么 简单描述下Handler,Handler是怎么切换线程的,Handler同步屏障 synchronized是公平锁还是非公平锁,ReteranLock是公平锁吗？是怎么实现的 线程间同步的方法 锁之间的区别 OkHttp怎么实现连接池 如果让你来实现一个网络框架，你会考虑什么 说说你对volatile字段有什么用途？ 四种线程池原理？ 怎么中止一个线程，Thread.Interupt一定有效吗？ 如何让两个线程循环交替打印 线程池了解多少？拒绝策略有几种,为什么有newSingleThread okhttp线程使用方式 RXJava RXJava怎么切换线程 Rxjava自定义操作符 JVMhttps://juejin.im/post/6875638406165037063 设计模式之美 25 26 39. 40代码没什么了解 Hashmap 注解作用路线图 注解","categories":[],"tags":[{"name":"inter","slug":"inter","permalink":"http://noteforme.github.io.com/tags/inter/"}],"keywords":[]},{"title":"DesignPattern_Decorator","slug":"DesignPattern-Decorator","date":"2020-07-12T04:37:59.000Z","updated":"2021-08-19T11:11:43.800Z","comments":true,"path":"2020/07/12/DesignPattern-Decorator/","link":"","permalink":"http://noteforme.github.io.com/2020/07/12/DesignPattern-Decorator/","excerpt":"","text":"装饰器模式 应用场景: 拓展一个类的功能或给一个类添加附加职责. 优点: 不改变原有对象的情况下给一个对象拓展功能 使用不同的组合实现不同的效果 符合开闭原则 1234567891011121314151617181920212223242526272829interface Component&#123; void operation();&#125;// 具体类class ConcreteComponent implements Component&#123; @Override public void operation() &#123; System.out.println(&quot;拍照&quot;); &#125;&#125;//对具体类的拓展class ConcreteComponent1 implements Component &#123; private Component component; public ConcreteComponent1(Component component) &#123; this.component = component; &#125; @Override public void operation() &#123; System.out.println(&quot;美颜&quot;); component.operation(); &#125;&#125;//测试new ConcreteComponent1(new ConcreteComponent()).operation(); 也可以把装饰器抽象出来 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354interface Component&#123; void operation();&#125;// 具体类class ConcreateComponent implements Component&#123; @Override public void operation() &#123; System.out.println(&quot;拍照&quot;); &#125;&#125;abstract class Decorator implements Component&#123; Component component; public Decorator(Component component) &#123; this.component = component; &#125; @Override public void operation() &#123; component.operation(); &#125;&#125;//对具体类的拓展class ConcreateComponent1 extends Decorator&#123; public ConcreateComponent1(Component component) &#123; super(component); &#125; @Override public void operation() &#123; System.out.println(&quot;美颜&quot;); super.operation(); &#125;&#125;class ConcreateComponent2 extends Decorator&#123; public ConcreateComponent2(Component component) &#123; super(component); &#125; @Override public void operation() &#123; System.out.println(&quot;呵呵&quot;); super.operation(); &#125;&#125;//测试 ConcreateComponent2 concreateComponent1 = new ConcreateComponent2(new ConcreateComponent1(new ConcreateComponent())); concreateComponent1.operation(); https://www.bilibili.com/video/BV1hp4y1D7MP?from=search&amp;seid=6785978722248254154 https://www.bilibili.com/video/BV1Hv411r7uN?p=2","categories":[{"name":"DesignPatterns","slug":"DesignPatterns","permalink":"http://noteforme.github.io.com/categories/DesignPatterns/"}],"tags":[],"keywords":[{"name":"DesignPatterns","slug":"DesignPatterns","permalink":"http://noteforme.github.io.com/categories/DesignPatterns/"}]},{"title":"LiveData","slug":"LiveData","date":"2020-06-15T03:20:42.000Z","updated":"2021-08-19T11:11:44.127Z","comments":true,"path":"2020/06/15/LiveData/","link":"","permalink":"http://noteforme.github.io.com/2020/06/15/LiveData/","excerpt":"","text":"优势 确保界面符合数据状态 不会发生内存泄漏 不会因Activity停止而导致崩溃 不再需要手动处理生命周期 数据始终保持最新状态 适当的配置更改 共享资源 livedata和viewmodel关系viewmodel中的数据发生变化时通知页面 LiveData原理注册观察者 1234567891011121314151617public void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;? super T&gt; observer) &#123; assertMainThread(&quot;observe&quot;); if (owner.getLifecycle().getCurrentState() == DESTROYED) &#123; // ignore return; &#125; LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer); ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper); if (existing != null &amp;&amp; !existing.isAttachedTo(owner)) &#123; throw new IllegalArgumentException(&quot;Cannot add the same observer&quot; + &quot; with different lifecycles&quot;); &#125; if (existing != null) &#123; return; &#125; owner.getLifecycle().addObserver(wrapper); //在这里注册 &#125; 给观察者发送消息 1234567891011121314151617181920212223void dispatchingValue(@Nullable ObserverWrapper initiator) &#123; if (mDispatchingValue) &#123; mDispatchInvalidated = true; return; &#125; mDispatchingValue = true; do &#123; mDispatchInvalidated = false; if (initiator != null) &#123; considerNotify(initiator); initiator = null; &#125; else &#123; for (Iterator&lt;Map.Entry&lt;Observer&lt;? super T&gt;, ObserverWrapper&gt;&gt; iterator = mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123; //遍历观察者，给观察者发送消息 considerNotify(iterator.next().getValue()); if (mDispatchInvalidated) &#123; break; &#125; &#125; &#125; &#125; while (mDispatchInvalidated); mDispatchingValue = false;&#125; 数据粘性经过了解和使用 view model,databiding后，我觉得这个不是官方留的坑，在特定的场景可能还需要这样做，我获取手环睡眠数据此时有其他fragment还没创建，我就需要创建后才就监听到数据。 方法1我们能不能再创建新的ObserverWrapper的时候，直接把mVersion的值赋给mLastVersion，这样就符合(observer.mLastVersion &gt;= mVersion)这一条件了，就不会再继续执行onChanged方法了 https://blog.csdn.net/geyuecang/article/details/89028283 方法2 singleLiveEvent 其实这个方法解决的并不是粘性事件的问题，而是“数据倒灌”的问题。“数据倒灌”一词出自KunMinX的Blog重学安卓：LiveData 数据倒灌 背景缘由全貌 独家解析,即在setValue后,observe对此次set的value值会进行多次消费。比如进行第二次observe的时候获取到的数据是第一次的旧数据。这样会带来不可预期的后果。 方法三UnPeekLiveData 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class ProtectedUnPeekLiveData&lt;T&gt; extends LiveData&lt;T&gt; &#123; protected boolean isAllowNullValue; private final HashMap&lt;Integer, Boolean&gt; observers = new HashMap&lt;&gt;(); public void observeInActivity(@NonNull AppCompatActivity activity, @NonNull Observer&lt;? super T&gt; observer) &#123; LifecycleOwner owner = activity; Integer storeId = System.identityHashCode(observer);//源码这里是activity.getViewModelStore()，是为了保证同一个ViewModel环境下&quot;唯一可信源&quot; observe(storeId, owner, observer); &#125; private void observe(@NonNull Integer storeId, @NonNull LifecycleOwner owner, @NonNull Observer&lt;? super T&gt; observer) &#123; if (observers.get(storeId) == null) &#123; observers.put(storeId, true); &#125; super.observe(owner, t -&gt; &#123; if (!observers.get(storeId)) &#123; observers.put(storeId, true); if (t != null || isAllowNullValue) &#123; observer.onChanged(t); &#125; &#125; &#125;); &#125; @Override protected void setValue(T value) &#123; if (value != null || isAllowNullValue) &#123; for (Map.Entry&lt;Integer, Boolean&gt; entry : observers.entrySet()) &#123; entry.setValue(false); &#125; super.setValue(value); &#125; &#125; protected void clear() &#123; super.setValue(null); &#125;&#125; ，为每个传入的observer对象携带一个布尔类型的值，作为其是否能进入observe方法的开关。每当有一个新的observer存进来的时候，开关默认关闭。 每次setValue后，打开所有Observer的开关，允许所有observe执行。 这个确实清晰，简单 https://www.jianshu.com/p/d0244c4c7cc9 https://juejin.cn/post/6844903623252508685 UnPeekLiveData 或者 ELiveData https://www.ershicimi.com/p/2f57df7148300017e8a0f7227720a2e8 https://juejin.im/post/5b2b1b2cf265da5952314b63 https://www.jianshu.com/p/79d909b6f8bd https://juejin.im/post/6892704779781275662 https://www.jianshu.com/p/d0244c4c7cc9","categories":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://noteforme.github.io.com/categories/Jetpack/"}],"tags":[],"keywords":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://noteforme.github.io.com/categories/Jetpack/"}]},{"title":"THINKING","slug":"THINKING","date":"2020-05-19T01:55:11.000Z","updated":"2021-08-19T11:11:44.239Z","comments":true,"path":"2020/05/19/THINKING/","link":"","permalink":"http://noteforme.github.io.com/2020/05/19/THINKING/","excerpt":"","text":"https://juejin.im/post/5eb168e9f265da7bb65fb27a https://www.mifengtd.cn/articles/runningcheese-gtd-system.html https://github.com/JsonChao/Awesome-Android-Notebook I don’t know what to do if I prevent me think code or tech in my life. I think i love tech ,but it could’t support my career now.I l’m look forword is that what I can do . CodeReview","categories":[{"name":"TOOL","slug":"TOOL","permalink":"http://noteforme.github.io.com/categories/TOOL/"}],"tags":[{"name":"THINK","slug":"THINK","permalink":"http://noteforme.github.io.com/tags/THINK/"}],"keywords":[{"name":"TOOL","slug":"TOOL","permalink":"http://noteforme.github.io.com/categories/TOOL/"}]},{"title":"ActivityLayout","slug":"ActivityLayout","date":"2020-05-08T01:54:32.000Z","updated":"2021-08-19T11:11:43.525Z","comments":true,"path":"2020/05/08/ActivityLayout/","link":"","permalink":"http://noteforme.github.io.com/2020/05/08/ActivityLayout/","excerpt":"","text":"https://mp.weixin.qq.com/s/ii07I8Cy80MqjsqKkns_WQ https://www.jianshu.com/p/b5b1b8e1747f","categories":[],"tags":[{"name":"AOSP","slug":"AOSP","permalink":"http://noteforme.github.io.com/tags/AOSP/"}],"keywords":[]},{"title":"DataStructure","slug":"DataStructure","date":"2020-05-06T01:46:22.000Z","updated":"2021-08-19T11:11:43.790Z","comments":true,"path":"2020/05/06/DataStructure/","link":"","permalink":"http://noteforme.github.io.com/2020/05/06/DataStructure/","excerpt":"","text":"无论什么难题，降低复杂度的方法就是这三个步骤。只要你能深入理解这里的核心思想，就能把问题迎刃而解。 第一步，暴力解法。在没有任何时间、空间约束下，完成代码任务的开发。 第二步，无效操作处理。将代码中的无效计算、无效存储剔除，降低时间或空间复杂度。 第三步，时空转换。设计合理数据结构，完成时间复杂度向空间复杂度的转移。 既然说这是这门专栏的总纲，那么很显然后续的学习都是在这个总纲体系的框架中。第一步的暴力解法没有太多的套路，只要围绕你面临的问题出发，大胆发挥想象去尝试解决即可。第二步的无效操作处理中，你需要学会并掌握递归、二分法、排序算法、动态规划等常用的算法思维。第三步的时空转换，你需要对数据的操作进行细分，全面掌握常见数据结构的基础知识。再围绕问题，有针对性的设计数据结构、采用合理的算法思维，去不断完成时空转移，降低时间复杂度。 https://github.com/labuladong/fucking-algorithm 复杂度 消耗计算时间和计算空间 时间复杂度 对数阶 1234int count =1;while(count &lt; n)&#123; count = count * 2;&#125; 代码看到 2 * 2 * 2 … 最终离n很近，最终退出循环，2^x =n ,得到 x = log2^n,所以这个循环时间复杂度为O(logn) 空间复杂度空间方面主要体现在计算过程中,对于存储资源的消耗情况 ![](DataStructure/Screen Shot 2021-03-12 at 5.37.58 PM.png) ![](DataStructure/Screen Shot 2021-03-12 at 5.38.08 PM.png) 链表​ p,q指向的都是整体 1234567891011121314typedef struct node&#123; int data; // 存储数据本身 struct node *pNext; //pNext存储 它指向的下一个节点的指针&#125; NODE, *PNODE;// NODE等价于struct node//PNODE等价于struct node*//将动态分配的新节点的地址赋给pPNODE p = (PNODE)malloc(sizeof(NODE));free(p) //删除p指向节点所占的内存，不是删除p本身所占的内存p-&gt;pNext; //p所指向结构体变量中pNext成员本身 插入q节点 12345方法1:r = p-&gt; pNext ; p-&gt;pNext =q ; q-&gt;pNext = r;方法2:q-&gt;pNext = p-&gt;pNext;p-&gt;pNext = q; 删除p后面的节点 123r = p-&gt;pNext;p-&gt;pNext= r-&gt;pNext;free(r); 双向链表插入 123456ListNodePosi &lt;T&gt; insertAsPred(T const&amp;e)&#123;//紧靠当前节点之前插入新节点 ListNodePosi&lt;T&gt; x = new ListNode(e,pred,this); //创建新节点 pred-&gt;succ = x; this-&gt;pred= x;//设置正向链接,这里是当前节点的前置节点的意思，容易和节点pred混淆 return x; //返回新节点的位置&#125; 递归 递归必须得有一个明确的中止条件。 该函数所处理的数据规模必须在递减。 递归复杂度递归跟踪(recursion trace)分析1234sum(int A[],int n)&#123; return (n&lt;1)? 0:sum(A,n-1)+A[n-1]&#125; 检查每个递归实例，累计所需的时间(调用语句本身，计入对应的子实例) 其总和即算法执行时间 本例中，单个递归实例自身只需o(1)时间 T(n) = o(1) * (n+1) = o(n) 递归方程求解sum(A,n) : 递归求解规模为n-1的问题sum(A,n-1) 加上 A[n-1] 。 ​ T(n) = T(n-1) + o(1) // 为了求解T(n)所需要的时间,花了T(n-1)的时间求解n-1的问题,然后再花了o(1)的时间 ​ T(0) = o(1) T(n) = T(n-1) + o(1) //两边同时 -n T(n) -n = T(n-1) -(n-1) ​ = … ​ =T(2) - 2 ​ = T(1) -1 ​ =T(0) T(n) = o(1) +n = o(n) 递归实例阶乘 、求和12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;long f(int n);long sum(int n);int main(void) &#123; printf(&quot;n=1 输出 %ld \\n &quot;, f(1)); printf(&quot;n=2 输出 %ld \\n &quot;, f(2)); printf(&quot;n=3 输出 %ld \\n &quot;, f(3)); printf(&quot;n=4 输出 %ld \\n &quot;, f(4)); printf(&quot;n=5 输出 %ld \\n &quot;, f(5)); printf(&quot;n=100 相加 %ld \\n &quot;, sum(100)); int val,mult = 1; printf(&quot;请输入一个数: val=&quot;); scanf(&quot;%d&quot;,&amp;val); for (int i = 1; i &lt;= val; ++i) &#123; mult = mult * i; &#125; printf(&quot;%d的阶乘是: %d\\n&quot;,val,mult);&#125;//假定n的值是1或大于1的值long f(int n) &#123; if (n == 1) &#123; return 1; &#125; else &#123; return n * f(n - 1); &#125;&#125;// 1+2+...+100long sum(int n) &#123; if (n == 1) &#123; return 1; &#125; else &#123; return (n + sum(n-1)); &#125;&#125; 汉诺塔123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;void hannuota(int n, char a, char b, char c) &#123; /** * 一个盘子 : * 直接将a柱子上的盘子从a移动到b * 否则 : * 先将a柱子上的n-1个盘子借助c移到b * 直接将a柱子上的盘中从a移到c * 最后将b柱子上的n-1个盘子借助a移到c */ if (1 == n) &#123; printf(&quot;将编号为%d的盘子直接从%c柱子移到%c柱子\\n&quot;, n, a, c); &#125; else &#123; hannuota(n - 1, a, c, b); printf(&quot;将编号为%d的盘子直接从%c柱子移到%c柱子\\n&quot;, n, a, c); hannuota(n - 1, b, a, c); &#125;&#125;int main(void) &#123; char ch1 = &#x27;A&#x27;; char ch2 = &#x27;B&#x27;; char ch3 = &#x27;C&#x27;; printf(&quot;请输入要移动盘子的个数:&quot;); int n; scanf(&quot;%d&quot;,&amp;n); hannuota(n,&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;); return 0;&#125; Fibonacci.c12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;int f(int n)&#123; if(n==0)&#123; return 0; &#125; else if(n==1)&#123; return 1; &#125; else&#123; return f(n-1)+f(n-2); &#125;&#125;int main()&#123; int n; printf(&quot;输入n的值为 &quot;); while (true)&#123; scanf(&quot;%d&quot;,&amp;n); printf(&quot;f(n) %d \\n&quot;,f(n)); &#125;&#125; 上面这种求和方式，随着n增加，时间复杂度会指数型增加，到了40已经算不动了，里面会有大量重复的计算 123456789int f(int n) &#123; int f = 0; int g = 1; while (n--)&#123; g = g+f; f = g-f; &#125; return g;&#125; 这种时间复杂度O(n),不要太快,交替滚动向前推进。 Hash(散列)[Hash(key) + 1^2] % M 以平方数为距离，确定下一试探桶单元 M为三列表的容量","categories":[{"name":"DataStructure","slug":"DataStructure","permalink":"http://noteforme.github.io.com/categories/DataStructure/"}],"tags":[{"name":"DataStructure","slug":"DataStructure","permalink":"http://noteforme.github.io.com/tags/DataStructure/"}],"keywords":[{"name":"DataStructure","slug":"DataStructure","permalink":"http://noteforme.github.io.com/categories/DataStructure/"}]},{"title":"DeliverValue","slug":"DeliverValue","date":"2020-04-28T02:20:55.000Z","updated":"2021-08-19T11:11:43.800Z","comments":true,"path":"2020/04/28/DeliverValue/","link":"","permalink":"http://noteforme.github.io.com/2020/04/28/DeliverValue/","excerpt":"","text":"Value Copyhttps://blog.csdn.net/huaiyiheyuan/article/details/55102057 https://mp.weixin.qq.com/s/lP-xB5yzpvqVEiA439euVQ https://juejin.im/post/5e91cc6c51882573a343db03 基本数据类型 declare in stack Object declare in Heap Java value deliver https://juejin.im/post/5af3a44bf265da0b74522bf3 1234String name = &quot;hollischuang&quot;;String name = new String(&quot;hollischuang&quot;);","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}],"tags":[],"keywords":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}]},{"title":"Bluetooth04","slug":"Bluetooth04","date":"2020-04-26T02:46:23.000Z","updated":"2021-08-19T11:11:43.750Z","comments":true,"path":"2020/04/26/Bluetooth04/","link":"","permalink":"http://noteforme.github.io.com/2020/04/26/Bluetooth04/","excerpt":"","text":"蓝牙问题汇总https://race604.com/android-ble-in-action/ 连接断开之后可以根据实际情况进行重连，但如果是连接失败的情况，建议不要立即重连，而是调用void closeBluetoothGatt()清空一下状态，并延迟一段时间等待复位，否则会把gatt阻塞，导致手机不重启蓝牙就再也无法连接任何设备的严重情况。 https://github.com/Jasonchenlijian/FastBle/blob/master/README_1.2.x.md 每当设备断开连接时，请确保在BluetoothGatt对象上调用close()并将其设置为null, 解决方法:始终在断开连接时关闭gatt实例，并在每次连接时创建一个新的gatt实例。 在onLeScan(..)中启动一个新线程，然后进行连接 https://stackoom.com/question/1Cyqr/Android-%E8%93%9D%E7%89%99%E4%BD%8E%E5%8A%9F%E8%80%97%E4%B8%8D%E7%A8%B3%E5%AE%9A BluetoothLeScanner: could not find callback wrapper 连接失败处理 分两个平台来说，iOS端也有连接失败的委托，但是好像几乎不会发生这种情况，至少我从来没遇见过，而对于同款设备，android常常会出现连接失败的情况，status != BluetoothGatt.GATT_SUCCESS ，android端开发请不要把连接失败和断开连接放在一块处理，因为断开连接可以直接尝试重新连接，而连接失败后尝试重新连接，需要加一些延时，并且需要gatt.close，清空一下状态，否则会把gatt阻塞导致手机不重启蓝牙就再也无法连接任何设备的情况。 http://liuyanwei.jumppo.com/2017/01/23/zhihu-live-a-hour-for-bluetooth-0.html 扫描广播包 所有外设，只有在发出广播包的情况下，才能被central发现，绝大多数情况下，外设被连接后就不会发出广播（也有例外），很多人遇到无法找到设备的问题，大多属于这种情况。 重复扫描问题—————— http://liuyanwei.jumppo.com/2017/01/23/zhihu-live-a-hour-for-bluetooth-0.html Android 7+ will stop scanning if it continues without stopping at all for 30 minutes or more. This was added as a feature to prevent battery drain in case developers had inadvertently or abusively left scanning on forever. https://github.com/AltBeacon/android-beacon-library/issues/528 https://blog.csdn.net/m0_37796683/article/details/83657204 status 133 https://blog.csdn.net/baidu_26352053/article/details/54571688 unregisterApp() - mClientIf=5 filter https://juejin.im/post/5d37d4d6f265da1bc414958a 防止Android7中的BLE扫描滥用，从而做了一些限制，即不要在30s内对蓝牙扫描重复开启-关闭超过5次。 https://blog.classycode.com/undocumented-android-7-ble-behavior-changes-d1a9bd87d983 蓝牙添加扫描间隔 ​ https://github.com/haodynasty/AndroidBleManager ​ https://github.com/AltBeacon/android-beacon-library 应用如何做自动重连其实自动重连比想象的要简单许多，无论是android还是ios端，只需要在设备断开连接的委托方法中，重新调用gatt.connet或者是centralManager.connet方法就可以了，无论当时设备是否有点，是否在周围，当设备再次开会或者连接到可连接范围内，都会自动被连上，就是这么简单。 http://liuyanwei.jumppo.com/2017/01/23/zhihu-live-a-hour-for-bluetooth-0.html Intent mIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);startActivityForResult(mIntent, 1); 12mBluetoothAdapter.enable();mBluetoothAdapter.disable(); https://blog.csdn.net/u014418171/article/details/81219297 扫描 过滤 Scanning by device name Looking for a device by it’s name has 2 main use cases: to look for 1 specific device or to look for 1 specific device model. For example, my Polar H7 chest strap advertises itself as “Polar H7 391BB014”. The latter part (‘391BB014’) is a unique number (or serial number) and the first part is generic for all Polar H7 devices. This is very common practice. Unfortunately the device name scan filter can only be used to find specific devices as it does full string matching. If you want to find all Polar H7 devices you will need to do a ‘substring’ compare on ‘Polar H7’, but you can’t do that with a filter. You just need to pass null as the filter and do the substring comparison yourself in onScanResult. So here is an example of how to scan for devices by exact name 123456789101112String[] names = new String[]&#123;&quot;Polar H7 391BB014&quot;&#125;;List&lt;ScanFilter&gt; filters = null;if(names != null) &#123; filters = new ArrayList&lt;&gt;(); for (String name : names) &#123; ScanFilter filter = new ScanFilter.Builder() .setDeviceName(name) .build(); filters.add(filter); &#125;&#125;scanner.startScan(filters, scanSettings, scanCallback); https://medium.com/@martijn.van.welie/making-android-ble-work-part-1-a736dcd53b02 android蓝牙自动连接 http://www.cocoachina.com/articles/83844 Ble libraryAndroid-BLE-Library 123LoggableBleManager public void log(final int priority, @NonNull final String message)是日志打印出口是 BleManager public void log(final int priority, @NonNull final String message)的实现 nRF-Logger-API是手机日志查看工具 12345678910111213141516171819202122232425262728293031public abstract class LoggableBleManager&lt;T extends BleManagerCallbacks&gt; extends BleManager&lt;T&gt; &#123; private ILogSession logSession; /** * The manager constructor. * &lt;p&gt; * After constructing the manager, the callbacks object must be set with * &#123;@link #setManagerCallbacks(BleManagerCallbacks)&#125;. * * @param context the context. */ public LoggableBleManager(@NonNull final Context context) &#123; super(context); &#125; /** * Sets the log session to log into. * * @param session nRF Logger log session to log inti, or null, if nRF Logger is not installed. */ public void setLogger(@Nullable final ILogSession session) &#123; logSession = session; &#125; @Override public void log(final int priority, @NonNull final String message) &#123; Logger.log(logSession, LogContract.Log.Level.fromPriority(priority), message); Log.println(priority, &quot;BleManager&quot;, message);// Timber.i(&quot;BleManager &quot;+ message); &#125;&#125;","categories":[{"name":"BLE","slug":"BLE","permalink":"http://noteforme.github.io.com/categories/BLE/"}],"tags":[],"keywords":[{"name":"BLE","slug":"BLE","permalink":"http://noteforme.github.io.com/categories/BLE/"}]},{"title":"annotation","slug":"annotation","date":"2020-04-25T14:38:39.000Z","updated":"2021-09-08T02:44:16.645Z","comments":true,"path":"2020/04/25/annotation/","link":"","permalink":"http://noteforme.github.io.com/2020/04/25/annotation/","excerpt":"","text":"注解注解的作用 https://blog.csdn.net/briblue/article/details/73824058 提供信息给编译器： 编译器可以利用注解来探测错误和警告信息 编译阶段时的处理： 软件工具可以用来利用注解信息来生成代码、Html文档或者做其它相应处理。 运行时的处理： 某些注解可以在程序运行的时候接受代码的提取 元注解 ： 不可以再分的注解， 负责注解其他注解。java定义了4个标准的meta-annotation类型,它们被用来提供对其它annotation类型作说明。Target Retention Documented Inherited ​ 如上图的 Overide被@Target和@Retention修饰，他们用来说明解释其他注解，位于 java.lang.annotation下 元注解类型Target用于描述注解的使用范围(注解可以用在什么地方) 如 类 属性 方法等 Retention需要什么级别保存该注释信息，用于保留注解的生命周期 @Inherited标明所修饰的注解，在所作用的类上，是否可以被继承。 @Documentedjavadoc的工具文档化 注解使用123public @interface Sxt&#123; String studentName(); // studentName 参数名， String参数类型&#125; 注解元素必须要有值，我们定义注解元素时，经常使用空字符串，0作为默认值。 也经常使用负数(比如:-1)表示不存在的含义 annotation01 123456789@Target(value = &#123;ElementType.METHOD,ElementType.TYPE&#125;) //针对方法 和类有效@Retention(RetentionPolicy.RUNTIME) // 针对运行时有效public @interface Annotation01 &#123; String studentName() default &quot;&quot;; int age() default 0; int id() default -1; // String indexOf(&quot;abc&quot;) -1 String[] schools() default &#123;&quot;清华大学&quot;,&quot;哈工大&quot;&#125;;&#125; Annotation02 12345@Target(value = &#123;ElementType.METHOD,ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface Annotation02 &#123; String value();&#125; 如果只有一个参数，一般写成value Demo01 1234567891011121314@Annotation01public class Demo02 &#123; @Annotation01(age = 19, studentName = &quot;老高&quot;, id = 1001, schools = &#123;&quot;哈工大&quot;, &quot;清华大学&quot;&#125;) public void test() &#123; &#125; @Annotation02(value = &quot;aaaa&quot;) public void test01() &#123; &#125; @Annotation02(&quot;aaaa&quot;) public void test02() &#123; &#125;&#125; 使用注解,参照 test01(),也可以省略”value=” 参见test02() 注解实例注解设置 SxtStudent信息，映射数据库 12345@Target(value = &#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface SxtTable &#123; String value();&#125; 1234567@Target(value = &#123;ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface SxtField &#123; String columnName(); String type(); int length();&#125; 1234567891011@SxtTable(&quot;tb_student&quot;)public class SxtStudent &#123; @SxtField(columnName = &quot;id&quot;,type = &quot;int&quot;,length = 10) private int id; @SxtField(columnName = &quot;sname&quot;,type = &quot;varchar&quot;,length = 10) private String studentName; @SxtField(columnName = &quot;age&quot;,type = &quot;int&quot;,length = 3) private int age;&#125; 通过第三方工具获取注解信息 12345678910111213141516171819202122try &#123; Class clazz = Class.forName(&quot;annotation.SxtStudent&quot;); //获得类的所有有效注解 Annotation[] annotations = clazz.getAnnotations(); for (Annotation a:annotations)&#123; System.out.println(a); &#125; //获得类的指定注解 SxtTable st = (SxtTable)clazz.getAnnotation(SxtTable.class); System.out.println(st.value()); //获得类的属性的注解 Field f = clazz.getDeclaredField(&quot;studentName&quot;); SxtField sxtField = f.getAnnotation(SxtField.class); System.out.println(sxtField.columnName()+&quot;--&quot; + sxtField.type()+&quot;---&quot; + sxtField.length());&#125; catch (ClassNotFoundException e) &#123; e.printStackTrace();&#125; catch (NoSuchFieldException e) &#123; e.printStackTrace();&#125; 运行结果 @annotation.SxtTable(value=tb_student)tb_studentsname–varchar—10 反射实例1234567891011121314151617181920String path = &quot;reflection.User&quot;;try &#123; Class&lt;?&gt; clazz = Class.forName(path); //对象是表示或封装一些数据。一个类被加载后，JVM会创建一个对应该类的Class对象，类的整个结构信息会放到对应的CLass对象中。 //这个Class对象就像一面镜子一样，通过这面镜子我可已看到对应类的全部信息。 System.out.println(clazz.hashCode()); Class clazz2 = Class.forName(path); // 一个类对应的一个class对象 System.out.println(clazz2.hashCode()); Class intCLazz = int.class; int[] arr01 = new int[10]; int[][] arr02 = new int[30][3]; int[]arr03 = new int[30]; double[] arr04 = new double[10]; System.out.println(arr01.getClass().hashCode()); System.out.println(arr02.getClass().hashCode()); System.out.println(arr03.getClass().hashCode()); System.out.println(arr04.getClass().hashCode()); https://www.youtube.com/watch?v=vZe5zG0vh3U&amp;list=PLC664nq_h8b9Jzh-qYJ_AeOpmSoBLC_tg&amp;index=1 注解处理器是javac处理注解的一种工具，它用来在编译时扫描和处理注解。简单来说就是在编译器，通过注解采集信息，生成.java文件。减少重复代码的编写。 APT原理 步骤 问题APT就这固定的几步，网上demo可以生成，我的就是没法生成，原来是因为,@DIActivity类的头部没有设置 123@DIActivitypublic class MainActivity extends AppCompatActivity &#123;&#125; 项目 MRouter Arouter原理获得当前程序在手机中对应的apk文件,使用classsloader:dexfile(PMS)，反射获取apk所有的类，筛选出注册activity的类。初始化 核心实现 https://www.bilibili.com/video/BV1uV411n787?p=6&amp;spm_id_from=pageDriver https://www.bilibili.com/video/BV1Ly4y1W7f5?p=6&amp;spm_id_from=pageDriver https://www.bilibili.com/video/BV1nU4y1a79o?from=search&amp;seid=3188418579827888379 https://juejin.cn/post/6925283352698159117#heading-14 https://juejin.cn/post/6947992544252788767 https://blog.csdn.net/xx326664162/article/details/68490059 https://hanshuliang.blog.csdn.net/article/details/117072224 https://github.com/han1202012/APT 反射机制Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象都能够调用它的任意一个方法；这种动态获取的信息以及动态调用对象的方法的功能称为java的反射机制。 基本使用123456package reflection;public class MethodReflect &#123; public int addResult(int addNum) &#123; return addNum; &#125;&#125; 1234567891011121314151617181920212223242526//使用反射第一步:获取操作类MethodDemoFieldDemo所对应的Class对象Class &lt; ?&gt;cls = Class.forName(&quot;reflection.MethodReflect&quot;);//使用MethodDemo类的class对象生成 实例Object obj = cls.newInstance();//获取public int addResult(int addNum)方法Method addMethod = cls.getMethod(&quot;addResult&quot;, new Class[] &#123; int.class&#125;);System.out.println(&quot;修饰符: &quot; + Modifier.toString(addMethod.getModifiers()));System.out.println(&quot;返回值: &quot; + addMethod.getReturnType());System.out.println(&quot;方法名称: &quot; + addMethod.getName());System.out.println(&quot;参数列表: &quot; + addMethod.getParameterTypes());int result = (int) addMethod.invoke(obj, 2);System.out.println(&quot;调用addResult后的运行结果:&quot; + result);System.out.println(&quot;--------------------------------&quot;);//获取public String toString() 方法Method toStringMethod = cls.getMethod(&quot;toString&quot;, new Class[] &#123;&#125;);System.out.println(&quot;修饰符: &quot; + Modifier.toString(toStringMethod.getModifiers()));System.out.println(&quot;返回值: &quot; + toStringMethod.getReturnType());System.out.println(&quot;方法名称: &quot; + toStringMethod.getName());System.out.println(&quot;参数列表: &quot; + toStringMethod.getParameterTypes());String msg = (String) toStringMethod.invoke(obj);System.out.println(&quot;调用toString后的运行结果:&quot; + msg); Method类的invoke(Object obj,Object args[])方法接收的参数必须为对象,如果参数为基本类型数据,必须转换为相应的包装类型的对象。invoke()方法的返回值总是对象,如果实际被调用的方法的返回类型是基本类型数据,那么invoke()方法会把它转换为相应的包装类型的对象,再将其返回. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class InvokeTester &#123; private String name; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public InvokeTester() &#123; &#125; public int add(int param1, int param2) &#123; return param1 + param2; &#125; public String echo(String mesg) &#123; return &quot;echo&quot; + mesg; &#125; public static void main(String[] args) throws Exception &#123; Class classType = InvokeTester.class; Object invokertester = classType.newInstance(); //1 Method addMethod = classType.getMethod(&quot;add&quot;, new Class[]&#123; //2 int.class, int.class &#125;); Object result = addMethod.invoke(invokertester, new Object[]&#123; //3 new Integer(100), new Integer(200) &#125;); System.out.println(result); Method echo = classType.getMethod(&quot;echo&quot;, new Class[]&#123; String.class &#125;); Object obj = echo.invoke(invokertester, new Object[]&#123; new String(&quot;Jon is very good!!!&quot;) &#125;); System.out.println(obj.toString()); InvokeTester test = new InvokeTester(); //1 test.setName(&quot;黄翊&quot;); //2 //Method[] methods; Method[] methods = test.getClass().getDeclaredMethods(); //3 //循环查找获取id方法，并执行查看是否有返回值 for (int i = 0; i &lt; methods.length; i++) &#123; //如果此方法有get和Id关键字则执行 if (methods[i].getName().indexOf(&quot;get&quot;) != -1 &amp;&amp; methods[i].getName().indexOf(&quot;Name&quot;) != -1) &#123; // 获取此get方法返回值,判断是否有值,如果没有值说明即将执行的操作新增 if (methods[i].invoke(test, null) == null) &#123; //4 System.out.println(&quot;此对象没有值！！！&quot;); &#125; else &#123; Object strName = methods[i].invoke(test, null); System.out.println(strName); &#125; &#125; &#125; &#125;&#125; invoke方法的使用实际上invoke方法的使用，和我们常见的有所区别。 我们经常创建一个对象A，A对象里面的方法getA()方法，然后A.getA() 我们采用新的方式调用（1）弄一个方法的“替身”（其实就是构建一个Method对象，让这个Method对象来代替你现在要用的方法）（2）然后给替身需要的对象和参数，让替身去替你调用（像替身替你去战斗） 12345678910111213141516171819202122232425262728package reflection;import org.junit.jupiter.api.Test;import java.lang.reflect.Method;public class InvokeTest &#123; public void test(String[] arg)&#123; for (String string : arg) &#123; System.out.println(&quot;zp is &quot; + string); &#125; &#125; @Test public void invokeDemo() throws Exception &#123; //获取字节码对象,这里要填好你对应对象的包的路径 Class&lt;InvokeTest&gt; clazz = (Class&lt;InvokeTest&gt;) Class.forName(&quot;reflection.InvokeTest&quot;); //形式一：获取一个对象// Constructor con = clazz.getConstructor();// InvokeTest m = (InvokeTest) con.newInstance(); //形式二：直接new对象，实际上不是框架的话，自己写代码直接指定某个对象创建并调用也可以 InvokeTest m = new InvokeTest(); String[] s = new String[]&#123;&quot;handsome&quot;,&quot;smart&quot;&#125;; //获取Method对象 Method method = clazz.getMethod(&quot;test&quot;, String[].class); //invoke方法要比别的方法多做一步 //调用invoke方法来调用 method.invoke(m, (Object) s); &#125;&#125; 输出结果 zp is handsomezp is smart 所以使用invoke方法要比别的方法多做一步，就是构建一个Method对象，这个对象替代的是现在程序要调用方法的替代品。 而且除了参数以外，invoke还会多要一个对象，因为方法调用需要对象，所以invoke要想调用的目标方法，就需要目标方法的需要的对象。 看起来invoke方法不仅比平常方法直接调用要麻烦很多，但是你有想过吗，我只需要输入参数，我可以调用替代各种方法，在未知的情况下，根据条件决定去调用什么对象，什么方法，一下子就让代码变得灵活，这不仅是invoke的妙处，也是整个反射的妙处，在程序运行时根据条件灵活使用。 https://zhuanlan.zhihu.com/p/350058223 Method信息我们已经能通过Class实例获取所有Field对象，同样的，可以通过Class实例获取所有Method信息。Class类提供了以下几个方法来获取Method： Method getMethod(name, Class...)：获取某个public的Method（包括父类） Method getDeclaredMethod(name, Class...)：获取当前类的某个Method（不包括父类） Method[] getMethods()：获取所有public的Method（包括父类） Method[] getDeclaredMethods()：获取当前类的所有Method（不包括父类） 123456789101112131415161718192021222324class Student extends Person &#123; public int getScore(String type) &#123; return 99; &#125; private int getGrade(int year) &#123; return 1; &#125;// @Override// public void hello() &#123;// System.out.println(&quot;Student:hello&quot;);// &#125;&#125;class Person &#123; public String getName() &#123; return &quot;Person&quot;; &#125; public void hello() &#123; System.out.println(&quot;Person:hello&quot;); &#125;&#125; 12Class&lt;Student&gt; methodClass = Student.class;Arrays.stream(methodClass.getMethods()).forEach(method -&gt; System.out.println(&quot;method方法: &quot; + method)); 打印出 method方法: public int reflection.liao.Student.getScore(java.lang.String)method方法: public void reflection.liao.Person.hello()method方法: public java.lang.String reflection.liao.Person.getName() 12Class&lt;Person&gt; methodClass = Person.class;Arrays.stream(methodClass.getMethods()).forEach(method -&gt; System.out.println(&quot;method方法: &quot; + method)); 打印出 method方法: public void reflection.liao.Person.hello()method方法: public java.lang.String reflection.liao.Person.getName() …object方法 getMethods()可以 获取所有public的Method（包括父类）， 不能获取到子类的方法,除非是是多肽实现 getDeclaredMethod获取的Method能否调用子类?父类class通过getDeclaredMethod获取的Method能否调用子类的对象 验证是不可以 1234567891011Class&lt;?&gt; clz = Class.forName(&quot;reflection.liao.Person&quot;);Object o = clz.newInstance();Method methodGetName = clz.getMethod(&quot;getName&quot;);Object noParams = methodGetName.invoke(o);System.out.println(noParams);Method methodHello = clz.getMethod(&quot;hello&quot;);System.out.println(methodHello.invoke(o));Method methodGetGrade = clz.getMethod(&quot;getGrade&quot;);System.out.println(methodGetGrade.invoke(o)); A PersonPerson:hellonull // 这个null是哪里来的 提示 java.lang.NoSuchMethodException: reflection.liao.Person.getGrade() 所以是调用不了的。 https://www.liaoxuefeng.com/wiki/1252599548343744/1264803678201760 http://www.51gjie.com/java/796.html https://www.cnblogs.com/onlywujun/p/3519037.html","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}],"tags":[],"keywords":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}]},{"title":"JVM","slug":"JVM","date":"2020-04-18T14:19:42.000Z","updated":"2021-08-19T11:11:44.055Z","comments":true,"path":"2020/04/18/JVM/","link":"","permalink":"http://noteforme.github.io.com/2020/04/18/JVM/","excerpt":"","text":"JVM方法区-第六章 ![Screen Shot 2020-04-16 at 8.22.33 PM](JVM/Screen Shot 2020-04-16 at 8.22.33 PM.png) ![Screen Shot 2020-04-16 at 8.29.39 PM](JVM/Screen Shot 2020-04-16 at 8.29.39 PM.png) ![Screen Shot 2020-04-16 at 8.41.39 PM](JVM/Screen Shot 2020-04-16 at 8.41.39 PM.png) ![Screen Shot 2020-04-16 at 8.43.41 PM](Screen Shot 2020-04-16 at 8.43.41 PM.png) https://juejin.im/post/5f0376e3e51d45349b5c9d0c https://www.iteye.com/blog/rednaxelafx-656951 https://www.bilibili.com/video/av75247289?p=2","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://noteforme.github.io.com/tags/JVM/"}],"keywords":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}]},{"title":"tool_mac","slug":"tool-mac","date":"2020-04-11T08:35:50.000Z","updated":"2021-09-13T08:32:30.118Z","comments":true,"path":"2020/04/11/tool-mac/","link":"","permalink":"http://noteforme.github.io.com/2020/04/11/tool-mac/","excerpt":"","text":"IntelliJ idea clionclion激活: CLion-2019.2.5.dmg 下载完成后,先使用再打开,jetbrains-agent-20200227.zip直接拖入就好了。 some tool for mac 查看当前环境变量 : env Packet Sendertcp ip tool HomeBrew安装 下载 https://raw.githubusercontent.com/Homebrew/install/master/install.sh 更换源 123BREW_REPO=&quot;https://github.com/Homebrew/brew&quot; 换成 BREW_REPO=&quot;git://mirrors.ustc.edu.cn/brew.git&quot; 权限 12chmod 755 install.sh ./install.sh https://blog.csdn.net/weixin_43635647/article/details/104249968 set environment variable mac Flutter 12345vi ~/.bash_profileexport PATH=&quot;$PATH:/Users/john/development/flutter/bin&quot;which flutter jdk https://docs.oracle.com/javase/10/install/installation-jdk-and-jre-macos.htm#JSJIG-GUID-F575EB4A-70D3-4AB4-A20E-DBE95171AB5F mac terminal download and install iterm2 Download iterm2-finder-tools-1.0.0 open Open iTerm.workflow install file top 右键 customize toolbar then move opem iTerm into toolbar Ignore Command + Shift + . Environment set AppledeMacBook-Pro:~ apple$ cat ~/.bash_profile export PATH=”$PATH:/Users/john/development/flutter/bin” export PUB_HOSTED_URL=https://pub.flutter-io.cn export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn gradle 阿里云镜像/Users/john/.gradle 目录添加 init.gradle 鼠须管默认简繁体control 加上 ~ 快捷键 屏幕录制https://blog.csdn.net/qq_43428139/article/details/109038098 https://www.cnblogs.com/hi3254014978/p/15084851.html#:~:text=%E8%A7%A3%E5%86%B3Mac%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%B5%E8%84%91%E8%87%AA%E5%B8%A6%E5%BD%95%E5%B1%8F%E8%BD%AF%E4%B adb 环境变量12345678910sudo touch ~/.zshrcsudo vi ~/.zshrc复制export ANDROID_HOME=/Users/m/Library/Android/sdkexport PATH=$ANDROID_HOME/platform-tools:$PATHexport PATH=$ANDROID_HOME/tools:$PATHexport PATH=$ANDROID_HOME/tools/bin:$PATH https://dev.to/ravics09/solution-of-command-not-found-adb-error-29e7","categories":[{"name":"TOOL","slug":"TOOL","permalink":"http://noteforme.github.io.com/categories/TOOL/"}],"tags":[],"keywords":[{"name":"TOOL","slug":"TOOL","permalink":"http://noteforme.github.io.com/categories/TOOL/"}]},{"title":"viewmodel","slug":"viewmodel","date":"2020-04-06T07:51:24.000Z","updated":"2021-08-19T11:11:44.320Z","comments":true,"path":"2020/04/06/viewmodel/","link":"","permalink":"http://noteforme.github.io.com/2020/04/06/viewmodel/","excerpt":"","text":"https://developer.android.com/topic/libraries/architecture/viewmodel &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD Share data between fragments======= livedata和viewmodel关系viewmodel中的数据发生变化时通知页面 ViewModel出现前 瞬间数据丢失 异步调用的内存泄漏 类膨胀提高维护难度和测试难度 Share data between fragments d7906d4909f312e25743be4a4c56ad1539df1ea6 It’s very common that two or more fragments in an activity need to communicate with each other 12345678910111213141516171819202122232425262728293031323334353637class SharedViewModel : ViewModel() &#123; val selected = MutableLiveData&lt;Item&gt;() fun select(item: Item) &#123; selected.value = item &#125;&#125;class MasterFragment : Fragment() &#123; private lateinit var itemSelector: Selector // Use the &#x27;by activityViewModels()&#x27; Kotlin property delegate // from the fragment-ktx artifact private val model: SharedViewModel by activityViewModels() override fun onViewCreated(view: View, savedInstanceState: Bundle?) &#123; super.onViewCreated(view, savedInstanceState) itemSelector.setOnClickListener &#123; item -&gt; // Update the UI &#125; &#125;&#125;class DetailFragment : Fragment() &#123; // Use the &#x27;by activityViewModels()&#x27; Kotlin property delegate // from the fragment-ktx artifact private val model: SharedViewModel by activityViewModels() override fun onViewCreated(view: View, savedInstanceState: Bundle?) &#123; super.onViewCreated(view, savedInstanceState) model.selected.observe(viewLifecycleOwner, Observer&lt;Item&gt; &#123; item -&gt; // Update the UI &#125;) &#125;&#125; https://codelabs.developers.google.com/codelabs/android-lifecycles/#0 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 使用12345678910111213141516public class MyViewModel extends ViewModel &#123; public MyViewModel(Application application)&#123; super(); &#125; public int number;&#125;public class MyViewModel extends AndroidViewModel &#123; //需要用到application就用AndroidViewModel public MyViewModel(Application application) &#123; super(application); &#125; public int number;&#125; ======= ViewModel保持数据原理 使用 1viewModel = new ViewModelProvider(this, new ViewModelProvider.AndroidViewModelFactory(getApplication())).get(MyViewModel.class); owner.getViewModelStore() 123public ViewModelProvider(@NonNull ViewModelStoreOwner owner, @NonNull Factory factory) &#123; this(owner.getViewModelStore(), factory);&#125; ComponentActivity 12345678910111213141516171819@Overridepublic ViewModelStore getViewModelStore() &#123; if (getApplication() == null) &#123; throw new IllegalStateException(&quot;Your activity is not yet attached to the &quot; + &quot;Application instance. You can&#x27;t request ViewModel before onCreate call.&quot;); &#125; if (mViewModelStore == null) &#123; NonConfigurationInstances nc = (NonConfigurationInstances) getLastNonConfigurationInstance(); //拿到上次屏幕的状态 if (nc != null) &#123; // Restore the ViewModelStore from NonConfigurationInstances mViewModelStore = nc.viewModelStore; // 获取上次的mViewModelStore，里面保存有HashMap&lt;String, ViewModel&gt; mMap &#125; if (mViewModelStore == null) &#123; mViewModelStore = new ViewModelStore(); &#125; &#125; return mViewModelStore;&#125; 所以ViewModel横竖屏切换保存数据的秘诀就是 //拿到上次屏幕的状态,获取上次的mViewModelStore，里面保存有HashMap&lt;String, ViewModel&gt; mMap,接着通过.get(MyViewModel.class);获取ViewModel,如果获取不到就反射newInstance()一个。 https://www.bilibili.com/video/BV1Hh411a7LX?p=6&amp;spm_id_from=pageDriver d7906d4909f312e25743be4a4c56ad1539df1ea6","categories":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://noteforme.github.io.com/categories/Jetpack/"}],"tags":[],"keywords":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://noteforme.github.io.com/categories/Jetpack/"}]},{"title":"Corouties","slug":"Corouties","date":"2020-04-05T02:37:04.000Z","updated":"2021-09-07T02:12:31.021Z","comments":true,"path":"2020/04/05/Corouties/","link":"","permalink":"http://noteforme.github.io.com/2020/04/05/Corouties/","excerpt":"","text":"https://www.bilibili.com/video/BV164411C7FK?from=search&amp;seid=2446477518780731765 https://codelabs.developers.google.com/codelabs/kotlin-coroutines/#1 https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html https://mp.weixin.qq.com/s/kmvn637E56t1bae2jXgqfw","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://noteforme.github.io.com/categories/Kotlin/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://noteforme.github.io.com/tags/Kotlin/"}],"keywords":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://noteforme.github.io.com/categories/Kotlin/"}]},{"title":"databinding","slug":"databinding","date":"2020-03-31T21:52:42.000Z","updated":"2021-08-19T11:11:44.298Z","comments":true,"path":"2020/04/01/databinding/","link":"","permalink":"http://noteforme.github.io.com/2020/04/01/databinding/","excerpt":"","text":"layout expression of the language https://codelabs.developers.google.com/codelabs/android-databinding/#0 https://developer.android.com/topic/libraries/data-binding Create first layout expression when you want to use it in your own projects the first step is to enable the library in the modules that will use it: 123456android &#123;... dataBinding &#123; enabled true &#125;&#125; Convert to data binding layout 打开布局文件，选中根布局的 ViewGroup，按住 option + 回车键，点击 “Convert to data binding layout”，就可以生成 DataBinding 需要的布局规则 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt; &lt;data&gt; &lt;variable name=&quot;name&quot; //不能用下划线 &quot;_&quot; type=&quot;String&quot;/&gt; &lt;variable name=&quot;lastName&quot; type=&quot;String&quot;/&gt; &lt;/data&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:id=&quot;@+id/plain_name&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;16dp&quot; android:layout_marginTop=&quot;8dp&quot; android:layout_marginEnd=&quot;128dp&quot; android:text=&quot;@&#123;name&#125;&quot; android:textAppearance=&quot;@style/TextAppearance.AppCompat.Large&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/name_label&quot;/&gt; &lt;TextView android:id=&quot;@+id/plain_lastname&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;16dp&quot; android:layout_marginTop=&quot;8dp&quot; android:layout_marginEnd=&quot;128dp&quot; android:text=&quot;@&#123;lastName&#125;&quot; android:textAppearance=&quot;@style/TextAppearance.AppCompat.Large&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/lastname_label&quot;/&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; &lt;/layout&gt; Bind TextView 12345678910111213141516171819class PlainOldActivitySolution2 : AppCompatActivity() &#123; // Obtain ViewModel from ViewModelProviders private val viewModel by lazy &#123; ViewModelProviders.of(this).get(SimpleViewModel::class.java) &#125; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) val binding: PlainActivitySolution2Binding = DataBindingUtil.setContentView(this, R.layout.plain_activity_solution_2) binding.name = &quot;John&quot; binding.lastName = &quot;lice&quot; // TODO: Explicitly setting initial values is a bad pattern. We&#x27;ll fix that later on. updateLikes() &#125;&#125;&#125; Dealing with user events Observering data12345&lt;data&gt; &lt;variable name=&quot;viewmodel&quot; type=&quot;com.example.android.databinding.basicsample.data.SimpleViewModel&quot;/&gt; &lt;/data&gt; 12345android:onClick=&quot;@&#123;() -&gt; viewmodel.onLike()&#125;&quot; binding.viewmodel = viewModel 1234private val _likes = MutableLiveData(0) fun onLike() &#123; _likes.value = (_likes.value ?: 0) + 1 &#125; 123&lt;TextView android:id=&quot;@+id/likes&quot; android:text=&quot;@&#123;Integer.toString(viewmodel.likes)&#125;&quot; Using Binding Adapters One parameter 123456@BindingAdapter(&quot;android:text&quot;) public static void setText(TextView view, CharSequence text) &#123; // Some checks removed for clarity view.setText(text); &#125; 1234@BindingAdapter(&quot;app:hideIfZero&quot;) fun hideIfZero(view: View, number: Int) &#123; view.visibility = if (number == 0) View.GONE else View.VISIBLE &#125; 123&lt;ProgressBar android:id=&quot;@+id/progressBar&quot; app:hideIfZero=&quot;@&#123;viewmodel.likes&#125;&quot; Create a Binding Adapter with multiple parameters 12345&lt;ProgressBar android:id=&quot;@+id/progressBar&quot; app:hideIfZero=&quot;@&#123;viewmodel.likes&#125;&quot; app:progressScaled=&quot;@&#123;viewmodel.likes&#125;&quot; android:max=&quot;@&#123;100&#125;&quot; oberver class fieldhttps://developer.android.com/topic/libraries/data-binding/observability#observable_fields https://developer.android.com/topic/libraries/data-binding/observability#observable_objects Using Binding Adapters to create custom attributes1234@BindingAdapter(value=[&quot;app:setSleepData&quot;])fun setSleepData(viewBodySleep: ViewBodySleep, sleepData: String) &#123; viewBodySleep.setSleepData(sleepData)&#125; 12345678&lt;com.android.util.view.ViewBodySleep android:id=&quot;@+id/view_body_sleep&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:paddingLeft=&quot;55dp&quot; android:paddingRight=&quot;48dp&quot; app:setSleepData=&quot;@&#123;vmBodyFragment.spData&#125;&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; https://developer.android.com/topic/libraries/data-binding/expressions#expression_language Work with observable data objects isNull 1android:text=&#x27;@&#123;viewModel.patientInfo.remoteCheckReceiveName??&quot;&quot;&#125;&#x27; visible 1234@BindingAdapter(&quot;app:goneUnless&quot;)fun goneUnless(view: View, visible: Boolean) &#123; view.visibility = if (visible) View.VISIBLE else View.GONE&#125; android-databinding https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&amp;mid=2652046992&amp;idx=1&amp;sn=b8b4c47537be1227eecd01c1eaee2550&amp;chksm=808ca6d5b7fb2fc32d9ec361c91a2958e51a2db1c6b20370e7ef6493bb5cb20314cda6ab059c&amp;scene=38#wechat_redirect https://juejin.im/post/5d2be05ff265da1bd605d49a https://mp.weixin.qq.com/s/4UP-pDs0FK66g1QUQvRN6A 定义xml背景 https://juejin.im/post/5b95c6a0e51d450e664b0aa0 https://www.jianshu.com/p/741103ba2ff1 https://www.cs.usfca.edu/~galles/visualization/RedBlack.html","categories":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://noteforme.github.io.com/categories/Jetpack/"}],"tags":[],"keywords":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://noteforme.github.io.com/categories/Jetpack/"}]},{"title":"Java_Queue","slug":"Java-Queue","date":"2020-03-23T09:47:11.000Z","updated":"2021-08-19T11:11:44.087Z","comments":true,"path":"2020/03/23/Java-Queue/","link":"","permalink":"http://noteforme.github.io.com/2020/03/23/Java-Queue/","excerpt":"","text":"https://blog.csdn.net/bn493235694/article/details/79600634 队列是一个先进先出的的数据结构 DequeI need to have a thread-safe LIFO structure Use LinkedBlockingDeque if at a time you want only single thread can operate your data. Use ConcurrentLinkedDeque if you want that each thread can access the shared data https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentLinkedDeque.html ConcurrentLinkedDeque https://blog.csdn.net/hello_worldee/article/details/77880532 Deque : https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html https://www.liaoxuefeng.com/wiki/1252599548343744/1265122668445536 https://www.geeksforgeeks.org/deque-interface-java-example/ LinkedList 线程安全处理 https://blog.csdn.net/d380025303/article/details/81010980","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}],"tags":[],"keywords":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}]},{"title":"ActivityRender01","slug":"ActivityRender01","date":"2020-03-22T14:45:17.000Z","updated":"2021-08-19T11:11:43.525Z","comments":true,"path":"2020/03/22/ActivityRender01/","link":"","permalink":"http://noteforme.github.io.com/2020/03/22/ActivityRender01/","excerpt":"","text":"https://juejin.im/post/5baf275f5188255c9a7740ba https://github.com/SusionSuc/AdvancedAndroid/blob/master/AndroidFramework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%E8%A7%86%E5%9B%BE%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/README.md https://blog.csdn.net/luoshengyang/article/details/8170307 https://juejin.im/post/6844904146227691527 https://mp.weixin.qq.com/s/sKJCG1AjhIRRQL9tQTrLZg","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[{"name":"Activity","slug":"Activity","permalink":"http://noteforme.github.io.com/tags/Activity/"}],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"UML","slug":"UML","date":"2020-03-20T10:00:33.000Z","updated":"2021-09-09T08:49:11.601Z","comments":true,"path":"2020/03/20/UML/","link":"","permalink":"http://noteforme.github.io.com/2020/03/20/UML/","excerpt":"","text":"工具Android Studio插件 UML.xmind UML标准建模语言中5种主要的类型图https://www.visual-paradigm.com/tw/guide/uml-unified-modeling-language/what-is-uml/ https://www.cnblogs.com/shindo/p/5579191.html https://juejin.im/post/5e96b1cae51d4546e41beeb3 类图1234567891011121314151617181920public class Person &#123; private Integer age; private String name; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 依赖关系-dependency 类中用到了对方。 如果是类的成员属性。 如果是方法的返回类型。 是方法接收的参数类型。 方法中使用到。 12345678910111213141516171819202122public class PersonServiceBean &#123; private PersonDao personDao; public void save(Person person) &#123; &#125; public void modify() &#123; Department department = new Department(); &#125;&#125;class PersonDao &#123;&#125;class IdCard &#123;&#125;class Person &#123;&#125;class Department &#123;&#125; 泛化关系-generalization泛化关系实际上就是继承关系，他是依赖关系的特例。 12345678910111213abstract class DataSupport &#123; public void save(Object entity) &#123; &#125; public void delete(Object id) &#123; &#125;&#125;public class PersonServiceBean extends DataSupport &#123;&#125; 实现关系-realizationA实现B类，就是依赖关系的特例。 1234567891011//A实现B类，就是依赖关系的特例。public class PersonServiceBean implements PersonService &#123; @Override public void delete(Integer id) &#123; System.out.println(&quot;delte..&quot;); &#125;&#125;interface PersonService&#123; public void delete(Integer id);&#125; 关联关系-Association关联关系实际上是 类与类之间的联系，他是依赖关系的特例。 关联具有导航性（理解成属性）： 即双向关系或单向关系 关系具有多重性： “1” 有且仅有一个，“0”表示0个或者多个，”n…m”表示n到m个 单向一对一关系 123456Public class Person&#123; private IDCard card;&#125;public class IDCard&#123;&#125; 双向一对一关系 12345678Public class Person&#123; private IDCard card;&#125;public class IDCard&#123; private Person person;&#125; 聚合关系- Aggregation表示整体和部分的关系，整体与部分可以分开。聚合关系是关联关系的特例，所有他具有关联的导航性与多重性。 如:一台电脑由keyboard ,monitor mouse组成，组成电脑的各个配件是可以从电脑上分离处理的，使用带空心菱形的实线表示。 123456789101112public class Computer &#123; private Moniter moniter; //moniter可以和computer分离 private Mouse mouse;//mouse可以和computer分离&#125;class Mouse &#123;&#125;class Moniter &#123;&#125; 下面是组合关系 12345678910111213// computer对象创建moniter,mouse创建， computer销毁也跟着销毁。public class Computer &#123; private Moniter moniter = new Moniter(); //moniter可以和computer不能分离 private Mouse mouse = new Mouse();//mouse可以和computer不能分离&#125;class Mouse &#123;&#125;class Moniter &#123;&#125; 组合关系-Composition也是整体与部分的关系，整体与部分不可以分开。 Person与IDCard Head，Head与Person就是组合关系，IDCard与Person就是聚合关系。 但是如果在程序中Person实体中定义了对 IDCard进行 级联删除，即删除Person时连同IDCard一起删除，那么IDCard和Person就是组合了。 1234567public class Person &#123; private IDCard card; private Head head = new Head();&#125;class IDCard&#123;&#125;class Head&#123;&#125; https://www.bilibili.com/video/BV1W4411c77E?p=28&amp;spm_id_from=pageDriver drawio部署​ https://zhangzw.com/posts/20200107.html tomacat 下载,下载 Core下的文件,解压 Draw下载，解压放到/apache-tomcat-8.5.65/webapps 启动tomcat chomd +x ./startup.sh , sudo ./statup.sh PlantUmlhttps://plantuml.com/zh/ https://tngdigital.yuque.com/tngd-mobile/key-battle/xccdfz 时序图都是plantuml,点编辑才能看到code","categories":[{"name":"TOOL","slug":"TOOL","permalink":"http://noteforme.github.io.com/categories/TOOL/"}],"tags":[],"keywords":[{"name":"TOOL","slug":"TOOL","permalink":"http://noteforme.github.io.com/categories/TOOL/"}]},{"title":"OnClick","slug":"OnClick","date":"2020-03-16T01:56:26.000Z","updated":"2021-08-19T11:11:44.196Z","comments":true,"path":"2020/03/16/OnClick/","link":"","permalink":"http://noteforme.github.io.com/2020/03/16/OnClick/","excerpt":"","text":"点击抖动 https://www.jianshu.com/p/483d6ae21322 https://juejin.im/post/5bffbcbf5188255b5d59705e","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"ActivityStart01","slug":"ActivityStart01","date":"2020-01-18T13:53:41.000Z","updated":"2021-08-19T11:11:43.526Z","comments":true,"path":"2020/01/18/ActivityStart01/","link":"","permalink":"http://noteforme.github.io.com/2020/01/18/ActivityStart01/","excerpt":"","text":"Activity创建 ​ 生命周期方法调用 本篇文章将根据源码解剖Android的Activity的启动流程，需注意的是下列的分析均基于Android7.0, 7.0版本相较于之前几个版本做了许多改动和重构，但是整体的流程是变化不大。根据启动Activity时机的不同，可分为根Activity的启动流程和普通Activity启动流程，根Activity启动流程又可以称为应用程序启动流程，即在桌面上点击一个应用图标到进入到应用第一个Activity的流程。而普通Activity的启动流程就是在一个应用里开启另外一个Activity的流程。由于两种启动流程是有重叠的，而根Activity的启动流程更加复杂，所以接下来我们重点分析根Activity的启动流程，而普通Activity的启动流程在涉及的地方会稍微提一下。由于考虑到篇幅较长，这里将分为两篇来介绍。 这篇将分析启动流程中的应用进程的创建： Launcher进程请求AMS AMS发送创建应用进程请求 Zygote进程接受请求并孵化应用进程 应用进程启动ActivityThread MainActivity组件是由Launcher 组件来启动的，而Launcher组件又是通过Activity管理服务ActivityManagerServ ice来启动Main Activity组件的’。MainActivity组件、Launcher组件和 ActivityManagerService是分别运行在不同的进程中的，因此，MainActivity组件的启动过程就涉及到了三个进程。这三个进程是通过Binder进程间通信机制来完成MainActivity组件的启动过程的。 Launcher组件启动MainActivity组件的过程如下所示。 (1)Launcher组件向ActivityManagerService发送一个启动MainActivity组件的进程间通信请求。 ( 2 ) ActivityManagerService首先将要启动的MainActivity组件的信息保存下来，然后再向Launcher 组件发送一个进入中止状态的进程间通信请求。 ( 3 ) Launcher组件进入到中止状态之后，就会向ActivityManagerService发送一个已进人中止状态 的进程间通信请求，以便ActivityManagerServ ice可以继续执行启动MainActivity组件的操作。 (4) ActivityManagerService发现用来运行MairiActivity组件的应用程序进程不存在，因此，它就会 先启动一个新的应用程序进程。 (5）新的应用程序进程启动完成之后，就会向ActivityManagerServi(e发送一个启动完成的进程间 通信请求，以便ActivityManagerService可以继续执行启动MainActivity组件的操作。 (6) ActivityManagerService将第2步保存下来的MainActivity组件的信息发送给第4步创建的应用程序进程，以便它可以将MainActivity组件启动起来。 一、Launcher进程请求AMS上面我们提到根Activity的启动流程其实就是桌面上点击一个应用图标进入到应用的第一个Activity的流程，其实桌面也可以看成一个程序，即Launcher。当系统开机后，Launcher也随之被启动，然后将已经安装的应用程序图标显示到桌面上，所以当我们点击一个应用图标其实就是相当于点击Activity中的一个button,其相应事件就是Launcher进程请求AMS来启动该应用程序。 1. 时序图 2. 详细过程请求的入口就是Launcher的startActivitySafe方法，如下： packages/apps/Launcher3/src/com/android/launcher3/Launcher.java 12345678910111213141516171819202122232425public boolean startActivitySafely(View v, Intent intent, ItemInfo item) &#123; ... // 根Activity会在新的任务栈中启动 intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); try &#123; ... if (isShortcut) &#123; // Shortcuts need some special checks due to legacy reasons. startShortcutIntentSafely(intent, optsBundle, item); &#125; else if (user == null || user.equals(Process.myUserHandle())) &#123; // 调用startActivity startActivity(intent, optsBundle); &#125; else &#123; LauncherAppsCompat.getInstance(this).startActivityForProfile( intent.getComponent(), user, intent.getSourceBounds(), optsBundle); &#125; ... return true; &#125; catch (ActivityNotFoundException|SecurityException e) &#123; ... &#125; return false;&#125; 可以发现该方法为根Activity设置了flag，即根Activity会在新的任务栈中启动。然后会调用我们熟悉的startActivity方法,而在Launcher并没有这个方法，所以我们自然想到了应该是父类的方法，然后让我们来看看Launcher继承了哪些类？ 1234567891011public class Launcher extends BaseDraggingActivity implements LauncherExterns, LauncherModel.Callbacks, LauncherProviderChangeListener, UserEventDelegate&#123; &#125;public abstract class BaseDraggingActivity extends BaseActivity implements WallpaperColorInfo.OnChangeListener &#123; &#125;public abstract class BaseActivity extends Activity implements UserEventDelegate&#123;&#125; 其实一直追踪下去，你就会发现其实Launcher调用的startActivity其实就是Activity中的startActivity。从这里也可以证明Launcher其实也是个Activity。所以在Launcher启动一个app，和我们平时在startActivity基本是一样的（基本一样，不代表完全一样，通过后文分析你就会明白！），于是我们来看看我们熟悉的Activity中的startActivity的源码是如何的： 源码：frameworks/base/core/java/android/app/Activity.java 123456789101112131415161718192021222324252627282930@Overridepublic void startActivity(Intent intent, @Nullable Bundle options) &#123; //第二个参数为-1表示Launcher不需要知道根Activity的启动结果 if (options != null) &#123; startActivityForResult(intent, -1, options); &#125; else &#123; // Note we want to go through this call for compatibility with // applications that may have overridden the method. startActivityForResult(intent, -1); &#125;&#125;public void startActivityForResult(@RequiresPermission Intent intent, int requestCode) &#123; startActivityForResult(intent, requestCode, null);&#125;public void startActivityForResult(@RequiresPermission Intent intent, int requestCode, @Nullable Bundle options) &#123; //mParent表示当前Activity的父类，当根活动还没创建则mParent==null if (mParent == null) &#123; options = transferSpringboardActivityOptions(options); Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); ... &#125; ...&#125; 从上面代码可以发现startActivity的最终实现是startActivityForResult，startActivity()第二个参数为-1表示Launcher不需要知道根Activity的启动结果,然后在startActivityForResult中由于此时根Activity还没有创建，故mParent=null,所以我们只需要关注mParent=null的情况。在这种情况中会调用Instrumentation的execStartActivity。这时候也许你就会问这个Instrumentation是什么？为什么要交给它处理？其实Instrumentation这个类很重要，重要体现在对Activity生命周期的调用。每个Activity都持有Instrumentation对象的一个引用，但是整个进程只会存在一个Instrumentation对象。看看Instrumentation的execStartActivity这个方法。 frameworks/base/core/java/android/app/Instrumentation.java 12345678910111213141516171819public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; ... try &#123; ... //获取AMS的代理对象 int result = ActivityManager.getService() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; throw new RuntimeException(&quot;Failure from system&quot;, e); &#125; return null;&#125; 在这个方法会调用ActivityManager的getService方法来得到AMS的代理对象，然后调用这个代理对象的 startActivity方法，那么这个代理对象是谁呢？让我们一探究竟 123456789101112131415161718@UnsupportedAppUsagepublic static IActivityManager getService() &#123; return IActivityManagerSingleton.get();&#125;@UnsupportedAppUsageprivate static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton = new Singleton&lt;IActivityManager&gt;() &#123; @Override protected IActivityManager create() &#123; //得到activity的service引用，即IBinder类型的AMS引用 final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE); //转换成IActivityManager对象 final IActivityManager am = IActivityManager.Stub.asInterface(b); return am; &#125; &#125;; 可以发现在Singleton中的create方法中由于b是AMS引用作为服务端处于SystemServer进程中，与当前Launcher进程作为客户端与服务端不在同一个进程，所以am返回的是IActivityManager.Stub的代理对象，此时如果要实现客户端与服务端进程间的通信，只需要在AMS继承了IActivityManager.Stub类并实现了相应的方法，而通过下面的代码可以发现AMS刚好是继承了IActivityManager.Stub类的，这样Launcher进程作为客户端就拥有了服务端AMS的代理对象，然后就可以调用AMS的方法来实现具体功能了，就这样Launcher的工作就交给AMS实现了。 12345public class ActivityManagerService extends IActivityManager.Stub implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback &#123; &#125;复制代码 二、AMS发送创建应用进程请求通过上面的分析，我们已经知道现在任务已经交给了AMS，入口是AMS的startActivity。 1. 时序图 2. 详细过程2.1 AMS将请求任务转移给Process首先来看看在AMS中的startActivity方法： 源码：frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Overridepublic final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) &#123; return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, UserHandle.getCallingUserId());&#125;@Overridepublic final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) &#123; return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, userId, true /*validateIncomingUser*/);&#125;public final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId, boolean validateIncomingUser) &#123; //判断调用者的进程是否隔离 enforceNotIsolatedCaller(&quot;startActivity&quot;); //检查调用者权限 userId = mActivityStartController.checkTargetUser(userId, validateIncomingUser, Binder.getCallingPid(), Binder.getCallingUid(), &quot;startActivityAsUser&quot;); // TODO: Switch to user app stacks here. return mActivityStartController.obtainStarter(intent, &quot;startActivityAsUser&quot;) .setCaller(caller) .setCallingPackage(callingPackage) .setResolvedType(resolvedType) .setResultTo(resultTo) .setResultWho(resultWho) .setRequestCode(requestCode) .setStartFlags(startFlags) .setProfilerInfo(profilerInfo) .setActivityOptions(bOptions) .setMayWait(userId) .execute();&#125; startActivity方法经过多个方法调用会去执行startActivityAsUser方法，在startActivityAsUser方法最后会返回mActivityStartController的一长串链式调用方法，如果AlertDialog的话，应该不难看出这链式方法肯定都是返回一个类型的对象的，我们只需要看看obtainStarter的返回类型就可以知道这个对象是什么类型了。 frameworks/base/services/core/java/com/android/server/am/ActivityStartController.java 1234ActivityStarter obtainStarter(Intent intent, String reason) &#123; return mFactory.obtain().setIntent(intent).setReason(reason);&#125; 可以发现这个obtainStarter返回的是ActivityStarter类型的，所以链式方法就是对ActivityStarter对象设置了要启动的活动的相关信息，最后再调用ActivityStarter对象execute方法。所以我们下一步所需要看的就是这个execute方法。 frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java 12345678910111213141516171819202122232425262728293031int execute() &#123; try &#123; // TODO(b/64750076): Look into passing request directly to these methods to allow // for transactional diffs and preprocessing. if (mRequest.mayWait) &#123; return startActivityMayWait(mRequest.caller, mRequest.callingUid, mRequest.callingPackage, mRequest.intent, mRequest.resolvedType, mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo, mRequest.resultWho, mRequest.requestCode, mRequest.startFlags, mRequest.profilerInfo, mRequest.waitResult, mRequest.globalConfig, mRequest.activityOptions, mRequest.ignoreTargetSecurity, mRequest.userId, mRequest.inTask, mRequest.reason, mRequest.allowPendingRemoteAnimationRegistryLookup, mRequest.originatingPendingIntent); &#125; else &#123; return startActivity(mRequest.caller, mRequest.intent, mRequest.ephemeralIntent, mRequest.resolvedType, mRequest.activityInfo, mRequest.resolveInfo, mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo, mRequest.resultWho, mRequest.requestCode, mRequest.callingPid, mRequest.callingUid, mRequest.callingPackage, mRequest.realCallingPid, mRequest.realCallingUid, mRequest.startFlags, mRequest.activityOptions, mRequest.ignoreTargetSecurity, mRequest.componentSpecified, mRequest.outActivity, mRequest.inTask, mRequest.reason, mRequest.allowPendingRemoteAnimationRegistryLookup, mRequest.originatingPendingIntent); &#125; &#125; finally &#123; onExecutionComplete(); &#125;&#125; 因为在startActivityAsUser的链式方法中我们调用了setMayWait这个方法，所以这里的mRequest.mayWait为true，故会继续调用startActivityMayWait方法。 ActivityStarter#startActivityMayWait 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 private int startActivityMayWait(IApplicationThread caller, int callingUid, String callingPackage, Intent intent, String resolvedType, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, WaitResult outResult, Configuration globalConfig, SafeActivityOptions options, boolean ignoreTargetSecurity, int userId, TaskRecord inTask, String reason, boolean allowPendingRemoteAnimationRegistryLookup, PendingIntentRecord originatingPendingIntent) &#123; ..... //根据intent在系统中找到合适的应用的activity，如果有多个activity可选择，//则会弹出ResolverActivity让用户选择合适的应用。 ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo); int res = startActivity(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, outRecord, inTask, reason, allowPendingRemoteAnimationRegistryLookup, originatingPendingIntent); .... &#125; private int startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent, String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, SafeActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, TaskRecord inTask, String reason, boolean allowPendingRemoteAnimationRegistryLookup) &#123; ... mLastStartActivityResult = startActivity(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, mLastStartActivityRecord, inTask, allowPendingRemoteAnimationRegistryLookup); ... return getExternalResult(mLastStartActivityResult); &#125; private int startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent, String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, SafeActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, TaskRecord inTask, boolean allowPendingRemoteAnimationRegistryLookup) &#123; ... return startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true /* doResume */, checkedOptions, inTask, outActivity); &#125; private int startActivity(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity) &#123; ... result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags, doResume, options, inTask, outActivity); ... postStartActivityProcessing(r, result, mTargetStack); return result; &#125; startActivityMayWait方法经过调用多次的startActivity方法后会调用到startActivityUnchecked这个方法，那这个方法是干啥的呢？这个方法会根据启动标志位和Activity启动模式来决定如何启动一个Activity以及是否要调用deliverNewIntent方法通知Activity有一个Intent试图重新启动它。比如我们在一开始将活动设置了FLAG_ACTIVITY_NEW_TASK后将创建一个任务栈，其它的就自行看代码。 12345678910111213141516171819202122232425262728293031323334353637383940 private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity) &#123;... if (mStartActivity.resultTo == null &amp;&amp; mInTask == null &amp;&amp; !mAddingToTask &amp;&amp; (mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != 0) &#123; newTask = true; //创建新的TaskRecord result = setTaskFromReuseOrCreateNewTask( taskToAffiliate, preferredLaunchStackId, topStack); &#125; else if (mSourceRecord != null) &#123; result = setTaskFromSourceRecord(); &#125; else if (mInTask != null) &#123; result = setTaskFromInTask(); &#125; else &#123; setTaskToCurrentTopOrCreateNewTask(); &#125; ... if (mDoResume) &#123; final ActivityRecord topTaskActivity = mStartActivity.getTask().topRunningActivityLocked(); if (!mTargetStack.isFocusable() || (topTaskActivity != null &amp;&amp; topTaskActivity.mTaskOverlay &amp;&amp; mStartActivity != topTaskActivity)) &#123; ... &#125; else &#123; if (mTargetStack.isFocusable() &amp;&amp; !mSupervisor.isFocusedStack(mTargetStack)) &#123; mTargetStack.moveToFront(&quot;startActivityUnchecked&quot;); &#125; mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity, mOptions); &#125; &#125; else &#123; mTargetStack.addRecentActivityLocked(mStartActivity); &#125; ...&#125; 然后无论以何种模式启动最终都会调用ActivityStackSupervisor.resumeFocusedStackTopActivityLocked方法。 frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java 123456789boolean resumeFocusedStackTopActivityLocked( ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) &#123; .... if (targetStack != null &amp;&amp; isFocusedStack(targetStack)) &#123; return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions); &#125; ....&#125; 于是又调用了ActivityStack的resumeTopActivityUncheckedLocked frameworks/base/services/core/java/com/android/server/am/ActivityStack.java 1234567891011121314151617181920 @GuardedBy(&quot;mService&quot;) boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) &#123; ... try &#123; // Protect against recursion. mStackSupervisor.inResumeTopActivity = true; result = resumeTopActivityInnerLocked(prev, options); &#125; ... &#125;private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) &#123; ... mStackSupervisor.startSpecificActivityLocked(next, true, true); &#125; if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked(); return true;&#125; emmmm…..，看到这估计都懵逼了，几个类跳来跳去也不知道干了些什么，不慌，让我们坚持看下ActivityStackSupervisor.startSpecificActivityLocked,因为这个方法很重要。这个方法将是普通Activity和根Activity启动流程的分岔路口。 ActivityStackSupervisor#startSpecificActivityLocked 1234567891011121314151617181920212223242526272829303132 void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) &#123; //获取即将要启动的Activity的所在的应用程序进程 ProcessRecord app = mService.getProcessRecordLocked(r.processName, r.info.applicationInfo.uid, true); //如果应用进程已经存在 if (app != null &amp;&amp; app.thread != null) &#123; try &#123; if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == 0 || !&quot;android&quot;.equals(r.info.packageName)) &#123; // Don&#x27;t add this if it is a platform component that is marked // to run in multiple processes, because this is actually // part of the framework so doesn&#x27;t make sense to track as a // separate apk in the process. app.addPackage(r.info.packageName, r.info.applicationInfo.longVersionCode, mService.mProcessStats); &#125; realStartActivityLocked(r, app, andResume, checkConfig); return; &#125; catch (RemoteException e) &#123; Slog.w(TAG, &quot;Exception when starting activity &quot; + r.intent.getComponent().flattenToShortString(), e); &#125; // If a dead object exception was thrown -- fall through to // restart the application. &#125;//应用进程还未创建，则通过AMS调用startProcessLocked向Zygote进程发送请求 mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, &quot;activity&quot;, r.intent.getComponent(), false, false, true); &#125; 阅读上面的代码我们可以知道在方法中首先获取到了即将要启动的Activity所在的应用进程，假如是普通的Activity的启动流程的活，这个进程肯定是存在的，所以将执行realStartActivityLocked的方法。但是我们现在讨论的是根Activity的启动流程，由于应用都还未启动，意味着根Activity所在的应用进程还未创建，而mService其实就是AMS，所以这里将调用AMS的startProcessLocked。于是我们又回到了最初的起点AMS。 ActivityManagerService.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116final ProcessRecord startProcessLocked(String processName, ApplicationInfo info, boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName, boolean allowWhileBooting, boolean isolated, boolean keepIfLarge) &#123; return startProcessLocked(processName, info, knownToBeDead, intentFlags, hostingType, hostingName, allowWhileBooting, isolated, 0 /* isolatedUid */, keepIfLarge, null /* ABI override */, null /* entryPoint */, null /* entryPointArgs */, null /* crashHandler */);&#125;final ProcessRecord startProcessLocked(String processName, ApplicationInfo info, boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName, boolean allowWhileBooting, boolean isolated, int isolatedUid, boolean keepIfLarge, String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler) &#123; ... final boolean success = startProcessLocked(app, hostingType, hostingNameStr, abiOverride); ...&#125;@GuardedBy(&quot;this&quot;)private final boolean startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride) &#123; return startProcessLocked(app, hostingType, hostingNameStr, false /* disableHiddenApiChecks */, abiOverride);&#125;private final boolean startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, boolean disableHiddenApiChecks, String abiOverride) &#123; ... int uid = app.uid; //创建应用进程的用户ID int[] gids = null; int mountExternal = Zygote.MOUNT_EXTERNAL_NONE; if (!app.isolated) &#123; int[] permGids = null; try &#123; checkTime(startTime, &quot;startProcess: getting gids from package manager&quot;); final IPackageManager pm = AppGlobals.getPackageManager(); permGids = pm.getPackageGids(app.info.packageName, MATCH_DEBUG_TRIAGED_MISSING, app.userId); StorageManagerInternal storageManagerInternal = LocalServices.getService( StorageManagerInternal.class); mountExternal = storageManagerInternal.getExternalStorageMountMode(uid, app.info.packageName); &#125; catch (RemoteException e) &#123; throw e.rethrowAsRuntimeException(); &#125; /* * 对用户组进行创建和赋值 */ if (ArrayUtils.isEmpty(permGids)) &#123; gids = new int[3]; &#125; else &#123; gids = new int[permGids.length + 3]; System.arraycopy(permGids, 0, gids, 3, permGids.length); &#125; gids[0] = UserHandle.getSharedAppGid(UserHandle.getAppId(uid)); gids[1] = UserHandle.getCacheAppGid(UserHandle.getAppId(uid)); gids[2] = UserHandle.getUserGid(UserHandle.getUserId(uid)); // Replace any invalid GIDs if (gids[0] == UserHandle.ERR_GID) gids[0] = gids[2]; if (gids[1] == UserHandle.ERR_GID) gids[1] = gids[2]; &#125; ... //这个参数后文会提到 final String entryPoint = &quot;android.app.ActivityThread&quot;; return startProcessLocked(hostingType, hostingNameStr, entryPoint, app, uid, gids, runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet, invokeWith, startTime); &#125;private boolean startProcessLocked(String hostingType, String hostingNameStr, String entryPoint, ProcessRecord app, int uid, int[] gids, int runtimeFlags, int mountExternal, String seInfo, String requiredAbi, String instructionSet, String invokeWith, long startTime) &#123; .... //重点关注 final ProcessStartResult startResult = startProcess(app.hostingType, entryPoint, app, app.startUid, gids, runtimeFlags, mountExternal, app.seInfo, requiredAbi, instructionSet, invokeWith, app.startTime); ...&#125;private ProcessStartResult startProcess(String hostingType, String entryPoint, ProcessRecord app, int uid, int[] gids, int runtimeFlags, int mountExternal, String seInfo, String requiredAbi, String instructionSet, String invokeWith, long startTime) &#123; .... if (hostingType.equals(&quot;webview_service&quot;)) &#123; startResult = startWebView(entryPoint, app.processName, uid, uid, gids, runtimeFlags, mountExternal, app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet, app.info.dataDir, null, new String[] &#123;PROC_START_SEQ_IDENT + app.startSeq&#125;); &#125; else &#123; //通过Process.start方法来为应用创建进程 startResult = Process.start(entryPoint, app.processName, uid, uid, gids, runtimeFlags, mountExternal, app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet, app.info.dataDir, invokeWith, new String[] &#123;PROC_START_SEQ_IDENT + app.startSeq&#125;); &#125; checkTime(startTime, &quot;startProcess: returned from zygote!&quot;); return startResult; &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125;&#125; 通过调用多个startProcessLocked方法后最终将调用startProcess方法，不过需要重点看一下上面的第四个startProcessLocked，在该方法中有个entryPoint参数为 “android.app.ActivityThread”，这个参数将在后文讲到创建应用进程后启动ActivityThread会用到。然后在startProcess方法里将调用Process.start来发送应用创建进程的请求。这样AMS就将发送请求的事交给了Process 2.2 Process向Zygote进程发送创建应用进程请求 frameworks/base/core/java/android/os/Process.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static final ProcessStartResult start(final String processClass, final String niceName, int uid, int gid, int[] gids, int runtimeFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String invokeWith, String[] zygoteArgs) &#123; return ZYGOTE_PROCESS.start(processClass, niceName, uid, gid, gids, runtimeFlags, mountExternal, targetSdkVersion, seInfo, abi, instructionSet, appDataDir, invokeWith, /*useBlastulaPool=*/ true, zygoteArgs);&#125;public final Process.ProcessStartResult start(final String processClass, final String niceName, int uid, int gid, int[] gids, int runtimeFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String invokeWith, boolean useBlastulaPool, String[] zygoteArgs) &#123; try &#123; //重点关注 return startViaZygote(processClass, niceName, uid, gid, gids, runtimeFlags, mountExternal, targetSdkVersion, seInfo, abi, instructionSet, appDataDir, invokeWith, /*startChildZygote=*/false, useBlastulaPool, zygoteArgs); &#125; catch (ZygoteStartFailedEx ex) &#123; Log.e(LOG_TAG, &quot;Starting VM process through Zygote failed&quot;); throw new RuntimeException( &quot;Starting VM process through Zygote failed&quot;, ex); &#125;&#125; 从上面可以发现，Process中的start方法的实现是startViaZygote方法，所以我们重点观察下这个方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243private Process.ProcessStartResult startViaZygote(final String processClass, final String niceName, final int uid, final int gid, final int[] gids, int runtimeFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String invokeWith, boolean startChildZygote, boolean useBlastulaPool, String[] extraArgs) throws ZygoteStartFailedEx &#123; ArrayList&lt;String&gt; argsForZygote = new ArrayList&lt;String&gt;(); // --runtime-args, --setuid=, --setgid=, //创建字符串列表argsForZygote，并将启动应用进程的启动参数保存在这个列表中 argsForZygote.add(&quot;--runtime-args&quot;); argsForZygote.add(&quot;--setuid=&quot; + uid); argsForZygote.add(&quot;--setgid=&quot; + gid); argsForZygote.add(&quot;--runtime-flags=&quot; + runtimeFlags); if (mountExternal == Zygote.MOUNT_EXTERNAL_DEFAULT) &#123; argsForZygote.add(&quot;--mount-external-default&quot;); &#125; else if (mountExternal == Zygote.MOUNT_EXTERNAL_READ) &#123; argsForZygote.add(&quot;--mount-external-read&quot;); &#125; else if (mountExternal == Zygote.MOUNT_EXTERNAL_WRITE) &#123; argsForZygote.add(&quot;--mount-external-write&quot;); &#125; argsForZygote.add(&quot;--target-sdk-version=&quot; + targetSdkVersion); ... synchronized(mLock) &#123; //重点关注 return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), useBlastulaPool, argsForZygote); &#125;&#125; 在startViaZygote中会创建字符串列表argsForZygote来保存将要创建的应用进程的启动参数，然后最后会调用zygoteSendArgsAndGetResult方法，而在这个方法中第一个参数会调用openZygoteSocketIfNeeded方法，第三个参数就是启动参数列表。所以我们先看看openZygoteSocketIfNeeded这个方法的实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 private ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx &#123; Preconditions.checkState(Thread.holdsLock(mLock), &quot;ZygoteProcess lock not held&quot;);//64位进程中的 if (primaryZygoteState == null || primaryZygoteState.isClosed()) &#123; try &#123; //调用ZygoteState的connect函数与mZygoteSocketAddress建立连接， //这里mZygoteSocketAddress的值为“zygote” primaryZygoteState = ZygoteState.connect(mZygoteSocketAddress, mBlastulaPoolSocketAddress); &#125; catch (IOException ioe) &#123; throw new ZygoteStartFailedEx(&quot;Error connecting to primary zygote&quot;, ioe); &#125; maybeSetApiBlacklistExemptions(primaryZygoteState, false); maybeSetHiddenApiAccessLogSampleRate(primaryZygoteState); &#125; if (primaryZygoteState.matches(abi)) &#123; //Socket进行连接成功并匹配abi后会返回ZygoteState类型对象 return primaryZygoteState; &#125; // 32位Zygote进程中 if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) &#123; try &#123; secondaryZygoteState = ZygoteState.connect(mZygoteSecondarySocketAddress, mBlastulaPoolSecondarySocketAddress); &#125; catch (IOException ioe) &#123; throw new ZygoteStartFailedEx(&quot;Error connecting to secondary zygote&quot;, ioe); &#125; maybeSetApiBlacklistExemptions(secondaryZygoteState, false); maybeSetHiddenApiAccessLogSampleRate(secondaryZygoteState); &#125; if (secondaryZygoteState.matches(abi)) &#123; return secondaryZygoteState; &#125; throw new ZygoteStartFailedEx(&quot;Unsupported zygote ABI: &quot; + abi); &#125; openZygoteSocketIfNeeded这个方法从方法名就可以推测出这个方法的作用，大概就是与Zygote建立Socket连接。而从代码中也证实了这一点，在代码中会根据Zygote进程的位数来建立相应的Socket连接，然后返回ZygoteState类型的对象。既然与Zygote建立好Socket连接后，接下来当然是发送请求！我们来看看zygoteSendArgsAndGetResult这个方法中是如何发送请求的！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//将传入的应用进程的启动参数argsForZygote写入到ZygoteState @GuardedBy(&quot;mLock&quot;) private static Process.ProcessStartResult zygoteSendArgsAndGetResult( ZygoteState zygoteState, boolean useBlastulaPool, ArrayList&lt;String&gt; args) throws ZygoteStartFailedEx &#123; String msgStr = Integer.toString(args.size()) + &quot;\\n&quot; + String.join(&quot;\\n&quot;, args) + &quot;\\n&quot;; // Should there be a timeout on this? Process.ProcessStartResult result = new Process.ProcessStartResult(); // TODO (chriswailes): Move branch body into separate function. if (useBlastulaPool &amp;&amp; Zygote.BLASTULA_POOL_ENABLED &amp;&amp; isValidBlastulaCommand(args)) &#123; LocalSocket blastulaSessionSocket = null; try &#123; blastulaSessionSocket = zygoteState.getBlastulaSessionSocket(); final BufferedWriter blastulaWriter = new BufferedWriter( new OutputStreamWriter(blastulaSessionSocket.getOutputStream()), Zygote.SOCKET_BUFFER_SIZE); final DataInputStream blastulaReader = new DataInputStream(blastulaSessionSocket.getInputStream()); blastulaWriter.write(msgStr); blastulaWriter.flush(); result.pid = blastulaReader.readInt(); // Blastulas can&#x27;t be used to spawn processes that need wrappers. result.usingWrapper = false; if (result.pid &lt; 0) &#123; throw new ZygoteStartFailedEx(&quot;Blastula specialization failed&quot;); &#125; return result; &#125; catch (IOException ex) &#123; // If there was an IOException using the blastula pool we will log the error and // attempt to start the process through the Zygote. Log.e(LOG_TAG, &quot;IO Exception while communicating with blastula pool - &quot; + ex.toString()); &#125; finally &#123; try &#123; blastulaSessionSocket.close(); &#125; catch (IOException ex) &#123; Log.e(LOG_TAG, &quot;Failed to close blastula session socket: &quot; + ex.getMessage()); &#125; &#125; &#125; try &#123; final BufferedWriter zygoteWriter = zygoteState.mZygoteOutputWriter; final DataInputStream zygoteInputStream = zygoteState.mZygoteInputStream; zygoteWriter.write(msgStr); zygoteWriter.flush(); // Always read the entire result from the input stream to avoid leaving // bytes in the stream for future process starts to accidentally stumble // upon. result.pid = zygoteInputStream.readInt(); result.usingWrapper = zygoteInputStream.readBoolean(); &#125; catch (IOException ex) &#123; zygoteState.close(); Log.e(LOG_TAG, &quot;IO Exception while communicating with Zygote - &quot; + ex.toString()); throw new ZygoteStartFailedEx(ex); &#125; if (result.pid &lt; 0) &#123; throw new ZygoteStartFailedEx(&quot;fork() failed&quot;); &#125; return result; &#125; 因为在openZygoteSocketIfNeeded中我们已经与Zygote进程建立了Socket连接，所以在这个方法中将传入的应用进程的启动参数argsForZygote写入到ZygoteState。这样AMS就完成了向Zygote进程发送创建应用进程的请求的任务。 三、Zygote进程接受请求并孵化应用进程从上面我们知道，AMS已经与Zygote进程建立Socket连接并发送了创建应用进程的请求，那么Zygote进程是在哪里收到请求，收到请求后又是怎么处理的呢？通过阅读后我们知道Zygote进程是在ZygoteInit的main方法中接受请求的。所以现在的入口就是ZygoteInit的main方法。 1. 时序图 2. 详细过程从时序图与上面的分析我们知道现在Zygote进程接受请求是在main方法，就让我们来看看这个main方法 frameworks/base/core/java/com/android/internal/os/ZygoteInit.java 12345678910111213141516171819202122232425262728293031323334353637383940 @UnsupportedAppUsage public static void main(String argv[]) &#123; ZygoteServer zygoteServer = new ZygoteServer(); Runnable caller; try &#123; ... //创建名为zygote的Socket zygoteServer.createZygoteSocket(socketName); .... //由于在init.rc中设置了start-system-server参数,因此 //这里将启动SystemServer,可见SystemServer由Zygote创建的第一个进程 if (startSystemServer) &#123; Runnable r = forkSystemServer(abiList, socketName, zygoteServer); if (r != null) &#123; r.run(); return; &#125; &#125; caller = Zygote.initBlastulaPool(); if (caller == null) &#123; Log.i(TAG, &quot;Accepting command socket connections&quot;); //等待AMS的请求 runSelectLoop(abiList); &#125; &#125; catch (Throwable ex) &#123; Log.e(TAG, &quot;System zygote died with exception&quot;, ex); throw ex; &#125; finally &#123; zygoteServer.closeServerSocket(); &#125; // We&#x27;re in the child process and have exited the select loop. Proceed to execute the // command. if (caller != null) &#123; caller.run(); &#125; &#125;复制代码 通过main方法，我们可以知道在这个main方法首先要创建一个Server端的Socket，这个name为”zygote”的Socket用来等待ActivityManagerService来请求Zygote来创建新的应用程序进程,在上面AMS请求的分析中我们也知道客户端将根据这个name来与Zygote的Socket建立连接。接下去会启动SystemServer进程，这个进程会启动各种系统服务，比如与Activity启动息息相关的AMS。最后会调用ZygoteServer.runSelectLoop(abiList)来使创建的Socket进入无限循环，等待AMS请求。让我们来看看这个runSelectLoop frameworks/base/core/java/com/android/internal/os/ZygoteServer.java 12345678910111213141516171819202122232425262728 Runnable runSelectLoop(String abiList) &#123; ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;ZygoteConnection&gt;(); peers.add(null); while (true) &#123; while (--pollIndex &gt;= 0) &#123; if ((pollFDs[pollIndex].revents &amp; POLLIN) == 0) &#123; continue; &#125; if (pollIndex == 0) &#123; //监听Socket连接，充当服务端Socket ZygoteConnection newPeer = acceptCommandPeer(abiList); peers.add(newPeer); socketFDs.add(newPeer.getFileDescriptor()); &#125; else if (pollIndex &lt; blastulaPoolEventFDIndex) &#123; try &#123; //不断处理客户端的AMS的请求，然后交给processOneCommand ZygoteConnection connection = peers.get(pollIndex); final Runnable command = connection.processOneCommand(this); &#125; .... &#125; &#125; &#125; &#125;复制代码 可以发现这个方法是死循环表示不停的监听着Socket连接。acceptCommandPeer方法就是监听是否收到了请求，如果收到了请求就交给processOneCommand来实现 frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 Runnable processOneCommand(ZygoteServer zygoteServer) &#123; String args[]; ZygoteArguments parsedArgs = null; FileDescriptor[] descriptors; try &#123; //获取应用程序进程的启动参数 args = Zygote.readArgumentList(mSocketReader); // TODO (chriswailes): Remove this and add an assert. descriptors = mSocket.getAncillaryFileDescriptors(); &#125; catch (IOException ex) &#123; throw new IllegalStateException(&quot;IOException on command socket&quot;, ex); &#125; .... parsedArgs = new ZygoteArguments(args); .... //fork当前进程创建一个子进程 pid = Zygote.forkAndSpecialize(parsedArgs.mUid, parsedArgs.mGid, parsedArgs.mGids, parsedArgs.mRuntimeFlags, rlimits, parsedArgs.mMountExternal, parsedArgs.mSeInfo, parsedArgs.mNiceName, fdsToClose, fdsToIgnore, parsedArgs.mStartChildZygote, parsedArgs.mInstructionSet, parsedArgs.mAppDataDir, parsedArgs.mTargetSdkVersion); try &#123; //pid为0则代表这个进程为子进程，即新创建的应用程序进程 if (pid == 0) &#123; zygoteServer.setForkChild(); zygoteServer.closeServerSocket(); IoUtils.closeQuietly(serverPipeFd); serverPipeFd = null; return handleChildProc(parsedArgs, descriptors, childPipeFd, parsedArgs.mStartChildZygote); &#125; else &#123; // In the parent. A pid &lt; 0 indicates a failure and will be handled in // handleParentProc. IoUtils.closeQuietly(childPipeFd); childPipeFd = null; handleParentProc(pid, descriptors, serverPipeFd); return null; &#125; &#125; finally &#123; IoUtils.closeQuietly(childPipeFd); IoUtils.closeQuietly(serverPipeFd); &#125; &#125;复制代码 在这个方法中将对请求进行处理，首先获取到将要启动的应用进程的启动参数，然后调用forkAndSpecialize来创建应用进程。 frameworks/base/core/java/com/android/internal/os/Zygote.java 12345678910111213141516171819202122 public static int forkAndSpecialize(int uid, int gid, int[] gids, int runtimeFlags, int[][] rlimits, int mountExternal, String seInfo, String niceName, int[] fdsToClose, int[] fdsToIgnore, boolean startChildZygote, String instructionSet, String appDataDir, int targetSdkVersion) &#123; ZygoteHooks.preFork(); // Resets nice priority for zygote process. resetNicePriority(); int pid = nativeForkAndSpecialize( uid, gid, gids, runtimeFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose, fdsToIgnore, startChildZygote, instructionSet, appDataDir); // Enable tracing as soon as possible for the child process. if (pid == 0) &#123; Zygote.disableExecuteOnly(targetSdkVersion); Trace.setTracingEnabled(true, runtimeFlags); // Note that this event ends at the end of handleChildProc, Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;PostFork&quot;); &#125; ZygoteHooks.postForkCommon(); return pid; &#125;复制代码 在forkAndSpecialize中，最终将创建应用进程的任务交给nativeForkAndSpecialize，而这个方法可以看出来应该是本地方法，所以具体如何创建的我们就不深究了，在这里我们这需要知道nativeForkAndSpecialize最终是通过fork当前线程来创建一个子线程，而fork后会有返回值给pid: 父进程中，fork返回新创建的子进程pid; 子进程中，fork返回0； 出现错误时，fork返回负数。 于是到这里子线程也就是应用进程就被孵化出来了。你以为这样就结束了？其实还早呢！别忘了我们的最终使命是根Activity的启动，而现在只是有了根Activity所需要的应用进程，革命尚未成功，仍需要努力！ 四、应用进程启动ActivityThread1. 时序图 2. 详细过程从上面我们知道应用进程已经被创建，那创建后呢？这就需要我们回头看上面的processOneCommand方法，细心的你肯定会发现再孵化出应用进程后，还是有返回值的。 frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java 1234567891011121314151617181920212223 Runnable processOneCommand(ZygoteServer zygoteServer) &#123; ....//fork当前进程创建一个子进程 pid = Zygote.forkAndSpecialize(parsedArgs.mUid, parsedArgs.mGid, parsedArgs.mGids, parsedArgs.mRuntimeFlags, rlimits, parsedArgs.mMountExternal, parsedArgs.mSeInfo, parsedArgs.mNiceName, fdsToClose, fdsToIgnore, parsedArgs.mStartChildZygote, parsedArgs.mInstructionSet, parsedArgs.mAppDataDir, parsedArgs.mTargetSdkVersion); try &#123; //pid为0则代表这个进程为子进程，即新创建的应用程序进程 if (pid == 0) &#123; .... return handleChildProc(parsedArgs, descriptors, childPipeFd, parsedArgs.mStartChildZygote); &#125; else &#123; ... &#125; &#125; .... &#125; 在上面我们分析了当pid=0的时候，则代表了当前进程已经是子进程了，即应用进程。所以下一步将执行handleChildProc方法。 1234567891011private Runnable handleChildProc(ZygoteArguments parsedArgs, FileDescriptor[] descriptors, FileDescriptor pipeFd, boolean isZygote) &#123; ..... if (!isZygote) &#123; return ZygoteInit.zygoteInit(parsedArgs.mTargetSdkVersion, parsedArgs.mRemainingArgs, null /* classLoader */); &#125; else &#123; .... &#125;&#125; 而handleChildProc最终又会调用ZygoteInit.zygoteInit方法。如下 frameworks/base/core/java/com/android/internal/os/ZygoteInit.java 12345678910111213141516 public static final Runnable zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) &#123; if (RuntimeInit.DEBUG) &#123; Slog.d(RuntimeInit.TAG, &quot;RuntimeInit: Starting application from zygote&quot;); &#125; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ZygoteInit&quot;); RuntimeInit.redirectLogStreams();//为当前的VM设置未捕获异常器 RuntimeInit.commonInit();//Binder驱动初始化，该方法完成后，可通过Binder进行进程通信 ZygoteInit.nativeZygoteInit();//主要调用SystemServer的main方法 return RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader); &#125; 在这个方法里会创建当前进程的Binder线程池，便于后续与其它进程通信，然后调用了RuntimeInit的applicationInit方法，如下： frameworks/base/core/java/com/android/internal/os/RuntimeInit.java 12345678protected static Runnable applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) &#123; ... final Arguments args = new Arguments(argv); // Remaining arguments are passed to the start class&#x27;s static main return findStaticMain(args.startClass, args.startArgs, classLoader); &#125; 这个方法最终会调用findStaticMain方法，不过需注意的是方法的第一个参数args.startClass其实就是我们上文AMS将请求任务转移给Process中在最后强调的那个参数：android.app.ActivityThread。然后我们看看findStaticMain的实现 12345678910111213141516171819protected static Runnable findStaticMain(String className, String[] argv, ClassLoader classLoader) &#123; Class&lt;?&gt; cl; try &#123; cl = Class.forName(className, true, classLoader);//1 &#125; catch (ClassNotFoundException ex) &#123; .... &#125; Method m; try &#123; m = cl.getMethod(&quot;main&quot;, new Class[] &#123; String[].class &#125;);//2 &#125; catch (NoSuchMethodException ex) &#123; ... &#125; catch (SecurityException ex) &#123; ... &#125; return new MethodAndArgsCaller(m, argv);&#125; 在这个方法中首先在注释1通过反射获取到android.app.ActivityThread类，然后在注释2获取到ActivityThread的main方法，最后通过main方法来构造MethodAndArgsCaller。而这个MethodAndArgsCaller是什么呢？如下： frameworks/base/core/java/com/android/internal/os/RuntimeInit.java 1234567891011121314151617181920212223242526272829static class MethodAndArgsCaller implements Runnable &#123; /** method to call */ private final Method mMethod; /** argument array */ private final String[] mArgs; public MethodAndArgsCaller(Method method, String[] args) &#123; mMethod = method; mArgs = args; &#125; public void run() &#123; try &#123; mMethod.invoke(null, new Object[] &#123; mArgs &#125;); &#125; catch (IllegalAccessException ex) &#123; throw new RuntimeException(ex); &#125; catch (InvocationTargetException ex) &#123; Throwable cause = ex.getCause(); if (cause instanceof RuntimeException) &#123; throw (RuntimeException) cause; &#125; else if (cause instanceof Error) &#123; throw (Error) cause; &#125; throw new RuntimeException(ex); &#125; &#125; &#125; 追踪下去，MethodAndArgsCaller其实是RuntimeInit的一个内部类并且继承了Runnable,然后在run方法中会通过反射调用了mMethod方法，此时mMethod是ActivityThread的main方法，即run方法中将会执行ActivityThread的main方法，在这里你可能会有疑问了，那这个run方法什么时候执行呢？让我们来看看最开始的ZygoteInit的main方法。 frameworks/base/core/java/com/android/internal/os/ZygoteInit.java 1234567891011121314151617181920212223@UnsupportedAppUsagepublic static void main(String argv[]) &#123; Runnable caller; try &#123; .... caller = Zygote.initBlastulaPool(); if (caller == null) &#123; Log.i(TAG, &quot;Accepting command socket connections&quot;); //等待AMS的请求 caller = zygoteServer.runSelectLoop(abiList); &#125; &#125; catch (Throwable ex) &#123; Log.e(TAG, &quot;System zygote died with exception&quot;, ex); throw ex; &#125; finally &#123; zygoteServer.closeServerSocket(); &#125; if (caller != null) &#123; caller.run(); &#125;&#125; 从分析Zygote进程接受请求并孵化应用进程的一开始，我们就是分析runSelectLoop(abiList)这个方法，而分析到最后findStaticMain方法将返回MethodAndArgsCaller对象（继承Runnable）,所以这时候在ZygoteInit的main方法caller会等于这个MethodAndArgsCaller对象，显然caller不等于null，故最后会执行caller.run方法，即执行ActivityThread的main方法。于是应用进程成功启动ActivityThread。 https://juejin.im/post/5d9d948de51d45782c23fabc https://juejin.im/post/5a936c5a6fb9a0633229ca74 http://codemx.cn/2018/01/26/AndroidOS008-Activity/ Android系统启动流程（二）解析Zygote进程启动过程 https://juejin.im/post/6867744083809419277 https://juejin.im/post/6887431834041483271 启动流程目的 https://juejin.cn/post/6897892195483779080","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[{"name":"AOSP","slug":"AOSP","permalink":"http://noteforme.github.io.com/tags/AOSP/"}],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"ActivityStart02","slug":"ActivityStart02","date":"2020-01-13T02:49:39.000Z","updated":"2021-08-19T11:11:43.527Z","comments":true,"path":"2020/01/13/ActivityStart02/","link":"","permalink":"http://noteforme.github.io.com/2020/01/13/ActivityStart02/","excerpt":"","text":"Application OnCreate() 12345678910111213141516171819public static void main(String[] args) &#123; Looper.prepareMainLooper(); //创建消息循环 ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;)); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); //使当前进程进入消息循环&#125; 在这里我们就不再详细分析prepareMainLooper和loop方法，其主要功能就是准备好主线程的Looper以及消息队列，最后再开启主线程的消息循环。 1234567891011121314151617181920212223242526272829303132private void attach(boolean system) &#123; IActivityManager mgr = ActivityManagerNative.getDefault(); //获得ApplicationThreadNative //代理类ActivityManagerProxy try &#123; mgr.attachApplication(mAppThread); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; // Watch for getting close to heap limit. BinderInternal.addGcWatcher(new Runnable() &#123; @Override public void run() &#123; if (!mSomeActivitiesChanged) &#123; return; &#125; Runtime runtime = Runtime.getRuntime(); long dalvikMax = runtime.maxMemory(); long dalvikUsed = runtime.totalMemory() - runtime.freeMemory(); if (dalvikUsed &gt; ((3*dalvikMax)/4)) &#123; if (DEBUG_MEMORY_TRIM) Slog.d(TAG, &quot;Dalvik max=&quot; + (dalvikMax/1024) + &quot; total=&quot; + (runtime.totalMemory()/1024) + &quot; used=&quot; + (dalvikUsed/1024)); mSomeActivitiesChanged = false; try &#123; mgr.releaseSomeActivities(mAppThread); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; &#125; &#125;);&#125; 可以看到由于在ActivityThread的attach中我们传入的是false，故在attach方法中将执行!system里的代码，通过调用AMS的attachApplication来将ActivityThread中的内部类ApplicationThread对象绑定至AMS，这样AMS就可以通过这个代理对象 来控制应用进程。接着为这个进程添加垃圾回收观察者，每当系统触发垃圾回收的时候就在run方法中计算应用使用了多大的内存，如果超过总量的3/4就尝试释放内存。 1234567891011public void attachApplication(IApplicationThread app) throws RemoteException&#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(app.asBinder()); mRemote.transact(ATTACH_APPLICATION_TRANSACTION, data, reply, 0); reply.readException(); data.recycle(); reply.recycle();&#125; 12345678910111213141516@Overridepublic boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; switch (code) &#123; case ATTACH_APPLICATION_TRANSACTION: &#123; data.enforceInterface(IActivityManager.descriptor); IApplicationThread app = ApplicationThreadNative.asInterface( data.readStrongBinder()); //得到代理类ApplicationThreadProxy if (app != null) &#123; attachApplication(app); &#125; reply.writeNoException(); return true; &#125; &#125;&#125; 123456789@Overridepublic final void attachApplication(IApplicationThread thread) &#123; synchronized (this) &#123; int callingPid = Binder.getCallingPid(); final long origId = Binder.clearCallingIdentity(); attachApplicationLocked(thread, callingPid); Binder.restoreCallingIdentity(origId); &#125;&#125; ​ 将应用进程的ApplicationThread对象绑定到AMS，即AMS获得ApplicationThread的代理对象 123456789101112131415161718private final boolean attachApplicationLocked(IApplicationThread thread, int pid) &#123; //创建Application thread.bindApplication(processName, appInfo, providers, app.instrumentationClass, profilerInfo, app.instrumentationArguments, app.instrumentationWatcher, app.instrumentationUiAutomationConnection, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(mConfiguration), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked()); //创建Activity if (mStackSupervisor.attachApplicationLocked(app)) &#123; didSomething = true; &#125; &#125; create Application 12345678910111213141516171819@Overridepublic final void bindApplication(String packageName, ApplicationInfo info, List&lt;ProviderInfo&gt; providers, ComponentName testName, ProfilerInfo profilerInfo, Bundle testArgs, IInstrumentationWatcher testWatcher, IUiAutomationConnection uiAutomationConnection, int debugMode, boolean enableBinderTracking, boolean trackAllocation, boolean restrictedBackupMode, boolean persistent, Configuration config, CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services, Bundle coreSettings) throws RemoteException &#123; data.writeInt(restrictedBackupMode ? 1 : 0); data.writeInt(persistent ? 1 : 0); config.writeToParcel(data, 0); compatInfo.writeToParcel(data, 0); data.writeMap(services); data.writeBundle(coreSettings); mRemote.transact(BIND_APPLICATION_TRANSACTION, data, null, IBinder.FLAG_ONEWAY); data.recycle();&#125; 123456789101112131415161718192021 @Override public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; switch (code) &#123; case BIND_APPLICATION_TRANSACTION: boolean trackAllocation = data.readInt() != 0; boolean restrictedBackupMode = (data.readInt() != 0); boolean persistent = (data.readInt() != 0); Configuration config = Configuration.CREATOR.createFromParcel(data); CompatibilityInfo compatInfo = CompatibilityInfo.CREATOR.createFromParcel(data); HashMap&lt;String, IBinder&gt; services = data.readHashMap(null); Bundle coreSettings = data.readBundle(); bindApplication(packageName, info, providers, testName, profilerInfo, testArgs, testWatcher, uiAutomationConnection, testMode, enableBinderTracking, trackAllocation, restrictedBackupMode, persistent, config, compatInfo, services, coreSettings); return true; &#125;&#125; 1234567891011121314151617public final void bindApplication(String processName, ApplicationInfo appInfo, List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName, ProfilerInfo profilerInfo, Bundle instrumentationArgs, IInstrumentationWatcher instrumentationWatcher, IUiAutomationConnection instrumentationUiConnection, int debugMode, boolean enableBinderTracking, boolean trackAllocation, boolean isRestrictedBackupMode, boolean persistent, Configuration config, CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services, Bundle coreSettings) &#123; data.restrictedBackupMode = isRestrictedBackupMode; data.persistent = persistent; data.config = config; data.compatInfo = compatInfo; data.initProfilerInfo = profilerInfo; sendMessage(H.BIND_APPLICATION, data);&#125; 12345case BIND_APPLICATION: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;bindApplication&quot;); AppBindData data = (AppBindData)msg.obj; handleBindApplication(data); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); 1234567891011private void handleBindApplication(AppBindData data) &#123; // If the app is being launched for full backup or restore, bring it up in // a restricted environment with the base application class. Application app = data.info.makeApplication(data.restrictedBackupMode, null); mInitialApplication = app; mInstrumentation.callApplicationOnCreate(app); //调用Application的create方法 &#125; 1234567891011121314151617181920212223242526public Application makeApplication(boolean forceDefaultAppClass, Instrumentation instrumentation) &#123; if (mApplication != null) &#123; return mApplication; &#125; Application app = null; String appClass = mApplicationInfo.className; if (forceDefaultAppClass || (appClass == null)) &#123; appClass = &quot;android.app.Application&quot;; &#125; try &#123; java.lang.ClassLoader cl = getClassLoader(); if (!mPackageName.equals(&quot;android&quot;)) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;initializeJavaContextClassLoader&quot;); initializeJavaContextClassLoader(); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this); app = mActivityThread.mInstrumentation.newApplication( cl, appClass, appContext); appContext.setOuterContext(app);&#125; LaunchActivity1234567891011121314151617181920212223242526272829303132333435// we use token to identify this activity without having to send the // activity itself back to the activity manager. (matters more with ipc) @Override public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123; ActivityClientRecord r = new ActivityClientRecord(); r.token = token; r.ident = ident; r.intent = intent; r.referrer = referrer; r.voiceInteractor = voiceInteractor; r.activityInfo = info; r.compatInfo = compatInfo; r.state = state; r.persistentState = persistentState; r.pendingResults = pendingResults; r.pendingIntents = pendingNewIntents; r.startsNotResumed = notResumed; r.isForward = isForward; r.profilerInfo = profilerInfo; r.overrideConfig = overrideConfig; updatePendingConfiguration(curConfig); sendMessage(H.LAUNCH_ACTIVITY, r); &#125; 12345678910111213public void handleMessage(Message msg) &#123; if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what)); switch (msg.what) &#123; case LAUNCH_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;); final ActivityClientRecord r = (ActivityClientRecord) msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) &#123; //通过Activity所在的应用程序信息及该Activity对应的CompatibilityInfo信息从PMS服务中查询当前Activity的包信息 ActivityInfo aInfo = r.activityInfo; if (r.packageInfo == null) &#123; r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE); &#125; //获取当前Activity的组件信息 ComponentName component = r.intent.getComponent(); if (component == null) &#123; component = r.intent.resolveActivity( mInitialApplication.getPackageManager()); r.intent.setComponent(component); &#125; //packageName为启动Activity的包名，targetActivity为Activity的类名 if (r.activityInfo.targetActivity != null) &#123; component = new ComponentName(r.activityInfo.packageName, r.activityInfo.targetActivity); &#125; //通过类反射方式加载即将启动的Activity Activity activity = null; try &#123; java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; ...... try &#123; //通过单例模式为应用程序进程创建Application对象 Application app = r.packageInfo.makeApplication(false, mInstrumentation); ...... if (activity != null) &#123; //为当前Activity创建上下文对象ContextImpl Context appContext = createBaseContextForActivity(r, activity); ...... //将当前启动的Activity和上下文ContextImpl、Application绑定 activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window); ...... //将Activity保存到ActivityClientRecord中，ActivityClientRecord为Activity在应用程序进程中的描述符 r.activity = activity; activity.mCalled = false; if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; ...... //生命周期onStart、onresume if (!r.activity.mFinished) &#123; activity.performStart(); r.stopped = false; &#125; //ActivityThread的成员变量mActivities保存了当前应用程序进程中的所有Activity的描述符 mActivities.put(r.token, r); ...... return activity;&#125; 在上述方法中将调用performLaunchActivity来启动Activity，如下 应用程序进程通过performLaunchActivity函数将即将要启动的Activity加载到当前进程空间来，同时为启动Activity做准备。 [ActivityThread.java #performLaunchActivity()] 123456789101112private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; //用类加载器来创建该Activity的实例 activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent);&#125; public Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; return (Activity)cl.loadClass(className).newInstance(); &#125; 解决问题Application Activity创建流程 Launch app启动问题 https://juejin.im/post/5baf275f5188255c9a7740ba","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[{"name":"AOSP","slug":"AOSP","permalink":"http://noteforme.github.io.com/tags/AOSP/"}],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"JVM_HEAP","slug":"JVM-HEAP","date":"2020-01-06T09:37:17.000Z","updated":"2021-08-19T11:11:43.983Z","comments":true,"path":"2020/01/06/JVM-HEAP/","link":"","permalink":"http://noteforme.github.io.com/2020/01/06/JVM-HEAP/","excerpt":"","text":"堆内存细分现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为： Java7 及之前堆内存逻辑上分为三部分：新生区+养老区+永久区 Young Generation Space 新生区 Young/New 又被划分为Eden区和Survivor区 Old generation space 养老区 Old/Tenure Permanent Space 永久区 Perm Java 8及之后堆内存逻辑上分为三部分：新生区+养老区+元空间 Young Generation Space 新生区，又被划分为Eden区和Survivor区 Old generation space 养老区 Meta Space 元空间 Meta 约定：新生区 &lt;–&gt; 新生代 &lt;–&gt; 年轻代 、 养老区 &lt;–&gt; 老年区 &lt;–&gt; 老年代、 永久区 &lt;–&gt; 永久代 堆空间内部结构，JDK1.8之前从永久代 替换成 元空间 堆是分配对象的唯一选择么？在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述： 随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。 在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。 此外，前面提到的基于OpenJDK深度定制的TaoBao VM，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。 逃逸分析 如何将堆上的对象分配到栈，需要使用逃逸分析手段。 这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。 通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。 逃逸分析的基本行为就是分析对象动态作用域： 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。 逃逸分析举例 1、没有发生逃逸的对象，则可以分配到栈（无线程安全问题）上，随着方法执行的结束，栈空间就被移除（也就无需GC） 123456public void my_method() &#123; V v = new V(); // use v // .... v = null;&#125; 2、下面代码中的 StringBuffer sb 发生了逃逸，不能在栈上分配 123456public static StringBuffer createStringBuffer(String s1, String s2) &#123; StringBuffer sb = new StringBuffer(); sb.append(s1); sb.append(s2); return sb;&#125; 3、如果想要StringBuffer sb不发生逃逸，可以这样写 123456public static String createStringBuffer(String s1, String s2) &#123; StringBuffer sb = new StringBuffer(); sb.append(s1); sb.append(s2); return sb.toString();&#125; 12345678910111213141516171819202122232425262728293031323334353637/** * 逃逸分析 * * 如何快速的判断是否发生了逃逸分析，大家就看new的对象实体是否有可能在方法外被调用。 */public class EscapeAnalysis &#123; public EscapeAnalysis obj; /* 方法返回EscapeAnalysis对象，发生逃逸 */ public EscapeAnalysis getInstance()&#123; return obj == null? new EscapeAnalysis() : obj; &#125; /* 为成员属性赋值，发生逃逸 */ public void setObj()&#123; this.obj = new EscapeAnalysis(); &#125; //思考：如果当前的obj引用声明为static的？仍然会发生逃逸。 /* 对象的作用域仅在当前方法中有效，没有发生逃逸 */ public void useEscapeAnalysis()&#123; EscapeAnalysis e = new EscapeAnalysis(); &#125; /* 引用成员变量的值，发生逃逸 */ public void useEscapeAnalysis1()&#123; EscapeAnalysis e = getInstance(); //getInstance().xxx()同样会发生逃逸 &#125;&#125; 逃逸分析参数设置 在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析 如果使用的是较早的版本，开发人员则可以通过： 选项“-XX:+DoEscapeAnalysis”显式开启逃逸分析 通过选项“-XX:+PrintEscapeAnalysis”查看逃逸分析的筛选结果 总结 开发中能使用局部变量的，就不要使用在方法外定义。 代码优化使用逃逸分析，编译器可以对代码做如下优化： 栈上分配：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配 同步省略：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。 分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://noteforme.github.io.com/tags/JVM/"}],"keywords":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}]},{"title":"Java_List","slug":"Java-List","date":"2020-01-05T13:50:30.000Z","updated":"2021-08-19T11:11:44.086Z","comments":true,"path":"2020/01/05/Java-List/","link":"","permalink":"http://noteforme.github.io.com/2020/01/05/Java-List/","excerpt":"","text":"Java List source analysis List &lt;– ArrayList LinkedList ArrayList ```ArrayList arrayList = new ArrayList&lt;&gt;(); 12345 得到一个object数组 `private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;`source public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } 12342. ``` arrayList.add(1); arrayList.add(2); source 1234567891011public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125; private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); &#125; 先看看calculateCapacity 123456789private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;private static final int DEFAULT_CAPACITY = 10;private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity;&#125; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) minCapacity==10 ensureExplicitCapacity() 1234567891011121314151617181920private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125; private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; 添加arrayList.add(1);时，size 为10的数组， elementData[size++] = e; 注意size初始化值==0，程序先 执行elementData[0]=1,然后是size++; 当添加的数是11时， int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);开始执行 10 + 1010&gt;&gt;1 = 10+5,申请了5个空间 然后get()可以获取element 源码简写 123456789int size =0;Object[] elementData= &#123;&#125;;Object[] elementArr = Arrays.copyOf(elementData, 10);elementArr[size++] = 5;elementArr[size++] = 7;for ( Object el :elementArr)&#123; System.out.print(el+&quot; &quot;);&#125;System.out.println(elementArr[0]); LinkedList 源码功能如图所示 1234567891011121314151617181920212223void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++;&#125;private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125; List iterator List crunchifyList = new ArrayList(); ​ // add 4 different values to list ​ crunchifyList.add(“Facebook”); ​ crunchifyList.add(“Paypal”); ​ crunchifyList.add(“Google”); ​ crunchifyList.add(“Yahoo”); ​ // Other way to define list is - we will not use this list :) ​ List crunchifyListNew = Arrays.asList(“Facebook”, “Paypal”, “Google”, “Yahoo”); ​ Iterator - Returns an iterator over the elements in this list in proper sequence. 1234567Iterator&lt;String&gt; crunchifyIterator = crunchifyList.iterator(); while(crunchifyIterator.hasNext()) &#123; System.out.println(crunchifyIterator.next()); &#125; // ListIterator - traverse a list of elements in either forward or backward order ​ // An iterator for lists that allows the programmer to traverse the list in either direction, modify the list during iteration, ​ // and obtain the iterator’s current position in the list. 1234ListIterator&lt;String&gt; crunchifyListIterator = crunchifyList.listIterator(); while (crunchifyListIterator.hasNext()) &#123; System.out.println(crunchifyListIterator.next()); &#125; Iterable.forEach() util: Returns a sequential Stream with this collection as its source 12345crunchifyList.forEach((temp) -&gt; &#123; System.out.println(temp); &#125;); collection Stream.forEach() util: Returns a sequential Stream with this collection as its source 1crunchifyList.stream().forEach((crunchifyTemp) -&gt; System.out.println(crunchifyTemp)); List use in kotlin1var mPatientList = patientList.filter &#123; it.patientCode == patientCode &#125; 123return mQnList?.let &#123; it -&gt; it.filter &#123; it.type == type &#125;.map &#123; it.value &#125;&#125;","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}],"tags":[],"keywords":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}]},{"title":"JVM_METHOD","slug":"JVM-METHOD","date":"2020-01-04T14:27:53.000Z","updated":"2021-08-19T11:11:43.988Z","comments":true,"path":"2020/01/04/JVM-METHOD/","link":"","permalink":"http://noteforme.github.io.com/2020/01/04/JVM-METHOD/","excerpt":"","text":"对象的访问定位 Person类的.class信息存放在 方法区中 person变量存放在Java栈的局部变量表中 Person对象存放在Java堆中 在Person堆中，有个指针指向方法区的person类型数据,表示person对象是方法区中的Person类New出来的. 内存布局总结 123456789101112131415161718public class Customer&#123; int id = 1001; String name; Account acct; &#123; name = &quot;匿名客户&quot;; &#125; public Customer()&#123; acct = new Account(); &#125; public static void main(String[] args) &#123; Customer cust = new Customer(); &#125;&#125;class Account&#123;&#125; 图解内存布局 原子性(Atomicity)​ 由 J a v a 内 存 模 型 来 直 接 保 证 的 原 子 性 变 量 操 作 包 括 r e a d 、 l o a d 、 a s s i gn 、 u s e 、 s t o r e 和 w r i t e 这 六 个 ， 我们大致可以认为，基本数据类型的访问、读写都是具备原子性的(例外就是long和double的非原子性 协定，读者只要知道这件事情就可以了，无须太过在意这些几乎不会发生的例外情况)。 如果应用场景需要一个更大范围的原子性保证(经常会遇到)，Java内存模型还提供了lock和 unlock操作来满足这种需求，尽管虚拟机未把lock和unlock操作直接开放给用户使用，但是却提供了更 高 层 次 的 字 节 码 指 令 m o n i t o r e n t e r 和 m o n i t o r e xi t 来 隐 式 地 使 用 这 两 个 操 作 。 这 两 个 字 节 码 指 令 反 映 到 J a v a 代码中就是同步块——synchronized关键字，因此在synchronized块之间的操作也具备原子性。 long 和 double 的原子性在前面，我们讲述了 long 和 double 和其他的基本类型不太一样，好像不具备原子性，这是什么原因造成的呢？ ​ long 和 double 的值需要占用 64 位的内存空间，而对于 64 位值的写入，可以分为两个 32 位的操作来进行。 这样一来，本来是一个整体的赋值操作，就可能被拆分为低 32 位和高 32 位的两个操作。如果在这两个操作之间发生了其他线程对这个值的读操作，就可能会读到一个错误、不完整的值。 可 见 性 ( Vi s i b i l i t y )可见性就是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。上文在讲解 volat ile变量的时候我们已详细讨论过这一点。Java内存模型是通过在变量修改后将新值同步回主内 存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是 普通变量还是volat ile变量都是如此。普通变量与volat ile变量的区别是，volat ile的特殊规则保证了新值 能立即同步到主内存，以及每次使用前立即从主内存刷新。因此我们可以说volat ile保证了多线程操作 时变量的可见性，而普通变量则不能保证这一点。 能立即同步到主内存 ？？ 感觉也有问题 示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 描述： 演示可见性带来的问题 */public class VisibilityProblem &#123; int a = 10; int b = 20; private void change() &#123; a = 30; b = a; &#125; private void print() &#123; System.out.println(&quot;b=&quot; + b + &quot;;a=&quot; + a); &#125; public static void main(String[] args) &#123; while (true) &#123; VisibilityProblem problem = new VisibilityProblem(); new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; problem.change(); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; problem.print(); &#125; &#125;).start(); &#125; &#125;&#125; 会出现 b = 30;a = 30 b = 20;a = 10 b = 20;a = 30 还会有一种情况 b = 30;a = 10, 这种情况就会有可见性问题,a 的值已经被第 1 个线程修改了，但是其他线程却看不到，由于 a 的最新值却没能及时同步过来，所以才会打印出 a 的旧值。 主内存和工作内存的关系CPU 有多级缓存，导致读的数据过期,由于 CPU 的处理速度很快，相比之下，内存的速度就显得很慢，所以为了提高 CPU 的整体运行效率，减少空闲时间，在 CPU 和内存之间会有 cache 层，也就是缓存层的存在。虽然缓存的容量比内存小，但是缓存的速度却比内存的速度要快得多，其中 L1 缓存的速度仅次于寄存器的速度 越靠近核心，其容量就越小，但是速度也越快. 线程可见性问题的实质线程间对于共享变量的可见性问题，并不是直接由多核引起的，而是由我们刚才讲到的这些 L3 缓存、L2 缓存、L1 缓存，也就是多级缓存引起的：每个核心在获取数据时，都会将数据从内存一层层往上读取，同样，后续对于数据的修改也是先写入到自己的 L1 缓存中，然后等待时机再逐层往下同步，直到最终刷回内存。 假设 core 1 修改了变量 a 的值，并写入到了 core 1 的 L1 缓存里，但是还没来得及继续往下同步，由于 core 1 有它自己的的 L1 缓存，core 4 是无法直接读取 core 1 的 L1 缓存的值的，那么此时对于 core 4 而言，变量 a 的值就不是 core 1 修改后的最新的值，core 4 读取到的值可能是一个过期的值，从而引起多线程时可见性问题的发生。 什么是主内存和工作内存Java 作为高级语言，屏蔽了 L1 缓存、L2 缓存、L3 缓存(可以看作 工作内存)，也就是多层缓存的这些底层细节，用 JMM 定义了一套读写数据的规范。我们不再需要关心 L1 缓存、L2 缓存、L3 缓存等多层缓存的问题，我们只需要关心 JMM 抽象出来的主内存和工作内存的概念。 每个线程只能够直接接触到工作内存，无法直接操作主内存，而工作内存中所保存的正是主内存的共享变量的副本，主内存和工作内存之间的通信是由 JMM 控制的。 JMM 有以下规定： （1）所有的变量都存储在主内存中，同时每个线程拥有自己独立的工作内存，而工作内存中的变量的内容是主内存中该变量的拷贝； （2）线程不能直接读 / 写主内存中的变量，但可以操作自己工作内存中的变量，然后再同步到主内存中，这样，其他线程就可以看到本次修改； （3） 主内存是由多个线程所共享的，但线程间不共享各自的工作内存，如果线程间需要通信，则必须借助主内存中转来完成。 https://kaiwu.lagou.com/course/courseInfo.htm?courseId=16#/detail/pc?id=298 指令重排序假设我们写了一个 Java 程序，包含一系列的语句，我们会默认期望这些语句的实际运行顺序和写的代码顺序一致。但实际上，编译器、JVM 或者 CPU 都有可能出于优化等目的，对于实际指令执行的顺序进行调整，这就是重排序。 重排序的好处 左侧 3 行 Java 代码，右侧是这 3 行代码可能被转化成的指令。可以看出 a = 100 对应的是 Load a、Set to 100、Store a，意味着从主存中读取 a 的值，然后把值设置为 100，并存储回去，同理， b = 5 对应的是下面三行 Load b、Set to 5、Store b，最后的 a = a + 10，对应的是 Load a、Set to 110、Store a。如果你仔细观察，会发现这里有两次“Load a”和两次“Store a”，说明存在一定的重排序的优化空间。 重排序后， a 的两次操作被放到一起，指令执行情况变为 Load a、Set to 100、Set to 110、 Store a。下面和 b 相关的指令不变，仍对应 Load b、 Set to 5、Store b。 可以看出，重排序后 a 的相关指令发生了变化，节省了一次 Load a 和一次 Store a。重排序通过减少执行指令，从而提高整体的运行速度，这就是重排序带来的优化和好处。 重排序的 3 种情况下面我们来看一下重排序的 3 种情况。 （1）编译器优化 编译器（包括 JVM、JIT 编译器等）出于优化的目的，例如当前有了数据 a，把对 a 的操作放到一起效率会更高，避免读取 b 后又返回来重新读取 a 的时间开销，此时在编译的过程中会进行一定程度的重排。不过重排序并不意味着可以任意排序，它需要需要保证重排序后，不改变单线程内的语义，否则如果能任意排序的话，程序早就逻辑混乱了。 （2）CPU 重排序 CPU 同样会有优化行为，这里的优化和编译器优化类似，都是通过乱序执行的技术来提高整体的执行效率。所以即使之前编译器不发生重排，CPU 也可能进行重排，我们在开发中，一定要考虑到重排序带来的后果。 （3） 内存的“重排序” 内存系统内不存在真正的重排序，但是内存会带来看上去和重排序一样的效果，所以这里的“重排序”打了双引号。由于内存有缓存的存在，在 JMM 里表现为主存和本地内存，而主存和本地内存的内容可能不一致，所以这也会导致程序表现出乱序的行为。 https://kaiwu.lagou.com/course/courseInfo.htm?courseId=16#/detail/pc?id=295","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://noteforme.github.io.com/tags/JVM/"}],"keywords":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}]},{"title":"flutter_begin","slug":"flutter-begin","date":"2020-01-04T05:46:38.000Z","updated":"2021-09-03T15:34:37.446Z","comments":true,"path":"2020/01/04/flutter-begin/","link":"","permalink":"http://noteforme.github.io.com/2020/01/04/flutter-begin/","excerpt":"","text":"环境变量 bash_profile ~/.bash_profile 123456export PATH=/Users/m/development/flutter/bin:$PATHexport ANDROID_HOME=&quot;/Users/m/Library/Android/sdk&quot;export PATH=$&#123;PATH&#125;:$&#123;ANDROID_HOME&#125;/toolsexport PATH=$&#123;PATH&#125;:$&#123;ANDROID_HOME&#125;/platform-toolsexport PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn ~/.zshrc ，在其中添加：source ~/.bash_profile Project struct -&gt; Modules -&gt; no sdk 选择 https://mp.weixin.qq.com/s/YfzcvebruRk4LJRTQFVDXA https://github.com/toly1994328/FlutterUnit build apk出错解决: rm /Users/john/development/flutter/bin/cache A problem occurred evaluating root project ‘agora_rtm’. Could not get unknown property ‘kotlin_version’ for object of type org.gradle.api.internal.artifacts.dsl.dependencies.DefaultDependencyHandler. 版本配置 /Users/***/flutter/.pub-cache/hosted/pub.flutter-io.cn/cipher2-xxxx/android/build.gradle’ , ext.kotlin_version = 1.3.10 Users/john/.pub-cache/hosted/pub.flutter-io.cn/agora_rtm-0.9.9/android/build.gradle’ https://blog.csdn.net/weixin_44416513/article/details/90298303 WidgetText1234567891011121314151617181920212223class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: &#x27;Text widget&#x27;, home: Scaffold( body: Center( child: Text( &#x27;Hello JSPang ,非常喜欢前端，并且愿意为此奋斗一生。我希望可以出1000集免费教程。&#x27;, textAlign: TextAlign.left, overflow: TextOverflow.ellipsis, maxLines: 1, style: TextStyle( fontSize: 25.0, color: Color.fromARGB(255, 255, 150, 150), decoration: TextDecoration.underline, decorationStyle: TextDecorationStyle.solid, ), )), ), ); &#125;&#125; Image1234567891011121314151617181920212223class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; // TODO: implement build // TODO: implement createState return MaterialApp( title: &quot;Text WIDGET&quot;, home: Scaffold( body: Center( child: Container( child: new Image.network( &#x27;http://blogimages.jspang.com/blogtouxiang1.jpg&#x27;, repeat: ImageRepeat.repeatY, ), width: 300, height: 200, color: Colors.lightBlue, ), ), ), ); &#125;&#125; ListView 横向 123456789101112131415161718192021222324252627282930313233343536373839class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: &#x27;JSPang Flutter Demo&#x27;, home: Scaffold( appBar: AppBar(title: Text(&#x27;ListView Widget&#x27;)), body: Center( child: Container( height: 200, child: MyListView(), ), ), )); &#125;&#125;class MyListView extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return ListView( scrollDirection: Axis.horizontal, children: &lt;Widget&gt;[ Container( width: 180, color: Colors.amber, ), Container( width: 180, color: Colors.lightBlue, ), Container( width: 180, color: Colors.deepPurpleAccent, ), ], ); &#125;&#125; 动态数据 123456789101112131415161718192021class MyApp extends StatelessWidget &#123; final List&lt;String&gt; items; MyApp(&#123;@required this.items&#125;) : super(); @override Widget build(BuildContext context) &#123; return MaterialApp( title: &#x27;JSPang Flutter Demo&#x27;, home: Scaffold( appBar: AppBar(title: Text(&#x27;ListView Widget&#x27;)), body: ListView.builder( itemCount: items.length, itemBuilder: (context,index)&#123; return ListTile( title: Text(&#x27;$&#123;items[index]&#125;&#x27;), ); &#125;, ))); &#125;&#125; gridview 1234567891011121314151617181920212223class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: &#x27;JSPang Flutter Demo&#x27;, home: Scaffold( appBar: AppBar(title: Text(&#x27;ListView Widget&#x27;)), body: GridView.count( padding: EdgeInsets.all(20), crossAxisSpacing: 10, crossAxisCount: 4, children: &lt;Widget&gt;[ Text(&#x27;I am JOHN&#x27;), Text(&#x27;I am LI&#x27;), Text(&#x27;I am JON&#x27;), Text(&#x27;I am HEHE&#x27;), Text(&#x27;I am LILI&#x27;), Text(&#x27;I am SIYUE&#x27;), Text(&#x27;I am QIQI&#x27;), ], ))); &#125;&#125; row 固定 123456789101112131415161718192021222324252627282930313233class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return MaterialApp( title: &#x27;Row Widget Demo&#x27;, home: Scaffold( appBar: AppBar( title: Text(&quot;水平方向布局&quot;), ), body: Row( children: &lt;Widget&gt;[ RaisedButton( onPressed: () &#123;&#125;, color: Colors.amber, child: Text(&#x27;red Button&#x27;), ), RaisedButton( onPressed: () &#123;&#125;, color: Colors.lightBlue, child: Text(&#x27;lightBlue Button&#x27;), ), RaisedButton( onPressed: () &#123;&#125;, color: Colors.redAccent, child: Text(&#x27;redAccent Button&#x27;), ), ] ), ), ); &#125;&#125; 不固定 12345678910111213141516171819202122232425262728293031323334353637class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return MaterialApp( title: &#x27;Row Widget Demo&#x27;, home: Scaffold( appBar: AppBar( title: Text(&quot;水平方向布局&quot;), ), body: Row(children: &lt;Widget&gt;[ Expanded( child: RaisedButton( onPressed: () &#123;&#125;, color: Colors.lightBlue, child: Text(&#x27;lightBlue Button&#x27;), ), ), Expanded( child: RaisedButton( onPressed: () &#123;&#125;, color: Colors.redAccent, child: Text(&#x27;redAccent Button&#x27;), ), ), Expanded( child: RaisedButton( onPressed: () &#123;&#125;, color: Colors.deepPurpleAccent, child: Text(&#x27;deepPurpleAccent Button&#x27;), ), ), ]), ), ); &#125;&#125; coloumn12345678910111213141516171819202122232425262728class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return MaterialApp( title: &#x27;Column Widget Demo&#x27;, home: Scaffold( appBar: AppBar( title: Text(&quot;水平方向布局&quot;), ), body: Column( crossAxisAlignment: CrossAxisAlignment.center, mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Text(&#x27;I am JOHN&#x27;), Text(&#x27;I am LI&#x27;), Text(&#x27;I am JON I am JON I am JON&#x27;), Text(&#x27;I am HEHE&#x27;), Text(&#x27;I am LILI&#x27;), Text(&#x27;I am SIYUE&#x27;), Text(&#x27;I am QIQI&#x27;), ], ), ), ); &#125;&#125; CrossAxisAlignment 相对于最长的布局 StackWidget1234567891011121314151617181920212223242526272829class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; var stack = Stack( alignment: FractionalOffset(0.5,0.8), children: &lt;Widget&gt;[ CircleAvatar( backgroundImage: NetworkImage(&#x27;http://blogimages.jspang.com/blogtouxiang1.jpg&#x27;), radius: 100, ), Container( decoration: BoxDecoration(color: Colors.blue), padding: EdgeInsets.all(5), child: Text(&quot;I am JON&quot;), ) ], ); return MaterialApp( title: &#x27;Column Widget Demo&#x27;, home: Scaffold( appBar: AppBar( title: Text(&quot;水平方向布局&quot;), ), body:Center(child: stack), ), ); &#125;&#125; FractionalOffset 0-1 相对于当前容器的 X Y轴 Position Widget12345678910111213141516171819202122232425262728293031323334353637383940class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; var stack = Stack( alignment: FractionalOffset(0.1, 0.5), children: &lt;Widget&gt;[ CircleAvatar( backgroundImage: NetworkImage(&#x27;http://blogimages.jspang.com/blogtouxiang1.jpg&#x27;), radius: 100, ), Positioned( top: 10, left: 60, child: Text(&quot;I am JON&quot;), ), Positioned( bottom: 10, right: 10, child: Text( &quot;I am JON&quot;, style: TextStyle(fontSize: 25, color: Colors.lightBlue), ), ), ], ); return MaterialApp( title: &#x27;Column Widget Demo&#x27;, home: Scaffold( appBar: AppBar( title: Text( &quot;水平方向布局&quot;, style: TextStyle(fontSize: 25, color: Colors.redAccent), ), ), body: Center(child: stack), ), ); &#125;&#125; Positioned 相对于当前容器 padding? card123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; var card = new Card( child: Column( children: &lt;Widget&gt;[ ListTile( title: Text( &quot;上海市 高兴区&quot;, style: TextStyle(fontWeight: FontWeight.w500), ), subtitle: Text(&quot;john 182929739933&quot;), leading: Icon( Icons.account_box, color: Colors.lightBlue, ), ), Divider(), ListTile( title: Text( &quot;北京市 高兴区&quot;, style: TextStyle(fontWeight: FontWeight.w500), ), subtitle: Text(&quot;elon 182929739933&quot;), leading: Icon( Icons.account_box, color: Colors.lightBlue, ), ), Divider(), ListTile( title: Text( &quot;江西省 高兴区&quot;, style: TextStyle(fontWeight: FontWeight.w500), ), subtitle: Text(&quot;lari 182929739933&quot;), leading: Icon( Icons.account_box, color: Colors.lightBlue, ), ), ], ), ); return MaterialApp( title: &quot;Row Widget Demo&quot;, home: Scaffold( appBar: AppBar( title: Text(&#x27;Card布局&#x27;), ), body: Center( child: card, ), )); &#125;&#125; 页面跳转1234567891011121314151617181920212223242526272829303132333435363738class FirstScreen extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return Scaffold( appBar: AppBar(title: Text(&#x27;导航页面&#x27;)), body: Center( child: RaisedButton( child: Text(&#x27;查看商品详情页&#x27;), onPressed: () &#123; Navigator.push(context, MaterialPageRoute(builder: (context) =&gt; new SecondScreen())); &#125;, ), ), ); &#125;&#125;class SecondScreen extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return Scaffold( appBar: AppBar( title: Text(&#x27;导航商品详情页&#x27;), ), body: Center( child: RaisedButton( child: Text(&#x27;返回&#x27;), onPressed: ()&#123; Navigator.pop(context); &#125;, ), ), ); &#125;&#125; 列表传参1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859void main() =&gt; runApp(MaterialApp( title: &quot;列表数据传递&quot;, home: ProductList( products: List.generate(20, (i) =&gt; Product(&#x27; 商品 $i&#x27;, &#x27;这是一个商品详情， 编号: $i&#x27;)))));class ProductList extends StatelessWidget &#123; final List&lt;Product&gt; products; ProductList(&#123;this.products&#125;) : super(); @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(&#x27;商品列表&#x27;), ), body: ListView.builder( itemCount: products.length, itemBuilder: (context, index) &#123; return ListTile( title: Text(products[index].title), onTap: () &#123; Navigator.push( context, MaterialPageRoute( builder: (context) =&gt; ProductDetail(product: products[index]))); &#125;, ); &#125;), ); &#125;&#125;class Product &#123; final String title; final String description; Product(this.title, this.description);&#125;class ProductDetail extends StatelessWidget &#123; final Product product; ProductDetail(&#123;this.product&#125;) : super(); @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(&#x27;$&#123;product.title&#125;&#x27;), ), body: Center( child: Text(&#x27;$&#123;product.description&#125;&#x27;), ), ); &#125;&#125; 跳转返回1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class FirstPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(&#x27;小姐姐要电话&#x27;), ), body: Center( child: RouteButton(), ), ); &#125;&#125;class RouteButton extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return RaisedButton( onPressed: () &#123; _navigateToXiaoJIe(context); &#125;, child: Text(&#x27;找小姐姐&#x27;), ); &#125;&#125;_navigateToXiaoJIe(BuildContext context) async &#123; final result = await Navigator.push( context, MaterialPageRoute(builder: (context) =&gt; XiaoJieJie())); Scaffold.of(context).showSnackBar(SnackBar( content: Text(&#x27;$result&#x27;), ));&#125;class XiaoJieJie extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return Scaffold( appBar: AppBar( title: Text(&#x27;我是小姐姐&#x27;), ), body: Center( child: Column( children: &lt;Widget&gt;[ RaisedButton( child: Text(&#x27;可爱小姐姐&#x27;), onPressed: () &#123; Navigator.pop(context, &#x27;可爱小姐姐 1550008883&#x27;); &#125;, ), RaisedButton( child: Text(&#x27;漂亮小姐姐&#x27;), onPressed: () &#123; Navigator.pop(context, &#x27;漂亮小姐姐 1550009983&#x27;); &#125;, ), ], ), ), ); &#125;&#125;","categories":[{"name":"flutter","slug":"flutter","permalink":"http://noteforme.github.io.com/categories/flutter/"}],"tags":[],"keywords":[{"name":"flutter","slug":"flutter","permalink":"http://noteforme.github.io.com/categories/flutter/"}]},{"title":"JVM_STACK","slug":"JVM-STACK","date":"2020-01-04T03:28:39.000Z","updated":"2021-08-19T11:11:44.020Z","comments":true,"path":"2020/01/04/JVM-STACK/","link":"","permalink":"http://noteforme.github.io.com/2020/01/04/JVM-STACK/","excerpt":"","text":"字节码指令运行 https://www.bilibili.com/video/BV1PJ411n7xZ?p=49 虚拟机栈虚拟机栈的出现背景 由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的【如果设计成基于寄存器的，耦合度高，性能会有所提升，因为可以对具体的CPU架构进行优化，但是跨平台性大大降低】。 优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。 内存中的栈与堆 首先栈是运行时的单位，而堆是存储的单位。 即：栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放，放哪里 虚拟机栈基本内容 Java虚拟机栈是什么？ Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用，栈是线程私有的 12345678910111213141516171819public class StackTest &#123; public static void main(String[] args) &#123; StackTest test = new StackTest(); test.methodA(); &#125; public void methodA() &#123; int i = 10; int j = 20; methodB(); &#125; public void methodB()&#123; int k = 30; int m = 40; &#125;&#125; 虚拟机栈的生命周期 生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了 虚拟机栈的作用 主管Java程序的运行，它保存方法的局部变量（8 种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回。 局部变量，它是相比于成员变量来说的（或属性） 基本数据类型变量 VS 引用类型变量（类、数组、接口） ​ 虚拟机栈的特点 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。 JVM直接对Java栈的操作只有两个： 每个方法执行，伴随着进栈（入栈、压栈） 执行结束后的出栈工作 对于栈来说不存在垃圾回收问题 栈不需要GC，但是可能存在OOM 虚拟机栈的异常面试题：栈中可能出现的异常？ Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。 如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个StackoverflowError 异常。 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 OutofMemoryError 异常。 设置栈内存大小我们可以使用参数 -Xss 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。 Sets the thread stack size (in bytes). Append the letter k or K to indicate KB, m or M to indicate MB, and g or G to indicate GB. The default value depends on the platform: Linux/x64 (64-bit): 1024 KB macOS (64-bit): 1024 KB Oracle Solaris/x64 (64-bit): 1024 KB Windows: The default value depends on virtual memory The following examples set the thread stack size to 1024 KB in different units: 123-Xss1m-Xss1024k-Xss1048576 12345678public class StackErrorTest &#123; private static int count = 1; public static void main(String[] args) &#123; System.out.println(count); count++; main(args); &#125;&#125; 没设置参数前 部分输出结果： 12345114041140511406Exception in thread &quot;main&quot; java.lang.StackOverflowError at sun.nio.cs.UTF_8$Encoder.encodeLoop(UTF_8.java:691) 说明栈在11406这个深度溢出了 12345247424752476Exception in thread &quot;main&quot; java.lang.StackOverflowError at sun.nio.cs.UTF_8.updatePositions(UTF_8.java:77) 栈的存储单位栈中存储什么？ 每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在 在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。 栈运行原理 JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循先进后出（后进先出）原则 在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的。这个栈帧被称为当前栈帧（Current Frame），与当前栈帧相对应的方法就是当前方法（Current Method），定义这个方法的类就是当前类（Current Class） 执行引擎运行的所有字节码指令只针对当前栈帧进行操作。 如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。 不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。 如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。 Java方法有两种返回函数的方式。 一种是正常的函数返回，使用return指令。 另一种是方法执行中出现未捕获处理的异常，以抛出异常的方式结束。 但不管使用哪种方式，都会导致栈帧被弹出。 栈帧的内部结构每个栈帧中存储着： 局部变量表（Local Variables） 操作数栈（Operand Stack）（或表达式栈） 动态链接（Dynamic Linking）（或指向运行时常量池的方法引用） 方法返回地址（Return Address）（或方法正常退出或者异常退出的定义） 一些附加信息 并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表 和 操作数栈决定的 局部变量表 局部变量表也被称之为局部变量数组或本地变量表 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress返回值类型。 由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题 局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。 方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。 对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。 进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。 局部变量表中的变量只在当前方法调用中有效。 在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。 当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class LocalVariablesTest &#123; private int count = 0; public static void main(String[] args) &#123; LocalVariablesTest test = new LocalVariablesTest(); int num = 10; test.test1(); &#125; //练习： public static void testStatic()&#123; LocalVariablesTest test = new LocalVariablesTest(); Date date = new Date(); int count = 10; System.out.println(count); //因为this变量不存在于当前方法的局部变量表中！！// System.out.println(this.count); &#125; //关于Slot的使用的理解 public LocalVariablesTest()&#123; this.count = 1; &#125; public void test1() &#123; Date date = new Date(); String name1 = &quot;atguigu.com&quot;; test2(date, name1); System.out.println(date + name1); &#125; public String test2(Date dateP, String name2) &#123; dateP = null; name2 = &quot;songhongkang&quot;; double weight = 130.5;//占据两个slot char gender = &#x27;男&#x27;; return dateP + name2; &#125; public void test3() &#123; this.count++; &#125; public void test4() &#123; int a = 0; &#123; int b = 0; b = a + 1; &#125; //变量c使用之前已经销毁的变量b占据的slot的位置 int c = a + 1; &#125;&#125; 看完字节码后，可得结论：所以局部变量表所需的容量大小是在编译期确定下来的。 部分详解为了更好讲解，我们直接用jclasslib来看字节码，以main方法为例来讲解。一些一目了然的就不讲了 1、0-15 也就是有16行字节码 2、方法异常信息表 3、Misc 4、行号表 ​ Java代码的行号和字节码指令行号的对应关系 5、注意：生效行数和剩余有效行数都是针对于字节码文件的行数 1、图中圈的东西表示该局部变量的作用域 2、Start PC==11表示在字节码的11行开始生效，也就是Java代码对应的第15行。而声明int num在java代码的是第14行，说明是从声明的下一行开始生效 3、Length== 5表示局部变量剩余有效行数，main方法字节码指令总共有16行，从11行开始生效，那么剩下就是16-11 ==5。 4、Ljava/lang/String 前面的L表示引用类型 关于Slot的理解 参数值的存放总是从局部变量数组索引 0 的位置开始，到数组长度-1的索引结束。 局部变量表，最基本的存储单元是Slot（变量槽），局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。 在局部变量表里， 32位以内的类型只占用一个slot （包括returnAddress类型）， 64位的类型占用两个slot （1ong和double）。 byte、short、char在储存前辈转换为int，boolean也被转换为int，0表示false，非0表示true long和double则占据两个slot JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值 当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个slot上 如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问long或double类型变量） 如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列。（this也相当于一个变量） Slot代码示例this 存放在 index = 0 的位置： 123public void test3() &#123; this.count++;&#125; 局部变量表：this 存放在 index = 0 的位置 64位的类型（1ong和double）占用两个slot 1234567 public String test2(Date dateP, String name2) &#123; dateP = null; name2 = &quot;songhongkang&quot;; double weight = 130.5;//占据两个slot char gender = &#x27;男&#x27;; return dateP + name2;&#125; weight 为 double 类型，index 直接从 3 蹦到了 5 static 无法调用 this this 不存在与 static 方法的局部变量表中，所以无法调用 12345678 public static void testStatic()&#123; LocalVariablesTest test = new LocalVariablesTest(); Date date = new Date(); int count = 10; System.out.println(count); //因为this变量不存在于当前方法的局部变量表中！！// System.out.println(this.count); &#125; Slot的重复利用栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明新的局部变量变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。 123456789public void test4() &#123; int a = 0; &#123; int b = 0; b = a + 1; &#125; //变量c使用之前已经销毁的变量b占据的slot的位置 int c = a + 1;&#125; 静态变量与局部变量的对比12345678变量的分类：1、按照数据类型分：① 基本数据类型 ② 引用数据类型2、按照在类中声明的位置分： 2-1、成员变量：在使用前，都经历过默认初始化赋值 2-1-1、类变量: linking的prepare阶段：给类变量默认赋值 ---&gt; initial阶段：给类变量显式赋值即静态代码块赋值 2-1-2、实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值 2-2、局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过。 参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。 我们知道成员变量有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。 和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。 补充说明 在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。 局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。 操作数栈操作数栈的特点 每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）的 操作数栈，也可以称之为表达式栈（Expression Stack） 操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop） 某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈， 比如：执行复制、交换、求和等操作 操作数栈的作用 操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。 操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这时方法的操作数栈是空的。 每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为maxstack的值。 栈中的任何一个元素都是可以任意的Java数据类型 32bit的类型占用一个栈单位深度 64bit的类型占用两个栈单位深度 操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问。只不过操作数栈是用数组这个结构来实现的而已 如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。 操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。 另外，我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。 局部变量表就相当于食材 操作数栈就相当于做法步骤 操作数栈代码追踪123456789public void testAddOperation() &#123; //byte、short、char、boolean：都以int型来保存 byte i = 15; int j = 8; int k = i + j; // int m = 800;&#125; 对应字节码指令 123456789 0 bipush 15 2 istore_1 3 bipush 8 5 istore_2 6 iload_1 7 iload_2 8 iadd 9 istore_310 return 一步一步看流程1、首先执行第一条语句，PC寄存器指向的是0，也就是指令地址为0，然后使用bipush让操作数15入操作数栈. 2、执行完后，PC寄存器往下移，指向下一行代码，下一行代码就是将操作数栈的元素存储到局部变量表1的位置（istore_1），我们可以看到局部变量表的已经增加了一个元素。并且操作数栈为空了. 解释为什么局部变量表索引从 1 开始，因为该方法为实例方法，局部变量表索引为 0 的位置存放的是 this 3、然后PC下移，指向的是下一行。让操作数8也入栈，同时执行store操作，存入局部变量表中 4、然后从局部变量表中，依次将数据放在操作数栈中，等待执行 add 操作 iload_1：取出局部变量表中索引为1的数据入操作数栈 5、然后将操作数栈中的两个元素执行相加操作，并存储在局部变量表3的位置 5、然后将操作数栈中的两个元素执行相加操作，并存储在局部变量表3的位置 关于类型转换的说明 m改成800之后，byte存储不了，就成了short型，sipush 800 如果被调用的方法带有返回值，返回值入操作数栈 123456789101112public int getSum()&#123; int m = 10; int n = 20; int k = m + n; return k; &#125; public void testGetSum()&#123; //获取上一个栈桢返回的结果，并保存在操作数栈中 int i = getSum(); int j = 10; &#125; getSum() 方法字节码指令：最后带着个 ireturn testGetSum() 方法字节码指令：一上来就加载 getSum() 方法的返回值() ? testGetSum() 方法字节码指令：一上来就加载 getSum() 方法的返回值() 栈顶缓存技术栈顶缓存技术：Top Of Stack Cashing 前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数（也就是你会发现指令很多）和导致内存读/写次数多，效率不高。 由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。 寄存器的主要优点：指令更少，执行速度快，但是指令集（也就是指令种类）很多 动态链接（或指向运行时常量池的方法引用） 每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking），比如：invokedynamic指令 在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用 1234567891011121314151617public class DynamicLinkingTest &#123; int num = 10; public void methodA()&#123; System.out.println(&quot;methodA()....&quot;); &#125; public void methodB()&#123; System.out.println(&quot;methodB()....&quot;); methodA(); num++; &#125;&#125; 对应字节码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114Classfile /F:/IDEAWorkSpaceSourceCode/JVMDemo/out/production/chapter05/com/atguigu/java1/DynamicLinkingTest.class Last modified 2020-11-10; size 712 bytes MD5 checksum e56913c945f897c7ee6c0a608629bca8 Compiled from &quot;DynamicLinkingTest.java&quot;public class com.atguigu.java1.DynamicLinkingTest minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #9.#23 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Fieldref #8.#24 // com/atguigu/java1/DynamicLinkingTest.num:I #3 = Fieldref #25.#26 // java/lang/System.out:Ljava/io/PrintStream; #4 = String #27 // methodA().... #5 = Methodref #28.#29 // java/io/PrintStream.println:(Ljava/lang/String;)V #6 = String #30 // methodB().... #7 = Methodref #8.#31 // com/atguigu/java1/DynamicLinkingTest.methodA:()V #8 = Class #32 // com/atguigu/java1/DynamicLinkingTest #9 = Class #33 // java/lang/Object #10 = Utf8 num #11 = Utf8 I #12 = Utf8 &lt;init&gt; #13 = Utf8 ()V #14 = Utf8 Code #15 = Utf8 LineNumberTable #16 = Utf8 LocalVariableTable #17 = Utf8 this #18 = Utf8 Lcom/atguigu/java1/DynamicLinkingTest; #19 = Utf8 methodA #20 = Utf8 methodB #21 = Utf8 SourceFile #22 = Utf8 DynamicLinkingTest.java #23 = NameAndType #12:#13 // &quot;&lt;init&gt;&quot;:()V #24 = NameAndType #10:#11 // num:I #25 = Class #34 // java/lang/System #26 = NameAndType #35:#36 // out:Ljava/io/PrintStream; #27 = Utf8 methodA().... #28 = Class #37 // java/io/PrintStream #29 = NameAndType #38:#39 // println:(Ljava/lang/String;)V #30 = Utf8 methodB().... #31 = NameAndType #19:#13 // methodA:()V #32 = Utf8 com/atguigu/java1/DynamicLinkingTest #33 = Utf8 java/lang/Object #34 = Utf8 java/lang/System #35 = Utf8 out #36 = Utf8 Ljava/io/PrintStream; #37 = Utf8 java/io/PrintStream #38 = Utf8 println #39 = Utf8 (Ljava/lang/String;)V&#123; int num; descriptor: I flags: public com.atguigu.java1.DynamicLinkingTest(); descriptor: ()V flags: ACC_PUBLIC Code: stack=2, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: aload_0 5: bipush 10 7: putfield #2 // Field num:I 10: return LineNumberTable: line 7: 0 line 9: 4 LocalVariableTable: Start Length Slot Name Signature 0 11 0 this Lcom/atguigu/java1/DynamicLinkingTest; public void methodA(); descriptor: ()V flags: ACC_PUBLIC Code: stack=2, locals=1, args_size=1 0: getstatic #3 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #4 // String methodA().... 5: invokevirtual #5 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return LineNumberTable: line 12: 0 line 13: 8 LocalVariableTable: Start Length Slot Name Signature 0 9 0 this Lcom/atguigu/java1/DynamicLinkingTest; public void methodB(); descriptor: ()V flags: ACC_PUBLIC Code: stack=3, locals=1, args_size=1 0: getstatic #3 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #6 // String methodB().... 5: invokevirtual #5 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: aload_0 9: invokevirtual #7 // Method methodA:()V 12: aload_0 13: dup 14: getfield #2 // Field num:I 17: iconst_1 18: iadd 19: putfield #2 // Field num:I 22: return LineNumberTable: line 16: 0 line 18: 8 line 20: 12 line 21: 22 LocalVariableTable: Start Length Slot Name Signature 0 23 0 this Lcom/atguigu/java1/DynamicLinkingTest;&#125;SourceFile: &quot;DynamicLinkingTest.java&quot; 1、在字节码指令中，methodB() 方法中通过 invokevirtual #7 指令调用了方法 A ，那么 #7 是个啥呢？ 2、往上面翻，找到常量池的定义：#7 = Methodref #8.#31 先找 #8 ： #8 = Class #32 ：去找 #32 #32 = Utf8 com/atguigu/java1/DynamicLinkingTest 结论：通过 #8 我们找到了 DynamicLinkingTest 这个类 再来找 #31： #31 = NameAndType #19:#13 ：去找 #19 和 #13 #19 = Utf8 methodA ：方法名为 methodA #13 = Utf8 ()V ：方法没有形参，返回值为 void 3、结论：通过 #7 我们就能找到需要调用的 methodA() 方法，并进行调用 4、在上面，其实还有很多符号引用，比如 Object、System、PrintStream 等等 为什么要用常量池呢？ 因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，然后记录其引用即可，节省了空间。 常量池的作用：就是为了提供一些符号和常量，便于指令的识别 方法的调用静态链接与动态链接在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关 静态链接： 当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期确定，且运行期保持不变时，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接 动态链接： 如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。 早期绑定与晚期绑定 静态链接与动态链接针对的是方法。早期绑定和晚期绑定范围更广。早期绑定涵盖了静态链接，晚期绑定涵盖了动态链接。 静态链接和动态链接对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。 早期绑定 早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。 晚期绑定 如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Animal &#123; public void eat() &#123; System.out.println(&quot;动物进食&quot;); &#125;&#125;interface Huntable &#123; void hunt();&#125;class Dog extends Animal implements Huntable &#123; @Override public void eat() &#123; System.out.println(&quot;狗吃骨头&quot;); &#125; @Override public void hunt() &#123; System.out.println(&quot;捕食耗子，多管闲事&quot;); &#125;&#125;class Cat extends Animal implements Huntable &#123; public Cat() &#123; super();//表现为：早期绑定 &#125; public Cat(String name) &#123; this();//表现为：早期绑定 &#125; @Override public void eat() &#123; super.eat();//表现为：早期绑定 System.out.println(&quot;猫吃鱼&quot;); &#125; @Override public void hunt() &#123; System.out.println(&quot;捕食耗子，天经地义&quot;); &#125;&#125;public class AnimalTest &#123; public void showAnimal(Animal animal) &#123; animal.eat();//表现为：晚期绑定 &#125; public void showHunt(Huntable h) &#123; h.hunt();//表现为：晚期绑定 &#125;&#125; 部分字节码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#123; public com.atguigu.java2.AnimalTest(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 54: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lcom/atguigu/java2/AnimalTest; public void showAnimal(com.atguigu.java2.Animal); descriptor: (Lcom/atguigu/java2/Animal;)V flags: ACC_PUBLIC Code: stack=1, locals=2, args_size=2 0: aload_1 1: invokevirtual #2 // Method com/atguigu/java2/Animal.eat:()V 4: return LineNumberTable: line 56: 0 line 57: 4 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lcom/atguigu/java2/AnimalTest; 0 5 1 animal Lcom/atguigu/java2/Animal; public void showHunt(com.atguigu.java2.Huntable); descriptor: (Lcom/atguigu/java2/Huntable;)V flags: ACC_PUBLIC Code: stack=1, locals=2, args_size=2 0: aload_1 1: invokeinterface #3, 1 // InterfaceMethod com/atguigu/java2/Huntable.hunt:()V 6: return LineNumberTable: line 60: 0 line 61: 6 LocalVariableTable: Start Length Slot Name Signature 0 7 0 this Lcom/atguigu/java2/AnimalTest; 0 7 1 h Lcom/atguigu/java2/Huntable;&#125;SourceFile: &quot;AnimalTest.java&quot; invokevirtual 体现为晚期绑定 invokeinterface 也体现为晚期绑定 invokespecial 体现为早期绑定 多态与绑定 随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。 Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。 虚方法与非虚方法虚方法与非虚方法的区别 如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。 静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。 其他方法称为虚方法。 子类对象的多态的使用前提： 类的继承关系 方法的重写 虚拟机中调用方法的指令 普通指令： invokestatic：调用静态方法，解析阶段确定唯一方法版本 invokespecial：调用&lt;init&gt;方法、私有及父类方法，解析阶段确定唯一方法版本 invokevirtual：调用所有虚方法 invokeinterface：调用接口方法 动态调用指令 invokedynamic：动态解析出需要调用的方法，然后执行 前四条指令固化在虚拟机内部，方法的调用执行不可人为干预。而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class Father &#123; public Father() &#123; System.out.println(&quot;father的构造器&quot;); &#125; public static void showStatic(String str) &#123; System.out.println(&quot;father &quot; + str); &#125; public final void showFinal() &#123; System.out.println(&quot;father show final&quot;); &#125; public void showCommon() &#123; System.out.println(&quot;father 普通方法&quot;); &#125;&#125;public class Son extends Father &#123; public Son() &#123; //invokespecial super(); &#125; public Son(int age) &#123; //invokespecial this(); &#125; //不是重写的父类的静态方法，因为静态方法不能被重写！ public static void showStatic(String str) &#123; System.out.println(&quot;son &quot; + str); &#125; private void showPrivate(String str) &#123; System.out.println(&quot;son private&quot; + str); &#125; public void show() &#123; //invokestatic showStatic(&quot;atguigu.com&quot;); //invokestatic super.showStatic(&quot;good!&quot;); //invokespecial showPrivate(&quot;hello!&quot;); //invokespecial super.showCommon(); //invokevirtual showFinal();//因为此方法声明有final，不能被子类重写，所以也认为此方法是非虚方法。 //虚方法如下： /* invokevirtual 你没有显示的加super.，编译器认为你可能调用子类的showCommon(即使son子类没有重写，也 会认为)，所以编译期间确定不下来，就是虚方法。 */ showCommon(); info(); MethodInterface in = null; //invokeinterface in.methodA(); &#125; public void info() &#123; &#125; public void display(Father f) &#123; f.showCommon(); &#125; public static void main(String[] args) &#123; Son so = new Son(); so.show(); &#125;&#125;interface MethodInterface &#123; void methodA();&#125; Son 类中 show() 方法的字节码指令如下 关于 invokedynamic 指令 JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现【动态类型语言】支持而做的一种改进。 但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。 Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。 123456789101112131415161718192021222324@FunctionalInterfaceinterface Func &#123; public boolean func(String str);&#125;public class Lambda &#123; public void lambda(Func func) &#123; return; &#125; public static void main(String[] args) &#123; Lambda lambda = new Lambda(); Func func = s -&gt; &#123; return true; &#125;; lambda.lambda(func); lambda.lambda(s -&gt; &#123; return true; &#125;); &#125;&#125; 动态语言和静态语言 动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。 说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。 Java：String info = “mogu blog”; (Java是静态类型语言的，会先编译就进行类型检查) JS：var name = “shkstart”; var name = 10; （运行时才进行检查） 1Python: info = 130.5 (运行时才检查) Java语言中方法重写的本质 找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。 如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验。 如果通过则返回这个方法的直接引用，查找过程结束 如果不通过，则返回java.lang.IllegalAccessError 异常 否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。 如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。 上面这个过程称为动态分派 IllegalAccessError介绍 程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。 比如，你把应该有的jar包放从工程中拿走了，或者Maven中存在jar包冲 虚方法表 在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM采用在类的方法区建立一个虚方法表（virtual method table）来实现，非虚方法不会出现在表中。使用索引表来代替查找。【上面动态分派的过程，我们可以看到如果子类找不到，还要从下往上找其父类，非常耗时】 每个类中都有一个虚方法表，表中存放着各个方法的实际入口。 虚方法表是什么时候被创建的呢？虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的虚方法表也初始化完毕。 例子1 如图所示：如果类中重写了方法，那么调用的时候，就会直接在该类的虚方法表中查找 1、比如说son在调用toString的时候，Son没有重写过，Son的父类Father也没有重写过，那就直接调用Object类的toString。那么就直接在虚方法表里指明toString直接指向Object类。 2、下次Son对象再调用toString就直接去找Object，不用先找Son–&gt;再找Father–&gt;最后才到Object的这样的一个过程。 方法返回地址 在一些帖子里，方法返回地址、动态链接、一些附加信息 也叫做帧数据区 存放调用该方法的pc寄存器的值。一个方法的结束，有两种方式： 正常执行完成 出现未处理的异常，非正常退出 无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。 本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。 正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。 方法退出的两种方式 当一个方法开始执行后，只有两种方式可以退出这个方法， 正常退出： 执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称正常完成出口； 一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。 在字节码指令中，返回指令包含： ireturn：当返回值是boolean，byte，char，short和int类型时使用 lreturn：Long类型 freturn：Float类型 dreturn：Double类型 areturn：引用类型 return：返回值类型为void的方法、实例初始化方法、类和接口的初始化方法 异常退出： 在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称异常完成出口。 方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码 一些附加信息栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。 栈相关面试题举例栈溢出的情况？SOF（StackOverflowError），栈大小分为固定的，和动态变化。如果是固定的就可能出现StackOverflowError。如果是动态变化的，内存不足时就可能出现OOM 调整栈大小，就能保证不出现溢出么？不能保证不溢出，只能保证SOF出现的几率小 分配的栈内存越大越好么？不是，一定时间内降低了OOM概率，但是会挤占其它的线程空间，因为整个虚拟机的内存空间是有限的 垃圾回收是否涉及到虚拟机栈？方法中定义的局部变量是否线程安全？具体问题具体分析 如果只有一个线程才可以操作此数据，则必是线程安全的。 如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。 具体问题具体分析： ? 如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 面试题： * 方法中定义的局部变量是否线程安全？具体情况具体分析 * * 何为线程安全？ * 如果只有一个线程才可以操作此数据，则必是线程安全的。 * 如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。 */public class StringBuilderTest &#123; int num = 10; //s1的声明方式是线程安全的（只在方法内部用了） public static void method1()&#123; //StringBuilder:线程不安全 StringBuilder s1 = new StringBuilder(); s1.append(&quot;a&quot;); s1.append(&quot;b&quot;); //... &#125; //sBuilder的操作过程：是线程不安全的（作为参数传进来，可能被其它线程操作） public static void method2(StringBuilder sBuilder)&#123; sBuilder.append(&quot;a&quot;); sBuilder.append(&quot;b&quot;); //... &#125; //s1的操作：是线程不安全的（有返回值，可能被其它线程操作） public static StringBuilder method3()&#123; StringBuilder s1 = new StringBuilder(); s1.append(&quot;a&quot;); s1.append(&quot;b&quot;); return s1; &#125; //s1的操作：是线程安全的（s1自己消亡了，最后返回的智商s1.toString的一个新对象） public static String method4()&#123; StringBuilder s1 = new StringBuilder(); s1.append(&quot;a&quot;); s1.append(&quot;b&quot;); return s1.toString(); &#125; public static void main(String[] args) &#123; StringBuilder s = new StringBuilder(); new Thread(() -&gt; &#123; s.append(&quot;a&quot;); s.append(&quot;b&quot;); &#125;).start(); method2(s); &#125;&#125;","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://noteforme.github.io.com/tags/JVM/"}],"keywords":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}]},{"title":"JVM_RUNTIME","slug":"JVM-RUNTIME","date":"2020-01-03T13:45:04.000Z","updated":"2021-08-19T11:11:44.009Z","comments":true,"path":"2020/01/03/JVM-RUNTIME/","link":"","permalink":"http://noteforme.github.io.com/2020/01/03/JVM-RUNTIME/","excerpt":"","text":"[运行时数据区概述及线程]前言本节主要讲的是运行时数据区，也就是下图这部分，它是在类加载完成后的阶段 当我们通过前面的：类的加载 –&gt; 验证 –&gt; 准备 –&gt; 解析 –&gt; 初始化，这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区 运行时数据区结构运行时数据区与内存 内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。不同的JVM对于内存的划分方式和管理机制存在着部分差异。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。 我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁 线程的内存空间 Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区：其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。 灰色的为单独线程私有的，红色的为多个线程共享的。即： 线程独有：独立包括程序计数器、栈、本地方法栈 线程间共享：堆、堆外内存（永久代或元空间、代码缓存） Runtime类每个JVM只有一个Runtime实例。即为运行时环境，相当于内存结构的中间的那个框框：运行时环境。 JVM 线程 线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行 在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射 当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收 操作系统负责将线程安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法 关于线程，并发可以看笔者的Java并发系列 JVM 系统线程 如果你使用jconsole或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用public static void main(String[])的main线程以及所有这个main线程自己创建的线程。 这些主要的后台系统线程在Hotspot JVM里主要是以下几个： 虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销 周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行 GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持 编译线程：这种线程在运行时会将字节码编译成到本地代码 信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理 程序计数器(PC寄存器)PC寄存器介绍官方文档网址：https://docs.oracle.com/javase/specs/jvms/se8/html/index.html JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。 这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。 它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。 在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。 任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefned）。 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。 它是唯一一个在Java虚拟机规范中没有规定任何OutofMemoryError情况的区域。 PC寄存器的作用PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令，并执行该指令。 12345678910111213public class PCRegisterTest &#123; public static void main(String[] args) &#123; int i = 10; int j = 20; int k = i + j; String s = &quot;abc&quot;; System.out.println(i); System.out.println(k); &#125;&#125; 看字节码的方法：https://blog.csdn.net/21aspnet/article/details/88351875 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102Classfile /F:/IDEAWorkSpaceSourceCode/JVMDemo/out/production/chapter04/com/atguigu/java/PCRegisterTest.class Last modified 2020-11-2; size 675 bytes MD5 checksum 53b3ef104479ec9e9b7ce5319e5881d3 Compiled from &quot;PCRegisterTest.java&quot;public class com.atguigu.java.PCRegisterTest minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #6.#26 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = String #27 // abc #3 = Fieldref #28.#29 // java/lang/System.out:Ljava/io/PrintStream; #4 = Methodref #30.#31 // java/io/PrintStream.println:(I)V #5 = Class #32 // com/atguigu/java/PCRegisterTest #6 = Class #33 // java/lang/Object #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 LocalVariableTable #12 = Utf8 this #13 = Utf8 Lcom/atguigu/java/PCRegisterTest; #14 = Utf8 main #15 = Utf8 ([Ljava/lang/String;)V #16 = Utf8 args #17 = Utf8 [Ljava/lang/String; #18 = Utf8 i #19 = Utf8 I #20 = Utf8 j #21 = Utf8 k #22 = Utf8 s #23 = Utf8 Ljava/lang/String; #24 = Utf8 SourceFile #25 = Utf8 PCRegisterTest.java #26 = NameAndType #7:#8 // &quot;&lt;init&gt;&quot;:()V #27 = Utf8 abc #28 = Class #34 // java/lang/System #29 = NameAndType #35:#36 // out:Ljava/io/PrintStream; #30 = Class #37 // java/io/PrintStream #31 = NameAndType #38:#39 // println:(I)V #32 = Utf8 com/atguigu/java/PCRegisterTest #33 = Utf8 java/lang/Object #34 = Utf8 java/lang/System #35 = Utf8 out #36 = Utf8 Ljava/io/PrintStream; #37 = Utf8 java/io/PrintStream #38 = Utf8 println #39 = Utf8 (I)V&#123; public com.atguigu.java.PCRegisterTest(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 7: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lcom/atguigu/java/PCRegisterTest; public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=5, args_size=1 0: bipush 10 2: istore_1 3: bipush 20 5: istore_2 6: iload_1 7: iload_2 8: iadd 9: istore_3 10: ldc #2 // String abc 12: astore 4 14: getstatic #3 // Field java/lang/System.out:Ljava/io/PrintStream; 17: iload_1 18: invokevirtual #4 // Method java/io/PrintStream.println:(I)V 21: getstatic #3 // Field java/lang/System.out:Ljava/io/PrintStream; 24: iload_3 25: invokevirtual #4 // Method java/io/PrintStream.println:(I)V 28: return LineNumberTable: line 10: 0 line 11: 3 line 12: 6 line 14: 10 line 15: 14 line 16: 21 line 18: 28 LocalVariableTable: Start Length Slot Name Signature 0 29 0 args [Ljava/lang/String; 3 26 1 i I 6 23 2 j I 10 19 3 k I 14 15 4 s Ljava/lang/String;&#125;SourceFile: &quot;PCRegisterTest.java&quot; 左边的数字代表指令地址（指令偏移），即 PC 寄存器中可能存储的值，然后执行引擎读取 PC 寄存器中的值，并执行该指令 两个面试题使用PC寄存器存储字节码指令地址有什么用呢？或者问为什么使用 PC 寄存器来记录当前线程的执行地址呢？ 因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行 JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令 PC寄存器为什么被设定为私有的？ 我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。 由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。 这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。 注意并行和并发的区别，笔者的并发系列有讲 CPU 时间片 CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。 在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。 但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://noteforme.github.io.com/tags/JVM/"}],"keywords":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}]},{"title":"JVM_Overview","slug":"JVM-Overview","date":"2020-01-03T02:48:45.000Z","updated":"2021-08-19T11:11:43.991Z","comments":true,"path":"2020/01/03/JVM-Overview/","link":"","permalink":"http://noteforme.github.io.com/2020/01/03/JVM-Overview/","excerpt":"","text":"虚拟机是通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。 JVM分类 https://www.zhihu.com/question/29265430/answer/43818804 元空间寸哪些数据? https://www.cnblogs.com/duanxz/p/3520829.html JVM整体结构 Java代码执行流程 ​ 详细图 JVM的架构模型Java编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。具体来说：这两种架构之间的区别： 基于栈式架构的特点 设计和实现更简单，适用于资源受限的系统； 避开了寄存器的分配难题：使用零地址指令方式分配。 指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现。 不需要硬件支持，可移植性更好，更好实现跨平台 基于寄存器架构的特点 典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。 指令集架构则完全依赖硬件，可移植性差 性能优秀和执行更高效 花费更少的指令去完成一项操作。 在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主方水洋 总结 由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。 时至今日，尽管嵌入式平台已经不是Java程序的主流运行平台了（准确来说应该是HotSpotVM的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？ 栈 跨平台性 指令集小 指令多 执行性能比寄存器差 类加载过程1234567public class HelloLoader &#123; public static void main(String[] args) &#123; System.out.println(&quot;谢谢ClassLoader加载我....&quot;); System.out.println(&quot;你的大恩大德，我下辈子再报！&quot;); &#125;&#125; 它的加载过程是怎么样的呢? 执行 main() 方法（静态方法）就需要先加载main方法所在类 HelloLoader 加载成功，则进行链接、初始化等操作。完成后调用 HelloLoader 类中的静态方法 main 加载失败则抛出异常 完整的流程图如下所示： 加载阶段加载： 通过一个类的全限定名获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口 加载class文件的方式： 从本地系统中直接加载 通过网络获取，典型场景：Web Applet 从zip压缩包中读取，成为日后jar、war格式的基础 运行时计算生成，使用最多的是：动态代理技术 由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见 从加密文件中获取，典型的防Class文件被反编译的保护措施 链接阶段链接分为三个子阶段：验证 -&gt; 准备 -&gt; 解析 目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全 主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。 举例 使用 BinaryViewer软件查看字节码文件，其开头均为 CAFE BABE ，如果出现不合法的字节码文件，那么将会验证不通过。 准备(Prepare) 为类变量（static变量）分配内存并且设置该类变量的默认初始值，即零值 这里不包含用final修饰的static，因为final在编译的时候就会分配好了默认值，准备阶段会显式初始化 注意：这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中 代码：变量a在准备阶段会赋初始值，但不是1，而是0，在初始化阶段会被赋值为 1 12345678public class HelloApp &#123; private static int a = 1;//prepare：a = 0 ---&gt; initial : a = 1 public static void main(String[] args) &#123; System.out.println(a); &#125;&#125; 解析(Resolve) 将常量池内的符号引用转换为直接引用的过程 事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行 符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等 符号引用 反编译 class 文件后可以查看符号引用 初始化阶段类的初始化时机 创建类的实例 访问某个类或接口的静态变量，或者对该静态变量赋值 调用类的静态方法 反射（比如：Class.forName(“com.atguigu.Test”)） 初始化一个类的子类 Java虚拟机启动时被标明为启动类的类 JDK7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化 除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化，即不会执行初始化阶段（不会调用 clinit() 方法和 init() 方法） clinit() 初始化阶段就是执行类构造器方法&lt;clinit&gt;()的过程 此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。也就是说，当我们代码中包含static变量的时候，就会有clinit方法 &lt;clinit&gt;()方法中的指令按语句在源文件中出现的顺序执行 &lt;clinit&gt;()不同于类的构造器。（关联：构造器是虚拟机视角下的&lt;init&gt;()） 若该类具有父类，JVM会保证子类的&lt;clinit&gt;()执行前，父类的&lt;clinit&gt;()已经执行完毕 虚拟机必须保证一个类的&lt;clinit&gt;()方法在多线程下被同步加锁 IDEA 中安装 JClassLib Bytecode viewer 插件，可以很方便的看字节码。安装过程可以自行百度 5说明若该类具有父类，JVM会保证子类的&lt;clinit&gt;()执行前，父类的&lt;clinit&gt;()已经执行完毕 如上代码，加载流程如下： 首先，执行 main() 方法需要加载 ClinitTest1 类 获取 Son.B 静态变量，需要加载 Son 类 Son 类的父类是 Father 类，所以需要先执行 Father 类的加载，再执行 Son 类的加载 6说明虚拟机必须保证一个类的&lt;clinit&gt;()方法在多线程下被同步加锁 1234567891011121314151617181920212223242526public class DeadThreadTest &#123; public static void main(String[] args) &#123; Runnable r = () -&gt; &#123; System.out.println(Thread.currentThread().getName() + &quot;开始&quot;); DeadThread dead = new DeadThread(); System.out.println(Thread.currentThread().getName() + &quot;结束&quot;); &#125;; Thread t1 = new Thread(r,&quot;线程1&quot;); Thread t2 = new Thread(r,&quot;线程2&quot;); t1.start(); t2.start(); &#125;&#125;class DeadThread&#123; static&#123; if(true)&#123; System.out.println(Thread.currentThread().getName() + &quot;初始化当前类&quot;); while(true)&#123; &#125; &#125; &#125;&#125; 12345线程2开始线程1开始线程2初始化当前类&#x2F;然后程序卡死了 程序卡死，分析原因： 两个线程同时去加载 DeadThread 类，而 DeadThread 类中静态代码块中有一处死循环 先加载 DeadThread 类的线程抢到了同步锁，然后在类的静态代码块中执行死循环，而另一个线程在等待同步锁的释放 所以无论哪个线程先执行 DeadThread 类的加载，另外一个类也不会继续执行。（一个类只会被加载一次） 类加载器的分类概述 JVM严格来讲支持两种类型的类加载器 。分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader） 从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器 无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示 1234567891011121314151617181920212223242526public class ClassLoaderTest &#123; public static void main(String[] args) &#123; //获取系统类加载器 ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); System.out.println(systemClassLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2 //获取其上层：扩展类加载器 ClassLoader extClassLoader = systemClassLoader.getParent(); System.out.println(extClassLoader);//sun.misc.Launcher$ExtClassLoader@1540e19d //获取其上层：获取不到引导类加载器 ClassLoader bootstrapClassLoader = extClassLoader.getParent(); System.out.println(bootstrapClassLoader);//null //对于用户自定义类来说：默认使用系统类加载器进行加载 ClassLoader classLoader = ClassLoaderTest.class.getClassLoader(); System.out.println(classLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2 //String类使用引导类加载器进行加载的。---&gt; Java的核心类库都是使用引导类加载器进行加载的。 ClassLoader classLoader1 = String.class.getClassLoader(); System.out.println(classLoader1);//null &#125;&#125; 我们尝试获取引导类加载器，获取到的值为 null ，这并不代表引导类加载器不存在，因为引导类加载器右 C/C++ 语言，我们获取不到 两次获取系统类加载器的值都相同：sun.misc.Launcher$AppClassLoader@18b4aac2 ，这说明系统类加载器是全局唯一的 双亲委派机制双亲委派机制原理ava虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行； 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器； 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。 父类加载器一层一层往下分配任务，如果子类加载器能加载，则加载此类，如果将加载任务分配至系统类加载器也无法加载此类，则抛出异常 双亲委派机制代码演示举例11、我们自己建立一个 java.lang.String 类，写上 static 代码块 123456public class String &#123; // static&#123; System.out.println(&quot;我是自定义的String类的静态代码块&quot;); &#125;&#125; 2、在另外的程序中加载 String 类，看看加载的 String 类是 JDK 自带的 String 类，还是我们自己编写的 String 类 12345678910public class StringTest &#123; public static void main(String[] args) &#123; java.lang.String str = new java.lang.String(); System.out.println(&quot;hello,atguigu.com&quot;); StringTest test = new StringTest(); System.out.println(test.getClass().getClassLoader()); &#125;&#125; 12hello,atguigu.comsun.misc.Launcher$AppClassLoader@18b4aac2 程序并没有输出我们静态代码块中的内容，可见仍然加载的是 JDK 自带的 String 类。 把刚刚的类改一下 1234567891011package java.lang;public class String &#123; // static&#123; System.out.println(&quot;我是自定义的String类的静态代码块&quot;); &#125; //错误: 在类 java.lang.String 中找不到 main 方法 public static void main(String[] args) &#123; System.out.println(&quot;hello,String&quot;); &#125;&#125; 由于双亲委派机制一直找父类，所以最后找到了Bootstrap ClassLoader，Bootstrap ClassLoader找到的是 JDK 自带的 String 类，在那个String类中并没有 main() 方法，所以就报了上面的错误。 123456789package java.lang;public class ShkStart &#123; public static void main(String[] args) &#123; System.out.println(&quot;hello!&quot;); &#125;&#125; 1234567891011121314151617java.lang.SecurityException: Prohibited package name: java.lang at java.lang.ClassLoader.preDefineClass(ClassLoader.java:662) at java.lang.ClassLoader.defineClass(ClassLoader.java:761) at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142) at java.net.URLClassLoader.defineClass(URLClassLoader.java:467) at java.net.URLClassLoader.access$100(URLClassLoader.java:73) at java.net.URLClassLoader$1.run(URLClassLoader.java:368) at java.net.URLClassLoader$1.run(URLClassLoader.java:362) at java.security.AccessController.doPrivileged(Native Method) at java.net.URLClassLoader.findClass(URLClassLoader.java:361) at java.lang.ClassLoader.loadClass(ClassLoader.java:424) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:335) at java.lang.ClassLoader.loadClass(ClassLoader.java:357) at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:495)Error: A JNI error has occurred, please check your installation and try againException in thread &quot;main&quot; Process finished with exit code 1 即使类名没有重复，也禁止使用java.lang这种包名。这是一种保护机制 举例3当我们加载jdbc.jar 用于实现数据库连接的时候 我们现在程序中需要用到SPI接口，而SPI接口属于rt.jar包中Java核心api 然后使用双清委派机制，引导类加载器把rt.jar包加载进来，而rt.jar包中的SPI存在一些接口，接口我们就需要具体的实现类了 具体的实现类就涉及到了某些第三方的jar包了，比如我们加载SPI的实现类jdbc.jar包【首先我们需要知道的是 jdbc.jar是基于SPI接口进行实现的】 第三方的jar包中的类属于系统类加载器来加载 从这里面就可以看到SPI核心接口由引导类加载器来加载，SPI具体实现类由系统类加载器来加载 双亲委派机制优势通过上面的例子，我们可以知道，双亲机制可以 避免类的重复加载 保护程序安全，防止核心API被随意篡改 自定义类：自定义java.lang.String 没有被加载。 自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类） 沙箱安全机制 自定义String类时：在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java.lang.String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。 这样可以保证对java核心源代码的保护，这就是沙箱安全机制。 其他如何判断两个class对象是否相同？在JVM中表示两个class对象是否为同一个类存在两个必要条件： 类的完整类名必须一致，包括包名 加载这个类的ClassLoader（指ClassLoader实例对象）必须相同 换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的 对类加载器的引用 JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的 如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中 当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的（后面讲） https://youthlql.gitee.io/javayouth/#/?id=java","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://noteforme.github.io.com/tags/JVM/"}],"keywords":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}]},{"title":"AnimPropertyView","slug":"AnimPropertyView","date":"2019-12-29T14:23:37.000Z","updated":"2021-08-19T11:11:43.546Z","comments":true,"path":"2019/12/29/AnimPropertyView/","link":"","permalink":"http://noteforme.github.io.com/2019/12/29/AnimPropertyView/","excerpt":"","text":"估值器（TypeEvaluator）设置动画 如何从初始值 过渡到 结束值 的逻辑 插值器（Interpolator）决定 值 的变化模式（匀速、加速） 估值器（TypeEvaluator）决定 值 的具体变化数值 ValueAnimator实现原理 : 通过不断控制 值的变化， 再不断赋值给对象的属性，从而实现动画的效果。 从上面原理可以看出：ValueAnimator类中有3个重要方法： ValueAnimator.ofInt（int values） ValueAnimator.ofFloat（float values） ValueAnimator.ofObject（int values） ValueAnimator.ofInt（int values）将初始值 以整型数值的形式 过渡到结束值 即估值器是整型估值器 - IntEvaluator 模板代码实际开发中，建议使用Java代码实现属性动画：因为很多时候属性的起始值是无法提前确定的（无法使用XML设置），这就需要在Java代码里动态获取。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 步骤1：设置动画属性的初始值 &amp; 结束值ValueAnimator anim = ValueAnimator.ofInt(0, 3); // ofInt（）作用有两个 // 1. 创建动画实例 // 2. 将传入的多个Int参数进行平滑过渡:此处传入0和1,表示将值从0平滑过渡到1 // 如果传入了3个Int参数 a,b,c ,则是先从a平滑过渡到b,再从b平滑过渡到C，以此类推 // ValueAnimator.ofInt()内置了整型估值器,直接采用默认的.不需要设置，即默认设置了如何从初始值 过渡到 结束值 // 关于自定义插值器我将在下节进行讲解 // 下面看看ofInt()的源码分析 -&gt;&gt;关注1 // 步骤2：设置动画的播放各种属性 anim.setDuration(500); // 设置动画运行的时长 anim.setStartDelay(500); // 设置动画延迟播放时间 anim.setRepeatCount(0); // 设置动画重复播放次数 = 重放次数+1 // 动画播放次数 = infinite时,动画无限重复 anim.setRepeatMode(ValueAnimator.RESTART); // 设置重复播放动画模式 // ValueAnimator.RESTART(默认):正序重放 // ValueAnimator.REVERSE:倒序回放 // 步骤3：将改变的值手动赋值给对象的属性值：通过动画的更新监听器 // 设置 值的更新监听器 // 即：值每次改变、变化一次,该方法就会被调用一次 anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; int currentValue = (Integer) animation.getAnimatedValue(); // 获得改变后的值 System.out.println(currentValue); // 输出改变后的值 // 步骤4：将改变后的值赋给对象的属性值，下面会详细说明 View.setproperty（currentValue）； // 步骤5：刷新视图，即重新绘制，从而实现动画效果 View.requestLayout(); &#125; &#125;); anim.start(); // 启动动画 &#125;// 关注1：ofInt（）源码分析 public static ValueAnimator ofInt(int... values) &#123; // 允许传入一个或多个Int参数 // 1. 输入一个的情况（如a）：从0过渡到a； // 2. 输入多个的情况（如a，b，c）：先从a平滑过渡到b，再从b平滑过渡到C ValueAnimator anim = new ValueAnimator(); // 创建动画对象 anim.setIntValues(values); // 将传入的值赋值给动画对象 return anim; &#125; XML设置123456789101112131415// ValueAnimator采用&lt;animator&gt; 标签&lt;animator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:valueFrom=&quot;0&quot; // 初始值 android:valueTo=&quot;100&quot; // 结束值 android:valueType=&quot;intType&quot; // 变化值类型 ：floatType &amp; intType android:duration=&quot;3000&quot; // 动画持续时间（ms），必须设置，动画才有效果 android:startOffset =&quot;1000&quot; // 动画延迟开始时间（ms） android:fillBefore = “true” // 动画播放完后，视图是否会停留在动画开始的状态，默认为true android:fillAfter = “false” // 动画播放完后，视图是否会停留在动画结束的状态，优先于fillBefore值，默认为false android:fillEnabled= “true” // 是否应用fillBefore值，对fillAfter值无影响，默认为true android:repeatMode= “restart” // 选择重复播放动画模式，restart代表正序重放，reverse代表倒序回放，默认为restart| android:repeatCount = “0” // 重放次数（所以动画的播放次数=重放次数+1），为infinite时无限重复 android:interpolator = @[package:]anim/interpolator_resource // 插值器，即影响动画的播放速度,下面会详细讲/&gt; 12345678Animator animator = AnimatorInflater.loadAnimator(context, R.animator.set_animation); // 载入XML动画animator.setTarget(view); // 设置动画对象animator.start(); // 启动动画 实战按钮的宽度从 200px 放大到 500px 123456&lt;Button android:id=&quot;@+id/bt_value_anim&quot; android:layout_width=&quot;200px&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerInParent=&quot;true&quot; android:text=&quot;动画&quot; /&gt; ？代码设置初始值 12345678910111213141516171819202122232425// 步骤1：设置属性数值的初始值(此处在xml中200) &amp; 结束值(600)val valueAnimator = ValueAnimator.ofInt(bt_value_anim.layoutParams.width, 600) // ValueAnimator.ofInt()内置了整型估值器,直接采用默认的.不需要设置 // 即默认设置了如何从初始值200 过渡到 结束值500// 步骤2：设置动画的播放各种属性valueAnimator.duration = 2000// 步骤3：将改变的值手动赋值给对象的属性值：通过动画的更新监听器 // 设置 值的更新监听器 // 即：值每次改变、变化一次,该方法就会被调用一次valueAnimator.addUpdateListener &#123; val currentValue = it.animatedValue // 获得每次变化后的属性值 Timber.d(&quot;currentValue $currentValue&quot;) // 每次值变化时，将值手动赋值给对象的属性 bt_value_anim.layoutParams.width = currentValue as Int // 即将每次变化后的值 赋 给按钮的宽度，这样就实现了按钮宽度属性的动态变化 // 步骤4：刷新视图，即重新绘制，从而实现动画效果 bt_value_anim.requestLayout()&#125;valueAnimator.start() 浮点型：ValueAnimator.oFloat（）将初始值 以浮点型数值的形式 过渡到结束值 ValueAnimator.oFloat（）采用默认的浮点型估值器 (FloatEvaluator) ValueAnimator.ofInt（）采用默认的整型估值器（IntEvaluator） 在使用上完全没有区别 ValueAnimator.ofObject（）将初始值 以对象的形式 过渡到结束值 即通过操作 对象 实现动画效果 实战可以看到 ValueAnimator.ofObject（）的本质还是操作 值,将多个值封装到一个对象里的方式，同时对多个值一起操作 PointEvaluator 12345678910111213141516class PointEvaluator : TypeEvaluator&lt;Point&gt; &#123; override fun evaluate(fraction: Float, startValue: Point?, endValue: Point?): Point &#123; // 将动画初始值startValue 和 动画结束值endValue 强制类型转换成Point对象 val startPoint = startValue val endPoint = endValue // 根据fraction来计算当前动画的x和y的值 val x = startPoint!!.x + fraction * (endPoint!!.x - startPoint!!.x) val y = startPoint!!.y + fraction * (endPoint!!.y - startPoint!!.y) // 将计算后的坐标封装到一个新的Point对象中并返回 val point = Point(x,y) return point &#125;&#125; Point 1class Point(val x: Float, val y: Float) MyView 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class MyView : View &#123; constructor(context: Context?, attrs: AttributeSet?) : super(context, attrs) // 设置需要用到的变量 val RADIUS = 70f // 圆的半径 = 70 private var currentPoint // 当前点坐标 : Point? = null val mPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply &#123; color = Color.BLUE &#125; init &#123; &#125; override fun onDraw(canvas: Canvas?) &#123; // 如果当前点坐标为空(即第一次执行) if (currentPoint == null) &#123; currentPoint = Point(RADIUS, RADIUS) val x = currentPoint?.x val y = currentPoint?.y if (x != null &amp;&amp; y != null) &#123; canvas?.drawCircle(x, y, RADIUS, mPaint) &#125; // (重点关注)将属性动画作用到View中 // 步骤1:创建初始动画时的对象点 &amp; 结束动画时的对象点 // (重点关注)将属性动画作用到View中 // 步骤1:创建初始动画时的对象点 &amp; 结束动画时的对象点 val startPoint = Point(RADIUS, RADIUS) // 初始点为圆心(70,70) val endPoint = Point(700f, 1000f) // 结束点为(700,1000) // 步骤2:创建动画对象 &amp; 设置初始值 和 结束值 val anim = ValueAnimator.ofObject(PointEvaluator(), startPoint, endPoint) // 参数说明 // 参数1：TypeEvaluator 类型参数 - 使用自定义的PointEvaluator(实现了TypeEvaluator接口) // 参数2：初始动画的对象点 // 参数3：结束动画的对象点 // 步骤3：设置动画参数 anim.duration = 5000 // 设置 值的更新监听器 // 即每当坐标值（Point对象）更新一次,该方法就会被调用一次 anim.addUpdateListener &#123; currentPoint = it.animatedValue as Point? // 将每次变化后的坐标值（估值器PointEvaluator中evaluate（）返回的Piont对象值）到当前坐标值对象（currentPoint） // 从而更新当前坐标值（currentPoint） Timber.d(&quot;currentPoint==null $&#123;currentPoint?.x&#125; $&#123;currentPoint?.y&#125;&quot;) // 步骤4：每次赋值后就重新绘制，从而实现动画效果 invalidate() &#125; anim.start() &#125; else &#123; //除了第一次，后面每次都根据addUpdateListener回调，在这画圆 // 所以坐标值每改变一次,就会调用onDraw()一次,就会画一次圆,从而实现动画效果 // 在该点画一个圆:圆心 = (30,30),半径 = 30 val x = currentPoint!!.x val y = currentPoint!!.y canvas?.drawCircle(x, y, RADIUS, mPaint) Timber.d(&quot;currentPoint currentPoint!=null $&#123;currentPoint?.x&#125; $&#123;currentPoint?.y&#125;&quot;) &#125; &#125;&#125; 插值器xml设置当在XML文件设置插值器时，只需传入对应的插值器资源ID即可 主要是设置插值器属性android:interpolator 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;scale xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:interpolator=&quot;@android:anim/overshoot_interpolator&quot; // 通过资源ID设置插值器 android:duration=&quot;3000&quot; android:fromXScale=&quot;0.0&quot; android:fromYScale=&quot;0.0&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:toXScale=&quot;2&quot; android:toYScale=&quot;2&quot; /&gt;&gt; 代码设置当在Java代码设置插值器时，只需创建对应的插值器对象即可 123456789101112131415Button mButton = (Button) findViewById(R.id.Button);// 步骤1:创建 需要设置动画的 视图ViewAnimation alphaAnimation = new AlphaAnimation(1,0);// 步骤2：创建透明度动画的对象 &amp; 设置动画效果alphaAnimation.setDuration(3000);Interpolator overshootInterpolator = new OvershootInterpolator();// 步骤3：创建对应的插值器类对象alphaAnimation.setInterpolator(overshootInterpolator);// 步骤4：给动画设置插值器mButton.startAnimation(alphaAnimation);// 步骤5：播放动画 系统内置插值器![](AnimPropertyView/Screen Shot 2021-02-01 at 10.57.34 AM.png) 自定义插值器​ 根据动画的进度（0%-100%）计算出当前属性值改变的百分比 ​ 自定义插值器需要实现 Interpolator / TimeInterpolator接口 &amp; 复写getInterpolation（） 补间动画 实现 Interpolator接口；属性动画实现TimeInterpolator接口 TimeInterpolator接口是属性动画中新增的，用于兼容Interpolator接口，这使得所有过去的Interpolator实现类都可以直接在属性动画使用 12345678910111213141516171819202122// Interpolator接口 tween动画public interface Interpolator &#123; // 内部只有一个方法 float getInterpolation(float input) &#123; // 参数说明 // input值值变化范围是0-1，且随着动画进度（0% - 100% ）均匀变化 // 即动画开始时，input值 = 0；动画结束时input = 1 // 而中间的值则是随着动画的进度（0% - 100%）在0到1之间均匀增加 ...// 插值器的计算逻辑 return xxx； // 返回的值就是用于估值器继续计算的fraction值，下面会详细说明 &#125; // TimeInterpolator接口 属性动画// 同上public interface TimeInterpolator &#123; float getInterpolation(float input); &#125; 匀速插值器 12345678910111213141516171819202122232425262728// 匀速差值器：LinearInterpolator@HasNativeInterpolator public class LinearInterpolator extends BaseInterpolator implements NativeInterpolatorFactory &#123; // 仅贴出关键代码 ... public float getInterpolation(float input) &#123; return input; // 没有对input值进行任何逻辑处理，直接返回 // 即input值 = fraction值 // 因为input值是匀速增加的，因此fraction值也是匀速增加的，所以动画的运动情况也是匀速的，所以是匀速插值器 &#125; // 先加速再减速 差值器：AccelerateDecelerateInterpolator@HasNativeInterpolator public class AccelerateDecelerateInterpolator implements Interpolator, NativeInterpolatorFactory &#123; // 仅贴出关键代码 ... public float getInterpolation(float input) &#123; return (float)(Math.cos((input + 1) * Math.PI) / 2.0f) + 0.5f; // input的运算逻辑如下： // 使用了余弦函数，因input的取值范围是0到1，那么cos函数中的取值范围就是π到2π。 // 而cos(π)的结果是-1，cos(2π)的结果是1 // 所以该值除以2加上0.5后，getInterpolation()方法最终返回的结果值还是在0到1之间。只不过经过了余弦运算之后，最终的结果不再是匀速增加的了，而是经历了一个先加速后减速的过程 // 所以最终，fraction值 = 运算后的值 = 先加速后减速 // 所以该差值器是先加速再减速的 &#125; &#125; 先加速再减速 插值器：AccelerateDecelerateInterpolator 123456789101112131415// 先加速再减速 差值器：AccelerateDecelerateInterpolator@HasNativeInterpolator public class AccelerateDecelerateInterpolator implements Interpolator, NativeInterpolatorFactory &#123; // 仅贴出关键代码 ... public float getInterpolation(float input) &#123; return (float)(Math.cos((input + 1) * Math.PI) / 2.0f) + 0.5f; // input的运算逻辑如下： // 使用了余弦函数，因input的取值范围是0到1，那么cos函数中的取值范围就是π到2π。 // 而cos(π)的结果是-1，cos(2π)的结果是1 // 所以该值除以2加上0.5后，getInterpolation()方法最终返回的结果值还是在0到1之间。只不过经过了余弦运算之后，最终的结果不再是匀速增加的了，而是经历了一个先加速后减速的过程 // 所以最终，fraction值 = 运算后的值 = 先加速后减速 // 所以该差值器是先加速再减速的 &#125; &#125; 对input值 根据动画的进度（0%-100%）通过逻辑计算 计算出当前属性值改变的百分比 实战 DecelerateAccelerateInterpolator 12345678910111213141516class DecelerateAccelerateInterpolator : TimeInterpolator &#123; override fun getInterpolation(input: Float): Float &#123; var result: Float = 0.0f if (input &lt;= 0.5) &#123; result = Math.sin(Math.PI * input).toFloat() / 2 // 使用正弦函数来实现先减速后加速的功能，逻辑如下： // 因为正弦函数初始弧度变化值非常大，刚好和余弦函数是相反的 // 随着弧度的增加，正弦函数的变化值也会逐渐变小，这样也就实现了减速的效果。 // 当弧度大于π/2之后，整个过程相反了过来，现在正弦函数的弧度变化值非常小，渐渐随着弧度继续增加，变化值越来越大，弧度到π时结束，这样从0过度到π，也就实现了先减速后加速的效果 &#125; else &#123; result= (2 - Math.sin(Math.PI * input)).toFloat() / 2 &#125; return result // 返回的result值 = 随着动画进度呈先减速后加速的变化趋势 &#125;&#125; InterpolatorActivity 123456val curTranslationX = bt_anim_interpolator.translationXval animator = ObjectAnimator.ofFloat(bt_anim_interpolator, &quot;translationX&quot;, curTranslationX, 300f, curTranslationX)animator.duration = 5000animator.interpolator = DecelerateAccelerateInterpolator()animator.start() ObjectAnimator与 ValueAnimator类的区别 ValueAnimator 类是先改变值，然后 手动赋值 给对象的属性从而实现动画；是 间接 对对象属性进行操作； ObjectAnimator 类是先改变值，然后 自动赋值 给对象的属性从而实现动画；是 直接 对对象属性进行操作 估值器（TypeEvaluator) 和插值器 插值器（Interpolator）决定 值 的变化模式（匀速、加速） 估值器（TypeEvaluator）决定 值 的具体变化数值,设置动画从初始值过渡到结束值的逻辑。 https://blog.csdn.net/carson_ho/article/details/99619871 作者：Carson_Ho链接：https://www.jianshu.com/p/7c95342f4bc2 ​ https://www.jianshu.com/p/2f19fe1e3ca1 来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"anim","slug":"anim","permalink":"http://noteforme.github.io.com/categories/anim/"}],"tags":[],"keywords":[{"name":"anim","slug":"anim","permalink":"http://noteforme.github.io.com/categories/anim/"}]},{"title":"AnimationView","slug":"AnimationView","date":"2019-12-26T10:23:55.000Z","updated":"2021-08-19T11:11:43.675Z","comments":true,"path":"2019/12/26/AnimationView/","link":"","permalink":"http://noteforme.github.io.com/2019/12/26/AnimationView/","excerpt":"","text":"View Animation第一种就pass了，看下View Animation: You can use the view animation system to perform tweened animation on Views. Tween animation calculates the animation with information such as the start point, end point, size, rotation, and other common aspects of an animation. 这种动画可以在一个视图容器执行 位置、大小、旋转、透明度的变化，使用XML定义更具可读性 -set|-android:interpolator -&gt; 插值器，影响动画的速度 |-默认值 -&gt; @android:anim/accelerate_decelerate_interpolator|-android:shareInterpolator -&gt; 集合所有动画是否使用同一插值器|-android:fillAfter -&gt; 动画结束后View是否停留在结束的位置|-android:startOffset -&gt; 动画多少秒之后执行|-android:repeatMode -&gt; 重复的模式,默认为restart,即重头开始重新运行,reverse即从结束开始向前重新运行-TranslateAnimation -&gt; 移动View|- |-android:fillAfter -&gt; |-android:duration -&gt; 表示动画持续的时间 |-android:fromXDelta -&gt; 表示 x 的起始值 |-android:toXDelta -&gt; 表示 x 的结束值 |-android:fromYDelta -&gt; 表示 y 的起始值 |-android:toYDelta -&gt; 表示 y 的结束值-scaleAnimation -&gt; 放大或者缩小View|- |-android:duration -&gt; 表示动画持续的时间 |-android:fromXScale -&gt; 表示水平方向缩放的起始值 |-android:fromYScale -&gt; 表示竖直方向缩放的起始值 |-android:pivotX -&gt; 表示缩放中心点的 X 坐标 |-android:pivotY -&gt; 表示缩放中心点的 Y 坐标 |-android:toXScale -&gt; 表示水平方向缩放的结束值 |-android:toYScale -&gt; 表示竖直方向缩放的结束值-RotateAnimation -&gt; 旋转View|- |-android:duration -&gt; 表示动画持续的时间 |-android:fromDegrees -&gt; 旋转开始的角度 |-android:toDegrees -&gt; 旋转结束的角度 |-android:pivotX -&gt; 旋转中心点的 X 坐标 |-android:pivotY -&gt; 旋转中心点的 Y 坐标-AlphaAnimation -&gt; 改变View的透明度|- |-android:duration -&gt; 表示动画持续的时间 |-android:fromAlpha -&gt; 透明度的起始值 |-android:toAlpha -&gt; 透明度的结束值-自定义View动画 -&gt; (不会,待实践中学习) 1234private fun anim(resAnim:Int)&#123; val translateAnimation = AnimationUtils.loadAnimation(this,resAnim) textView5.startAnimation(translateAnimation)&#125; view_anim_translate.xml 12345678910111213141516// 以下参数是4种动画效果的公共属性,即都有的属性 android:duration=&quot;3000&quot; // 动画持续时间（ms），必须设置，动画才有效果 android:startOffset =&quot;1000&quot; // 动画延迟开始时间（ms） android:fillBefore = “true” // 动画播放完后，视图是否会停留在动画开始的状态，默认为true android:fillAfter = “false” // 动画播放完后，视图是否会停留在动画结束的状态，优先于fillBefore值，默认为false android:fillEnabled= “true” // 是否应用fillBefore值，对fillAfter值无影响，默认为true android:repeatMode= “restart” // 选择重复播放动画模式，restart代表正序重放，reverse代表倒序回放，默认为restart| android:repeatCount = “0” // 重放次数（所以动画的播放次数=重放次数+1），为infinite时无限重复 android:interpolator = @[package:]anim/interpolator_resource // 插值器，即影响动画的播放速度,下面会详细讲 // 以下参数是平移动画特有的属性 android:fromXDelta=&quot;0&quot; // 视图在水平方向x 移动的起始值 android:toXDelta=&quot;500&quot; // 视图在水平方向x 移动的结束值 android:fromYDelta=&quot;0&quot; // 视图在竖直方向y 移动的起始值 android:toYDelta=&quot;500&quot; // 视图在竖直方向y 移动的结束值 View_anim_translate.xml 12345678910111213141516171819202122232425262728293031&lt;!-- // 以下参数是4种动画效果的公共属性,即都有的属性 android:duration=&quot;3000&quot; // 动画持续时间（ms），必须设置，动画才有效果 android:startOffset =&quot;1000&quot; // 动画延迟开始时间（ms） android:fillBefore = “true” // 动画播放完后，视图是否会停留在动画开始的状态，默认为true android:fillAfter = “false” // 动画播放完后，视图是否会停留在动画结束的状态，优先于fillBefore值，默认为false android:fillEnabled= “true” // 是否应用fillBefore值，对fillAfter值无影响，默认为true android:repeatMode= “restart” // 选择重复播放动画模式，restart代表正序重放，reverse代表倒序回放，默认为restart| android:repeatCount = “0” // 重放次数（所以动画的播放次数=重放次数+1），为infinite时无限重复 android:interpolator = @[package:]anim/interpolator_resource // 插值器，即影响动画的播放速度,下面会详细讲 // 以下参数是缩放动画特有的属性 android:fromXScale=&quot;0.0&quot; // 动画在水平方向X的起始缩放倍数 // 0.0表示收缩到没有；1.0表示正常无伸缩 // 值小于1.0表示收缩；值大于1.0表示放大 android:toXScale=&quot;2&quot; //动画在水平方向X的结束缩放倍数 android:fromYScale=&quot;0.0&quot; //动画开始前在竖直方向Y的起始缩放倍数 android:toYScale=&quot;2&quot; //动画在竖直方向Y的结束缩放倍数 android:pivotX=&quot;50%&quot; // 缩放轴点的x坐标 android:pivotY=&quot;50%&quot; // 缩放轴点的y坐标 // 轴点 = 视图缩放的中心点 // pivotX pivotY,可取值为数字，百分比，或者百分比p // 设置为数字时（如50），轴点为View的左上角的原点在x方向和y方向加上50px的点。在Java代码里面设置这个参数的对应参数是Animation.ABSOLUTE。 // 设置为百分比时（如50%），轴点为View的左上角的原点在x方向加上自身宽度50%和y方向自身高度50%的点。在Java代码里面设置这个参数的对应参数是Animation.RELATIVE_TO_SELF。 // 设置为百分比p时（如50%p），轴点为View的左上角的原点在x方向加上父控件宽度50%和y方向父控件高度50%的点。在Java代码里面设置这个参数的对应参数是Animation.RELATIVE_TO_PARENT // 两个50%表示动画从自身中间开始，具体如下图 android:pivotX=”50%” // 缩放轴点的x坐标 android:pivotY=”50%” // 缩放轴点的y坐标 这个拿掉看看效果 添加 pivotX pivotY Rotate 12345678910111213// 以下参数是旋转动画特有的属性 android:duration=&quot;1000&quot; android:fromDegrees=&quot;0&quot; // 动画开始时 视图的旋转角度(正数 = 顺时针，负数 = 逆时针) android:toDegrees=&quot;270&quot; // 动画结束时 视图的旋转角度(正数 = 顺时针，负数 = 逆时针) android:pivotX=&quot;50%&quot; // 旋转轴点的x坐标 android:pivotY=&quot;0&quot; // 旋转轴点的y坐标 // 轴点 = 视图缩放的中心点 // pivotX pivotY,可取值为数字，百分比，或者百分比p // 设置为数字时（如50），轴点为View的左上角的原点在x方向和y方向加上50px的点。在Java代码里面设置这个参数的对应参数是Animation.ABSOLUTE。 // 设置为百分比时（如50%），轴点为View的左上角的原点在x方向加上自身宽度50%和y方向自身高度50%的点。在Java代码里面设置这个参数的对应参数是Animation.RELATIVE_TO_SELF。 // 设置为百分比p时（如50%p），轴点为View的左上角的原点在x方向加上父控件宽度50%和y方向父控件高度50%的点。在Java代码里面设置这个参数的对应参数是Animation.RELATIVE_TO_PARENT // 两个50%表示动画从自身中间开始，具体如下图 alpha 12345678910111213// 以下参数是4种动画效果的公共属性,即都有的属性android:duration=&quot;3000&quot; // 动画持续时间（ms），必须设置，动画才有效果android:startOffset =&quot;1000&quot; // 动画延迟开始时间（ms）android:fillBefore = “true” // 动画播放完后，视图是否会停留在动画开始的状态，默认为trueandroid:fillAfter = “false” // 动画播放完后，视图是否会停留在动画结束的状态，优先于fillBefore值，默认为falseandroid:fillEnabled= “true” // 是否应用fillBefore值，对fillAfter值无影响，默认为trueandroid:repeatMode= “restart” // 选择重复播放动画模式，restart代表正序重放，reverse代表倒序回放，默认为restart|android:repeatCount = “0” // 重放次数（所以动画的播放次数=重放次数+1），为infinite时无限重复android:interpolator = @[package:]anim/interpolator_resource // 插值器，即影响动画的播放速度,下面会详细讲// 以下参数是透明度动画特有的属性android:fromAlpha=&quot;1.0&quot; // 动画开始时视图的透明度(取值范围: -1 ~ 1)android:toAlpha=&quot;0.0&quot;// 动画结束时视图的透明度(取值范围: -1 ~ 1) 组合动画 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;// 采用&lt; Set/&gt;标签&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;// 组合动画同样具备公共属性 android:duration=&quot;3000&quot; // 动画持续时间（ms），必须设置，动画才有效果 android:startOffset =&quot;1000&quot; // 动画延迟开始时间（ms） android:fillBefore = “true” // 动画播放完后，视图是否会停留在动画开始的状态，默认为true android:fillAfter = “false” // 动画播放完后，视图是否会停留在动画结束的状态，优先于fillBefore值，默认为false android:fillEnabled= “true” // 是否应用fillBefore值，对fillAfter值无影响，默认为true android:repeatMode= “restart” // 选择重复播放动画模式，restart代表正序重放，reverse代表倒序回放，默认为restart| android:repeatCount = “0” // 重放次数（所以动画的播放次数=重放次数+1），为infinite时无限重复 android:interpolator = @[package:]anim/interpolator_resource // 插值器，即影响动画的播放速度,下面会详细讲 // 组合动画独特的属性 android:shareinterpolator = “true” // 表示组合动画中的动画是否和集合共享同一个差值器 // 如果集合不指定插值器，那么子动画需要单独设置// 组合动画播放时是全部动画同时开始// 如果想不同动画不同时间开始就要使用android:startOffset属性来延迟单个动画播放时间// 设置旋转动画，语法同单个动画 &lt;rotate android:duration=&quot;1000&quot; android:fromDegrees=&quot;0&quot; android:toDegrees=&quot;360&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:repeatMode=&quot;restart&quot; android:repeatCount=&quot;infinite&quot; /&gt;// 设置平移动画，语法同单个动画 &lt;translate android:duration=&quot;10000&quot; android:startOffset = “1000”// 延迟该动画播放时间 android:fromXDelta=&quot;-50%p&quot; android:fromYDelta=&quot;0&quot; android:toXDelta=&quot;50%p&quot; android:toYDelta=&quot;0&quot; /&gt;// 设置透明度动画，语法同单个动画 &lt;alpha android:startOffset=&quot;7000&quot; android:duration=&quot;3000&quot; android:fromAlpha=&quot;1.0&quot; android:toAlpha=&quot;0.0&quot; /&gt;// 设置缩放动画，语法同单个动画 &lt;scale android:startOffset=&quot;4000&quot; android:duration=&quot;1000&quot; android:fromXScale=&quot;1.0&quot; android:fromYScale=&quot;1.0&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:toXScale=&quot;0.5&quot; android:toYScale=&quot;0.5&quot; /&gt;// 特别注意：// 1. 在组合动画里scale缩放动画设置的repeatCount（重复播放）和fillBefore（播放完后，视图是否会停留在动画开始的状态）是无效的。// 2. 所以如果需要重复播放或者回到原位的话需要在set标签里设置// 3. 但是由于此处rotate旋转动画里已设置repeatCount为infinite，所以动画不会结束，也就看不到重播和回复原位&lt;/set&gt; 它是一个接一个播放，可以通过设置repeatCount 达到同时播放的目的 监听动画 Animation.addListener anim.addListener(new AnimatorListenerAdapter() 应用 Activity入场 activity_anim_enter.xml 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;translate android:duration= &quot;3000&quot; android:fromXDelta=&quot;100%p&quot; android:toXDelta=&quot;0%p&quot;/&gt;&lt;/set&gt; activity_anim_exit.xml 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;translate android:duration= &quot;3000&quot; android:fromXDelta=&quot;0%p&quot; android:toXDelta=&quot;-100%p&quot;/&gt;&lt;/set&gt; 视图组（ViewGroup）动画插值器https://www.jianshu.com/p/2f19fe1e3ca1 https://blog.csdn.net/carson_ho/article/details/72827747","categories":[{"name":"anim","slug":"anim","permalink":"http://noteforme.github.io.com/categories/anim/"}],"tags":[],"keywords":[{"name":"anim","slug":"anim","permalink":"http://noteforme.github.io.com/categories/anim/"}]},{"title":"AnimBitmaps","slug":"AnimBitmaps","date":"2019-12-25T07:38:00.000Z","updated":"2021-08-19T11:11:43.546Z","comments":true,"path":"2019/12/25/AnimBitmaps/","link":"","permalink":"http://noteforme.github.io.com/2019/12/25/AnimBitmaps/","excerpt":"","text":"Overviewhttps://developer.android.com/training/animation Animate drawable graphicsThe first option is to use an Animation Drawable. This allows you to specify several static drawable files that will be displayed one at a time to create an animation. The second option is to use an Animated Vector Drawable, which lets you animate the properties of a vector drawable. The XML file consists of &lt;animation=list&gt; 123456&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=&quot;true&quot;&gt; &lt;item android:drawable=&quot;@drawable/rocket_thrust1&quot; android:duration=&quot;200&quot; /&gt; &lt;item android:drawable=&quot;@drawable/rocket_thrust2&quot; android:duration=&quot;200&quot; /&gt; &lt;item android:drawable=&quot;@drawable/rocket_thrust3&quot; android:duration=&quot;200&quot; /&gt;&lt;/animation-list&gt; in which the animation is added to an ImageView and then animated when the screen is touched 12345678910111213private lateinit var rocketAnimation: AnimationDrawableoverride fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.main) val rocketImage = findViewById&lt;ImageView&gt;(R.id.rocket_image).apply &#123; setBackgroundResource(R.drawable.rocket_thrust) rocketAnimation = background as AnimationDrawable &#125; rocketImage.setOnClickListener(&#123; rocketAnimation.start() &#125;)&#125; It’s important to note that the start() method called on the AnimationDrawable cannot be called during the onCreate() method of your Activity, because the AnimationDrawable is not yet fully attached to the window. If you want to play the animation immediately, without requiring interaction, then you might want to call it from the onStart() method in your Activity, which will get called when Android makes the view visible on screen. AnimatedVectorDrawable","categories":[{"name":"anim","slug":"anim","permalink":"http://noteforme.github.io.com/categories/anim/"}],"tags":[],"keywords":[{"name":"anim","slug":"anim","permalink":"http://noteforme.github.io.com/categories/anim/"}]},{"title":"JCenterPublish","slug":"JCenterPublish","date":"2019-12-12T22:30:57.000Z","updated":"2021-08-19T11:11:43.981Z","comments":true,"path":"2019/12/13/JCenterPublish/","link":"","permalink":"http://noteforme.github.io.com/2019/12/13/JCenterPublish/","excerpt":"","text":"nexus sonatype 主要步骤按照这个操作 https://www.gcssloop.com/gebug/maven-private 注意： 密码不再是 admin admin 123了按照这个步骤 https://www.jianshu.com/p/fcb128e34c87 部署好一个平台后，sonatype-work复制过去，其他配置就不用再弄了，注意nexus-3.20.0-04-unix.tar.gz解压后也会有sonatype-work文件，可能会把之前的覆盖 运行 在命令行工具中输入启动命令： software/nexus-3.20.0-04-mac/nexus-3.20.0-04/bin 1./nexus start 如果一切顺利，在等待几十秒到一两分钟之后就可以查看我们的仓库了，如果出错了，可以使用 run 命令来查看具体的出错原因： 12# run 命令相当于 debug 模式，会输出所有的日志信息./nexus run 当然，Nexus 还有很多其他命令(例如:停止、重启、查看状态等)： 1./nexus &#123;start|stop|run|run-redirect|status|restart|force-reload&#125; 注意:windows启动是这样的 .\\nexus.exe /run 打包 在配置完善后同步一下项目，就可以打开 gradle 命令菜单看到多出来了3个命令，双击即可执行对应的命令： pack：打包项目 uploadToLocal：上传到本机仓库 uploadToPublic：上传到公网仓库 查看 http://localhost:8081 即可查看，如果修改了端口号，后面写对应的端口号即可。如果是运行在服务器上，则在其他电脑上输入http://&#123;服务器ip&#125;:&#123;port&#125; IP 和对应的端口号。如果运行成功，则会看到类似如下界面： Prepare Setting the JDK path 123Open ~/.bash_profile export JAVA_HOME=$(/usr/libexec/java_home)source ~/.bash_profile https://android.jlelse.eu/publishing-your-android-kotlin-or-java-library-to-jcenter-from-android-studio-1b24977fe450 maven center按照这个教程参考**TestMavenUp* 就差不多了 https://www.jianshu.com/p/6c1d2688ed2d/ https://www.jianshu.com/p/0629548ab5a4 可以把项目和jar放到同一个目录","categories":[{"name":"TOOL","slug":"TOOL","permalink":"http://noteforme.github.io.com/categories/TOOL/"}],"tags":[],"keywords":[{"name":"TOOL","slug":"TOOL","permalink":"http://noteforme.github.io.com/categories/TOOL/"}]},{"title":"Math_Trigonometric_functions","slug":"Math-Trigonometric-functions","date":"2019-12-08T11:34:25.000Z","updated":"2021-08-19T11:11:44.127Z","comments":true,"path":"2019/12/08/Math-Trigonometric-functions/","link":"","permalink":"http://noteforme.github.io.com/2019/12/08/Math-Trigonometric-functions/","excerpt":"","text":"Trigonometric functionhttps://zhidao.baidu.com/question/498563235 https://www.shuxuele.com/algebra/trig-four-quadrants.html","categories":[{"name":"Mathematics","slug":"Mathematics","permalink":"http://noteforme.github.io.com/categories/Mathematics/"}],"tags":[],"keywords":[{"name":"Mathematics","slug":"Mathematics","permalink":"http://noteforme.github.io.com/categories/Mathematics/"}]},{"title":"TEST_UNIT","slug":"TEST-UNIT","date":"2019-11-17T12:49:14.000Z","updated":"2021-09-09T02:15:16.299Z","comments":true,"path":"2019/11/17/TEST-UNIT/","link":"","permalink":"http://noteforme.github.io.com/2019/11/17/TEST-UNIT/","excerpt":"","text":"Test Driven Development MainPrinciple:Write the test case before the implementation of the function (only for unit tests) Write the function signature Write the test cases for the function Write the function logic so the tests pass You should only have one assertion per test case. 123456789101112131415161718192021222324252627282930object RegistrationUtil &#123; private val exitingUsers = listOf(&quot;Peter&quot;,&quot;Carl&quot;) /** * the input is not valid if... * ...the username /password is empty * ...the username is already taken * ...the confirmed password is not the same as the real password * ...the pasword contains less than 2 digits */ fun validateRegistrationInput( userName: String, password: String, confirmedPassword: String ):Boolean&#123; if (userName.isEmpty()||password.isEmpty())&#123; return false &#125; if (userName in exitingUsers)&#123; return false &#125; if (password!=confirmedPassword)&#123; return false &#125; if (password.count&#123;it.isDigit()&#125;&lt;2)&#123; return false &#125; return true &#125;&#125; RegistrationUtilTest.kt 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import com.google.common.truth.Truth.assertThatimport org.junit.Testclass RegistrationUtilTest&#123; @Test fun `empty username returns false`() &#123; val result = RegistrationUtil.validateRegistrationInput( &quot;&quot;, &quot;123&quot;, &quot;123&quot; ) assertThat(result).isFalse() &#125; @Test fun `valid username and correctly repeated password returns true`() &#123; val result = RegistrationUtil.validateRegistrationInput( &quot;Philipp&quot;, &quot;123&quot;, &quot;123&quot; ) assertThat(result).isTrue() &#125; @Test fun `username already exists returns false`() &#123; val result = RegistrationUtil.validateRegistrationInput( &quot;Carl&quot;, &quot;123&quot;, &quot;123&quot; ) assertThat(result).isFalse() &#125; @Test fun `incorrectly confirmed password returns false`() &#123; val result = RegistrationUtil.validateRegistrationInput( &quot;Philipp&quot;, &quot;123456&quot;, &quot;abcdefg&quot; ) assertThat(result).isFalse() &#125; @Test fun `empty password returns false`() &#123; val result = RegistrationUtil.validateRegistrationInput( &quot;Philipp&quot;, &quot;&quot;, &quot;&quot; ) assertThat(result).isFalse() &#125; @Test fun `less than 2 digit password returns false`() &#123; val result = RegistrationUtil.validateRegistrationInput( &quot;Philipp&quot;, &quot;abcdefg5&quot;, &quot;abcdefg5&quot; ) assertThat(result).isFalse() &#125;&#125; https://www.youtube.com/watch?v=W0ag98EDhGc&amp;list=PLQkwcJG4YTCSYJ13G4kVIJ10X5zisB2Lq&amp;index=3","categories":[{"name":"TEST","slug":"TEST","permalink":"http://noteforme.github.io.com/categories/TEST/"}],"tags":[{"name":"Test","slug":"Test","permalink":"http://noteforme.github.io.com/tags/Test/"}],"keywords":[{"name":"TEST","slug":"TEST","permalink":"http://noteforme.github.io.com/categories/TEST/"}]},{"title":"SharedPreferences","slug":"SharedPreferences","date":"2019-11-06T06:50:12.000Z","updated":"2021-08-19T11:11:44.238Z","comments":true,"path":"2019/11/06/SharedPreferences/","link":"","permalink":"http://noteforme.github.io.com/2019/11/06/SharedPreferences/","excerpt":"","text":"The different commit and apply","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"SurfaceView","slug":"SurfaceView","date":"2019-11-05T04:42:57.000Z","updated":"2021-08-19T11:11:44.238Z","comments":true,"path":"2019/11/05/SurfaceView/","link":"","permalink":"http://noteforme.github.io.com/2019/11/05/SurfaceView/","excerpt":"","text":"我们知道View是通过刷新来重绘视图，系统通过发出VSSYNC信号来进行屏幕的重绘，刷新的时间间隔是16ms,如果我们可以在16ms以内将绘制工作完成，则没有任何问题，如果我们绘制过程逻辑很复杂，并且我们的界面更新还非常频繁，这时候就会造成界面的卡顿，影响用户体验，为此Android提供了SurfaceView来解决这一问题。 如果View需要频繁的刷新，或者刷新的数据量比较大，就需要使用SurfaceView 优势 View中刷新频繁，Ondraw()会频繁调用,onDraw方法执行的时间过程会掉帧，出现页面卡顿。SurfaceView使用双缓冲技术，提高了绘制速度，可以缓解这一现象。 SurfaceView可以在子线程更新UI,不会阻塞主线程，提高了响应速度. https://www.jianshu.com/p/b037249e6d31 啥是双缓冲技术?https://blog.csdn.net/guanguanboy/article/details/99715643 Android群英传 6.8 SurfaceView使用模板大部分绘图都按照模板来 SurfaceViewTemplate 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class SurfaceViewTemplate extends SurfaceView implements SurfaceHolder.Callback, Runnable &#123; private SurfaceHolder mSurfaceHolder; //绘图的Canvas private Canvas mCanvas; //子线程标志位 private boolean mIsDrawing; public SurfaceViewTemplate(Context context) &#123; this(context, null); &#125; public SurfaceViewTemplate(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public SurfaceViewTemplate(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); initView(); &#125; @Override public void surfaceCreated(SurfaceHolder holder) &#123; mIsDrawing = true; //开启子线程 new Thread(this).start(); &#125; @Override public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123; &#125; @Override public void surfaceDestroyed(SurfaceHolder holder) &#123; mIsDrawing = false; &#125; @Override public void run() &#123; while (mIsDrawing)&#123; draw(); &#125; &#125; //绘图逻辑 private void draw() &#123; try &#123; //获得当前Canva绘图对象，获取的还是继续上次的Canvas对象，而不是一个新的对象,因此之前的绘图都将被保留，如果需要擦除，则绘制前，通过drawColor()方法进行清屏操作. mCanvas = mSurfaceHolder.lockCanvas(); //绘制背景 mCanvas.drawColor(Color.WHITE); //绘图 &#125;catch (Exception e)&#123; &#125;finally &#123; if (mCanvas != null)&#123; //释放canvas对象并提交画布 mSurfaceHolder.unlockCanvasAndPost(mCanvas); &#125; &#125; &#125; /** * 初始化View */ private void initView()&#123; mSurfaceHolder = getHolder(); mSurfaceHolder.addCallback(this); setFocusable(true); setKeepScreenOn(true); setFocusableInTouchMode(true); &#125;&#125; 正旋曲线 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/** * https://www.jianshu.com/p/b037249e6d31 */public class SurfaceViewSinFun extends SurfaceView implements SurfaceHolder.Callback, Runnable &#123; private SurfaceHolder mSurfaceHolder; //绘图的Canvas private Canvas mCanvas; //子线程标志位 private boolean mIsDrawing; private int x = 0, y = 0; private Paint mPaint; private Path mPath; public SurfaceViewSinFun(Context context) &#123; this(context, null); &#125; public SurfaceViewSinFun(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public SurfaceViewSinFun(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); mPaint = new Paint(); mPaint.setColor(Color.BLACK); mPaint.setStyle(Paint.Style.STROKE); mPaint.setAntiAlias(true); mPaint.setStrokeWidth(5); mPath = new Path(); //路径起始点(0, 100) mPath.moveTo(0, 100); initView(); &#125; @Override public void surfaceCreated(SurfaceHolder holder) &#123; mIsDrawing = true; new Thread(this).start(); &#125; @Override public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123; &#125; @Override public void surfaceDestroyed(SurfaceHolder holder) &#123; mIsDrawing = false; &#125; @Override public void run() &#123; long start = System.currentTimeMillis(); while (mIsDrawing)&#123; drawSomething(); x += 1; y = (int)(100 * Math.sin(2 * x * Math.PI / 180) + 400); //加入新的坐标点 mPath.lineTo(x, y); &#125; //控制绘制频率 long end = System.currentTimeMillis(); //50 - 100 if (end - start&lt;100)&#123; try &#123; Thread.sleep(100-(end-start)); //相当于绘制一次总的时间 100ms &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; private void drawSomething() &#123; try &#123; //获得canvas对象 mCanvas = mSurfaceHolder.lockCanvas(); //绘制背景 mCanvas.drawColor(Color.WHITE); //绘制路径 mCanvas.drawPath(mPath, mPaint); &#125;catch (Exception e)&#123; &#125;finally &#123; if (mCanvas != null)&#123; //释放canvas对象并提交画布 mSurfaceHolder.unlockCanvasAndPost(mCanvas); &#125; &#125; &#125; /** * 初始化View */ private void initView()&#123; mSurfaceHolder = getHolder(); mSurfaceHolder.addCallback(this); setFocusable(true); setKeepScreenOn(true); setFocusableInTouchMode(true); &#125;&#125; 通过draw()方法所使用的逻辑时长来确定sleep的时长，这是一个非常通用的解决方案，每次绘制时间控制在100ms 画板 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/** * 画板 */class DrawingBoardView : SurfaceView, SurfaceHolder.Callback, Runnable &#123; private var mCanvas: Canvas? = null private var mSurfaceHolder: SurfaceHolder? = holder //子线程标志位 private var mIsDrawing = false private val x = 0 private var y: Int = 0 private var mPaint: Paint? = Paint().apply &#123; color = Color.BLACK style = Paint.Style.STROKE isAntiAlias = true strokeWidth = 5f &#125; private var mPath: Path? = null constructor(context: Context) : this(context, null) constructor(context: Context, attrs: AttributeSet?) : this(context, attrs, 0) constructor(context: Context, attrs: AttributeSet?, defStyleAttr: Int) : super(context, attrs, defStyleAttr) &#123; &#125; init &#123; mSurfaceHolder?.addCallback(this) isFocusable = true keepScreenOn = true isFocusableInTouchMode = true mPath = Path() &#125; override fun surfaceChanged(holder: SurfaceHolder?, format: Int, width: Int, height: Int) &#123; &#125; override fun surfaceDestroyed(holder: SurfaceHolder?) &#123; &#125; override fun surfaceCreated(holder: SurfaceHolder?) &#123; mIsDrawing = true //开启子线程 Thread(this).start() &#125; override fun run() &#123; while (mIsDrawing) &#123; draw() &#125; &#125; private fun draw() &#123; try &#123; mCanvas = mSurfaceHolder?.lockCanvas() //SurfaceView背景 mCanvas?.drawColor(Color.WHITE) mPaint?.let &#123; mPath?.let &#123; it1 -&gt; mCanvas?.drawPath(it1, it) &#125; &#125; &#125; catch (e: Exception) &#123; &#125; finally &#123; mCanvas?.let &#123; mSurfaceHolder?.unlockCanvasAndPost(it) &#125; &#125; &#125; override fun onTouchEvent(event: MotionEvent?): Boolean &#123; val x = event?.x val y = event?.y when (event?.action) &#123; MotionEvent.ACTION_DOWN -&gt; x?.let &#123; if (y != null) &#123; mPath?.moveTo(it, y) &#125; &#125; MotionEvent.ACTION_MOVE -&gt; x?.let &#123; if (y != null) &#123; mPath?.lineTo(it, y) &#125; &#125; &#125; return true &#125;&#125;","categories":[{"name":"VIEW","slug":"VIEW","permalink":"http://noteforme.github.io.com/categories/VIEW/"}],"tags":[],"keywords":[{"name":"VIEW","slug":"VIEW","permalink":"http://noteforme.github.io.com/categories/VIEW/"}]},{"title":"room","slug":"room","date":"2019-09-20T02:22:52.000Z","updated":"2021-08-19T11:11:44.316Z","comments":true,"path":"2019/09/20/room/","link":"","permalink":"http://noteforme.github.io.com/2019/09/20/room/","excerpt":"","text":"https://developer.android.com/training/data-storage/room Room https://codelabs.developers.google.com/codelabs/android-room-with-a-view/#0 https://codelabs.developers.google.com/codelabs/android-room-with-a-view-kotlin/#0 kotlin need familiar [basic coroutines]( 数据库基本操作 主键 每个实体必须定义至少1个字段作为主键。即使只有1个字段，仍然需要用@PrimaryKey注解字段。此外，如果您想Room自动分配IDs给实体，则可以设置@PrimaryKey的autoGenerate属性。如果实体具有复合主键，则可以使用@Entity注解的primaryKeys属性 Entity 12345678@Entitypublic class BleData &#123; @PrimaryKey public int id; public long createDttm; public String bleParam;&#125; Dao https://developer.android.com/topic/libraries/architecture/room https://github.com/googlecodelabs/android-room-with-a-view https://codelabs.developers.google.com/codelabs/android-room-with-a-view/#0 https://github.com/googlecodelabs/android-room-with-a-view/tree/kotlin https://blog.skymxc.com/2018/04/15/Room/ https://www.jianshu.com/p/0ed8b17a199e 索引为什么加快访问速度 数据库迁移https://www.jianshu.com/p/72eeaded8913 https://blog.csdn.net/a254837127/article/details/84564545 https://developer.android.com/training/data-storage/room#java https://codelabs.developers.google.com/codelabs/kotlin-coroutines/#0)","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[{"name":"DB","slug":"DB","permalink":"http://noteforme.github.io.com/tags/DB/"}],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"RxJava02","slug":"RxJava02","date":"2019-09-19T03:50:24.000Z","updated":"2021-08-19T11:11:44.237Z","comments":true,"path":"2019/09/19/RxJava02/","link":"","permalink":"http://noteforme.github.io.com/2019/09/19/RxJava02/","excerpt":"","text":"操作符 retryWhen retryWhen是收到onError后触发是否要重订阅的询问，而repeatWhen是通过onComplete触发。 https://blog.csdn.net/qq_35599978/article/details/80290252 https://www.jianshu.com/p/d135f19e045c zip专用于合并事件，该合并不是连接（连接操作符后面会说），而是两两配对，也就意味着，最终配对出的 Observable 发射事件数目只和少的那个相同。 concat单一的把两个发射器连接成一个发射器 FlatMap它可以把一个发射器 Observable 通过某种方法转换为多个 Observables,flatMap 并不能保证事件的顺序 如果需要保证，需要用到我们下面要讲的 ConcatMap ConcatMapdoOnNext让订阅者在接收到数据之前可以做其他事情,获取到数据之前想先保存一下它 skip skip(2) 跳过count个数开始接收 take最多接收count个数据 just1Observable.just(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;) 简单的发射器依次调用 onNext() 方法 SingleSingle 只会接收一个参数，而 SingleObserver 只会调用 onError() 或者 onSuccess() distinct去重操作符，简单的作用就是去重 debouncedefer每次订阅都会创建一个新的 Observable，并且如果没有被订阅，就不会产生新的 last操作符仅取出可观察到的最后一个值 mergewindow按照实际划分窗口，将数据发送给不同的 Observable empty() &amp; never() &amp; error() empty() ： 直接发送 onComplete() 事件 never()：不发送任何事件 error()：发送 onError() 事件 https://www.jianshu.com/p/c08bfc58f4b6","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"http://noteforme.github.io.com/tags/RxJava/"}],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"ThreadStop","slug":"ThreadStop","date":"2019-08-30T02:00:40.000Z","updated":"2021-08-19T11:11:44.252Z","comments":true,"path":"2019/08/30/ThreadStop/","link":"","permalink":"http://noteforme.github.io.com/2019/08/30/ThreadStop/","excerpt":"","text":"https://segmentfault.com/a/1190000007961347 https://www.cnblogs.com/xingele0917/p/3994468.html","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}],"tags":[],"keywords":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}]},{"title":"GreenDao","slug":"GreenDao","date":"2019-08-12T09:42:58.000Z","updated":"2021-08-19T11:11:43.904Z","comments":true,"path":"2019/08/12/GreenDao/","link":"","permalink":"http://noteforme.github.io.com/2019/08/12/GreenDao/","excerpt":"","text":"基本使用数据库定义 Bean schema：告知GreenDao当前实体属于哪个schema active：标记一个实体处于活跃状态，活动实体有更新、删除和刷新方法 nameInDb：在数据库中使用的别名，默认使用的是实体的类名 indexes：定义索引，可以跨越多个列 createInDb：标记创建数据库表 基础属性注解 @Id：主键 Long 型，可以通过@Id(autoincrement = true)设置自增长@Property：设置一个非默认关系映射所对应的列名，默认是使用字段名，例如：@Property(nameInDb = “name”)@NotNull：设置数据库表当前列不能为空@Transient：添加此标记后不会生成数据库表的列 索引注解 @Index：使用@Index作为一个属性来创建一个索引，通过name设置索引别名，也可以通过unique给索引添加约束@Unique：向数据库添加了一个唯一的约束 关系注解 @ToOne：定义与另一个实体（一个实体对象）的关系@ToMany：定义与多个实体对象的关系 https://blog.csdn.net/speedystone/article/details/72769793 @Convert 自定义类型123456public @interface Convert &#123; Class&lt;? extends PropertyConverter&gt; converter(); Class columnType(); //可以在DB中保留的列的类。这仅限于greenDAO原生支持的所有java类。&#125;@Convert(converter = NoteTypeConverter.class, columnType = String.class) //类型转换类，自定义的类型在数据库中存储的类型private NoteType type; //在保存到数据库时会将自定义的类型 NoteType 通过 NoteTypeConverter 转换为数据库支持的 String 类型。反之亦然 Basic123456789101112131415161718192021@Entitypublic class Student &#123; @Id(autoincrement = true) // id 递增 Long id; @Unique public int studentNo; public int age; //年龄 @Property(nameInDb = &quot;usePhone&quot;) //数据库中映射的字段就是 usePhone public String telPhone;//手机号 @Transient //数据库中不会创建对应的字段 String sex; //性别 String name;//姓名 String address;//家庭住址 String schoolName;//学校名字 String grade;//几年级 private boolean statue; insert insertData 12345678910111213141516171819for (int i = 0; i &lt; 4; i++) &#123; Student student = new Student(); student.setStudentNo(i); student.age = new Random().nextInt() + 10; student.telPhone = RandomValue.getTel(); student.setName(RandomValue.getChineseName()); if (i % 2 == 0) &#123; student.setSex(&quot;男&quot;); &#125; else &#123; student.setSex(&quot;女&quot;); &#125; if (i == 0) &#123; student.setStatue(true); &#125; student.setAddress(RandomValue.getRoad()); student.setSchoolName(RandomValue.getSchoolName()); long dsoi = studaoImpl.insert(student); Timber.i(&quot;insertData &quot; + dsoi);&#125; insertOrReplace 1234Student student = new Student();student.setStudentNo(1);student.setName(&quot;我改名了&quot;);long df = studaoImpl.insertOrReplace(student); updateData 1234Student student = new Student();student.setStudentNo(1);student.setName(&quot;我改名了&quot;);studaoImpl.update(student); delete 123Student student = new Student();student.setId(1l);studaoImpl.delete(student); deleteAll ​ studaoImpl.deleteAll(); query QueryAll 12List&lt;Student&gt; dd = studaoImpl.loadAll();studaoImpl.loadAll().forEach(current-&gt;Timber.i(current.toString())); // print student QueryLastState 123456List&lt;Student&gt; sList = studaoImpl.queryBuilder().limit(1).where(StudentDao.Properties.Statue.eq(false)).list();Timber.i(sList.toString());Student student = sList.get(0);student.setStatue(true);studaoImpl.update(student);sList = studaoImpl.queryBuilder().limit(1).where(StudentDao.Properties.Statue.eq(false)).list(); oneToOne1234567@Entitypublic class Person &#123; @Id(autoincrement = true) private long pid; private String name; private int age;&#125; 123456789@Entitypublic class CreditCard &#123; @Id(autoincrement = true) private long cid; private long pid; //idcard和person是一对一关系，外键为personId @ToOne(joinProperty = &quot;pid&quot;) private Person person; &#125; insert12345678Long pid = 6L;//personIdPerson p = new Person(pid, &quot;xiaoMing&quot;, 18);mPersonDao.insert(p);Long cid = 2L;//idcardid;CreditCard c = new CreditCard(cid, 100); //这个写了100（无论写什么）,实际还是6,关联了personIdc.setPerson(p);mCreditCardDao.insert(c); query12345678910111213141516171819202122List&lt;CreditCard&gt; list = mCreditCardDao.loadAll();CreditCard card = list.get(0);if (card != null) &#123; Timber.i(&quot;CardInfo cardid----------&gt;&quot; + card.getCid() + &quot; personid----------&gt;&quot; + card.getPid());&#125;switch (position) &#123; case 0: selectPersonInfoByCard(card);//根据idcard获取person break;&#125; private void selectPersonInfoByCard(CreditCard card) &#123; Person person = null; if (card != null) &#123; person = card.getPerson(); &#125; if (person != null) &#123; Timber.i(&quot;PersonByCard personId + ----------&gt; &quot; + person.getPid() + &quot; name----------&gt; &quot; + person.getName() + &quot; age----------&gt;&quot; + person.getAge()); &#125; else &#123; Timber.i(&quot;----获取person信息失败------&quot;); &#125; &#125; https://juejin.im/post/5a30f79c6fb9a045031014fd https://blog.csdn.net/qq_34358104/article/details/69833909 OneToMany123456789101112131415161718@Entitypublic class MStudent &#123; @Id(autoincrement = true) private Long sid; private String name; private Long tid;&#125;@Entitypublic class MTecher &#123; @Id(autoincrement = true) private Long tid; private String name; //一对多关系，tid为Student表的外键 @ToMany(referencedJoinProperty = &quot;tid&quot;) private List&lt;MStudent&gt; students; &#125; insert123456789101112131415161718192021222324252627282930313233/** * 添加Student信息 */ private void insertStudent() &#123; try &#123; Long sid = 1L; for (int i = 0; i &lt; 5; i++) &#123; MStudent s = new MStudent(sid, &quot;xiaoMing--&gt;&quot; + i, tid); mStudentDao.insert(s); sid++; &#125; Log.i(&quot;tag&quot;, &quot;学生信息添加成功&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); Log.i(&quot;tag&quot;, &quot;学生信息添加失败&quot;); &#125; &#125; /** * 添加Teacher信息 */ private void insertTeacher() &#123; try &#123; String name = &quot;Miss zhang&quot;; MTecher mTecher = new MTecher(tid, name); mTecherDao.insert(mTecher); Log.i(&quot;tag&quot;,&quot;教师信息添加成功&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); Log.i(&quot;tag&quot;,&quot;教师信息添加失败&quot;); &#125; &#125; query1234567891011121314151617181920212223242526272829303132private void selectTeacher() &#123; MTecher t = null; try &#123; t = mTecherDao.loadByRowId(tid); if (t != null)&#123; Log.i(&quot;tag&quot;,&quot;查询教师信息----&gt;成功&quot;); Log.i(&quot;tag&quot;,&quot;tid---&gt;&quot;+t.getTid()); Log.i(&quot;tag&quot;,&quot;teacher&#x27;s name-----&gt;&quot;+t.getName()); selectStudentByTeacher(t); &#125;else&#123; Log.i(&quot;tag&quot;,&quot;查询表中没有该教师信息&quot;); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); Log.i(&quot;tag&quot;,&quot;查询教师信息----&gt;失败&quot;); &#125;&#125; /** * 根据获取得到的Teacher获取其名下的学生信息 * @param t */ private void selectStudentByTeacher(MTecher t) &#123; List&lt;MStudent&gt; list = t.getStudents(); if (list != null &amp;&amp; list.size() &gt; 0)&#123; for (MStudent mStudent : list) &#123; Log.i(&quot;tag&quot;,&quot;sid---------&gt; &quot;+mStudent.getSid() +&quot; tid---------&gt;&quot;+mStudent.getTid()+&quot; name--------&gt;&quot;+mStudent.getName()); &#125; &#125;else&#123; Log.i(&quot;tag&quot;,&quot;--------获取学生信息失败--------&quot;); &#125; &#125; ManyToMany12345678910@Entitypublic class NTeacher &#123; @Id(autoincrement = true) private Long tid; private String name; @ToMany @JoinEntity(entity = TandSRelative.class, sourceProperty = &quot;tid&quot;, targetProperty = &quot;sid&quot;) private List&lt;TandSRelative&gt; list; &#125; 1234567891011@Entitypublic class NStudent &#123; @Id(autoincrement = true) private Long sid; private String name; @ToMany @JoinEntity(entity = TandSRelative.class,sourceProperty = &quot;sid&quot;,targetProperty = &quot;tid&quot;) List&lt;NTeacher&gt; teacherList;&#125; 12345678@Entitypublic class TandSRelative &#123; @Id(autoincrement = true) private Long tsid; private Long tid;//teacher的id private Long sid;//student的id&#125; insert12345678910111213141516171819202122232425262728293031323334353637 //2个教师和3个学生的关系//教师1，带学生1、2//教师2，带学生1、3//学生1，选修教师1和教师2的课 private void addTeacherStu() &#123; List&lt;NTeacher&gt; teacherList = new ArrayList&lt;&gt;(); for (long i = 1; i &lt; 3; i++) &#123; NTeacher teacherBean = new NTeacher(); teacherBean.setTid(i); teacherList.add(teacherBean); &#125; daoSession.getNTeacherDao().insertInTx(teacherList); List&lt;NStudent&gt; studentList = new ArrayList&lt;&gt;(); for (long j = 1; j &lt; 4; j++) &#123; NStudent studentBean = new NStudent(); studentBean.setSid(j); studentList.add(studentBean); &#125; //教师1带学生1、2 List&lt;TandSRelative&gt; teacherTeachStuList = new ArrayList&lt;&gt;(); TandSRelative tandSRelative1 = new TandSRelative(null, 1L, 1L); teacherTeachStuList.add(tandSRelative1); TandSRelative tandSRelative2 = new TandSRelative(null, 1L, 2L); teacherTeachStuList.add(tandSRelative2); TandSRelative tandSRelative3 = new TandSRelative(null, 2L, 1L); teacherTeachStuList.add(tandSRelative3); TandSRelative tandSRelative4 = new TandSRelative(null, 2L, 3L); teacherTeachStuList.add(tandSRelative4); daoSession.getTandSRelativeDao().insertInTx(teacherTeachStuList); &#125; https://www.cnblogs.com/Free-Thinker/p/10654474.html https://juejin.im/post/5a30f79c6fb9a045031014fd https://blog.csdn.net/RobotHost/article/details/70098744 migration12345678910111213141516171819202122public class MySQLiteOpenHelper extends DaoMaster.OpenHelper &#123; public MySQLiteOpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory) &#123; super(context, name, factory); &#125; @Override public void onUpgrade(Database db, int oldVersion, int newVersion) &#123;// super.onUpgrade(db, oldVersion, newVersion); MigrationHelper.migrate(db, new MigrationHelper.ReCreateAllTableListener() &#123; @Override public void onCreateAllTables(Database db, boolean ifNotExists) &#123; DaoMaster.createAllTables(db, ifNotExists); &#125; @Override public void onDropAllTables(Database db, boolean ifExists) &#123; DaoMaster.dropAllTables(db, ifExists); &#125; &#125;, StudentDao.class); //可以添加多个 &#125;&#125; 123456// DaoMaster.DevOpenHelper helper = new DaoMaster.DevOpenHelper(this, &quot;dblearn.db&quot;); MigrationHelper.DEBUG = true; MySQLiteOpenHelper helper = new MySQLiteOpenHelper(this,&quot;dblearn.db&quot;,null); SQLiteDatabase db = helper.getWritableDatabase(); DaoMaster daoMaster = new DaoMaster(db); daoSession = daoMaster.newSession(); 1234567891011121314151617181920212223242526272829@Entitypublic class Student &#123; @Id(autoincrement = true) // id 递增 Long id; @Unique public int studentNo; public int age; //年龄 @Property(nameInDb = &quot;usePhone&quot;) //数据库中映射的字段就是 usePhone public String telPhone;//手机号 @Transient //数据库中不会创建对应的字段 String sex; //性别 String name;//姓名 String address;//家庭住址 String schoolName;//学校名字 String grade;//几年级 private boolean statue; @ToOne(joinProperty = &quot;name&quot;) IdCard student; private String migrate; //新添加的字段 迁移 &#125; https://github.com/yuweiguocn/GreenDaoUpgradeHelper/blob/master/README_CH.md https://stackoverflow.com/questions/13373170/greendao-schema-update-and-data-migration/30334668#30334668 查看数据库database navigator![check_Screen Shot 2020-04-13 at 5.59.22 PM](GreenDao/check_Screen Shot 2020-04-13 at 5.59.22 PM.png) ![Screen Shot 2020-04-13 at 6.04.11 PM](GreenDao/Screen Shot 2020-04-13 at 6.04.11 PM.png) C:\\Users\\john\\Desktop\\dbsqlite Device file explorer里面查看 data/data/{$packname}/mine https://blog.csdn.net/yu75567218/article/details/78904909 数据缓存 RxJava实现数据网络数据缓存 https://blog.csdn.net/qq_35064774/article/details/53449795 用户测量数据有网上传 https://wenku.baidu.com/view/65f16f61998fcc22bdd10d5b.html https://my.oschina.net/banxi/blog/57984 https://www.infoq.cn/article/q-EjPtHOVFaE46XKjhlf","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[{"name":"DB","slug":"DB","permalink":"http://noteforme.github.io.com/tags/DB/"}],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"Binder","slug":"Binder","date":"2019-08-11T07:26:25.000Z","updated":"2021-08-19T11:11:43.695Z","comments":true,"path":"2019/08/11/Binder/","link":"","permalink":"http://noteforme.github.io.com/2019/08/11/Binder/","excerpt":"","text":"IPC方式信号量 共享内存 : 容易导致同步问题。因为用户端没法解决。 Socket Binder: 服务端映射后， 官方解决了同步问题。 多进程作用 Binder流程![](Binder/2021-08-11 _8.31_binder_over.png) Binder机制mmap作用让一块虚拟内存 指向一块已知的物理内存。 这个物理内存是binder提供的。 传统进程通信 Binder进程通信 查看进程分配的内存大小123AppledeMacBook-Pro:MineUtils apple$ adb shellgeneric_x86:/ $ getprop dalvik.vm.heapsize512m https://www.bilibili.com/video/BV1Hr4y1P7QC?from=search&amp;seid=18026610356055236655 https://www.bilibili.com/video/BV1Hr4y1P7QC?p=4 https://www.bilibili.com/video/BV1Hr4y1P7QC?p=5&amp;spm_id_from=pageDriver https://github.com/weidongshan/APP_0005_Binder_JAVA_App https://www.bilibili.com/video/BV1tW411i7aB?p=22","categories":[],"tags":[{"name":"AOSP","slug":"AOSP","permalink":"http://noteforme.github.io.com/tags/AOSP/"}],"keywords":[]},{"title":"Gradient","slug":"Gradient","date":"2019-07-22T09:41:27.000Z","updated":"2021-08-19T11:11:43.903Z","comments":true,"path":"2019/07/22/Gradient/","link":"","permalink":"http://noteforme.github.io.com/2019/07/22/Gradient/","excerpt":"","text":"LinearGradient1234567891011121314151617181920212223/** * LinearGradient * Create a shader that draws a linear gradient along a line. * * @param x0 The x-coordinate for the start of the gradient line * @param y0 The y-coordinate for the start of the gradient line * @param x1 The x-coordinate for the end of the gradient line * @param y1 The y-coordinate for the end of the gradient line * @param colors The colors to be distributed along the gradient line * @param positions May be null. The relative positions [0..1] of * each corresponding color in the colors array. If this is null, * the the colors are distributed evenly along the gradient line. 所占比例，渲染颜色所占比例,如果传null，则均匀渲染 * @param tile The Shader tiling mode */val colors = intArrayOf( Color.RED, Color.GREEN, Color.BLUE)val positions = floatArrayOf(0.5f, 1f, 0.5f)val linearGradient = LinearGradient(0f, 300f, 300f, 300f, colors, positions, Shader.TileMode.CLAMP)val mPaint = Paint()mPaint.setShader(linearGradient)canvas?.drawRect(0f, 0f, 300f, 300f, mPaint) LinearGradient（0f, 0f, 300f, 300f）,说明从 (0,0) 到(300,300)对角线方向渲染 https://www.jianshu.com/p/5fb82b189094 渐变模式 -CLAMP边缘拉伸-REPEAT在水平和垂直两个方向上重复，相邻图像没有间隙-MIRROR 以镜像的方式在水平和垂直两个方向上重复，相邻图像有间隙","categories":[{"name":"VIEW","slug":"VIEW","permalink":"http://noteforme.github.io.com/categories/VIEW/"}],"tags":[],"keywords":[{"name":"VIEW","slug":"VIEW","permalink":"http://noteforme.github.io.com/categories/VIEW/"}]},{"title":"TEST_Robolectric","slug":"TEST_Robolectric","date":"2019-06-13T01:42:52.000Z","updated":"2021-09-09T02:15:02.666Z","comments":true,"path":"2019/06/13/TEST_Robolectric/","link":"","permalink":"http://noteforme.github.io.com/2019/06/13/TEST_Robolectric/","excerpt":"","text":"robolectric 12testImplementation &#x27;org.robolectric:robolectric:4.3&#x27;testImplementation &quot;org.robolectric:shadows-multidex:4.0.1&quot; https://github.com/robolectric/robolectric google官方 Fragment测试方法 https://developer.android.google.cn/training/basics/fragments/testing 谷歌官方推荐的开源测试框架 Robolectric就是这么一个工具，简单来说它实现了一套可以在JVM上运行的Android代码。 谷歌官方推荐的开源测试框架 Robolectric就是这么一个工具，它实现了一套可以在JVM上运行的Android代码。 https://juejin.cn/post/6844904054192111623","categories":[{"name":"TEST","slug":"TEST","permalink":"http://noteforme.github.io.com/categories/TEST/"}],"tags":[{"name":"Test","slug":"Test","permalink":"http://noteforme.github.io.com/tags/Test/"}],"keywords":[{"name":"TEST","slug":"TEST","permalink":"http://noteforme.github.io.com/categories/TEST/"}]},{"title":"kotlin","slug":"kotlin","date":"2019-05-15T07:32:51.000Z","updated":"2021-09-07T02:01:17.848Z","comments":true,"path":"2019/05/15/kotlin/","link":"","permalink":"http://noteforme.github.io.com/2019/05/15/kotlin/","excerpt":"","text":"Kotlin in Action函数类型1val d: (String, Int) -&gt; Unit // 函数类型 (String,Int) 接收参数 ， Unit 返回类型 kotlin lambda![Screen Shot 2020-08-01 at 6.39.38 PM](kotlin/Screen Shot 2020-08-01 at 6.39.38 PM.png) 1234567891011121314151617181920212223242526272829303132333435363738 val list = listOf(&quot;apple&quot;, &quot;pear&quot;, &quot;banana&quot;, &quot;watermelon&quot;)// val result = list.maxBy &#123; it.length &#125; val lambda = &#123; fruit: String -&gt; fruit.length &#125; //推导1// val result = list.maxBy(lambda) //推导2// val result = list.maxBy(&#123;fruit:String-&gt;// fruit.length// &#125;) //推导3// val result = list.maxBy(&#123; fruit: String -&gt;// fruit.length// &#125;) //如果一个函数， 他接收的最后一个参数是lambda表达式，那么这最后一个参数可以移到括号外面 //推导4// val result = list.maxBy&#123; fruit: String -&gt;// fruit.length //如果一个函数 ,括号可以省略// &#125; //推导4// val result = list.maxBy&#123; fruit -&gt;// fruit.length //kotlin类型推导机制，参数类型可以省略// &#125; //推导5 val result = list.maxBy&#123; it.length // lmbda表达式只有一个参数，参数可以省略 改用it替代 &#125; println(result) 1234567891011121314fun &lt;T,R:Comparable&lt;R&gt;&gt; List&lt;T&gt;.findMax(block: (T) -&gt; R):T?&#123; if (isEmpty()) return null var maxElement =get(0) //获取List上下文的 第一个元素 var maxValue = block(maxElement) //block() 走到了 lambda方法中 for(element in this)&#123; var value = block(element) if (value&gt; maxValue)&#123; maxElement = element maxValue = value &#125; &#125; return maxElement&#125; 1234// val result = list.findMax(lambda) val result = list.findMax&#123;it.length&#125; println(result) https://www.bilibili.com/s/video/BV1Ut4y127xM 1.Java定义的接口 2.单抽象方法 Defining and calling functions 3.2.3 Getting rid of static utility classes: top-level functions and properties 12345public class JoinJava &#123; public static void johnToString()&#123; System.out.println(&quot;johnToString java&quot;); &#125;&#125; 123456package com.kotlin3fun johnToString()&#123; println(&quot;johnToString kotlin&quot;)&#125; 1234fun main(args: Array&lt;String&gt;) &#123; johnToString() JoinJava.johnToString()&#125; 3.3.3 extension functions 123456789101112131415161718fun String.lastChar() = this.get(this.length-1)fun String.addName() = this + &quot; john&quot; //this 获取到String类的上下文val String.lastLetter: Char get()= get(length-1) //拓展属性fun String.hellowrod()&#123; println(&quot;hello world&quot;)&#125;fun String.cpaitalEnd():String&#123; if (this.isEmpty()) return &quot;&quot;; val charArray = this.toCharArray() charArray[length-1] = charArray[length-1].toUpperCase() return String(charArray)&#125; 1234567891011121314import com.kotlin3.t3_3_2.addNameimport com.kotlin3.t3_3_2.lastCharimport com.kotlin3.t3_3_2.lastLetterfun main(args: Array&lt;String&gt;) &#123; println(&quot;kotlin&quot;.lastChar()) println(&quot;kotlin&quot;.addName()) print(&quot;kotlin&quot;.lastLetter) &quot;&quot;.hellowrod() //输出 hello world println(&quot;code&quot;.cpaitalEnd()) // codE&#125; Conventions used 7.3 如果用 10..20构建一个普通的 区间(闭区间)，该区间则包括10到20的所有数字， 包括20。开区间10 until 20 包括从 10 到凹的数字，但不包括 20。矩形类通常定义成这样，它的底部和右 侧坐标不是矩形的一部分，因此在这里使用开区 间是合适的 。 Delegated - classs 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//原文链接：https://blog.csdn.net/xlh1191860939/article/details/99641573interface ServiceApi &#123; fun login(userName: String, password: String)&#125;class Retrofit : ServiceApi &#123; override fun login(userName: String, password: String) &#123; println(&quot;login successfully.&quot;) &#125;&#125;/** * 不用委托 *///class RemoteRepository : ServiceApi, NewsApi &#123;//// private val serverApi: ServiceApi = Retrofit()// private val retrofitApi: NewsApi = NewsApiImpl()//// override fun login(username: String, password: String) &#123;// serverApi.login(username, password)// &#125;//// override fun getNewsList() &#123;// retrofitApi.getNewsList()// &#125;//&#125;/* * 使用kotlin 委托用下面简化 */class RemoteRepository(): ServiceApi by Retrofit() , NewsApi by NewsApiImpl()interface NewsApi &#123; fun getNewsList()&#125;class NewsApiImpl : NewsApi &#123; override fun getNewsList() &#123; println(&quot;NewsApiImpl: getNewsList()&quot;) &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val repository = RemoteRepository() repository.login(&quot;David&quot;, &quot;123456&quot;) //输出 login successfully. repository.getNewsList()&#125; 7.5.2 使用委托属性:惰性初始化和 “by lazy()” 12345678910111213141516171819202122232425262728293031//class Person(val name: String) &#123;// private var _emails: List&lt;Email&gt;? = null// val emails: List&lt;Email&gt;// get() &#123;// if (_emails == null) &#123;// _emails = loadEmails(this)// &#125;// return _emails!!// &#125;//&#125;//你有一个属性， emails，用来存储这个值， 而另一个 emails，用来提供对属性的读取访 问 。你需要使用两个属性 ，因为属性 具有不同的类型: emails 可以为空，而 emails 为非空。这种技术经常会使用到， 值得熟练掌握。class Person(val name:String)&#123; val emails by lazy&#123; loadEmails(this) &#125;&#125;fun loadEmails(person: Person): List&lt;Email&gt;? &#123; println (&quot;load emails for $&#123;person.name &#125;&quot; ) return listOf()&#125;fun main(args: Array&lt;String&gt;) &#123; val p = Person(&quot;Alice&quot;) p.emails p.emails&#125; https://juejin.im/post/5e1288d86fb9a048217a19d9 https://zhuanlan.zhihu.com/p/65914552 委托Shareprefernce实战 简易版本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293class DelegateSharedPreferencesUtils &#123; object User : Delegates() &#123; override fun getSharedPreferencesName(): String = this.javaClass.simpleName var name by string() var phone by long() &#125; abstract class Delegates &#123; private val preferences: SharedPreferences by lazy &#123; AppUtil.getApp().applicationContext.getSharedPreferences( getSharedPreferencesName(), Context.MODE_PRIVATE ) &#125; abstract fun getSharedPreferencesName(): String fun int(defaultValue: Int = 0) = object : ReadWriteProperty&lt;Any, Int&gt; &#123; override fun getValue(thisRef: Any, property: KProperty&lt;*&gt;): Int &#123; return preferences.getInt(property.name, defaultValue) &#125; override fun setValue(thisRef: Any, property: KProperty&lt;*&gt;, value: Int) &#123; preferences.edit().putInt(property.name, value).apply() &#125; &#125; fun string(defaultValue: String? = null) = object : ReadWriteProperty&lt;Any, String?&gt; &#123; override fun getValue(thisRef: Any, property: KProperty&lt;*&gt;): String? &#123; return preferences.getString(property.name, defaultValue) &#125; override fun setValue(thisRef: Any, property: KProperty&lt;*&gt;, value: String?) &#123; preferences.edit().putString(property.name, value).apply() &#125; &#125; fun long(defaultValue: Long = 0L) = object : ReadWriteProperty&lt;Any, Long&gt; &#123; override fun getValue(thisRef: Any, property: KProperty&lt;*&gt;): Long &#123; return preferences.getLong(property.name, defaultValue) &#125; override fun setValue(thisRef: Any, property: KProperty&lt;*&gt;, value: Long) &#123; preferences.edit().putLong(property.name, value).apply() &#125; &#125; fun boolean(defaultValue: Boolean = false) = object : ReadWriteProperty&lt;Any, Boolean&gt; &#123; override fun getValue(thisRef: Any, property: KProperty&lt;*&gt;): Boolean &#123; return preferences.getBoolean(property.name, defaultValue) &#125; override fun setValue(thisRef: Any, property: KProperty&lt;*&gt;, value: Boolean) &#123; preferences.edit().putBoolean(property.name, value).apply() &#125; &#125; fun float(defaultValue: Float = 0.0f) = object : ReadWriteProperty&lt;Any, Float&gt; &#123; override fun getValue(thisRef: Any, property: KProperty&lt;*&gt;): Float &#123; return preferences.getFloat(property.name, defaultValue) &#125; override fun setValue(thisRef: Any, property: KProperty&lt;*&gt;, value: Float) &#123; preferences.edit().putFloat(property.name, value).apply() &#125; &#125; fun setString(defaultValue: Set&lt;String&gt;? = null) = object : ReadWriteProperty&lt;DelegateSharedPreferencesUtils, Set&lt;String&gt;?&gt; &#123; override fun getValue( thisRef: DelegateSharedPreferencesUtils, property: KProperty&lt;*&gt; ): Set&lt;String&gt;? &#123; return preferences.getStringSet(property.name, defaultValue) &#125; override fun setValue( thisRef: DelegateSharedPreferencesUtils, property: KProperty&lt;*&gt;, value: Set&lt;String&gt;? ) &#123; preferences.edit().putStringSet(property.name, value).apply() &#125; &#125; fun clearAll() &#123; preferences.edit().clear().apply() &#125; &#125;&#125; 12345DelegateSharedPreferencesUtils.User.name = &quot;john&quot; //存bt_get.setOnClickListener &#123; Timber.i(&quot;bt_get &quot;+DelegateSharedPreferencesUtils.User.name) //取&#125; https://wazing.github.io/2019/05/23/kotlin-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A7%94%E6%89%98%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0SharedPreferences/ Pro version 12345678910111213141516171819202122232425262728293031object SpUtil &#123; val SP by lazy &#123; AppUtil.getApp().getSharedPreferences(&quot;default&quot;, Context.MODE_PRIVATE) &#125; //读 SP 存储项 fun &lt;T&gt; getValue(name: String, default: T): T = with(SP) &#123; val res: Any = when (default) &#123; is Long -&gt; getLong(name, default) is String -&gt; getString(name, default) ?: &quot;&quot; is Int -&gt; getInt(name, default) is Boolean -&gt; getBoolean(name, default) is Float -&gt; getFloat(name, default) else -&gt; throw java.lang.IllegalArgumentException() &#125; res as T &#125; //写 SP 存储项 fun &lt;T&gt; putValue(name: String, value: T) = with(SP.edit()) &#123; when (value) &#123; is Long -&gt; putLong(name, value) is String -&gt; putString(name, value) is Int -&gt; putInt(name, value) is Boolean -&gt; putBoolean(name, value) is Float -&gt; putFloat(name, value) else -&gt; throw IllegalArgumentException(&quot;This type can&#x27;t be saved into Preferences&quot;) &#125;.apply() &#125;&#125; 123456789101112131415161718192021222324252627/** * @author xiaofei_dev * @desc 定义的 SP 存储项 */object SpBase&#123; //SP 存储项的键 private const val CONTENT_SOMETHING = &quot;CONTENT_SOMETHING&quot; // 这就定义了一个 SP 存储项 // 把 SP 的读写操作委托给 SPDelegates 类的一个实例（使用 by 关键字，by 是 Kotlin 语言层面的一个原语）， // 此时访问 SpBase 的 contentSomething (你可以简单把其看成 Java 里的一个静态变量)属性即是在读取 SP 的存储项， // 给 contentSomething 属性赋值即是写 SP 的操作，就这么简单 // 这里用到的 SPDelegates 对象的 getValue 方法的 thisRef（见上文） 参数的类型正是外层的 SpBase var contentSomething: String by SPDelegates(CONTENT_SOMETHING, &quot;我是一个 SP 存储项，点击编辑我&quot;)&#125;class SPDelegates&lt;T&gt;(private val key: String, private val default: T) : ReadWriteProperty&lt;Any?, T&gt; &#123; override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T &#123; return SpUtil.getValue(key, default) &#125; override fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: T) &#123; SpUtil.putValue(key, value) &#125;&#125; 123456SpBase.contentSomething = &quot;显示&quot; bt_get.setOnClickListener &#123; Timber.i(&quot;bt_get &quot;+SpBase.contentSomething)&#125; https://juejin.im/post/5e1bbf396fb9a02ffe702610 Operator FindViewById ​ Kotlin不用findViewById 注意在Fragmet中 需要在onViewCreated后使用 ​ https://blog.csdn.net/hust_twj/article/details/80290362 The reason why we ignore findviewbyId https://antonioleiva.com/kotlin-android-extensions/ ? 123456789//kotlin:a?.foo()//相当于java:if(a!=null)&#123; a.foo();&#125;else&#123; null &#125; !! 123456789//kotlin:a!!.foo()//相当于java: if(a!=null)&#123; a.foo();&#125;else&#123; throw new KotlinNullPointException();&#125; null or empty 1234data = &quot; &quot; // this is a text with blank space println(data.isNullOrBlank()?.toString()) //trueprintln(data.isNullOrEmpty()?.toString()) //false Elvis 1234val ss:String?=nullprintln(ss ?: &quot;1&quot;)&gt;&gt; 1 https://developer.android.com/samples/?language=kotlin https://developer.android.com/kotlin/get-started https://www.jianshu.com/p/9fb9a1ab6c31 https://juejin.im/post/5aa64556f265da238c3a51d3 高级用法https://www.cnblogs.com/Jetictors/p/9225557.html byhttps://blog.csdn.net/wzgiceman/article/details/82689135 oprator https://zhuanlan.zhihu.com/p/26546977 kotlin细节https://juejin.im/post/5eeffd73f265da02ec0bc42e apply 123456val mDialPaint = Paint(Paint.ANTI_ALIAS_FLAG)mDialPaint.apply &#123; color = Color.parseColor(&quot;#3333333&quot;) strokeWidth = arcWidth*8 textSize = 65f &#125; coroutineshttps://www.kotlincn.net/docs/reference/coroutines/coroutines-guide.html https://juejin.im/post/5eea757a51882565ae5cb287 https://blog.csdn.net/xlh1191860939/article/details/99641573 Android kotlin计划 ktx不是重心，重心在kotlin库如协程,paging3.0和compose https://www.bilibili.com/video/BV1fV411r7Lw","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://noteforme.github.io.com/categories/Kotlin/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://noteforme.github.io.com/tags/Kotlin/"}],"keywords":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://noteforme.github.io.com/categories/Kotlin/"}]},{"title":"PrincipleComputer","slug":"PrincipleComputer","date":"2019-04-08T07:52:07.000Z","updated":"2021-08-19T11:11:44.204Z","comments":true,"path":"2019/04/08/PrincipleComputer/","link":"","permalink":"http://noteforme.github.io.com/2019/04/08/PrincipleComputer/","excerpt":"","text":"进制运算的基本知识整数二进制2进制转10进制： 重复除2取余数 小数二进制 :𝑁= 0.11001 =1∗2−1+1∗2−2+1∗2−5=0.78125=25 / 32 (小数)十进制转换二进制:重复相乘法 二进制数据的表示方法原码 原码表示法 使用0表示正数、1表示负数 规定符号位位于数值第一位 表达简单明了，是人类最容易理解的表示法 0有两种表示方法:00 , 10 缺陷 但是原码表示法有缺陷 希望找到不同符号操作数更加简单的运算方法 希望找到使用正数代替负数的方法 使用加法操作代替减法操作，从而消除减法 阶码 尾数 补码补码表示法 例子2: x=-13，计算x的二进制原码和补码 原码:x=1,1101 补码:2^(𝑛+1) + 𝑥 = 2^(4+1) − 13 = 100000 − 1101 = 1,0011 ​ 1是符号位 补码:x=1,0011 例子3: x=-7，计算x的二进制原码和补码 原码:x=1,0111 补码:2^(𝑛+1) + 𝑥 = 2^(4+1) − 7 = 100000 − 0111 = 11001 ​ 补码:x=1,1001 缺陷 还是同样的问题, 希望找到使用正数代替负数的方法$$ 使用加法操作代替减法操作，从而消除减法 在计算补码的过程中，还是使用了减法!! 反码 引进补码的目的 减法运算复杂，希望找到使用正数替代负数的方法 使用加法代替减法操作，从而消除减法 例子1: x=-13，计算x的二进制原码和,反码,补码 原码: x=1,1101 反码: 2^(𝑛+1)−1 + 𝑥 = (2^(4+1)−1) − 13 = 011111 − 1101 = 10010 ​ 反码:x=1,0010 补码: 2^(𝑛+1) + 𝑥 = 2^(4+1) − 13 = 100000 − 1101 = 10011 例子2:x=-7，计算x的二进制原码和反码 原码:x=1,0111 反码:2^(𝑛+1) + 𝑥 = 2^(4+1) − 7 = 011111 − 0111 = 11000 ​ 反码:x=1,1000 反码表示法 负数的反码等于原码除符号位外按位取反 负数的补码= (反码+1) 例子3:x=-7，计算x的二进制原码和反码和补码 原码:x=1,0111 反码:x=1,1000. 补码:x=1,1001 例子4:x=-9，计算x的二进制原码和反码和补码 原码:x=1,1001 反码:x=1,0110 补码:x=1,0111 ​ 小数的补码小数的补码 反码规则和整数一样，原码的方式按照 小数二进制 先算出来 例子1: x= 9/16 ，计算x的二进制原码和反码和补码 原码:x=0,0.1001 反码:x= 0,0.1001 补码:x= 0,0.1001 例子2:x=- ，计算x的二进制原码和反码和补码 原码:x=1,0.01011 反码:x=1,1.10100 补码:x=1,1.10101 二进制数据的运算定点数的加法运算整数加法: A 补 + B 补 = 𝐴 + 𝐵 补 (𝑚𝑜𝑑2𝑛+1) 小数加法: A补 +B补 = 𝐴+𝐵 补(𝑚𝑜𝑑2) 数值位与符号位一同运算，并将符号位产生的进位自然丢掉 例子1: A=-110010， B=001101，求A+B A[补] = 1,001110 =&gt; A[原] = 1,110010 =&gt; A[反]= 1,001101 B 补 = B[原] = 0,001101 A 补 +B 补 =(A+B) 补 =1,011011 A + B = −100101 例子2:A=-0.1010010， B=0.0110100，求A+B A[补] = 1,1.0101110 B 补 = B[原] = 0,0.0110100 A 补 +B 补 =(A+B) 补 =1,1.1100010 A + B =-0.0011110 例子4 ： A=-10010000， B=-11010000，求A+B A补 =1,01110000 B补 =1,00110000 A 补 +B 补 =(A+B) 补 =0,10100000 A + B = 10100000 A + B = 160 A = −144 B = −208 发生了溢出 : A 判断溢出 双符号位判断法 **单符号位表示变成双符号位:**0=&gt;00,1=&gt;11 双符号位产生的进位丢弃 结果的双符号位不同则表示溢出 例子4:A=-10010000， B=-11010000，求A+B A补 =1,01110000 B补 =1,00110000 A 补 +B 补 =(A+B) 补 =10,10100000 双符号位不同，表示溢出 符号位进位舍去 例子3:A=-10010000， B=-01010000，求A+B A补 =1,01110000 B补 =1,10110000 A 补 +B 补 =(A+B) 补 =11,00100000 双符号位相同，没有溢出 (A+B)[原] = 11,11100000 = −11100000 定点数的减法运算整数减法: A补 −B补 =𝐴+(−𝐵)补(𝑚𝑜𝑑2𝑛+1) 小数减法: A 补 −B 补 =𝐴+(−𝐵) 补 (𝑚𝑜𝑑2) -B[补]等于B[补]连同符号位按位取反，末位加一 B 补 = 1,0010101 (−B) 补 = 0,1101011 例子5:A=11001000， B=-00110100，求A-B A 补 = A[原] = 0,11001000 B 补 = 1,11001100 (−B) 补 = 0,00110100 A补 −B补 =A+(−B)补 A+(−B)补 =0,11111100 A − B = 111111100 浮点数的加减法运算対阶 尾数求和 尾数规格化 舍入 溢出判断 浮点数乘除法也是上面4个步骤 做蓝牙开发时byte数组出现 -122，来看看这个负数是怎么出现的 byte转int类型 b1 &amp; 0xff http://ju.outofmemory.cn/entry/215778 https://blog.csdn.net/RuobaiMEN/article/details/79890823 https://blog.csdn.net/LVXIANGAN/article/details/72726152 问题: 计算机负数加法 8 + （-1） ​ b1 &amp; 0xff 不理解 https://www.imooc.com/article/21360 https://blog.csdn.net/zdy10326621/article/details/50236529 字节一个字节byte 两位16进制数1个字节是8位，二进制8位：xxxxxxxx 范围从00000000－11111111，表示0到255。 1位16进制数最大是15（用二进制表示是xxxx ）（即对应16进制的0xF 1111 4位），要表示到255,就还需要4位。 位运算符基本操作 https://blog.csdn.net/qiantudou/article/details/49928423 https://www.orchome.com/1190 取一个字节 某几位123456789101112131415161718192021222324252627282930313233343536/** * 取一个字节高几位 * * @param b * @param length * @return */public static int getLeftNum(byte b, int length) &#123; return b &gt;&gt; (8 - length);&#125;/** * 取一个字节低几位bit * * @param b * @param length * @return */public static int getRightNum(byte b, int length) &#123; byte mv = (byte) (0xff &gt;&gt; (8 - length)); return b &amp; mv;&#125;/** * https://blog.csdn.net/bluestarjava/article/details/83446129 * * @param b * @param startIndex 高位从0开始 * @param endIndex * @return */public static int getMidNum(byte b, int startIndex, int endIndex) &#123; byte i = (byte) getLeftNum(b, endIndex + 1);//先取高几位 return getRightNum(i, endIndex - startIndex + 1);//再取低几位&#125; https://bbs.csdn.net/topics/310178646","categories":[{"name":"Organization","slug":"Organization","permalink":"http://noteforme.github.io.com/categories/Organization/"}],"tags":[],"keywords":[{"name":"Organization","slug":"Organization","permalink":"http://noteforme.github.io.com/categories/Organization/"}]},{"title":"Popupwindow","slug":"Popupwindow","date":"2019-03-26T13:17:52.000Z","updated":"2021-08-19T11:11:44.204Z","comments":true,"path":"2019/03/26/Popupwindow/","link":"","permalink":"http://noteforme.github.io.com/2019/03/26/Popupwindow/","excerpt":"","text":"使用showAtLocation1234public void showAtLocation(View parent, int gravity, int x, int y) &#123; mParentRootView = new WeakReference&lt;&gt;(parent.getRootView()); showAtLocation(parent.getWindowToken(), gravity, x, y); &#125; gravity 9种情况 从 parent.getRootView()可以看到 parentview就是整个屏幕 Gravity.NO_GRAVITY ：显示效果同 Gravity.LEFT | Gravity.TOPGravity.LEFT：以屏幕左边中间位置为圆点Gravity.TOP：以屏幕顶部中间位置为参照物Gravity.RIGHT：以屏幕右侧中间位置为参照物Griavity.BOTTOM：以屏幕底部中间为参照物Gravity.LEFT | Gravity.TOP：以屏幕左上角为参照物Gravity.RIGHT | Gravity.TOP ：以屏幕右上角为参照物Gravity.LEFT | Gravity.BOTTOM ：以屏幕左下角为参照物Gravity.RIGHT | Gravity.BOTTOM ：以屏幕右下角为参照物x ：x &lt; 0时，向左偏移， x &gt;0 时，向右偏移 y ：显示效果受gravity参数影响。当参数不带Gravity.BOTTOM时，y &lt; 0，向上偏移， y &gt; 0 ，向下偏移；当参数带有Gravity.BOTTOM时, y &lt; 0,向下偏移，y &gt; 0，向下偏移 原文：https://blog.csdn.net/Justwen26/article/details/61621076 showAsDropDown123public void showAsDropDown(View anchor, int xoff, int yoff) &#123; showAsDropDown(anchor, xoff, yoff, DEFAULT_ANCHORED_GRAVITY);&#125; 弹窗会显示在anchor控件的正下方。","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"INTERVIEW_ANDROID","slug":"INTERVIEW-ANDROID","date":"2019-01-15T02:24:37.000Z","updated":"2021-08-19T14:17:45.846Z","comments":true,"path":"2019/01/15/INTERVIEW-ANDROID/","link":"","permalink":"http://noteforme.github.io.com/2019/01/15/INTERVIEW-ANDROID/","excerpt":"","text":"大佬面试经验 https://interview-q-a-1gdnkgkla15afdbe-1258598664.tcloudbaseapp.com/Android/ Android基础知识点四大组件是什么Activity ,Service ,BroadCastReceiver,ContentProvider ActivityActivity各种情况下的生命周期? 先启动A 再跳转B A_onCreate()-&gt; A_onStart()-&gt;A_onResume-&gt; A_onPause()-&gt; B_onCreate() -&gt; B_onStart() -&gt; B_resume -&gt; A_onSaveInstanceState()-&gt;A_onStop() 弹出Dialog 不调用任何生命周期,所以Activity上有Dialog的时候按Home键时的生命周期,有没有Dialog都一样的。 横竖屏切换的时候，Activity 各种情况下的生命周期 Activity状态保存于恢复 (什么都不设置) ![](INTERVIEW-ANDROID/Screen Shot 2021-01-24 at 3.37.01 PM.png) 设置android:screenOrientation=&quot;portrait&quot; 不会旋转 Android 8.0 设置android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot; 会发生旋转，生命周期不发生变化，只是会调用 onConfigurationChanged() https://blog.csdn.net/qq_36713816/article/details/80538467 前台切换到后台，然后再回到前台，Activity生命周期回调方法。 前台切换到后台: A_onCreate()-&gt; A_onStart()-&gt;A_onResume-&gt; A_onPause()-&gt;A_onSaveInstanceState()-&gt; A_onStop() 再回到前台: A_onRestart() -&gt;A_onStart()-&gt; A_onResume() Activity之间的通信方式 Intent startActivity()或startActivityForResult(),通过Intent传递信息,需要注意，Intent对携带信息大小有限制。 BroadcastReceiver 数据存取传递，sharePreference/sql/File Application 静态变量 Activity的四种启动模式对比 Standard 默认启动模式，每次都重新创建一个新的Activity 。 SingleStop 当前Activity如果在栈顶，那么就不会创建新的Activity，会原先调用Activity的onNewIntent() SingleTask 当前任务栈已经有Activity实例，就不会再创建了，会调用 onNewIntent(). SingleInstance 单一实例模式，整个手机操作系统里面只有一个实例存在。不同的应用去打开这个activity 共享公用的同一个activity。他会运行在自己单独，独立的任务栈里面，并且任务栈里面只有他一个实例存在。应用场景：呼叫来电界面。这种模式的使用情况比较罕见，在Launcher中可能使用。或者你确定你需要使Activity只有一个实例。 可以得出以下结论： \\1. 以singleInstance模式启动的Activity具有全局唯一性，即整个系统中只会存在一个这样的实例。 \\2. 以singleInstance模式启动的Activity在整个系统中是单例的，如果在启动这样的Activiyt时，已经存在了一个实例，那么会把它所在的任务调度到前台，重用这个实例。 \\3. 以singleInstance模式启动的Activity具有独占性，即它会独自占用一个任务，被他开启的任何activity都会运行在其他任务中。 \\4. 被singleInstance模式的Activity开启的其他activity，能够在新的任务中启动，但不一定开启新的任务，也可能在已有的一个任务中开启。 https://blog.csdn.net/zivensonice/article/details/51569502 https://ayusch.com/android-launch-modes-explained/ https://noteforme.github.io/2021/01/16/Activity/ 为什么 application.startActivity 要设置NEW_TASK 如果Activity是由一个已经启动的Activity发起的，那么把它放在这个已经启动的任务栈是合理的，Application本来没有任务栈，那么就新创建一个放起来. https://www.wanandroid.com/wenda/show/8697 任务栈的底层原理 Android APK编译打包流程 AAPT（Android Asset Packaging Tools）工具会打包应用中的资源文件，如AndroidManifest.xml、layout布局中的xml等，并将xml文件编译成二进制形式，当然assets文件夹中的文件不会被编译，图片以及raw文件夹中的资源也会保持原有的形态，需要注意的是raw文件夹中的资源也会生成资源ID。AAPT编译完成后会生成R.java文件。 AIDL工会将所有的aidl接口转换为java接口。 所有的Java源代码、R文件、接口都会编译器编译成.class文件。 Dex工具会将上述产生的.class文件以及第三方库和其他class文件转化为dex（Dalvik虚拟机可执行文件）文件，dex文件最终会被打包进APK文件。 apkbuilder会把编译后的资源和其他资源文件同dex文件一起打入APK中。 生成APK文件之后，，需要对其签名才能安装到设备上，平时测试都会使用debug keystore，当发布应用时必须使用release版的keystore对应用进行签名。 如果对APK正式签名，还需要使用zipalign工具对APK进行对齐操作，这样做的好处是当应用运行时能提高速度，但是会相应的增加内存开销。 总结：编译 –&gt; DEX –&gt; 打包 –&gt; 签名和对齐 ART虚拟机与Dalvik虚拟机的区别 什么是ART？ ART代表Android Runtime，其处理应用程序执行的方式完全不同于Dalvik，Dalvik是依靠一个Just-In-Time（JIT）编译器去解释字节码。开发者编译后的应用代码需要通过一个解释器在用户的设备上运行，这一机制并不高效，但让应用能更容易在不同硬件和架构上运行。ART则完全改变了这套做法，在应用安装时就预编译字节码到机器语言，这一机制叫Ahead-Of-Time（AOT）编译。在移除解释代码这一过程后，应用程序执行将更加效率。启动更快。 ART优点： 系统性能的显著提升。 应用启动更快、运行更快、体验更流畅、触摸反馈更及时。 更长的电池续航能力 支持更低的硬件。 ART缺点 更大的存储空间占用，可能会增加10%-20% 更长的应用安装时间 LaunchMode应用场景FragmmentFragment生命周期管理过程遇到的坑和解决办法fragment各种情况下的生命周期 Activity与Fragment之间生命周期比较​ onAttach() -&gt; onCreate() -&gt; onCreateView() -&gt; onActivityCreate() -&gt; onStart() -&gt; onResume() -&gt; onPause() -&gt; onStop() -&gt; ​ onDestroyView() -&gt; onDestroy() -&gt; onDetach() Fragment状态保存startActivityForResult是哪个类的方法，在什么情况下使用？ Fragment发起 Fragment onActivityResult能接收。Activity onActivityResult能接收,但是requestCode不正确。 Activity发起 Fragment不能接收。 Activity onActivityResult能接收。 fragment之间传递数据的方式？ Fragment.setArguments()方法传递bundle findFragmentById()找到tag,然后直接操作Framgent 123456789101112131415161718public void onArticleSelected(int position) &#123; ArticleFragment articleFrag = (ArticleFragment) getSupportFragmentManager().findFragmentById(R.id.article_fragment); if (articleFrag != null) &#123; articleFrag.updateArticleView(position); &#125; else &#123; ArticleFragment newFragment = new ArticleFragment(); Bundle args = new Bundle(); args.putInt(ArticleFragment.ARG_POSITION, position); newFragment.setArguments(args); FragmentTransaction transaction = getSupportFragmentManager().beginTransaction(); transaction.replace(R.id.fragment_container, newFragment); transaction.addToBackStack(null); transaction.commit(); &#125; &#125; 接口回调 Service请描述一下Service 的生命周期 startService() ​ 启动: onCreate() - onCommandStart() - onDestory() ​ 继续startService : 只会执行 onCommandStart() bindService() ​ onCreate() - onBind() - onUnbind()-onDestory() service和activity怎么进行数据交互？ bindService() Service中定义接口，ServiceConnection中获取Service实例，调用响应接口 注册广播传递数据说说ContentProvider、ContentResolver、ContentObserver 之间的关系 把自己的程序数据提供给其他应用程序调用，提供相关的uri接口,没用过ntentObserver 之间的关系 把自己的程序数据提供给其他应用程序调用，提供香港的uri接口,没用过 http://wangbufan.cn/2019/09/17/Service%E5%8F%8AService%E4%B8%8EActivity%E9%80%9A%E4%BF%A1/ 请描述一下广播BroadcastReceiver的理解 广播是可以作为应用全局监听器，可以实现应用中不同组件少量数据的通信！！！，更深研究后可以多说点. 基于消息的发布/订阅事件模型. 广播的分类 无序广播 有序广播 接收者按照优先级顺序接收,每个接收者都有权终止广播,下一个就得不到. 广播使用的方式和场景 app全局监听 binder机制 https://www.jianshu.com/p/5a983578418e BroadcastReceiver，LocalBroadcastReceiver(本地广播) 区别BroadcastReceiver：针对应用间，系统和应用间通信。 LocalBroadcastReceiver： 只有自己应用内部才能收到,效率更高. DialogAlertDialog,popupWindow,Toast区别 ？Android是不允许Activity或Dialog凭空出现的,而Dialog则必须在一个Activity上面弹出 AlertDialog 拦截了屏幕上所有的TouchK/key PopupWindow 仅仅拦截自身区域touch/key 需要Activity类型的Context启动 Toast 可以研究下 两者最根本的区别在于有没有新建一个 window，PopupWindow 没有新建，而是通过 WMS 将 View 加到 DecorView；Dialog 是新建了一个 window (PhoneWindow)，相当于走了一遍 Activity 中创建 window 的流程 https://www.jianshu.com/p/aed496937bd2 Application 和 Activity 的 Context 对象的区别ApplicatioContext ： ​ 应用生命周期一样长,长生命周期对象就用ApplicationContext Activity的Context： ​ 当前Activity的生命周期,和UI相关的都用Activity为Context来处理 https://www.jianshu.com/p/e215c90a460e Context的理解？​ Context是维持Android程序中各组件能够正常工作的一个核心功能类 AnimAndroid属性动画特性Android动画框架实现原理 可以改变对象的属性。还需要说说什么吗? 如何导入外部数据库?把数据库文件防盗asserts目录下，然后写入databases目录下面, 然后通过数据库容器装载里面数据库里面的数据。 https://blog.csdn.net/chaoyu168/article/details/50467913 插值器 估值器区别​ 插值器: （Interpolator）决定 值 的变化模式（匀速、加速） ​ 估值器 : (TypeEvaluator)决定 值 的具体变化数值 谈谈对接口与回调的理解 理解: A发送消息给B,B处理完后高速A处理结果. 实现: 一般而言，处理消息的类是唯一的，发送消息的类却是各种各样的，将回调方法做成一个接口，不同的发送者实现该接口，并且把自己的接口实现类的对象在发送消息时，传递给消息处理者。 注册之后不马上执行，而是某个时机再触发执行。 回调的原理 写一个回调demo1234567891011121314151617181920212223242526272829public class MyTest &#123; public static void main(String[] args) &#123; ProcessClick process = new ProcessClick(new OnClickListener() &#123; @Override public void onClick() &#123; System.out.println(&quot;已经点击&quot;); &#125; &#125;); process.click(); &#125;&#125;interface OnClickListener&#123; void onClick();&#125;class ProcessClick &#123; OnClickListener listener; public ProcessClick(OnClickListener listener) &#123; this.listener = listener; &#125; void click()&#123; listener.onClick(); &#125;&#125; https://developer.aliyun.com/article/614769 VIEW相关如何优化自定义Viewandroid view绘制机制和加载过程，请详细说下整个流程每个Activity包含一个Window对象，Android中window对象由PhoneWindow实现，PhoneWindow将一个DecorView设置为整个应用窗口的根View,DecorView作为窗口界面的顶层视图，封装了窗口操作的通用方法，DecorView将要显示的具体内容显示在PhoneWindow上，这里所有的View监听事件通过WindowMangerService来接收,通过Activity对象来回调相应的onCLicklistener.显示是将屏幕分成两部分，一个TitleView，另一个是ContentView. Measure 如果是原始的 View,通过measure方法就完成了测量过程,如果是ViewGroup,除了完成自己的测量外，还需要遍历所有的子View,各个子元素再去递归执行这个流程. Layout Draw MeasureSpeck的意义，怎么计算MeasureSpecwrap content 和MATCH_PARENT的测量方式WRAP_CONTENT : 最大模式，大小不定，但是不能超过窗口的大小. specMode是AT_MOST模式,这种模式下，它的宽，高等于specSize, 这种情况下specSize是parentSize,而parentSize是父容器目前可以使用的大小,也就是父容器剩余的空间大小. MATCH_PARENT: 精确模式，大小就是窗口大小. https://noteforme.github.io/2017/11/12/View_OVER/ LayoutParams是是什么介绍下SurfaceView SurfaceView使用双缓冲技术缓解，页面绘制频繁引起的卡顿。 SurfaceView可以在子线程更新 UI,不会阻塞主线程，提高响应速度。 https://noteforme.github.io/2019/11/05/SurfaceView/ SurfaceView在更新视图时用到了两张 Canvas，可以先创建一个临时的Canvas对象，将图像都绘制到这个临时的Canvas对象中，绘制完成之后再将这个临时Canvas对象中的内容(也就是一个Bitmap)，通过drawBitmap()方法绘制到onDraw()方法中的canvas对象中。 RecycleView的使用​ https://noteforme.github.io/2017/07/17/RecyclerView/ webview安全问题WebView漏洞的根源在于强制其访问攻击者控制的网页。网页中含有攻击者可以控制的JS,因此可能钓鱼，窃取私有文件，甚至是 RCE,带来比较大的危害。 下面主要是4.4系统以上的机型 Webview密码明文存储漏洞WebView默认开启密码保存功能mWebView.setSavePassword(true),如果未关闭，用户输入密码时，会弹出提示框，询问用户是否保存密码，如果选是，密码会明文保存到 /data/data/com.package.name/databases/webview.db WebView域控制不严格漏洞setAllowFileAccess(true) : 窃取APP任意目录下的私有文件 ​ setAllowUniversalAccessFromFileURLs : 允许通过file域url中的 javascript访问其他的源。 https://noteforme.github.io/2017/09/01/WebView/ webview内存泄漏 Leakcanary 验证?​ android 5.0以下有内存泄漏问题 https://juejin.cn/post/6901487965562732551 viewstub延迟加载原理 12345678910111213141516171819 // 设置 ViewStub 不进行绘制 setWillNotDraw(true); private void replaceSelfWithView(View view, ViewGroup parent) &#123; final int index = parent.indexOfChild(this); // 把 ViewStub 从控件层级中移除。 parent.removeViewInLayout(this); // 把新创建的 View 对象加入控件层级结构中，并且位于 ViewStub 的位置， // 并且在这个过程中，会使用 ViewStub 的布局参数，例如宽高等。 final ViewGroup.LayoutParams layoutParams = getLayoutParams(); if (layoutParams != null) &#123; parent.addView(view, index, layoutParams); &#125; else &#123; parent.addView(view, index); &#125;&#125; ​ https://juejin.cn/post/6844903799337779214 overdraw过度绘制优化方法​ 移除默认和不必要背景 ​ https://jaeger.itscoder.com/android/2016/09/29/android-performance-overdraw.html ​ https://www.jianshu.com/p/9e095bacf44a View刷新机制 View绘制流程 自定义控件原理 如何取消AsyncTask？ 为什么不能在子线程更新UI？ Requestlayout，onlayout，onDraw，DrawChild区别与联系 invalidate和postInvalidate的区别及使用 Activity-Window-View三者的差别 自定义View如何考虑机型适配 自定义View的事件 封装View的时候怎么知道view的大小 事件分发机制是否解决过事件冲突问题，怎么解决的。 问题: https://juejin.cn/post/6922300686638153736 https://noteforme.github.io/categories/VIEW/ https://www.bilibili.com/video/BV1754y1H7jT 请描述一下View事件传递分发机制 Touch事件传递流程 事件分发中的onTouch 和onTouchEvent 有什么区别，又该如何使用？ View和ViewGroup分别有哪些事件分发相关的回调方法 我的面试问题activity被销毁后重建，怎么获取fragment​ findFragmentByTag ​ https://www.wanandroid.com/wenda/show/11077 activity和service通信 通过bindService 通过广播 https://www.jianshu.com/p/6040dfa83594 activity销毁线程会不会消失不会, 可以这样处理 12345678910111213141516171819/** * 静态内部类将不会再隐式的持有外部类的引用，所以在配置改变时，你的Activity的实例在也不会 * 出现内存泄露 */ private static class MyThread extends Thread &#123; private boolean mRunning = false; @Override public void run() &#123; mRunning = true; while (mRunning) &#123; SystemClock.sleep(1000); &#125; &#125; public void close() &#123; mRunning = false; &#125; &#125; activity每个方法处理的区别 onCreate(): Activity创建的时候调用，绑定数据。 onStart() : 当Activity对用户变得可见的时候调用. onResume() : activity开始和用户交互的时候调用，这时候activity处于栈顶，伴随着用户的输入. onPause() : 当activity失去前台状态，开始进入stopped/hidden or destroyed状态，不能再获取焦点，此时activity对用户可见，但是更新的UI的操作要快。 onStop() : 当activity不再可见，可能是新的activity来到栈顶，或者当前activity正在被destroy. onDestory(): 当前activity正在离开。 activity fragment传递数据方式 ViewModel onTach() 回调 单例模式怎么理解的 创建唯一的对象 res/raw和assets 三者目录下的文件在打包后原封不动的保存在apk包中，不会被编译成二进制。 Res/raw文件会被映射到R.java文件中，访问的时候直接使用资源 R.id.filename; res/raw不可以有目录结构，而asserts则可以有目录结构，也就是asserts目录下可以建立文件夹. https://www.jianshu.com/p/4c8bcb8c3717 截获通知新建一个服务MessageNotificationService实现 NotificationListenerService final特性 final类不能被继承，没有子类 方法不能被子类的方法重写，但可以被继承 表示常量，只能被赋值一次，赋值后不再改变。 android多线程怎么处理的 ，两个子线程间怎么通讯​ Android主线程和子线程之间的通信是通过消息循环机制，主线程中的handler把子线程的 message发送给主线程的Looper，那么子线程是如何通信的， 可以把looper绑定到子线程中，调用Looper.prepare()为改子线程生成Looper,然后调用Looper.loop()启动消息队列，并且在该子线程中创建一个Handler,在另一个子线程调用handler发送消息。这样实现通信. 1234567891011121314151617181920212223242526272829303132333435363738val threadA = ThreadA()val threadB = ThreadB()Thread(threadA).start()if (threadA.getHandler() == null) &#123; Thread.sleep(1000) handler = threadA.getHandler()&#125;Thread(threadB).start()class ThreadA : Runnable &#123; var mHandler: Handler? = null fun getHandler(): Handler? &#123; return mHandler &#125; override fun run() &#123; Looper.prepare() mHandler = object : Handler(Looper.myLooper()!!) &#123; override fun handleMessage(msg: Message) &#123; super.handleMessage(msg) Timber.d(&quot;线程A: 线程B发过来消息了-- $&#123;msg.obj&#125; &quot;) &#125; &#125; Looper.loop() &#125; &#125; inner class ThreadB : Runnable &#123; override fun run() &#123; val message = Message.obtain() message.what = 1 message.obj = &quot;线程B 发送消息&quot; + System.currentTimeMillis() handler?.sendMessage(message) &#125; &#125; https://blog.csdn.net/pbm863521/article/details/103493708 防止应用被被杀死,怎么保证service不被杀死http://www.52im.net/thread-2881-1-1.html http://www.52im.net/thread-2893-1-1.html 怎么让线程有序两个线程，想让来的一个插队怎么弄​ Join 批量网络请求 子线程创建Handler context对象互相引用，对象回收 Android界面怎么回收的 生命周期 内存溢出和内存泄露的区别，oom是怎么处理的 ， ANR怎么避免 java内存回收机制 android管理机制 怎么处理内存泄露 怎么做性能优化 反射机制 broadcastReciever和 handler区别 后台图片更改，前台怎么处理 图片加载库,图片加载方法 图片加载框架怎么处理oom问题 java Android加载机制 Android加载动态库 AndroidManifest权限是怎么获取的，封装权限管理，为什么需要权限分组. listview图片 缓存，listview怎么优化 viewpager listview处理滑动冲突 list遍历删除 fragment tag sercice ALDL (后面再弄) Hashmap实现原理 实现有序 android事件分发机制，请详细说下整个流程 android四大组件的加载过程 提高sqlite的查询效率 冒泡排序，插入排序 Android源码相关分析Handler机制和底层实现​ https://noteforme.github.io/2017/08/21/Handler/ RecycleView​ https://noteforme.github.io/2017/07/17/RecyclerView/ Binder通信原理与机制https://blog.csdn.net/Android_SE/article/details/103898581 https://www.bilibili.com/video/BV1Ko4y117Ca?p=74 JetPackhttps://noteforme.github.io/categories/Jetpack/ Android各个版本API的区别 描述一次网络请求的流程 Bitmap对象的理解 ActivityThread，AMS，WMS的工作原理 SpareArray原理 AndroidService与Activity之间通信的几种方式 IntentService原理及作用是什么？ 说说Activity、Intent、Service 是什么关系 ApplicationContext和ActivityContext的区别 SP是进程同步的吗?有什么方法做到同步？ 谈谈多线程在Android中的使用 进程和 Application 的生命周期 AsyncTask机制 AsyncTask原理及不足 AndroidManifest的作用与理解 性能优化https://noteforme.github.io/2017/08/16/PerformancePatterns/ https://noteforme.github.io/2018/02/09/LeakMemory/ ANR产生的原因是什么？ ANR定位和修正 oom是什么？ 什么情况导致oom？ 有什么解决方法可以避免OOM？ Oom 是否可以try catch？为什么？ 内存泄漏是什么？ 什么情况导致内存泄漏？ 如何防止线程的内存泄漏？ 内存泄露场的解决方法 内存泄漏和内存溢出区别？ LruCache默认缓存大小 如何通过广播拦截和abort一条短信？ 广播引起anr的时间限制是多少？ 计算一个view的嵌套层级 Activity栈 Android线程有没有上限？ 线程池有没有上限？ Android为什么引入Parcelable？ 有没有尝试简化Parcelable的使用？ （四）开发中常见的一些问题 屏幕适配的处理技巧都有哪些? 服务器只提供数据接收接口，在多线程或多进程条件下，如何保证数据的有序到达？ 动态布局的理解 怎么去除重复代码？ 画出 Android 的大体架构图 Recycleview和ListView的区别 ListView图片加载错乱的原理和解决方案 动态权限适配方案，权限组的概念 Android系统为什么会设计ContentProvider？ 下拉状态栏是不是影响activity的生命周期 如果在onStop的时候做了网络请求，onResume的时候怎么恢复？ Bitmap 使用时候注意什么？ Bitmap的recycler() ViewPager使用细节，如何设置成每次只初始化当前的Fragment，其他的不初始化？ 点击事件被拦截，但是想传到下面的View，如何操作？ 微信上消息小红点的原理 CAS介绍（这是阿里巴巴的面试题，我不是很了解，可以参考博客: CAS简介） https://github.com/android-exchange/Android-Interview Kotin面试题 http://www.youkmi.cn/2019/10/27/kotlin-ti-mu-zheng-li/ https://www.jianshu.com/p/45866c8415c8 怎么看源码 https://www.bilibili.com/video/BV1d54y1h768 面经 https://blog.csdn.net/sjy0118/article/details/112759112 https://www.kaelli.com/43.html https://www.jianshu.com/p/058c54948ca5 https://juejin.cn/post/6888222422760488974#heading-51 https://github.com/Omooo/Android_QA","categories":[],"tags":[{"name":"inter","slug":"inter","permalink":"http://noteforme.github.io.com/tags/inter/"}],"keywords":[]},{"title":"View_Practice","slug":"View_Practice","date":"2019-01-01T14:44:09.000Z","updated":"2021-08-19T11:11:44.282Z","comments":true,"path":"2019/01/01/View_Practice/","link":"","permalink":"http://noteforme.github.io.com/2019/01/01/View_Practice/","excerpt":"","text":"绘制心电图 https://github.com/SeekerFighter/LuckyEcgDemo https://www.jianshu.com/p/16301de41a18 表单输入 1234567891011121314151617181920212223242526272829303132333435363738/** * EditText文字固定在右边 */public class EditTextRight extends AppCompatEditText &#123; private String txtRight; private Paint mPaint; public EditTextRight(Context context) &#123; super(context); &#125; public EditTextRight(Context context, AttributeSet attrs) &#123; super(context, attrs); initAttrs(context, attrs); &#125; private void initAttrs(Context context, AttributeSet attrs) &#123; TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.EditTextRight); mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); txtRight = ta.getString(R.styleable.EditTextRight_textright);// Timber.d(&quot;text&quot; + txtRight); ta.recycle(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); float txtSize = getTextSize(); if (!TextUtils.isEmpty(txtRight)) &#123; float yrig = getWidth() - txtSize * txtRight.length() - 10; //getWidth() 控件宽度 Timber.d(&quot;txt &quot; + txtRight + &quot; getRight &quot; + yrig); canvas.drawText(txtRight, yrig, getBaseline(), getPaint()); &#125; &#125;&#125; 1234&lt;com.jonzhou.mineutils.ui.customview.EditTextRight android:layout_width=&quot;100dp&quot; android:layout_height=&quot;wrap_content&quot; mineutils:textright=&quot;幢&quot; /&gt; 自定义属性画正方形 ```&lt;com.jonzhou.cusomview.view.MyView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;100dp&quot; android:background=&quot;@android:color/holo_blue_bright&quot; /&gt; 1 public class MyView extends View { public MyView(Context context) { super(context); } public MyView(Context context, AttributeSet attrs) { super(context, attrs); Timber.i(&quot; MyView(Context context, AttributeSet attrs)&quot;); } public MyView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); } @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); Timber.i(&quot;onMeasure(int widthMeasureSpec, int heightMeasureSpec)&quot;); int width = getMySize(100, widthMeasureSpec); int height = getMySize(100, heightMeasureSpec); if (width &lt; height) &#123; height = width; &#125; else &#123; width = height; &#125; Timber.i(&quot;width &quot; + width + &quot; height &quot; + height); setMeasuredDimension(width,height); &#125; private int getMySize(int defaultSize, int measureSpec) &#123; int mySize = defaultSize; int mode = MeasureSpec.getMode(measureSpec); int size = MeasureSpec.getSize(measureSpec); switch (mode) &#123; case MeasureSpec.UNSPECIFIED: //如果没有指定大小，就设置为默认大小 mySize = defaultSize; break; case MeasureSpec.AT_MOST://如果测量模式是最大取值为size //我们将大小取最大值,你也可以取其他值 mySize = size; break; case MeasureSpec.EXACTLY: mySize = size; break; &#125; return mySize; &#125; } 12345678910111213141516设置 match_parent不是正方形?- 关于自定义属性不提示 declare-styleable name要和自定义类名相同，然后重启Ide就好了- 那么获取到的mode和size又代表了什么呢？ mode代表了我们当前控件的父控件告诉我们控件，你应该按怎样的方式来布局。 mode有三个可选值：EXACTLY, AT_MOST, UNSPECIFIED。它们的含义是： EXACTLY：父控件告诉我们子控件了一个确定的大小，你就按这个大小来布局。比如我们指定了确定的dp值和macth_parent的情况。 AT_MOST：当前控件不能超过一个固定的最大值，一般是wrap_content的情况。 UNSPECIFIED:当前控件没有限制，要多大就有多大，这种情况很少出现。 - 下面是一个重写onMeasure的固定伪代码写法： if mode is EXACTLY{ 父布局已经告诉了我们当前布局应该是多大的宽高, 所以我们直接返回从measureSpec中获取到的size }else{ 计算出希望的desiredSize if mode is AT_MOST 返回desireSize和specSize当中的最小值 else: 返回计算出的desireSize } 123456789101112131415161718192021222324252627282930313233343536373839 原文：https://blog.csdn.net/yissan/article/details/51136088 ##### 自定义属性不提示 按照如图两名称一致，重启AndroidStudio![customview_2018-05-17_01](View_Practice/customview_2018-05-17_01.png)![customview_2018-05-17_02](View_Practice\\customview_2018-05-17_02.png) https://blog.csdn.net/skysmile_/article/details/78833438 https://developer.android.com/guide/topics/ui/custom-components https://developer.android.com/training/custom-views/custom-drawing绘图http://blog.csdn.net/huaiyiheyuan/article/details/52205969画圆http://www.jianshu.com/p/d891fe636898##### Scroll 滑动https://juejin.im/post/5c7f4f0351882562ed516ab6#heading-17https://blog.csdn.net/guolin_blog/article/details/48719871#### Kotlinclass TermRoundView @JvmOverloads constructor( context: Context?, attrs: AttributeSet?, defStyleAttr: Int = 0) : View(context, attrs, defStyleAttr) { init{ val a = context?.theme?.obtainStyledAttributes(attrs, R.styleable.TermRoundView, 0, 0) try { isRulerInput = a!!.getBoolean(R.styleable.TermRoundView_isRulerInput, false) } finally { a?.recycle() } }} ``` https://juejin.im/post/6844903909320835080","categories":[{"name":"VIEW","slug":"VIEW","permalink":"http://noteforme.github.io.com/categories/VIEW/"}],"tags":[{"name":"VIEW","slug":"VIEW","permalink":"http://noteforme.github.io.com/tags/VIEW/"}],"keywords":[{"name":"VIEW","slug":"VIEW","permalink":"http://noteforme.github.io.com/categories/VIEW/"}]},{"title":"MediaPlayer","slug":"MediaPlayer","date":"2018-11-18T01:05:11.000Z","updated":"2021-08-19T11:11:44.127Z","comments":true,"path":"2018/11/18/MediaPlayer/","link":"","permalink":"http://noteforme.github.io.com/2018/11/18/MediaPlayer/","excerpt":"","text":"https://developer.android.com/reference/android/media/MediaPlayer http://www.runoob.com/w3cnote/android-tutorial-mediaplayer.html 这张状态转换图清晰的描述了MediaPlayer的各个状态，也列举了主要的方法的调用时序，每种方法只能在一些特定的状态下使用，如果使用时MediaPlayer的状态不正确则会引发IllegalStateException异常。 Idle 状态：当使用new()方法创建一个MediaPlayer对象或者调用了其reset()方法时，该MediaPlayer对象处于idle状态。这两种方法的一个重要差别就是：如果在这个状态下调用了getDuration()等方法（相当于调用时机不正确），通过reset()方法进入idle状态的话会触发OnErrorListener.onError()，并且MediaPlayer会进入Error状态；如果是新创建的MediaPlayer对象，则并不会触发onError(),也不会进入Error状态。 End 状态：通过release()方法可以进入End状态，只要MediaPlayer对象不再被使用，就应当尽快将其通过release()方法释放掉，以释放相关的软硬件组件资源，这其中有些资源是只有一份的（相当于临界资源）。如果MediaPlayer对象进入了End状态，则不会在进入任何其他状态了。 Initialized 状态：这个状态比较简单，MediaPlayer调用setDataSource()方法就进入Initialized状态，表示此时要播放的文件已经设置好了。 Prepared 状态：初始化完成之后还需要通过调用prepare()或prepareAsync()方法，这两个方法一个是同步的一个是异步的，只有进入Prepared状态，才表明MediaPlayer到目前为止都没有错误，可以进行文件播放。 Preparing 状态：这个状态比较好理解，主要是和prepareAsync()配合，如果异步准备完成，会触发OnPreparedListener.onPrepared()，进而进入Prepared状态。 Started 状态：显然，MediaPlayer一旦准备好，就可以调用start()方法，这样MediaPlayer就处于Started状态，这表明MediaPlayer正在播放文件过程中。可以使用isPlaying()测试MediaPlayer是否处于了Started状态。如果播放完毕，而又设置了循环播放，则MediaPlayer仍然会处于Started状态，类似的，如果在该状态下MediaPlayer调用了seekTo()或者start()方法均可以让MediaPlayer停留在Started状态。 Paused 状态：Started状态下MediaPlayer调用pause()方法可以暂停MediaPlayer，从而进入Paused状态，MediaPlayer暂停后再次调用start()则可以继续MediaPlayer的播放，转到Started状态，暂停状态时可以调用seekTo()方法，这是不会改变状态的。 Stop 状态：Started或者Paused状态下均可调用stop()停止MediaPlayer，而处于Stop状态的MediaPlayer要想重新播放，需要通过prepareAsync()和prepare()回到先前的Prepared状态重新开始才可以。 PlaybackCompleted状态：文件正常播放完毕，而又没有设置循环播放的话就进入该状态，并会触发OnCompletionListener的onCompletion()方法。此时可以调用start()方法重新从头播放文件，也可以stop()停止MediaPlayer，或者也可以seekTo()来重新定位播放位置。 Error状态：如果由于某种原因MediaPlayer出现了错误，会触发OnErrorListener.onError()事件，此时MediaPlayer即进入Error状态，及时捕捉并妥善处理这些错误是很重要的，可以帮助我们及时释放相关的软硬件资源，也可以改善用户体验。通过setOnErrorListener(android.media.MediaPlayer.OnErrorListener)可以设置该监听器。如果MediaPlayer进入了Error状态，可以通过调用reset()来恢复，使得MediaPlayer重新返回到Idle状态。 原文：https://blog.csdn.net/ddna/article/details/5178864https://blog.csdn.net/biaobiao1217/article/details/51557733","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"mina","slug":"mina","date":"2018-11-03T01:48:09.000Z","updated":"2021-08-19T11:11:44.302Z","comments":true,"path":"2018/11/03/mina/","link":"","permalink":"http://noteforme.github.io.com/2018/11/03/mina/","excerpt":"","text":"MINA配置 下载 http://mina.apache.org/mina-project/downloads.html apache-mina-2.0.19-bin.zip 解压 下载 https://www.slf4j.org/download.html slf4j-1.7.25.zip解压 在MineUtil项目中有demo实现 IM键盘 https://juejin.im/post/5ef850c9f265da231019f6e4","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}],"tags":[],"keywords":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}]},{"title":"GestureDetector","slug":"GestureDetector","date":"2018-08-13T08:08:19.000Z","updated":"2021-08-19T11:11:43.897Z","comments":true,"path":"2018/08/13/GestureDetector/","link":"","permalink":"http://noteforme.github.io.com/2018/08/13/GestureDetector/","excerpt":"","text":"GestureDetector总结 https://blog.csdn.net/harvic880925/article/details/39520901 切换动画 https://blog.csdn.net/u013309870/article/details/52873515 http://www.jcodecraeer.com/a/basictutorial/2016/1014/6672.html https://www.jianshu.com/p/a06e4f215f49 1e1, MotionEvent e2坐标滑动距离 速度判断:velocityX：X轴上的移动速度，像素/秒 velocityY：Y轴上的移动速度，像素/秒","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"AndroidSource","slug":"AndroidSource","date":"2018-07-25T01:57:29.000Z","updated":"2021-08-19T11:11:43.538Z","comments":true,"path":"2018/07/25/AndroidSource/","link":"","permalink":"http://noteforme.github.io.com/2018/07/25/AndroidSource/","excerpt":"","text":"https://www.bilibili.com/video/BV15W411L7Lc?p=9 源码调试要学习Android源码需要编译一份，然后安装要求导入AndroidStudio,可以参考:http://blog.csdn.net/huaiyiheyuan/article/details/52069122 1public class Application extends ContextWrapper implements ComponentCallbacks2 &#123;&#125; 当我点开父类ContextWrapper后，发现引用的是jar立面的class文件，既然有源码这肯定不是我所需要的，可以这要操作:Project Structure-&gt;Dependencies(可以看到很多jar依赖删掉)-&gt; ＋JARS And Dierctories -&gt;添加源码要关联的frameworks 、packages… 新建JDK1.8 选择openjdk8 删除依赖 3. 选择需要的包 4. 这一步要衡量一下，转为gradle项目后，project structure下面就没有moudles了 这个设置后麻烦可以大了，后面不得不删除了android.ipr、android.iws、android.iml这三个文件重新生成 ５. 跳转到源码 找到pacages-&gt; apps-&gt;Settings public class SettingsDrawerActivity extends Activity &#123; 点开Activity发现还是跳转到jar的内容 点击Ok后再测试下 终于成功了 ** 哈哈 然后就可以愉快的调试源码了** /home/jon/noteforme.github.io/public/2017/08/10/DesignParrerns https://cloud.tencent.com/developer/news/277549 Activity启动过程 对应用程序Activity进行编译和打包 /home/jon/桌面/LaoLuo/chapter-7/src/packages/experimental/Activity make snod emulator 然后查看activity信息，在这里通过源码里面的 adb cd /home/jon/AOSP/out/host/linux-x86/bin adb shell dumpsys activity 1.Android系统架构Android系统架构分为五层，从上到下依次是应用层、应用框架层、系统运行库层、硬件抽象层和Linux内核层。 应用层系统内置的应用程序以及非系统级的应用程序都是属于应用层。负责与用户进行直接交互，通常都是用Java进行开发的。 应用框架层（Java Framework)应用框架层为开发人员提供了可以开发应用程序所需要的API，我们平常开发应用程序都是调用的这一层所提供的API，当然也包括系统的应用。这一层的是由Java代码编写的，可以称为Java Framework。下面来看这一层所提供的主要的组件。 名称 功能描述Activity Manager(活动管理器) 管理各个应用程序生命周期以及通常的导航回退功能Location Manager(位置管理器) 提供地理位置以及定位功能服务Package Manager(包管理器) 管理所有安装在Android系统中的应用程序Notification Manager(通知管理器) 使得应用程序可以在状态栏中显示自定义的提示信息Resource Manager（资源管理器） 提供应用程序使用的各种非代码资源，如本地化字符串、图片、布局文件、颜色文件等Telephony Manager(电话管理器) 管理所有的移动设备功能Window Manager（窗口管理器） 管理所有开启的窗口程序Content Providers（内容提供器） 使得不同应用程序之间可以共享数据View System（视图系统） 构建应用程序的基本组件表1系统运行库层（Native)系统运行库层分为两部分，分别是C/C++程序库和Android运行时库。下面分别来介绍它们。 1.C/C++程序库C/C++程序库能被Android系统中的不同组件所使用，并通过应用程序框架为开发者提供服务，主要的C/C++程序库如下表2所示。 名称 功能描述OpenGL ES 3D绘图函数库Libc 从BSD继承来的标准C系统函数库，专门为基于嵌入式Linux的设备定制Media Framework 多媒体库，支持多种常用的音频、视频格式录制和回放。SQLite 轻型的关系型数据库引擎SGL 底层的2D图形渲染引擎SSL 安全套接层，是为网络通信提供安全及数据完整性的一种安全协议FreeType 可移植的字体引擎，它提供统一的接口来访问多种字体格式文件表22.Android运行时库运行时库又分为核心库和ART(5.0系统之后，Dalvik虚拟机被ART取代)。核心库提供了Java语言核心库的大多数功能，这样开发者可以使用Java语言来编写Android应用。相较于JVM，Dalvik虚拟机是专门为移动设备定制的，允许在有限的内存中同时运行多个虚拟机的实例，并且每一个Dalvik 应用作为一个独立的Linux 进程执行。独立的进程可以防止在虚拟机崩溃的时候所有程序都被关闭。而替代Dalvik虚拟机的ART 的机制与Dalvik 不同。在Dalvik下，应用每次运行的时候，字节码都需要通过即时编译器转换为机器码，这会拖慢应用的运行效率，而在ART 环境中，应用在第一次安装的时候，字节码就会预先编译成机器码，使其成为真正的本地应用。 硬件抽象层（HAL)硬件抽象层是位于操作系统内核与硬件电路之间的接口层，其目的在于将硬件抽象化，为了保护硬件厂商的知识产权，它隐藏了特定平台的硬件接口细节，为操作系统提供虚拟硬件平台，使其具有硬件无关性，可在多种平台上进行移植。 从软硬件测试的角度来看，软硬件的测试工作都可分别基于硬件抽象层来完成，使得软硬件测试工作的并行进行成为可能。通俗来讲，就是将控制硬件的动作放在硬件抽象层中。 Linux内核层Android 的核心系统服务基于Linux 内核，在此基础上添加了部分Android专用的驱动。系统的安全性、内存管理、进程管理、网络协议栈和驱动模型等都依赖于该内核。Android系统的五层架构就讲到这，了解以上的知识对以后分析系统源码有很大的帮助。 2.Android系统源码目录我们要先了解Android系统源码目录，为后期源码学习打下基础。关于源码的阅读，你可以访问http://androidxref.com/来阅读系统源码。当然，最好是将源码下载下来。下载源码可以使用清华大学开源软件镜像站提供的Android 镜像：https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/ 。如果觉得麻烦也可以查找国内的网盘进行下载，推荐使用该百度网盘地址下载：http://pan.baidu.com/s/1ngsZs，它提供了多个Android版本的的源码下载。 整体结构各个版本的源码目录基本是类似，如果是编译后的源码目录会多增加一个out文件夹，用来存储编译产生的文件。Android7.0的根目录结构说明如下表所示。 从表3可以看出，系统源码分类清晰，并且内容庞大且复杂。接下来分析packages中的内容，也就是应用层部分。应用层部分应用层位于整个Android系统的最上层，开发者开发的应用程序以及系统内置的应用程序都是在应用层。源码根目录中的packages目录对应着系统应用层。它的目录结构如表4所示。 Android open source projectAndroid Architecture https://source.android.com/ https://source.android.com/devices/architecture Android源码根目录 描述 abi 应用程序二进制接口 art 全新的ART运行环境 bionic 系统C库 bootable 启动引导相关代码 build 存放系统编译规则及generic等基础开发包配置 cts Android兼容性测试套件标准 dalvik art 虚拟机 developers 开发者目录 development 应用程序开发相关 device 设备相关配置 docs 参考文档目录 external 开源模组相关文件 frameworks 应用程序框架，Android系统核心部分，由Java和C++编写 hardware 主要是硬件抽象层的代码 libcore 核心库相关文件 libnativehelper 动态库，实现JNI库的基础 ndk NDK相关代码，帮助开发人员在应用程序中嵌入C/C++代码 out 编译完成后代码输出在此目录 packages 应用程序包 pdk Plug Development Kit 的缩写，本地开发套件 platform_testing 平台测试 prebuilts x86和arm架构下预编译的一些资源 sdk sdk和模拟器 system 底层文件系统库、应用和组件 toolchain 工具链文件 tools 工具文件 Makefile 全局Makefile文件，用来定义编译规则 ———————————————— https://blog.csdn.net/wenzhi20102321/article/details/80739649 https://blog.csdn.net/wen0006/article/details/5804639","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[{"name":"AOSP","slug":"AOSP","permalink":"http://noteforme.github.io.com/tags/AOSP/"}],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"ViewDynamic","slug":"ViewDynamic","date":"2018-07-17T12:25:26.000Z","updated":"2021-08-19T11:11:44.266Z","comments":true,"path":"2018/07/17/ViewDynamic/","link":"","permalink":"http://noteforme.github.io.com/2018/07/17/ViewDynamic/","excerpt":"","text":"动态添加布局LinearLayout添加 父容器 123456&lt;LinearLayout android:id=&quot;@+id/ll_plan_one&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot;&gt;&lt;/LinearLayout&gt; 子布局 123View view1 = inflate.inflate(R.layout.layout_animation, null);View view2 = inflate.inflate(R.layout.ic_hpan_suger_press_y, null);View view3 = inflate.inflate(R.layout.ic_hpan_suger_press_y, null); 添加进容器 123llVertical.addView(view1);llVertical.addView(view2);llVertical.addView(view3); 添加同一个子布局会报错 12llVertical.addView(view1);llVertical.addView(view1); ​ Caused by: java.lang.IllegalStateException: The specified child already has a parent. You must call removeView() on the child’s parent first.","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"Lambda","slug":"Lambda","date":"2018-07-11T06:23:20.000Z","updated":"2021-08-19T11:11:44.095Z","comments":true,"path":"2018/07/11/Lambda/","link":"","permalink":"http://noteforme.github.io.com/2018/07/11/Lambda/","excerpt":"","text":"http://blog.oneapm.com/apm-tech/226.html android https://maxwell-nc.github.io/android/retrolambda.html https://cloud.tencent.com/developer/article/1526621 https://juejin.im/post/6844903668592934925 kotlin lambda https://juejin.im/post/6844903604613021703 Video Java lambda函数式编程 https://www.bilibili.com/video/av54941486/ http://www.chilangedu.com/sectionq/2132352424 map1&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper); 123public interface Function&lt;T, R&gt; &#123; R apply(T t); //将T类型转为R&#125;","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}],"tags":[],"keywords":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}]},{"title":"EventBus","slug":"EventBus","date":"2018-07-11T06:12:08.000Z","updated":"2021-08-19T11:11:43.803Z","comments":true,"path":"2018/07/11/EventBus/","link":"","permalink":"http://noteforme.github.io.com/2018/07/11/EventBus/","excerpt":"","text":"定义事件类 1234567891011public class MessageEvent &#123; private String message; public MessageEvent(String message) &#123; this.message = message; &#125; public String getMessage() &#123; return message; &#125;&#125; EventBusActivity 12345678910111213141516@Subscribe(threadMode = ThreadMode.MAIN)public void onMessageEvent(MessageEvent messageEvent)&#123; btEventRecieve.setText(messageEvent.getMessage());&#125;@Override public void onStart() &#123; super.onStart(); EventBus.getDefault().register(this); &#125; @Override public void onStop() &#123; super.onStop(); EventBus.getDefault().unregister(this); &#125; GoalEventActivity 12345findViewById(R.id.bt_message_send).setOnClickListener(v-&gt;&#123; new Thread(()-&gt;&#123; EventBus.getDefault().post(new MessageEvent(&quot;我是 GoalEventActivity&quot;)); &#125;).start();&#125;); 类别在上面的例子中，我们再注解@Subscribe(threadMode = ThreadMode.MAIN)中使用了ThreadMode.MAIN这个模式，表示该函数在主线程即UI线程中执行，实际上EventBus总共有四种线程模式，分别是： ThreadMode.MAIN：表示无论事件是在哪个线程发布出来的，该事件订阅方法onEvent都会在UI线程中执行，这个在Android中是非常有用的，因为在Android中只能在UI线程中更新UI，所有在此模式下的方法是不能执行耗时操作的。 ThreadMode.POSTING：表示事件在哪个线程中发布出来的，事件订阅函数onEvent就会在这个线程中运行，也就是说发布事件和接收事件在同一个线程。使用这个方法时，在onEvent方法中不能执行耗时操作，如果执行耗时操作容易导致事件分发延迟。 ThreadMode.BACKGROUND：表示如果事件在UI线程中发布出来的，那么订阅函数onEvent就会在子线程中运行，如果事件本来就是在子线程中发布出来的，那么订阅函数直接在该子线程中执行。 ThreadMode.AYSNC：使用这个模式的订阅函数，那么无论事件在哪个线程发布，都会创建新的子线程来执行订阅函数。 https://github.com/greenrobot/EventBus https://www.jianshu.com/p/a040955194fc https://segmentfault.com/a/1190000004279679","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"Bluetooth02","slug":"Bluetooth02","date":"2018-07-05T10:17:23.000Z","updated":"2021-08-19T11:11:43.732Z","comments":true,"path":"2018/07/05/Bluetooth02/","link":"","permalink":"http://noteforme.github.io.com/2018/07/05/Bluetooth02/","excerpt":"","text":"BLE stack(蓝牙协议栈) 作为 Android 开发者，我们不必理解 BLE 的协议栈每个细节，这里大概介绍一下协议架构。 协议一般都是分层设计的。BLE 协议栈也不例外。我们来看一下这个图。整个协议栈大致分为三部分，从下到上分别为，控制器 （Controller）→主机（Host）→应用（Applications）。 Controller : 它是协议栈的底层的实现，直接与硬件相关，一般直接集成在 SoC 中，由芯片厂商实现，包括物理层和链路层。 HOST : 这是协议栈的上层实现，是硬件的抽象，与具体的硬件和厂家无关 应用层： 就是使用 Host 层提供的 API，开发的应用。 Controller PhysicalLayer(物理层 ): 蓝牙是工作在 2.4GHz 附近，这是工业、科学、医疗 ISM 频段。可以看到它和 WiFi 工作在同一个频段。蓝牙把频段切分为 40 个通道，3 个广播通道，37 个数据通道，按照一定规律跳频通信（高斯频移键控 GFSK）。 HCI : 在 Host 层和 Controller 之间有一个接口层 :主机和控制器之间就是通过 HCI 命令和事件交互的。HCI 这一层是协议栈中是可选的，例如在一些简单小型的设备上可能就没有，但是所有的 Android 设备上肯定是有。这是蓝牙上层应用和芯片的交互的必经之路。后面我们会讲到，这一层的 log，能够很好的帮助我们分析和调试问题。 HostATT (Attribute Protocol)它是 BLE 通信的基础。ATT 把数据封装，向外暴露为“属性”，提供“属性”的为服务端，获取“属性”的为客户端。ATT 是专门为低功耗蓝牙设计的，结构非常简单，数据长度很短 . GATT(Generic Attribute Profile) 全称叫做通用属性配置文件，它是建立在前面说的 ATT 的基础上，对 ATT 进行进一步的逻辑封装，定义数据的交互方式和含义。这是我们做 BLE 开发的时候直接接触的概念。 GATT 按照层级定义了三个概念：服务（Service）、特征（Characteristic）和描述（Descriptor）。 一个 Service 包含若干个 Characteristic，一个 Characteristic 可以包含若干 Descriptor。而 Characteristic 定义了数值和操作。Characteristic 的操作这几种权限：读、写、通知等权限。我们说的 BLE 通信，其实就是对 Characteristic 的读写或者订阅通知。还有最外面一层，Profile配置文件，把若干个相关的 Service 组合在一起，就成为了一个 Profile，Profile 就是定义了一个实际的应用场景。 Service、Characteristic相当于标签（Service相当于他的类别，Characteristic相当于它的名字），而value才真正的包含数据，Descriptor是对这个value进行的说明和描述，当然我们可以从不同角度来描述和说明，因此可以有多个Descriptor. 例如: 常见的小米手环是一个BLE设备，（假设）它包含三个Service,分别是提供设备信息的Service、提供步数的Service、检测心率的Service; 而设备信息的service中包含的characteristic包括厂商信息、硬件信息、版本信息等；而心率Service则包括心率characteristic等，而心率characteristic中的value则真正的包含心率的数据，而descriptor则是对该value的描述说明，比如value的单位啊，描述啊，权限啊等。 GAP(Generic Access Profile)它定义了 BLE 整个通信过程中的流程，例如广播、扫描、连接等流程。还定义了参与通信的设备角色，以及他们各自的职能，例如广播数据的 Broadcaster，接收广播的 Observer，还有被连接的“外设” Peripheral 和发起连接的“中心设备” Central。可以看到，参与交互的设备角色都不是对等 Applications就是使用 Host 提供的 API 开发的低功耗蓝牙应用。 到这里，我们就把 BLE 的协议栈过了一下，为我们开发 BLE 有了一些理论基础。 BLE on Android Central mode : 从Android 4.3 Jelly Bean，也就是 API 18 才开始支持低功耗蓝牙(蓝牙4.0)。这时支持 BLE 的 Central 模式，也就是我们在上面 GAP 中说的，Android 设备只能作为中心设备去连接其他设备。 Peripheral mode:从 Android 5.0 开始才支持外设模式(蓝牙4.1)。Android 设备现在可以发挥蓝牙 LE 外围设备的作用。应用可以利用此功能让附近设备发现它。例如，您可以开发这样的应用：让设备发挥计步器或健康监测仪的作用，并与其他蓝牙 LE 设备进行数据通信。 新增的 android.bluetooth.le API 让您的应用可以发布广告、扫描响应以及与附近的蓝牙 LE 设备建立连接。要使用新增的广告和扫描功能，请在您的清单中添加 BLUETOOTH_ADMIN 权限。当用户更新您的应用或从 Play 商店下载您的应用时，会被要求向您的应用授予以下权限：“Bluetooth connection information:Allows the app to control Bluetooth, including broadcasting to or getting information about nearby Bluetooth devices.” 要启动蓝牙 LE 广播，以便其他设备能发现您的应用，请调用 startAdvertising()，并传入 AdvertiseCallback 类的实现。回调对象会收到广播操作成功或失败的报告。 Android 5.0 引入了 ScanFilter 类，让您的应用可以只扫描其感兴趣的特定类型设备。要开始扫描蓝牙 LE 设备，请调用 startScan()，并传入筛选器列表。在方法调用中，您还必须提供 ScanCallback 的实现，以便在发现蓝牙 LE 广播时进行报告。 https://developer.android.com/about/versions/android-5.0?hl=zh-cn#BluetoothBroadcasting https://en.wikipedia.org/wiki/Bluetooth#Communication_and_connection Android 7.0 蓝牙架构 Android 8.0 蓝牙架构Android 提供支持经典蓝牙和蓝牙低功耗的默认蓝牙堆栈。借助蓝牙，Android 设备可以创建个人区域网络，以便通过附近的蓝牙设备发送和接收数据。 在 Android 4.3 及更高版本中，Android 蓝牙堆栈可提供实现蓝牙低功耗 (BLE) 的功能。要充分利用 BLE API，请遵循 Android 蓝牙 HCI 要求。具有合格芯片组的 Android 设备可以实现经典蓝牙或同时实现经典蓝牙和 BLE。BLE 不能向后兼容较旧版本的蓝牙芯片组。 在 Android 8.0 中，原生蓝牙堆栈完全符合蓝牙 5.0 的要求。要使用可用的蓝牙 5.0 功能，该设备需要具有符合蓝牙 5 要求的芯片组。 注意：Android 8.0 及以前版本之间的原生蓝牙堆栈的最大变化是使用高音。Android 8.0 中的供应商实现必须使用 HIDL 而不是 libbt-vendor。 蓝牙系统服务 蓝牙系统服务（位于 packages/apps/Bluetooth 中）被打包为 Android 应用，并在 Android 框架层实现蓝牙服务和配置文件。此应用通过 JNI 调用原生蓝牙堆栈。 JNI 与 android.bluetooth 相关联的 JNI 代码位于 packages/apps/Bluetooth/jni 中。当发生特定蓝牙操作时（例如发现设备时），JNI 代码会调用蓝牙堆栈。 蓝牙堆栈 系统在 AOSP 中提供了默认蓝牙堆栈，它位于 system/bt 中。该堆栈会实现常规蓝牙 HAL，并通过扩展程序和更改配置对其进行自定义。 供应商实现 供应商设备使用硬件接口设计语言 (HIDL) 与蓝牙堆栈交互。 HIDLHIDL 定义了蓝牙堆栈和供应商实现之间的接口。要生成蓝牙 HIDL 文件，请将蓝牙接口文件传递到 HIDL 生成工具中。接口文件位于 hardware/interfaces/bluetooth 下。 Android 7.x 及更早版本的蓝牙架构 https://developer.android.com/guide/platform/?hl=zh-cn https://source.android.com/setup/ https://source.android.com/devices/bluetooth/?hl=zh-cn Android 中 BLE 操作的过程 这里介绍一下 Android 中 BLE 操作的过程，APP 发起一个 BLE 操作，然后理解返回，操作结果通过回调上报。操作被封装为一个消息，然后放到协议栈的消息队列中，有一个独立的线程获取消息进行处理，类似于 Looper 和 Handler 机制。 因为是使用消息机制，回调的时候必须知道通知哪个客户端？客户端发起请求之前，首先要向协议栈注册客户端，注册成功以后，返回一个 clientIf，这是一个整型，是客户端在协议栈的一个句柄，客户端的后续操作，都只需要带上这个 clientIf 句柄即可。 在操作完成的时候，一般都有一个显式的停止操作，用来释放前面的申请的 clientIf 和资源。如果不能正确的释放，不仅会造成内存泄漏，而且可能会导致后续所有的 BLE 操作都是不能做了。因为这个 clientIf 是有限，在现在蓝牙协议栈中只有 32 个，而且是Android 上所有 APP 共用的。当这些资源用完以后，只有通过杀掉对应的 APP 或者重启蓝牙才能恢复。 BLE 应用BLE 应用可以分为两大类：基于非连接的和连接的。 Beacon 基于非连接的，这种应用就是依赖 BLE 的广播，也叫作 Beacon。这里有两个角色，发送广播的一方叫做 Broadcaster，监听广播的一方叫 Observer。 基于连接的，就是通过建立 GATT 连接，收发数据。这里也有两个角色，发起连接的一方，叫做中心设备—Central，被连接的设备，叫做外设—Peripheral。 非连接它的网络拓扑结构如下。我们知道广播是单向的，Broadcaster 向外广播，监听者接收附近的广播，整体来说形成一个单向的星型。网络中可以有多个外设，也可以有多个监听者 还有些设备，可以同时实现两个角色，既能发送广播，也可以接收广播。一个设备接收到广播，可以通过处理，然后再转发出去，这样就可以形成一个双向的网格，这就是蓝牙的 Mesh。这样的网络可以不受蓝牙传输距离限制了，只要在空间中布置足够密集的节点，就能把信息从网络一点，传递到任何一点。这个可以应用在物联网和智能家居系统中。 前面在介绍协议栈物理层的时候，我们知道广播只在37、38、39这三个广播频道进行广播，监听者也在这三个频道进行监听。我们前面介绍了，蓝牙通信是跳频的，只有双方设备在某个时刻跳到同一个频到上，才能收到广播，这种传播数据效率比较低，数据量也有限，不适合大规模的数据传输。 广播包 ​ 广播数据其实包含两部分：Advertising Data（广播数据） 和 Scan Response Data（扫描响应数据）。通常 情况下，广播的一方，按照一定的间隔，往空中广播 Advertising Data，当某个监听设备监听到这个广播数据时 候，会通过发送 Scan Response Request，请求广播方发送扫描响应数据数据。这两部分数据的长度都是固定的 31 字节。在 Android 中，系统会把这两个数据拼接在一起，返回一个 62 字节的数组。 广播数据包的结构如这个图所示。广播包中是包含一个一个的小 AD structure，每个 AD structure 是一个完整的数据，它的结构是：第一个字节表示长度 n，后面紧接 n 个字节的数据。数据部分第一个字节表示数据类型，也就是后面的数据含义，后面 n - 1 个字节表示真实数据. 这些广播数据可以自己手动去解析，在 Android 5.0 也提供 ScanRecord 帮你解析，直接可以通过这个类获得有意义的数据。 广播数据类型：设备连接属性，标识设备支持的 BLE 模式，这个是必须的。设备名字，设备包含的关键 GATT service，或者 Service data，厂商自定义数据等等。 RSSI （信号强度 ）：RSSI 单位是 dB，通过 RSSI 能够大致推测出距离的远近。但是这个在 Android 设备上非常不靠谱，RSSI 的值波动很大，跟环境和手机的角度关系很大。 ​ Android 作为接收者怎么接收广播数据，扫描设备。代码其实很简单，首先创建一个 LeScanCallback，用来接收收到广播以后，回调上报数据。然后会用 BluetoothAdapter 的 startLeScan 来开始扫描，需要停止扫描的时候，使用 stopLeScan 来停止。 有 BluetoothDevice 这个参数，代表扫描到的设备，关键是设备的的 MAC 地址信息。然后就是 RSSI，表示扫描到的设备的信号强度，接下来 scanRecord 就是我们前面介绍的广播数据，这个数据的长度是62字节。值得提的一点是，BLE 所有回调函数都不是在主线程中的。 这里有几点需要注意，这里在不需要扫描以后，一定要 stopLeScan，而且 start 和 stop 中传入的 LeScanCallback 一定要是同一个，因为 LeScanCallback 就是我们客户端的标识。否者就会出现我们前面说的 clientIf 不释放的问题。在 Android 开发中，我们经常会使用匿名内部类来做参数，在这里就千万不要这么做。 在 Android 5.0 中，提供了全新的扫描 API — BluetoothLeScanner，它提供了对扫描更加精细的控制。 除了这种方法，还可以使用经典蓝牙扫描的方式，BluetoothAdapter 的 startDiscovery()，然后通过 BroadcastReceiver 来接收收到的广播。如果只是做 BLE 的开发，不建议使用这个方法，这是一个非常重的操作，灵活性非常差。 扫描的工作流程 ​ 首先 APP 发起扫描请求，通过蓝牙的 Service 发送请求给蓝牙芯片。蓝牙芯片开始扫描，扫描到了设备，就通过回调上报。我们知道，扫描真正执行实在 BT 芯片中，只要 APP 发送了请求下去以后，Android 系统就可以休眠了，也就是我们常说的 AP （Application Processor），等扫描到了设备以后，底层 BP （Baseband Processor）就会唤醒上层 AP，执行回调通知到 APP，（动画）就像我们图中红色框标出的这样。这里有一个问题，随着我们周围的 BLE 设备逐渐增多，频繁扫描到设备，系统就会被频繁的唤醒，甚至睡眠不下去，从而导致耗电严重。 为了避免这种问题，耗电的问题。我们需要尽可能少的使用扫描。即使需要扫描，我们也希望尽可能少的上报扫描到的设备。这里就可以使用 Android 5.0 上提供的新接口，设置 ScanFilter，通过一定的规则过滤，只有扫描到了符合我们的规则的设备才上报，或者通过设置延迟上报，从而减少唤醒系统的次数。 这里总结一下扫描中一些建议。1、首先，尽可能使用新的 API，功能更强大；2、尽可能少地扫描，因为毕竟扫描是一个比较重的操作，耗电，也会减慢 BLE 连接速度；3、扫描的时候，尽量设置 ScanFilter，只扫描那些你感兴趣的设备，而不是全盘扫描；4、正确使用 API，特别是合理停止扫描，防止资源泄漏。 Android手机 作为 Broadcaster 从 Android 5.0 开始，Android 设备就可以像外设一样发送 BLE 广播了。这时 Android 设备之间就可以通过 BLE 来交互数据，或者发现对方设备了，例如类似 NFC 一样交换简单信息的应用，想象空间还是很大的。 Android 中实现的代码如下，通过前面的介绍，我们知道广播有两种包：Advertising Data 和 Scan Response Data，我们这里设置好这两种包，然后通过 BluetoothLeAdvertier 的 startAdvertising 就可以了。这里需要注意的点和前面一样，Start 了，需要注意 Stop。 基于连接BLE 连接的建立是通过 GAP 来协商和创建连接。Central 设备发起连接，外设接收连接请求，并协商连接参数。 前面我们介绍了 GATT，GATT 核心内容就是 Service、Characteristic 以及 Descriptor。每个 BLE 外设，根据自己的功能，向外暴露 Service 等。其实最重要的获取 Service 中的 Characteristic，Characteristic 可以被读、写、还有变化的时候有通知，这样就实现了双向的通信。 ​ 连接到GATT服务器（发送数据的BLE设备） https://blog.csdn.net/Roshen_android/article/details/76916111 https://www.race604.com/android-ble-in-action/ http://yannischeng.com/Android%20BLE%20%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91/","categories":[{"name":"BLE","slug":"BLE","permalink":"http://noteforme.github.io.com/categories/BLE/"}],"tags":[],"keywords":[{"name":"BLE","slug":"BLE","permalink":"http://noteforme.github.io.com/categories/BLE/"}]},{"title":"Bluetooth01","slug":"Bluetooth01","date":"2018-07-04T10:37:45.000Z","updated":"2021-08-19T11:11:43.729Z","comments":true,"path":"2018/07/04/Bluetooth01/","link":"","permalink":"http://noteforme.github.io.com/2018/07/04/Bluetooth01/","excerpt":"","text":"蓝牙名称的由来 蓝牙这个名称来自于第十世纪的一位丹麦国王Harald Blatand,Blatand在英文里的意思可以被解为蓝牙， 因为国王喜欢吃蓝梅，牙龈每天都是蓝色的所以叫牙. 蓝牙这个标志的设计：它取自 Harald Bluetooth 名字中的「H」和「B」两个字母，用古北欧字母来表示，将这两者结合起来，就成为了蓝牙的 蓝牙技术联盟官网 它负责蓝牙规范制定和推广的国际组织。做蓝牙相关产品的，少不了和它打交道。蓝牙技术联盟同时也拥有蓝牙商标，如果要使用，需要通过他们的授权。 Bluetooth SIG 蓝牙个版本区别 ​ http://www.sohu.com/a/204758166_100040477 V1.0：定义了蓝牙是一种低功耗的无线技术，传输率约在748~810kb/s，因是早期设计，容易受到同频率之产品所干扰下影响通讯质量。 V1.1所有设备都使用79个子频段在2.4GHz的频谱范围之内进行相互通信。此外，Bluetooth 1.1规范也修正了互不兼容的数据格式会引发Bluetooth 1.0设备之间的互操作性问题. V1.2增加了AFH可调式跳频技术这项技术，并主要针对现有蓝牙协议和802.11b/g之间的互相干扰问题进行了全面的改进，防止用户在同时使用支持蓝牙和无线局域网(WLAN)的两种装置的时候出现互相干扰的情况。 V2.0 蓝牙2.0标准2.0 是 1.2 的改良提升版，传输率约在 1.8M/s~2.1M/s 开始支持双工模式——即一面作语音通讯，同时亦可以传输档案/高质素图片 2.0 版本当然也支持 Stereo 运作。 V2.1支持通过NFC（Near Field Communication，近距离通讯）进行配对，只需要将两个蓝牙设备靠近，按下一个键就可以配对了，配对密码将通过NFC进行传输，无需手动输入。 V3.0核心是加入了“Generic Alternate MAC/PHY”（AMP），使蓝牙设备能最大限度的利用多种高速无线技术中更高的传输速率。这是一种全新的交替射频技术，允许蓝牙协议栈针对任一任务动态地选择正确的射频。 4.0 首先需要说明的是，发布于2010年的蓝牙4.0标准，本身就包含两个蓝牙标准——它包含传统蓝牙部分（也有称之为经典蓝牙Classic Bluetooth），也包含有低功耗蓝牙部分（Bluetooth Low Energy）。所以，毫无疑问的，低功耗蓝牙BLE属于蓝牙4.0！ 蓝牙4.0的两个部分适用于不同的产品和应用场景，如传统蓝牙部分是在之前的1.0、2.0、3.0等基础上发展和完善起来的，主要用于和此前版本蓝牙1.0、2.0、3.0的兼容以及数据量比较大的传输，如语音，音乐，较高数据量传输等。 而低功耗蓝牙部分是在Nokia的Wibree标准上发展起来的。主要用于和蓝牙4.0以及更高标准版本的兼容 ，以及用于数据传输速率比较低的产品，如遥控类的，如鼠标，键盘，遥控鼠标(Air Mouse)，传感设备的数据发送，如心跳带，血压计，温度传感器等。 由于蓝牙4.0集成了传统蓝牙和低功耗蓝牙两个标准，所以蓝牙4.0有双模和单模之分。双模即是传统蓝牙部分+低功耗蓝牙部分，单模即是单纯的低功耗蓝牙部分（BLE）。 一台装配有蓝牙4.0双模模块的手机，当其配对连接的是蓝牙3.0设备时，其耗电量就会相对较高。若其配对的设备是智能手环等采用低功耗蓝牙模块的设备时，其功耗就非常低。针对一对一连接优化，并支持星形拓扑的一对多连接； https://www.jianshu.com/p/c96e0006b34d ​ 单模蓝牙 ​ 双模蓝牙 V 4.1 提升数据传输率 相比蓝牙4.0，蓝牙4.1单包数据传输最大值从20字节上调到23字节，提升了15%的数据传输率。根据该规则，大家可以尝试修改单包数据payload的值，如果该芯片只支持BT4.0，那么修改传输23字节要么会编译报错，要么传输过程中会丢包。 主从共存 central peripheral 链路层Link layer拓扑结构做了更新，允许单设备主从同时共存（时间片轮转方式），以及一主对多从设备的连接拓扑,当BLE作Central的时候可以一对多，但是作Peripheral的时候只能一对一。 例如智能手表可以作为发射方向手机发射身体健康指数，同时作为接收方连接到蓝牙耳机/手环或其他设备上 支持32-Bit UUID 32-Bit UUID指的是广播包携带的UUID，并不是指我们所说的针对属性列表的16 bit and 128 bit UUID。可以通过广播的32-Bit UUID映射得到完整的128 Bit UUID从而使得广播包内有效广播数据长度更多。 长期睡眠下的自动唤醒功能。例如在佩戴手环游泳1小时后，回到更衣室手环会自动和手机建立连接传输数据，不需要任何操作 通过IPv6建立网络连接。蓝牙设备只需要通过蓝牙4.1连接到可以上网的设备（如手机），就可以通过IPv6与云端的数据进行同步。即实现“云同步”不再需要wifi连接（wifi模块的成本通常更高，也更费电）。通过IPv6建立网络连接。蓝牙设备只需要通过蓝牙4.1连接到可以上网的设备（如手机），就可以通过IPv6与云端的数据进行同步。即实现“云同步”不再需要wifi连接（wifi模块的成本通常更高，也更费电） V 4.2 LE连接安全 从Spec定义上蓝牙4.0和4.1的配对加密环节都是基于AES-CCM加密，但是由于蓝牙4.1双方共享同一密钥，所以存在被破解风险和漏洞。蓝牙4.2的pairing环节，采用Diffie-HellmanKey Exchange密钥交换算法进行加密，每一个设备有一对密钥对，公钥和私钥，私钥自己保存，公钥公开给对方，数据交互时，一方通过自己的私钥和对方的公钥进行加密文件，接收方通过自己私钥和传输方的公钥进行解密，从而有效的防止中间人破解密钥的事件发生。 隐私保护 蓝牙在广播过程中会携带自己的BD address (bluetooth device address)即为蓝牙唯一的MAC地址，在某些应用，比如物流追踪应用当中是非常有帮助的，可以根据BD address固定物流设备。 但是在某些应用不希望自己的BD address暴露在主端设备的监控下，蓝牙4.2给出了灵活的选择，蓝牙4.2规定，从机设备可以选择在广播模式下发送随机BD address，这样主端设备除了接该到设备之后才能获取其真实BD address，除此该设备广播模式的BD address为随机序列。 大数据传输 蓝牙4.1最大支持23字节单包数据传输，蓝牙4.2最大支持255字节单包数据传输，极大提升了数据传输率。详细可以参考我写的另外一篇文章《提升蓝牙4.2数据传输率的办法 - ATT_MTU》。 5.0 传输距离更快、距离更远 蓝牙 5.0 和前一代蓝牙 4.2 相比，它的传输距离更远、速度更快。理论上的有效距离是 300 米，也就是整个家庭或整间办公室里的移动设备都可以稳定连结。而速度最快则是可以达到 2Mbps，让反应更快、性能更高的蓝牙设备更有可能被使用。除此之外，它还大幅增强了蓝牙广播的数据传输，能为商用蓝牙带来更好的前景，让使用蓝牙做为标准的物联网应用更加强大，可以向下相容旧版本产品 。 蓝牙 Mesh 技术改变传输应用 蓝牙技术联盟（Bluetooth SIG）日前宣布推出蓝牙 Mesh 技术，这项技术将打破传统蓝牙设备间“一对一”的配对转变成“多对多”的讯号传输模式，除了应用在蓝牙 5.0，也会扩展到过往版本。蓝牙技术联盟表示，蓝牙 Mesh 技术是基于低功耗蓝牙技术推出的新网络技术，将为商用和工业用设备网络带来转变，也能让现有的物联网技术更加完整、稳定。 http://www.eet-china.com/news/article/201711190911 蓝牙5.0和wifi的区别 WIFI Wi-Fi 的一大缺陷就是有距离限制，包括过去一对一蓝牙网络在内的传统无线网络，都会受两台设备距离的限制。以 Wi-Fi 来说，有效的传输距离为 50 平方米以内，除非你装中继设备，一旦离开这个区域，你的手机就失去用武之地。 除此之外，Wi-Fi 还有耗电问题，你的手机就算是把屏幕关闭，还是得一天充一次电，Wi-Fi 是一个很重要的因素。 蓝牙 Mesh “蓝牙 Mesh”找到一个聪明的解决办法。这些设备彼此间连接，并将信号传递给附近另一个设备，形成中继资料传输的互连设备网络或网格。这意味着讯息从一个设备传递到另一个设备，再到下一个设备，接力传输。 ▲ 左图为传统 Wi-Fi 的连接方式，必须要有一个 Hub 连系其他设备，因此有距离限制。右图则是蓝牙 Mesh 的方式，越多设备连到这个网络上，范围就会越广。 与传统的交换式网络相比，无线Mesh网络去掉了节点之间的布线需求，但仍具有分布式网络所提供的冗余机制和重新路由功能。在无线Mesh网络里，如果要添加新的设备，只需要简单地接上电源就可以了，它可以自动进行自我配置，并确定最佳的多跳传输路径。添加或移动设备时，网络能够自动发现拓扑变化，并自动调整通信路由，以获取最有效的传输路径。 透过这种接力传输，形成一个无需大量电力消耗或天线广布的可靠网络。蓝牙设备之间可不透过 Wi-Fi 网络就能实现设备与设备的“对话”。换句话说，智能设备采用这种技术，在有限范围内就能完成设备间的沟通，并利用手机等设备来控制。 过去因为家中需要有一个 Hub 连接其他设备，因此有 Google、Apple、Amazon 等这些“语音助手”出现，用这些当成控制中枢。但蓝牙 Mesh 架构下，你不需要另外一个“中枢”，用智能手机就可以掌握一切。家中的蓝牙设备建构自己的网络，手机只要与其中一个蓝牙设备取得联系，就可以控制全家（整个建筑物）设备，监控这些设备的状态。 由于 Mesh 网络不需复杂设定、配对或使用路由器等存取设备，因此并不会造成安装负担，反观采用其他智慧家庭联网技术如 ZigBee、Z-wave 或其他厂商间自有的通讯技术，多需加装闸道器（Gateway）才能确保各种设备沟通无虞。 蓝牙 Mesh 工作原理：为什么还是无法取代 Wi-Fi？ 蓝牙 BLE 通讯协议中，GAP 层（Generic Access Profile）用来控制决定蓝牙设备的扫描、广播和连接等关系，也就是说，GAP 决定蓝牙设备怎样与其他设备连接、被其他设备看到等流程。 在蓝牙 mesh 出现之前，GAP 有一个典型的父子网络关系，其中“父”端决定所有路由，“子”端执行分配的任务。 例如，当你将蓝牙键盘连接到平板电脑，平板为父端、键盘为子端。 GAP 使你的设备被其他设备看见，并决定你的设备是否可以或怎样与其他设备互动。例如常用在室内定位的 Beacon 设备就只是向外广播，不支持连接。智能手环等设备，就可以与你的手机设备连接。 从蓝牙 4.1 开始，GAP 扩大了蓝牙设备的网络能力。蓝牙设备可兼具“父”和“子”的功能，使所有设备能直接连接和广播到任何其他设备。蓝牙也因此适用传输范围内和传输范围外的所有设备。 正是上述这种能直接或间接连接任何数量有 Mesh 功能的设备，因此理论上建构一个长达几公里范围的 Mesh 网络也不是不可能。 如果网络中每个设备都在其他至少一个设备的广播范围内，Mesh 网络理论上可覆盖无限距离。 在这情况下，灯泡就可能成为一个家庭主要 Mesh 网络设备之一，因为一个家庭或是建筑，几乎每个角落都有光线覆盖的需要，因此灯泡就会以保持一定距离的方式连续安装。如果每个灯泡都是蓝牙 Mesh 设备，那么这个网络就得以全面覆盖建筑物。 蓝牙 Mesh 网络不仅有低功耗，还有低频宽的特色。这听起来好像是个缺点？其实不然。 由于蓝牙 Mesh 网络不是用来让你发送影音资料，主要是用来传递维护连接或发送命令，发送一个“关闭”或“打开”的指定，用不到多少频宽。这就是为什么蓝牙 Mesh 网络虽然范围无远弗届，但无法完全取代 Wi-Fi。 乍看很像，但仔细了解后，你会发现它们适合不同的利基市场。 http://www.icsmart.cn/13985/ https://en.wikipedia.org/wiki/Bluetooth#Communication_and_connection","categories":[{"name":"BLE","slug":"BLE","permalink":"http://noteforme.github.io.com/categories/BLE/"}],"tags":[],"keywords":[{"name":"BLE","slug":"BLE","permalink":"http://noteforme.github.io.com/categories/BLE/"}]},{"title":"INTERVIEW_CONCURRENCY","slug":"INTERVIEW-CONCURRENCY","date":"2018-07-02T08:15:24.000Z","updated":"2021-08-19T11:11:43.977Z","comments":true,"path":"2018/07/02/INTERVIEW-CONCURRENCY/","link":"","permalink":"http://noteforme.github.io.com/2018/07/02/INTERVIEW-CONCURRENCY/","excerpt":"","text":"https://noteforme.github.io/tags/concurrency/ 线程基础Java线程模型 用户线程与内核级线程 并发与并行 多线程模型 https://crazyfzw.github.io/2018/06/19/thred-model/ 谈谈对多线程的理解 在Android中一个应用程序就是一个单独的进程，一般来说，当我们运行一个应用，系统就会自动创建一个进程，并且为这个进程创建一个主线程–UI线程，这样就可以运行MainActivity。 线程是操作系统能够进行运算调度的最小单位，线程是进程的子集，线程可以并行的执行不同任务，所有的线程共享同一片内存空间，这就为线程间通信提供了基础，线程有五种状态：创建，就绪，运行，阻塞，死亡。 多线程有什么要注意的问题？并发问题，安全问题，效率问题。 谈谈你对并发编程的理解并举例说明 谈谈你对多线程同步机制的理解？ ? 进程和线程的区别 协程呢 进程 ​ 是系统给程序分配资源的基本单位，每个进程都有唯一的地址空间，一个程序至少有一个进程，一个进程至少有一个线程. 线程 线程是执行操作的基本单位，JVM结构中共享 Method Area ,Heap Area ​ https://blog.csdn.net/mxsgoden/article/details/8821936 ​ https://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html 进程 : 有很大的独立性 线程 : 所有线程都有完全一样的地址空间,意味着它们也共享同样的全局变量。由于线程可以访问进程地址空间的每一个内存地址，所以一个线程可以读、写甚至清除另一个线程的堆栈。 每个进程中的内容 : 地址空间 全局变量 打开文件 子进程 即将发生的定时器 信号与信号处理程序 每个线程中的内容：程序计数器、寄存器、堆栈、状态. 协程? ​ 协程拥有自己的寄存器上下文和栈，协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的 时候，恢复先前保存的寄存器上下文和栈，即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。 协程的好处: 无需线程上下文切换的开销 无需原子操作锁定及同步的开销 方便切换控制流，简化编程模型 ​ 为什么要有线程，而不是仅仅用进程？ 怎么创建一个线程 继承Thread类创建线程类. 通过Runnable接口创建线程类 通过Callable和FutureTask创建线程 1234567891011121314151617181920212223242526272829public class CallableThreadTest implements Callable&lt;Integer&gt; &#123; public static void main(String[] args) &#123; CallableThreadTest ctt = new CallableThreadTest(); FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(ctt); for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot; 的循环变量i的值&quot; + i); if (i == 20) &#123; new Thread(ft, &quot;有返回值的线程&quot;).start(); &#125; &#125; try &#123; System.out.println(&quot;子线程的返回值：&quot; + ft.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; @Override public Integer call() throws Exception &#123; int i = 0; for (; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot; &quot; + i); &#125; return i; &#125;&#125; 线程如何关闭？​ 最正确的停止线程的方式是使用 interrupt,和条件满足. 123while (!Thread.currentThread().isInterrupted() &amp;&amp; cout&lt;1000) &#123; do more work&#125; 在Java中wait和sleep方法的不同1. sleep作用Thread上，wait作用object上 2. sleep不会释放锁 3. sleep可以在任何代码块。wait必须在同步方法，持有锁中运行。 ​ 谈谈wait/notify关键字的理解 调用之前持有对象锁 wait ,线程进入 waiting状态，释放对象锁 notify,唤醒处于waiting状态的线程。 https://howtodoinjava.com/java/multi-threading/wait-notify-and-notifyall-methods/ 如何控制某个方法允许并发访问线程的个数？​ 信号量 什么导致线程阻塞？ 阻塞指的是暂停一个线程的执行以等待某个条件发生。 Thread.sleep t.join 等待输入 线程执行了一个对象的wait()方法，直接进入阻塞状态，等待其他线程执行notify()或者notifyAll()方法。 如何保证线程安全？1. 使用线程安全的类。 2. 使用synchronized同步代码块，或者用Lock锁。 如何实现线程同步？ 1. Synchronized修饰整个方法或代码块。 2. Lock 两个进程同时要求写或者读，能不能实现？如何防止进程的同步？​ 可以进行同时读写，但为了保证数据的正确，必须要针对进程访问的共享临界区进行处理；两个进程不能同时进入临界区，否则会导致数据错乱。常见的处理方式有：信号量、管程、会合、分布式系统 信号量 信号量是一个计数器，它只支持2种操作：P操作（进入临界区）和V操作（退出临界区）。假设有信号量SV，则对它的P、V操作含义如下： P(SV)，如果SV的值大于0，意味着可以进入临界区，就将它减1；如果SV的值为0，意味着别的进程正在访问临界区，则挂起当前进程的执行； V(SV)，当前进程退出临界区时，如果有其他进程因为等待SV而挂起，则唤醒之；如果没有，则将SV加1，之后再退出临界区。 管程 提出原因：信号量机制不足，程序编写困难、易出错 方案：在程序设计语言中引入一种高级维护机制 定义：是一个特殊的模块；有一个名字；由关于共享资源的数据结构及在其上操作上的一组过程组成。进程只能通过调用管程中的过程间接访问管程中的数据结构 1）互斥：管程是互斥进入的 为了保证数据结构的数据完整性 管程的互斥由编译器负责保证的，是一种语言机制 2）同步：设置条件变量及等待唤醒操作以解决同步问题 可以让一个进程或者线程在条件变量上等待（先释放管程的管理权），也可以通过发送信号将等待在条件变量上的进程线程唤醒 链接：https://www.jianshu.com/p/72f5017c6649 线程间操作List​ 怎么中止一个线程，Thread.Interupt一定有效吗？不一定 https://juejin.cn/post/6844903896339447815#heading-6 线程安全 锁讲一下java中的同步的方法 结果锁一起 synchronized wait和notify volatile a. volatile关键字为域变量的访问提供了一种免锁机制 b.使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新 c.因此每次使用该域就要重新计算，而不是使用寄存器中的值 d.volatile不会提供任何原子操作，它也不能用来修饰final类型的变量 synchronize的原理 原子性：确保线程互斥的访问同步代码； 可见性：保证共享变量的修改能够及时可见，其实是通过Java内存模型中的 “对一个变量unlock操作之前，必须要同步到主内存中；如果对一个变量进行lock操作，则将会清空工作内存中此变量的值，在执行引擎使用此变量前，需要重新从主内存中load操作或assign操作初始化变量值” 来保证的； 有序性：有效解决重排序问题，即 “一个unlock操作先行发生(happen-before)于后面对同一个锁的lock操作”； 谈谈对Synchronized关键字，类锁，方法锁，重入锁的理解 当synchronized作用于普通方法是，锁对象是this； 当synchronized作用于静态方法是，锁对象是当前类的Class对象； 当synchronized作用于代码块时，锁对象是synchronized(obj)中的这个obj。 static synchronized 方法的多线程访问和作用也就是两个的区别了,也就是synchronized相当于this.synchronized，而static synchronized相当于Something.synchronized，它可以对类的所有对象实例起作用 synchronized与Lock的区别Lock支持的功能: 公平锁：Synchronized是非公平锁，ReentrantLock支持公平锁，默认非公平锁 可中断锁：ReentrantLock提供了lockInterruptibly（）的功能，可以中断争夺锁的操作，抢锁的时候会check是否被中断，中断直接抛出异常，退出抢锁。而Synchronized只有抢锁的过程，不可干预，直到抢到锁以后，才可以编码控制锁的释放。 快速反馈锁：ReentrantLock提供了trylock（） 和 trylock（tryTimes）的功能，不等待或者限定时间等待获取锁，更灵活。可以避免死锁的发生。 读写锁：ReentrantReadWriteLock类实现了读写锁的功能，类似于Mysql，锁自身维护一个计数器，读锁可以并发的获取，写锁只能独占。而synchronized全是独占锁 Condition：ReentrantLock提供了比Sync更精准的线程调度工具，Condition，一个lock可以有多个Condition，比如在生产消费的业务下，一个锁通过控制生产Condition和消费Condition精准控制。 https://www.jianshu.com/p/09d5ba4bfb7a ReentrantLock的内部实现显式锁ReentrantLock和同步工具类的实现基础都是AQS (AbstractQueuedSynchronizer).AQS内部有一条双向的队列存放等待线程，节点是Node对象。每个Node维护了线程、前后Node的指针和等待状态等参数。 ReentrantLock是可重入锁，也就是同一个线程可以多次获取锁，每获取一次就会进行一次计数，解锁的时候就会递减这个计数，直到计数变为0。 它有两种实现，一种是公平锁，一种是非公平锁， lock原理整体来看Lock主要是通过两个东西来实现的分别是CAS和AQS(AbstractQueuedSynchronizer)。通过加锁和解锁的过程来分析锁的实现。 一、整体概述流程 读取表示锁状态的变量 如果表示状态的变量的值为0，那么当前线程尝试将变量值设置为1（通过CAS操作完成），当多个线程同时将表示状态的变量值由0设置成1时，仅一个线程能成功，其它线程都会失败。失败后进入队列自旋转并阻塞当前线程。 2.1 若成功，表示获取了锁， 2.1.1 如果该线程（或者说节点）已位于在队列中，则将其出列（并将下一个节点则变成了队列的头节点） 2.1.2 如果该线程未入列，则不用对队列进行维护 2.1.3 然后当前线程从lock方法中返回，对共享资源进行访问。 2.2 若失败，则当前线程将自身放入等待（锁的）队列中并阻塞自身，此时线程一直被阻塞在lock方法中，没有从该方法中返回（被唤醒后仍然在lock方法中，并从下一条语句继续执行，这里又会回到第1步重新开始）。 如果表示状态的变量的值为1，那么将当前线程放入等待队列中，然后将自身阻塞 https://blog.csdn.net/liyantianmin/article/details/54673109 死锁的四个必要条件？ 互斥条件: 指线程对己经获取到的资源进行排它性使用 ，即该资源同时只由 一个线程占用。如果 此时 还有其 他 线程请求获取该资源 ，则 请求者只能等待，直至占有资源 的 线程释放该资源。 请求并持有条件 : 指一个线程己经持有了至少一个资源，但又提出了新的资源请求，而新资源己被其 他 线程占有，所 以 当前线程会被阻塞 ，但 阻塞 的同时 并不释放自 己己经获取的资源。 不可剥夺条件 : 指线程获取到的资源在自己使用完之前不能被其他线程抢占 ， 只有在自己使用完 毕后才 由 自 己释放该资源。 环路等待条件 : 指在发生死锁时 ，必然存在一个线程→资源的环形链 ，即线程集合 怎么避免死锁？请求并持有和环路等待条件是可 以被破坏. synchronized是公平锁还是非公平锁,ReteranLock是公平锁吗？是怎么实现的 synchronized只能是非公平锁。 而ReentrantLock可以实现公平锁和非公平锁两种。 公平锁的公平的含义在于如果线程现在拿不到这把锁，那么线程就都会进入等待，开始排队，在等待队列里等待时间长的线程会优先拿到这把锁，有先来先得的意思。而非公平锁就不那么“完美”了，它会在一定情况下，忽略掉已经在排队的线程，发生插队现象 synchronized跟ReentranLock有什么区别？都是加锁方式同步，而且都是阻塞式的同步，也就是说当如果一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等待 synchronized 自动释放锁,只有非公平锁。都是可重入的 ReentrantLock 手动释放锁 对象锁和类锁是否会互相影响？不会相互影响 类锁 在代码中的方法上加了static和synchronized的锁，或者synchronized(xxx.class）的代码段 对象锁 在代码中的方法上加了synchronized的锁，或者synchronized(this）的代码段 私有锁 在类内部声明一个私有属性如private Object lock，在需要加锁的代码段synchronized(lock） 管理线程 提高效率volatile的原理 有序性. 可见性 : （1）修改volatile变量时会强制将修改后的值刷新的主内存中。 （2）修改volatile变量后会导致其他线程工作内存中对应的变量值失效。因此，再读取该变量值的时候就需要重新从读取主内存中的值。 https://www.cnblogs.com/paddix/p/5428507.html https://www.bilibili.com/video/BV1NT4y1G7WE?p=8 synchronized 和volatile 关键字的区别 volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性 volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化. 多线程断点续传原理 其实原理很简单，只需要保证每个子任务的下载进度能够被即时地记录即可。这样继续下载时只需要读取这些下载记录，从上次下载结束的位置开始下载即可。 https://juejin.cn/post/6844904013440221198 线程池JavaAPI线程池有哪些参数 为什么要用线程池 降低资源消耗2. 提高响应速度3. 提高线程的可管理性 什么是线程池，如何使用?很多小任务让一组线程来执行，而不是一个任务对应一个新线程。这种能接收大量小任务并进行分发处理的就是线程池 什么是核心线程​ 常驻线程池的线程数量 怎么销毁核心线程​ allowCoreThreadTimeOut ​ https://objcoding.com/2019/04/14/threadpool-some-settings/ 为什么DCL DOUBLE CHECK LOCK要那么写，直接在方法前加synchronized不行吗​ 不DCL 这样写，就会创建多个实例 ​ synchronized可以，这样粒度太大了. ​ https://blog.csdn.net/zhaoyajie1011/article/details/106812327 如何让两个线程循环交替打印LockSupport_1A2B.java 12345678910111213141516171819202122232425 char[] aI = &quot;1234567&quot;.toCharArray(); char[] aC = &quot;ABCDEFG&quot;.toCharArray(); t1 = new Thread(() -&gt; &#123; for (char c : aI) &#123; System.out.print(c); LockSupport.unpark(t2); LockSupport.park(); &#125; LockSupport.unpark(t2); &#125;); t2 = new Thread(() -&gt; &#123; for (char c : aC) &#123; System.out.print(c); LockSupport.unpark(t1); LockSupport.park(); &#125; LockSupport.unpark(t1); &#125;); t1.start(); t2.start();// System.out.println(&quot;t1 &quot; + t1.getState());// System.out.println(&quot;t2 &quot; + t2.getState()); t1.join(); t2.join(); Notify_1A2B.java 12345678910111213141516171819202122232425262728293031323334Notify_1A2B o = new Notify_1A2B();char[] aI = &quot;1234567&quot;.toCharArray();char[] aC = &quot;ABCDEFG&quot;.toCharArray();t1 = new Thread(() -&gt; &#123; synchronized (o) &#123; for (char c : aI) &#123; System.out.print(c); o.notify(); try &#123; o.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;);t2 = new Thread(() -&gt; &#123; try &#123; synchronized (o) &#123; for (char c : aC) &#123; System.out.print(c); o.notify(); o.wait(); &#125; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125;);t1.start();t2.start();t1.join();t2.join(); 协程可以在Java项目中使用吗？ 线程池了解多少？拒绝策略有几种,为什么有newSingleThread 跨进程通信了解多少？管道了解吗？文件 AIDL （基于 Binder） Android 进阶：进程通信之 AIDL 的使用 Android 进阶：进程通信之 AIDL 解析 Binder Android 进阶：进程通信之 Binder 机制浅析 Messenger （基于 Binder） Android 进阶：进程通信之 Messenger 使用与解析 ContentProvider （基于 Binder） Android 进阶：进程通信之 ContentProvider 内容提供者 Socket Android 进阶：进程通信之 Socket （顺便回顾 TCP UDP） 原文链接：https://blog.csdn.net/u011240877/article/details/72863432 底层原理 RXJava怎么切换线程 binder进程间通信可以调用原进程方法吗？ SharedPreference原理？读取xml是在哪个线程? AQS了解吗？ ConcurrentHashMap，线程安全，为何安全。底层实现是怎么样的。 https://www.zhihu.com/question/63859501 AQShttp://gee.cs.oswego.edu/dl/papers/aqs.pdf https://www.bilibili.com/video/BV11Q4y1M7K2?from=search&amp;seid=12598203519866117819 https://javadoop.com/post/AbstractQueuedSynchronizer https://www.bilibili.com/video/BV1yJ411v7er?from=search&amp;seid=12598203519866117819 阻塞队列原理 阻塞功能:阻塞功能使得生产者和消费者两端的能力得以平衡，当有任何一端速度过快时，阻塞队列便会把过快的速度给降下来 是否有界 LinkedBlockingQueue 的上限是 Integer.MAX_VALUE，约为 2 的 31 次方, ArrayBlockingQueue 如果容量满了，也不会扩容，所以一旦满了就无法再往里放数据了。","categories":[],"tags":[{"name":"inter","slug":"inter","permalink":"http://noteforme.github.io.com/tags/inter/"}],"keywords":[]},{"title":"INTERVIEW_SENIOR","slug":"INTERVIEW-SENIOR","date":"2018-06-22T10:56:44.000Z","updated":"2021-08-19T11:11:43.981Z","comments":true,"path":"2018/06/22/INTERVIEW-SENIOR/","link":"","permalink":"http://noteforme.github.io.com/2018/06/22/INTERVIEW-SENIOR/","excerpt":"","text":"高端技术面试题这里讲的是大公司需要用到的一些高端Android技术，这里专门整理了一个文档，希望大家都可以看看。这些题目有点技术含量，需要好点时间去研究一下的。 （一）图片 图片库对比 图片库的源码分析 图片框架缓存实现 LRUCache原理 图片加载原理 自己去实现图片库，怎么做？ Glide源码解析 Glide使用什么缓存？ Glide内存缓存如何控制大小？ 框架学习https://www.youtube.com/watch?v=pUV3qZh481k okhttp​ https://noteforme.github.io/2017/08/07/OKHTTP/ okhttp怎么支持http2.0​ Handshake则会把服务端支持的Tls版本，加密方式等都带回来，然后会把这个没有验证过的HandShake用X509Certificate去验证证书的有效性。然后会通过Platform去从SSLSocket去获取ALPN的协议支持信息，当后端支持的协议内包含Http2.0时，则就会把请求升级到Http2.0阶段。 ​ 配置合适的适配器，解析json数据。 ​ Android 如何编写基于编译时注解的项目 ​ 编译时注解与运行时注解，为什么retrofit要使用运行时注解？什么时候用运行时注解？ ​ 在项目中有直接使用tcp,socket来发送消息吗 ​ https://www.bilibili.com/video/BV1ib4y1f7S1 Okhttp缓存机制 网络请求缓存处理，okhttp如何处理网络缓存的自己去设计网络请求框架，怎么做？ 从网络加载一个10M的图片，说下注意事项 TCP的3次握手和四次挥手 TCP与UDP的区别 TCP与UDP的应用 HTTP协议 HTTP1.0与2.0的区别 HTTP报文结构 HTTP与HTTPS的区别以及如何实现安全性 如何验证证书的合法性? https中哪里用了对称加密，哪里用了非对称加密，对加密算法（如RSA）等是否有了解? client如何确定自己发送的消息被server收到? 谈谈你对安卓签名的理解。 请解释安卓为啥要加签名机制? 视频加密传输 App 是如何沙箱化，为什么要这么做？ 权限管理系统（底层的权限是如何进行 grant 的）？ Retrofit在retrofit中的泛型是怎么解析的 https://noteforme.github.io/2017/09/23/Retrofit/ RxJavahttps://noteforme.github.io/2020/08/04/RxJava/ 在 RxJava 中， 会遇到被观察者发送消息太快以至于它的操作符或者订阅者不能及时处理相关的消息，这就是典型的背压（ Back Pressure ）场景。 RxJava 是基于 Push 模型 。对于 Pull 模型而言，当消费者请求数据的时候，如果生产者比较慢 ，则消费者会阻塞等待。如果生产者比较快，生产者会等待消费者处理完后再生产新的数据，所以不会出现背压的情况。然而在 RxJava 中，只要生产者数据准备好了就会发射出去。如果生产者比较慢，则消费者会等待新的数据到来。如果生产者比较快，则会有很多数据发射给消费者，而不管消费者当前有没有能力处理数据，这样就会导致背压。 在 RxJava 2.x 中， Observable 不再支持背压，而是改用 Flowable 来专门支持背压。默认队列大小为 128 ，并且要求所有的操作符强制支持背压。 RxJava原理及如何封装使用​ 使用观察者模式，和装饰器模式。 ​ 先用Observablex向右构建流，然后向左创建订阅流，最后时间通过观察者回调流发送。 ​ ​ 你了解协程吗？协程有什么作用？可以完全取代rxjava吗？ rxjava里面用了大量的&lt;? super T&gt;这些，是什么意思。 如果要从集合中读取类型T的数据，并且不能写入，可以使用 ? extends 通配符；(Producer Extends) 如果要从集合中写入类型T的数据，并且不需要读取，可以使用 ? super 通配符；(Consumer Super),只能用Object接收。 如果既要存又要取，那么就不要使用任何通配符。 https://www.jianshu.com/p/86cf908afcb6 RxJava怎么通过被订阅者传给订阅者的过程是什么样的?Observer处理完onComplete后会还能onNext吗?​ onComplete是用来控制不能发送数据的，也就是不能onNext了，包括onError也是不能再发送onNext数据了，该方法中也是调用了 dispose方法。 RxJava中map、flatMap的区别，你还用过其他哪些操作符?​ map是通过原始数据类型返回另外一种数据类型，而flatMap是通过原始数据类型返回另外一种被观察者。 Maybe、Single、Flowable、Completable几种观察者的区别，以及他们在什么场景用？​ 如果只想发一条数据，或者不发数据就用Maybe，如果想发多条数据或者不发数据就用Observable，如果只发一条数据或者失败就用Single，如果想用背压策略使用Flowable，如果不发数据就用Completable 也就是说Maybe可能不发送数据，如果发送数据只会发送单条数据。 single也是发送单条数据，但是它要么成功要么失败。 RxJava切换线程是怎么回事?subscribeOn实际是创建了ObservableSubscribeOn的Observable，它的订阅方法里面创建了SubscribeOnObserver，通过线程池执行Runnable，使上游Observable的订阅在子线程中执行，这就是为什么subscribeOn能控制observable在哪个线程中执行的原因 RxJava的subscribeOn只有第一次生效?subscribeOn对subscribe订阅进行处理，针对是订阅流，从后向前流动，所以最前面的一次生效。 subscribeOn是规定上游的observable在哪个线程中执行，如果我们执行多次的subscribeOn的话，从下游的observer到上游的observable的订阅过程，最开始调用的subscribeOn返回的observable会把后面执行的subscribeOn返回的observable给覆盖了，因此我们感官的是只有第一次的subscribeOn能生效。 RxJava的observeOn多次调用哪个有效?observeOn在事件发送的 onNext(T t)进行处理，针对的是观察者流，从前向后流动，所以最后一次生效。 observeOn是指定下游的observer在哪个线程中执行，所以这个更好理解，看observeOn下一个observer是哪一个，所以多次调用observeOn肯定是最后一个observeOn控制有效。 https://juejin.cn/post/6900870262062120967 https://zhuanlan.zhihu.com/p/339620311 RxJava中背压是怎么回事？ https://www.jianshu.com/p/c3965e82b164 https://zhuanlan.zhihu.com/p/322405376 https://www.bilibili.com/video/BV1Af4y187b8 数据库 sqlite升级，增加字段的语句 数据库框架对比和源码分析 数据库的优化 数据库数据迁移问题 算法排序算法有哪些？冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序 https://zhuanlan.zhihu.com/p/42586566 最快的排序算法是哪个？快速排序 最好情况O(nlogn) 最坏情况 O(n^2) 为什么不是堆排序 ? 在堆排序（小根堆）的时候，每次总是将最小的元素移除，然后将最后的元素放到堆顶，再让其自我调整。这样一来，有很多比较将是被浪费的，因为被拿到堆顶的那个元素几乎肯定是很大的，而靠近堆顶的元素又几乎肯定是很小的，最后一个元素能留在堆顶的可能性微乎其微，最后一个元素很有可能最终再被移动到底部。在堆排序里面有大量这种近乎无效的比较。随着数据规模的增长，比较的开销最差情况应该在（线性*对数）级别，如果数据量是原来的10倍，那么用于比较的时间开销可能是原来的10log10倍原文链接：https://blog.csdn.net/qq_36770641/article/details/82669788 手写一个冒泡排序 手写快速排序代码 快速排序的过程、时间复杂度、空间复杂度 手写堆排序 堆排序过程、时间复杂度及空间复杂度 写出你所知道的排序算法及时空复杂度，稳定性 https://noteforme.github.io/2021/03/21/Data-Sort/ 二叉树给出根节点和目标节点，找出从根节点到目标节点的路径 给阿里2万多名员工按年龄排序应该选择哪个算法？ GC算法(各种算法的优缺点以及应用场景) 蚁群算法与蒙特卡洛算法 子串包含问题(KMP 算法)写代码实现 一个无序，不重复数组，输出N个元素，使得N个元素的和相加为M，给出时间复杂度、空间复杂度。手写算法 万亿级别的两个URL文件A和B，如何求出A和B的差集C(提示：Bit映射-&gt;hash分组-&gt;多文件读写效率-&gt;磁盘寻址以及应用层面对寻址的优化) 百度POI中如何试下查找最近的商家功能(提示：坐标镜像+R树)。 两个不重复的数组集合中，求共同的元素。 两个不重复的数组集合中，这两个集合都是海量数据，内存中放不下，怎么求共同的元素？ 一个文件中有100万个整数，由空格分开，在程序中判断用户输入的整数是否在此文件中。说出最优的方法 一张Bitmap所占内存以及内存占用的计算 2000万个整数，找出第五十大的数字？ 烧一根不均匀的绳，从头烧到尾总共需要1个小时。现在有若干条材质相同的绳子，问如何用烧绳的方法来计时一个小时十五分钟呢？ 求1000以内的水仙花数以及40亿以内的水仙花数 5枚硬币，2正3反如何划分为两堆然后通过翻转让两堆中正面向上的硬8币和反面向上的硬币个数相同 时针走一圈，时针分针重合几次 N*N的方格纸,里面有多少个正方形 x个苹果，一天只能吃一个、两个、或者三个，问多少天可以吃完？ 插件化、模块化、组件化、热修复、增量更新、Gradle 对热修复和插件化的理解 插件化原理分析 模块化实现（好处，原因） 热修复,插件化 项目组件化的理解 描述清点击 Android Studio 的 build 按钮后发生了什么 架构设计和设计模式​ https://noteforme.github.io/categories/DesignPatterns/ 设计原则​ 单一职责 ​ 一个类应该只负责一项职责。 接口隔离 ​ 客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。 依赖倒置 高层模块不应该依赖低层模块，二者都应该依赖其抽象。 抽象不应该依赖细节，细节应该依赖抽象。 依赖倒置的中心思想是面向接口编程。 里氏替换 所有使用基类的地方必须能透明的使用其子类。 使用继承时，遵循里氏替换原则，子类尽量不要重写父类的方法。继承实际上让两个类耦合性增强了，适当情况下可以通过 聚合 组合 依赖来解决问题。 ​ 通用做法是： 原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖，聚合，组合等关系代替。 开闭原则 ocp 迪米特法则 ​ 一个对象应该对其他对象保持最少的了解 设计模式 谈谈你对Android设计模式的理解 MVC MVP MVVM原理和区别 你所知道的设计模式有哪些？ 项目中常用的设计模式 手写生产者/消费者模式 写出观察者模式的代码 适配器模式，装饰者模式，外观模式的异同？ 用到的一些开源框架，介绍一个看过源码的，内部实现过程。 谈谈对RxJava的理解 RxJava的功能与原理实现 RxJava的作用，与平时使用的异步操作来比的优缺点 说说EventBus作用，实现方式，代替EventBus的方式 从0设计一款App整体架构，如何去做？ 说一款你认为当前比较火的应用并设计(比如：直播APP，P2P金融，小视频等) 谈谈对java状态机理解 Fragment如果在Adapter中使用应该如何解耦？ Binder机制及底层实现 对于应用更新这块是如何做的？(解答：灰度，强制更新，分区域更新)？ 实现一个Json解析器(可以通过正则提高速度) 统计启动时长,标准 性能优化 如何对Android 应用进行性能分析以及优化? ddms 和 traceView 性能优化如何分析systrace？ 用IDE如何分析内存泄漏？ Java多线程引发的性能问题，怎么解决？ 启动页白屏及黑屏解决？ 启动太慢怎么解决？ 怎么保证应用启动不卡顿？ App启动崩溃异常捕捉 自定义View注意事项 现在下载速度很慢,试从网络协议的角度分析原因,并优化(提示：网络的5层都可以涉及)。 Https请求慢的解决办法（提示：DNS，携带数据，直接访问IP） 如何保持应用的稳定性 RecyclerView和ListView的性能对比 ListView的优化 RecycleView优化 View渲染 Bitmap如何处理大图，如一张30M的大图，如何预防OOM java中的四种引用的区别以及使用场景 强引用置为null，会不会被回收？ NDK、jni、Binder、AIDL、进程通信有关 请介绍一下NDK 什么是NDK库? jni用过吗？ 如何在jni中注册native函数，有几种注册方式? Java如何调用c、c++语言？ jni如何调用java层代码？ 进程间通信的方式？ Binder机制 简述IPC？ 什么是AIDL？ AIDL解决了什么问题？ AIDL如何使用？ Android 上的 Inter-Process-Communication 跨进程通信时如何工作的？ 多进程场景遇见过么？ Android进程分类？ 进程和 Application 的生命周期？ 进程调度 谈谈对进程共享和线程安全的认识 谈谈对多进程开发的理解以及多进程应用场景 什么是协程？ framework层、ROM定制、Ubuntu、Linux之类的问题 java虚拟机的特性 谈谈对jvm的理解 JVM内存区域，开线程影响哪块内存 对Dalvik、ART虚拟机有什么了解？ Art和Dalvik对比 虚拟机原理，如何自己设计一个虚拟机(内存管理，类加载，双亲委派) 谈谈你对双亲委派模型理解 JVM内存模型，内存区域 类加载机制 谈谈对ClassLoader(类加载器)的理解 谈谈对动态加载（OSGI）的理解 内存对象的循环引用及避免 内存回收机制、GC回收策略、GC原理时机以及GC对象 垃圾回收机制与调用System.gc()区别 系统启动流程是什么？（提示：Zygote进程 –&gt; SystemServer进程 –&gt; 各种系统服务 –&gt; 应用进程） 大体说清一个应用程序安装到手机上时发生了什么 简述Activity启动全部过程 App启动流程，从点击桌面开始 Android中进程内存的分配，能不能自己分配定额内存？ 如何保证一个后台服务不被杀死？（相同问题：如何保证service在后台不被kill？）比较省电的方式是什么？ App中唤醒其他进程的实现方式 ​ https://www.jianshu.com/p/c3965e82b164 ​ https://www.cnblogs.com/deman/p/5860976.html#_label29 AMS是如何启动的？ AMS在Android起到什么作用？ AMS有哪些应用场景？我们是如何应用AMS核心原理的？ WMS的工作原理说说？ JVM的核心原理你懂多少？ 我们的代码是如何在栈区中运行的？ 如何使用字节码研究系统级原理？","categories":[],"tags":[{"name":"inter","slug":"inter","permalink":"http://noteforme.github.io.com/tags/inter/"}],"keywords":[]},{"title":"Zigbee","slug":"Zigbee","date":"2018-06-20T08:51:26.000Z","updated":"2021-08-19T11:11:44.292Z","comments":true,"path":"2018/06/20/Zigbee/","link":"","permalink":"http://noteforme.github.io.com/2018/06/20/Zigbee/","excerpt":"","text":"https://blog.csdn.net/qq_34581118/article/details/78452316 0000 01010001 0000 0001 0101 = 1 * 2^4+ 1*2^2 + 1 = 21 = 0X15 12301 02 10 11 02 10 02 10 11 03 10 10 10 10 01 00 11 00 00 11 03 https://blog.csdn.net/feiyangxiaomi/article/details/9257375 https://juejin.im/post/5b124346e51d450684732790","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"Architecture","slug":"Architecture","date":"2018-06-14T01:31:59.000Z","updated":"2021-08-19T11:11:43.682Z","comments":true,"path":"2018/06/14/Architecture/","link":"","permalink":"http://noteforme.github.io.com/2018/06/14/Architecture/","excerpt":"","text":"Jetpack It helps to be familiar with software architectural patterns that separate data from the user interface, such as MVP or MVC https://developer.android.com/jetpack/docs/getting-started modules should interact NetworkBoundResource It starts by observing the database for the resource. When the entry is loaded from the database for the first time, NetworkBoundResource checks whether the result is good enough to be dispatched or that it should be re-fetched from the network. Note that both of these situations can happen at the same time, given that you probably want to show cached data while updating it from the network. https://developer.android.com/topic/libraries/architecture 架构学习从codelab开始吧! https://www.jianshu.com/p/19f97654c451 https://github.com/qingmei2/MVVM-Architecture https://juejin.im/post/5dafc49b6fb9a04e17209922 https://juejin.im/post/5d2be05ff265da1bd605d49a LifecycleOwnerLifecycleOwner is an interface implemented by the AppCompatActivity and Fragment classes. You can subscribe other components to owner objects which implement this interface, to observe changes to the lifecycle of the owner. To read an introductory guide to this topic, see Handling Lifecycles. https://codelabs.developers.google.com/codelabs/android-lifecycles/#1 https://mp.weixin.qq.com/s/gQhBeKA2vGAkh3Tbqn0tEA ViewModelhttps://noteforme.github.io/2020/04/06/viewmodel/ https://www.jianshu.com/p/731ca42823ee viewmodelstoreowner navigationhttps://developer.android.com/guide/navigation/ https://developer.android.com/guide/navigation/navigation-getting-started https://codelabs.developers.google.com/codelabs/android-navigation/index.html?index=..%2F..%2Findex#0 Codelab 抽屉图标不显示 BottomNavigationView 导航栏优化 recarete fragment https://medium.com/@freedom.chuks7/how-to-use-jet-pack-components-bottomnavigationview-with-navigation-ui-19fb120e3fb9 NOTICE : NavigationView each item ID is matching with fragment ID in navigation https://jiangjiwei.site/post/navigation-zhi-fragment-qie-huan/ https://github.com/lwj1994/navigation-keep-state-fragment https://github.com/STAR-ZERO/navigation-keep-fragment-sample Bottom tab定位 https://stackoverflow.com/questions/50577356/android-jetpack-navigation-bottomnavigationview-with-youtube-or-instagram-like 全局共享 googlesamples previously architectureMVC MVP. MVVM三种架构介绍 http://www.jcodecraeer.com/a/anzhuokaifa/2017/1024/8636.html https://mp.weixin.qq.com/s/Kc1826MQ3ReMkoIWlsQGVw https://juejin.im/post/5dafc49b6fb9a04e17209922 https://juejin.im/post/5dafc49b6fb9a04e17209922#heading-13 MVP https://juejin.im/entry/5955e7166fb9a06bc23a8598 https://github.com/yaozs/YzsBaseActivity 多个activity对p的复用 https://juejin.im/post/599ce8016fb9a0247e4255f4 Component https://mp.weixin.qq.com/s/8_8gGpkpO2QFNkWgSRBwIg https://www.jianshu.com/p/6a50ef1ef45c https://developer.android.com/studio/build/dependencies#duplicate_classes https://developer.android.com/studio/build/manifest-merge?hl=zh-cn merge androidmanifest 合并 &lt;https://developer.android.com/studio/build/manifest-merge https://www.jianshu.com/p/14a822e42151 compose https://mp.weixin.qq.com/s/0mAbKEuBH5HHYa23EcWalg lifecycle https://juejin.im/post/6847902220755992589 组件化 服务 https://juejin.im/post/6884492604370026503","categories":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://noteforme.github.io.com/categories/Jetpack/"}],"tags":[],"keywords":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://noteforme.github.io.com/categories/Jetpack/"}]},{"title":"VideoNDK","slug":"VideoNDK","date":"2018-06-14T01:21:28.000Z","updated":"2021-08-19T11:11:44.263Z","comments":true,"path":"2018/06/14/VideoNDK/","link":"","permalink":"http://noteforme.github.io.com/2018/06/14/VideoNDK/","excerpt":"","text":"指针1234567891011121314#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, const char * argv[]) &#123; // insert code here... char* p = (char*)malloc(10); //字符型指针 malloc堆空间分配内存 *p = &#x27;a&#x27;; *(p+1) = &#x27;b&#x27;; *(p+2) = &#x27;c&#x27;; free(p); // p = NULL; printf(&quot;%s \\n&quot;,p); &#125; 输出 abc 指针函数:带指针的函数 函数的返回值为指针类型 函数声明 : int* func(int x,int y) 指针函数调用 12char *q;q = func(m); // q与被调用的函数的返回类型一致 示例112345678910111213141516171819202122#include &lt;stdio.h&gt;char *getWord(char c)&#123; switch (c) &#123; case &#x27;A&#x27;: return &quot;Apple&quot;; case &#x27;B&#x27;: return &quot;Banana&quot;; case &#x27;C&#x27;: return &quot;Cat&quot;; case &#x27;D&#x27;: return &quot;Dog&quot;; default:return &quot;None&quot;; &#125;&#125;int main(int argc, const char * argv[]) &#123; char input; printf(&quot;please input a charactar:&quot;); input = getchar(); printf(&quot;%c\\n&quot;,input); printf(&quot;%s\\n&quot;,getWord(input)); getchar(); return 0;&#125; 运行结果 123please input a charactar:AAApple 输入A ，getWord()返回值为 Apple的首地址,printf(“%s\\n),输出首地址所指向的值 示例212345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;char *getWord2(char c)&#123; char str1[] = &quot;Apple&quot;; char str2[] = &quot;Banana&quot;; char str3[] = &quot;Cat&quot;; char str4[] = &quot;Dog&quot;; char str5[] = &quot;None&quot;; switch (c) &#123; case &#x27;A&#x27;: return str1; case &#x27;B&#x27;: return str2; case &#x27;C&#x27;: return str3; case &#x27;D&#x27;: return str4; default:return str5; &#125;&#125;//#if (0)int main(int argc, const char * argv[]) &#123; char input; printf(&quot;please input a charactar:&quot;); input = getchar(); printf(&quot;%c\\n&quot;,input); printf(&quot;%s\\n&quot;,getWord2(input)); getchar(); return 0;&#125;//#endif 注意: 不要返回局部变量的指针 例子2中,str1数组是局部变量，这个字符数组在子程序结束后，它对应的存储空间会被释放. 函数指针：指向函数的指针指向函数起始地址的指针 函数指针的定义 int (*fptr)(int,int) // (*func)中括号是必要的，这会告诉编译器我们声明的是函数指针而不是声明一个具有返回型为指针的函数 指针变量 : *fptr , 如果*fptr变为函数名，整个就是一个函数 函数指针的使用 fptr = func; int x = fptr(5,8); “%x “ 打印指针本身 示例 1234567891011121314151617181920#include &lt;stdio.h&gt;int square(int num)&#123; return num * num;&#125;int main(int argc, const char * argv[]) &#123; int num; int (*fp)(int); // fp是一个指针，指向返回类型为int，参数为int的函数. printf(&quot;please input a number:&quot;); scanf(&quot;%d&quot;,&amp;num); fp = square; // 函数与指针的联系 printf(&quot;fp = 0x%x, %d\\n&quot;,fp,(*fp)(num)); //&#x27;0x%x&#x27; 打印指针本身 printf(&quot;fp = 0x%x, %d\\n&quot;,fp,fp(num)); // fp直接调用也可以 return 0; &#125; square内存中占据的位置，fp保存square指针的入口地址,fp指向square(),*fp代表 调用square(). 用法 123456789101112131415161718192021#include &lt;stdio.h&gt;int add(int num1,int num2)&#123; return num1+num2;&#125;int sub(int num1,int num2)&#123; return num1-num2;&#125;int calculate(int (*fp)(int,int),int num1,int num2)&#123; //通用功能的函数 return (*fp)(num1,num2);&#125;int main(int argc, const char * argv[]) &#123; printf(&quot;3+5=%d\\n&quot;,calculate(add,3,5)); printf(&quot;3-5=%d\\n&quot;,calculate(sub,3,5)); return 0;&#125; 函数指针数组 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;void function1(int);void function2(int);void function3(int);void function1(int choice)&#123; printf(&quot;input %d, run function1().\\n &quot;,choice);&#125;void function2(int choice)&#123; printf(&quot;input %d, run function2().\\n &quot;,choice);&#125;void function3(int choice)&#123; printf(&quot;input %d, run function3().\\n &quot;,choice);&#125;#if(1)int main(int argc, const char * argv[]) &#123; void (*f[3])(int) = &#123;function1,function2,function3&#125;;//f[3] f是有3个元素的数组，数组的每个元素是指针类型,每个指针指向 参数为(int)类型的函数 int choice; printf(&quot;please enter a digit : [0-2]: &quot;); scanf(&quot;%d&quot;,&amp;choice); while (choice&gt;0&amp;&amp;choice&lt;3) &#123; (*f[choice])(choice); printf(&quot;please enter a digit : [0-2]: &quot;); scanf(&quot;%d&quot;,&amp;choice); &#125; printf(&quot;run end&quot;);&#125;#endif https://www.bilibili.com/video/BV15J411Q7t9?from=search&amp;seid=1110914330533311902 函数指针pft指向了一个已经声明的函数bar()，然后通过pft来实现输出字符和整型的目的。 123456789101112void bar(char, int);typedef void (*PFT)(char, int);int main()&#123; PFT pft; pft = bar; pft(&#x27;e&#x27;,91);&#125;void bar(char ch,int i)&#123; cout&lt;&lt; &quot; bar &quot;&lt;&lt;ch&lt;&lt;&#x27; &#x27;&lt;&lt;i&lt;&lt;endl; return;&#125; 函数指针作为函数的参数，我们可以在一个函数的形参列表中传入一个函数指针， 然后便可以在这个函数中使用这个函数指针所指向的函数 123456789101112131415161718typedef void (*PFT)(char, int);void bar(char ch, int i) &#123; cout &lt;&lt; &quot;bar &quot; &lt;&lt; ch &lt;&lt; &#x27; &#x27; &lt;&lt; i &lt;&lt; endl; return;&#125;void foo(char ch, int i, PFT pf) &#123; pf(ch, i); return;&#125;int main() &#123; PFT pft; pft = bar; foo(&#x27;e&#x27;, 12, pft);&#125; 函数对象 12345678910class A &#123;public: int operator()(int x) &#123; return x; &#125;&#125;;int main()&#123; A a; cout&lt;&lt;a(5)&lt;&lt;endl;&#125; 123456789101112131415161718class Func &#123;public: int operator()(int a, int b) &#123; cout &lt;&lt; a &lt;&lt; &#x27;+&#x27; &lt;&lt; b &lt;&lt; &#x27;=&#x27; &lt;&lt; a + b &lt;&lt; endl; return a; &#125;&#125;;int addFunc(int a, int b, Func &amp;func) &#123; func(a, b); return a;&#125;int main() &#123; Func func; addFunc(1, 3, func);&#125; 结构体结构指针point 1234567struct point *pp; struct point pt = &#123;400,600&#125;; pp = &amp;pt; printf(&quot;pt %d, %d \\n&quot;,pt.x, pt.y);//(*pp.x)中的圆括号是必须的，因为结构成员运算符的 &quot;.&quot; 的优先级比先级高 printf(&quot;*pp %d, %d \\n&quot;,(*pp).x, (*pp).y); printf(&quot;pp-&gt; %d, %d \\n&quot;,pp-&gt;x, pp-&gt;y); 运行 1234pt 400, 600 *pp 400, 600 pp-&gt; 400, 600 结构指针的使用频度非常高，C语言提供了另一种简写方式，假定P指向一个结构的指针，可以用 p-&gt; 结构成员 == *p.结构成员 代码表达式printf(&quot;origin is (%d,%d)\\n&quot;, pp-&gt;x, pp-&gt;y); 123456struct rect r = &#123;&#123;200,300&#125;,&#123;400,500&#125;&#125;; struct rect *rp = &amp;r; printf(&quot;pt1.x %d \\n&quot;,r.pt1.x); printf(&quot;(*rp).pt1.x %d \\n&quot;,(*rp).pt1.x); printf(&quot; rp-&gt;pt1.x %d \\n&quot;,rp-&gt;pt1.x); printf(&quot;r.pt1.x %d \\n&quot;,r.pt1.x); 运行结果 1234pt1.x 200 (*rp).pt1.x 200 rp-&gt;pt1.x 200 r.pt1.x 200 动态内存分配1234567891011121314151617181920212223 int a[5] = &#123;4,10,2,8,6&#125;; int len; printf(&quot;请输入你需要分配的数组的长度：len = &quot;); scanf(&quot;%d&quot;,&amp;len); /** * sizeof(int) *len 分配len个int字节的长度，len =5时，就是20个字节 * malloc返回 指向 第一个字节的地址 * int * 第一个字节的地址，代表Int类型地址， pArr等价于a， pArr+1代表第二个Int地址 */ int *pArr = (int *)malloc(sizeof(int) *len); *pArr = 5; //类似于 a[0] =4; pArr[1] = 10; //类似于a[1]=10;// printf(&quot;%d %d &quot;,*pArr,pArr[1]); for (int i = 0; i &lt;len ; ++i) &#123; scanf(&quot;%d&quot; , &amp;pArr[i]); &#125; for (int i = 0; i&lt;len ; ++i) &#123; printf(&quot;%d\\n &quot; , *(pArr+i)); &#125; free(pArr); //把pArr所代表的动态分配的20个字节的内存释放 结构体变量(hao)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#include &lt;memory.h&gt;struct Student &#123; int sid; char name[200]; int age;&#125;;void g(struct Student student);void g2(struct Student *pst);void f(struct Student *pst);int main() &#123; struct Student st = &#123;1000, &quot;张三&quot;, 20&#125;; printf(&quot;%d %s %d\\n&quot;, st.sid, st.name, st.age); st.sid = 99;// st.name = &quot;lili&quot;; //error strcpy(st.name, &quot;lili&quot;);//复制 st.age = 22; printf(&quot;%d %s %d\\n&quot;, st.sid, st.name, st.age); struct Student *pst; pst = &amp;st; pst-&gt;sid = 99; // pst -&gt; sid 等价于 (*pst).sid 而(*pst).sid 等价于 st.sid // pst -&gt; sid // 所指向的结构体变量的sid这个成员 g(st); g2(&amp;st); return 0;&#125;void g2(struct Student *pst) &#123; printf(&quot;g2 %d %s %d\\n&quot;, pst-&gt;sid, pst-&gt;name, pst-&gt;age);&#125;//这种方式多耗 208 内存，耗时间 不推荐void g(struct Student st) &#123; printf(&quot;g %d %s %d\\n&quot;, st.sid, st.name, st.age);&#125; 跨函数使用内存123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;struct Student&#123; int sid; int age;&#125;;struct Student *createStudent(void);void showStudent(struct Student *pst);int main()&#123; struct Student *ps; ps = createStudent(); showStudent(ps);&#125;void showStudent(struct Student *pst) &#123; printf(&quot;%d %d\\n&quot;,pst-&gt;sid,pst-&gt;age);&#125;struct Student *createStudent() &#123; struct Student *p = malloc(sizeof(struct Student)); //表示 struct Student整体的数据类型代表的字节数 p-&gt;sid = 99; p-&gt;age = 88; return p;&#125; 运算符优先级 java运算符优先级 ! &amp;&amp; || 算法https://space.bilibili.com/501486236/video typedef 别名type_1 12345678910111213141516171819typedef int ZHANGSAN;//为int再重新多取一个名字，ZHANGSAN等价于inttypedef struct Student &#123; int sid; char name[100]; char sex;&#125; ST;int main(void) &#123; int i = 10; //等价于 ZHANGSAN i = 10; ZHANGSAN j = 20; printf(&quot;%d\\n&quot;, j); struct Student st;//等价于 ST st; struct Student *ps = &amp;st; // 等价于 ST * ps ST st2; st2.sid = 200; printf(&quot;%d\\n&quot;,st2.sid);&#125; type_2 12345678910111213typedef struct Student &#123; int sid; char name[100]; char sex;&#125; * PST ; //PST等价于 struct Student * ,这样就是一个指针类型了int main(void)&#123; struct Student st; PST ps = &amp;st; ps-&gt;sid = 99; printf(&quot;%d\\n&quot;,ps-&gt;sid); return 0;&#125; type_3 12345678910111213typedef struct Student &#123; int sid; char name[100]; char sex;&#125; * PSTU, STU; //等价于 ST代表了 struct Student st, PST 代表了struct Student *;int main(void) &#123; STU st; //等价于 struct Student st; PSTU ps = &amp;st; //struct Student * ps = &amp;st; ps-&gt;sid = 99; printf(&quot;%d\\n&quot;,ps-&gt;sid); return 0;&#125; C++引用 1C++ 引用引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量 12345678910111213141516#include &lt;iostream&gt;using namespace std;void swap(int &amp;x, int &amp;y) &#123; int t = x; x = y; y = t;&#125;int main() &#123; int a = 3, b = 4; cout &lt;&lt; a &lt;&lt; &quot;\\t&quot; &lt;&lt; b &lt;&lt; endl; swap(a, b); cout &lt;&lt; a &lt;&lt; &quot;\\t&quot; &lt;&lt; b &lt;&lt; endl;&#125; 函数模板123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;template&lt;typename T&gt;T add(T x,T y)&#123; return x+y;&#125;int main()&#123;#if 0 cout&lt;&lt;add&lt;int&gt;(5,3)&lt;&lt;endl; cout&lt;&lt;add&lt;double &gt;(5.3,7.8)&lt;&lt;endl; cout&lt;&lt;add&lt;int&gt;(4,6)&lt;&lt;endl; cout&lt;&lt;add&lt;string&gt;(&quot;hello&quot;,&quot;world&quot;)&lt;&lt;endl;#else //类型自动推断 cout&lt;&lt;add(5,3)&lt;&lt;endl; cout&lt;&lt;add(5.3,7.8)&lt;&lt;endl; cout&lt;&lt;add(4,6)&lt;&lt;endl; cout&lt;&lt;add((double)5,7.8)&lt;&lt;endl;#endif&#125; swift语法1234567891011121314151617181920212223242526272829303132333435363738394041424344var a = 10var b: Int = 20let aa = 40 //constif a&lt;20&#123; print(&quot;a &lt; 20 , true&quot; )&#125;else&#123; print(&quot;a &gt;= 20&quot;)&#125;switch a &#123; case 10: print(&quot;a equals 10&quot;)case 20: print(&quot;a equals 20&quot;)default : print(&quot;other&quot;)&#125;print(&quot;Hello, World!&quot;)for i in 25..&lt;100&#123; print(&quot;aa,i=&quot;,i)&#125;var list = [1,2,3,4,5]for i in list&#123; print(&quot;aa, i=&quot;,i);&#125;var loop = 0while loop&lt;10 &#123; print(&quot;loop, xxx = &quot;,loop) loop = loop + 1&#125;func myFunc(a : Int) -&gt; Int&#123; print(&quot;this is a function&quot;,a) return a&#125;var mm = myFunc(a: 10)print(&quot;Hello, World!&quot;,a,b,aa,mm) environmenthttps://juejin.im/post/5ad98412518825670960c13c https://developer.android.com/ndk/","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"Bluetooth03","slug":"Bluetooth03","date":"2018-06-11T01:41:39.000Z","updated":"2021-08-19T11:11:43.746Z","comments":true,"path":"2018/06/11/Bluetooth03/","link":"","permalink":"http://noteforme.github.io.com/2018/06/11/Bluetooth03/","excerpt":"","text":"经典蓝牙 低功耗蓝牙的区别http://www.loverobots.cn/the-analysis-is-simple-compared-with-the-classic-bluetooth-and-bluetooth-low-energy-in-android.html 蓝牙适配建议 蓝牙低功耗 ​ Android 4.3 为发挥核心作用的蓝牙低功耗（蓝牙 LE）引入了平台支持。在 Android 5.0 中，Android 设备现在可以发挥蓝牙 LE 外围设备的作用。应用可以利用此功能让附近设备发现它。例如，您可以开发这样的应用：让设备发挥计步器或健康监测仪的作用，并与其他蓝牙 LE 设备进行数据通信。 新增的 android.bluetooth.le API 让您的应用可以发布广告、扫描响应以及与附近的蓝牙 LE 设备建立连接。要使用新增的广告和扫描功能，请在您的清单中添加 BLUETOOTH_ADMIN 权限。当用户更新您的应用或从 Play 商店下载您的应用时，会被要求向您的应用授予以下权限：“Bluetooth connection information:Allows the app to control Bluetooth, including broadcasting to or getting information about nearby Bluetooth devices.” 要启动蓝牙 LE 广播，以便其他设备能发现您的应用，请调用 startAdvertising()，并传入 AdvertiseCallback 类的实现。回调对象会收到广播操作成功或失败的报告。 Android 5.0 引入了 ScanFilter 类，让您的应用可以只扫描其感兴趣的特定类型设备。要开始扫描蓝牙 LE 设备，请调用 startScan()，并传入筛选器列表。在方法调用中，您还必须提供 ScanCallback 的实现，以便在发现蓝牙 LE 广播时进行报告。 蓝牙基本操作蓝牙权限1&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH&quot; /&gt; 如果您希望您的应用启动设备发现或操作蓝牙设置，则还必须声明 BLUETOOTH_ADMIN 权限。 大多数应用需要此权限仅仅为了能够发现本地蓝牙设备。 除非该应用是将要应用户请求修改蓝牙设置的“超级管理员”，否则不应使用此权限所授予的其他能力。 注：如果要使用 BLUETOOTH_ADMIN 权限，则还必须拥有 BLUETOOTH 权限。 如打开关闭蓝牙 1&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH_ADMIN&quot; /&gt; 6.0权限12&lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot;/&gt; 设置蓝牙 判断设备是否支持 BluetoothAdapter 12345mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();if (mBluetoothAdapter == null) &#123; // Device does not support Bluetooth&#125; 启用蓝牙 12345if (mBluetoothAdapter==null||!mBluetoothAdapter.isEnabled())&#123; Toast.makeText(this,&quot;设备不支持蓝牙权限&quot;,Toast.LENGTH_SHORT).show(); &#125;else &#123; Toast.makeText(this,&quot;支持设备&quot;,Toast.LENGTH_SHORT).show(); &#125; 查找设备5.0以下的方式就不贴出来了，代码里有 123456789101112131415161718192021222324252627282930313233/** * android5.0以上使用 */ @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP) private void scanDevices()&#123; BluetoothLeScanner mBluetoothScanner = mBluetoothAdapter.getBluetoothLeScanner(); mBluetoothScanner.startScan(scanCallback); &#125; ScanCallback scanCallback = new ScanCallback() &#123; @Override public void onScanResult(int callbackType, ScanResult result) &#123; super.onScanResult(callbackType, result); //把byte数组转成16进制字符串，方便查看 Log.e(TAG,&quot;onScanResult :&quot;+result.getScanRecord().toString()); BluetoothDevice device = result.getDevice(); blueAdapter.addDevice(device); ScanRecord scanRecord = result.getScanRecord(); int rssi = result.getRssi(); &#125; @Override public void onBatchScanResults(List&lt;ScanResult&gt; results) &#123; super.onBatchScanResults(results); &#125; @Override public void onScanFailed(int errorCode) &#123; super.onScanFailed(errorCode); &#125; &#125;; 连接设备蓝牙设备经常处于关机状态，先调用下面方法 1BluetoothDevice remoteDevice = adapter.getRemoteDevice(address); 123remoteDevice.connectGatt(context, true, mGattCallback);//参数1：上下文。 //参数2：是否自动连接（当设备可以用时） //参数3：连接回调。 https://www.cnblogs.com/Free-Thinker/p/11507349.html 6、关于autoConnect参数为true的意义？ 在蓝牙核心文档Vol3: Core System Package[Host volume]-&gt;Part C: Generic Access Profile的Connection Modes and Procedures章节中有涉及到自动连接建立规程(Auto Connection Establishment Procedure)的定义。 自动连接建立规程用来向多个设备同时发起连接。一个中央设备的主机与多个外围设备绑定，只要它们开始广播，便立刻与其建立连接。跟多细节请参考蓝牙核心文档和协议栈源码。 回调 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455private BluetoothGattCallback mGattCallback = new BluetoothGattCallback() &#123; /** * Callback indicating when GATT client has connected/disconnected to/from a remote GATT server * @param gatt 返回连接建立的gatt对象 * @param status 返回的是此次gatt操作的结果，成功了返回0 * @param newState 每次client连接或断开连接状态变化，STATE_CONNECTED 0，STATE_CONNECTING 1,STATE_DISCONNECTED 2,STATE_DISCONNECTING 3 */ @Override public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) &#123; super.onConnectionStateChange(gatt, status, newState); if (newState == BluetoothProfile.STATE_CONNECTED) &#123; gatt.discoverServices(); //连接成功， 开始搜索服务 Log.i(TAG, &quot;onConnectionStateChange 连接成功&quot; + status); &#125; &#125; /** * Callback invoked when the list of remote services, characteristics and descriptors for the remote device have been updated, ie new services have been discovered. * @param gatt 返回的是本次连接的gatt对象 * @param status */ @Override public void onServicesDiscovered(BluetoothGatt gatt, int status) &#123; super.onServicesDiscovered(gatt, status); Log.i(TAG, &quot;onServicesDiscovered status&quot; + status); List&lt;BluetoothGattService&gt; mServiceList = gatt.getServices(); for (BluetoothGattService service : mServiceList) &#123; Log.i(TAG, &quot;onServicesDiscovered &quot; + service.getUuid()); &#125; BluetoothGattService service = gatt.getService(UUID.fromString(GATT_SERVICE_PRIMARY_1)); BluetoothGattCharacteristic characterisetic = service.getCharacteristic(UUID.fromString(CHARACTERISTIC_NOTIFY_1)); //调用以便当命令发送后返回信息可以自动返回 BluetoothGattDescriptor descriptor = characterisetic.getDescriptor(CCC); descriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE); gatt.writeDescriptor(descriptor); boolean isNotify = gatt.setCharacteristicNotification(characterisetic, true); &#125; //回调响应特征写操作的结果。 @Override public void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) &#123; Log.i(TAG, gatt.getDevice().getName() + &quot; write successfully&quot;); &#125; //回调响应特征读操作的结果。 @Override public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) &#123; Log.i(TAG, gatt.getDevice().getName() + &quot; recieved &quot;); &#125; @Override public void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) &#123; super.onCharacteristicChanged(gatt, characteristic); Log.i(TAG, &quot;The response is &quot; + &quot;onCharacteristicChanged&quot;); &#125;&#125;; Android 中 GATT 操作的流程 Android 中 GATT 操作的流程。右边这个图，APP 是我们的应用，右边蓝牙服务端，从左向右箭头是 APP 发起的请求，从右向左的箭头是回调。我们看到所有的操作都是异步的完成的。连接过程是，首先使用 gattConnect 发起连接，收到 onConnectionStateChange() 通知连接是否成功，若成功，则进行下一步的 discoverService()，这一步就是发现设备所有的 GATT Service，若发现成功，通过 onServiceDiscovered() 回调，这时才算真正的连接成功。然后可以通过 BluetoothGatt 的 getService() 来获得BluetoothGattService，进而获得BluetoothGattCharacteristic 等，然后对 Characteristic 进行读写。 office https://developer.android.com/guide/topics/connectivity/bluetooth?hl=zh-cn https://developer.android.com/guide/topics/connectivity/bluetooth-le?hl=zh-cn 官方demo android5.0已过时 https://source.android.google.cn/devices/bluetooth/ un https://juejin.im/entry/5919630444d904006c6e14ca https://www.jianshu.com/p/29a730795294 https://www.jianshu.com/p/046c1f5a7163 设备通知手机5 当你从文档看到遍历出来的UUID有接送通知的功能。这时你就可以设置可以接收通知。通过拿到对应通知UUID的BluetoothGattCharacteristic，调用setCharacteristicNotification().其中00002902-0000-1000-8000-00805f9b34fb是系统提供接受通知自带的UUID，通过设置BluetoothGattDescriptor相当于设置BluetoothGattCharacteristic的Descriptor属性来实现通知，这样只要蓝牙设备发送通知信号，就会回调onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) 方法，这你就可以在这方法做相应的逻辑处理。 https://juejin.im/entry/58c74fc42f301e006bce23fb 经典蓝牙开发https://www.jianshu.com/p/453a5cda5646 设置 00002902-0000-1000-8000-00805f9b34fb 123456789101112131415161718/* 设置特征信息推送 */··· BluetoothGattCharacteristic characteristic; mGatt.setCharacteristicNotification(characteristic,true);/* CCCD 的UUID */private UUID ID_CCCD = UUID.fromString(&quot;00002902-0000-1000-8000-00805f9b34fb&quot;); /* 获取CCCD */BluetoothGattDescriptor cccd = characteristic.getDescriptor(ID_CCCD);/* 设置推送通知，参考值为： * BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE: 通知 * BluetoothGattDescriptor.ENABLE_INDICATION_VALUE: 指示 * BluetoothGattDescriptor.DISABLE_NOTIFICATION_VALUE: 关闭 */ cccd.setValue(参考值);/* 写入CCCD */mGatt.writeDescriptor(descriptor) https://www.jianshu.com/p/43b1956d9f5c 官方三个蓝牙示例 :https://github.com/googlesamples?utf8=%E2%9C%93&amp;q=bluetooth&amp;type=&amp;language= 问题扫描不到任何设备 https://stackoverflow.com/questions/39646253/android-stops-finding-ble-devices-onclientregistered-status-133-clientif-0","categories":[{"name":"BLE","slug":"BLE","permalink":"http://noteforme.github.io.com/categories/BLE/"}],"tags":[],"keywords":[{"name":"BLE","slug":"BLE","permalink":"http://noteforme.github.io.com/categories/BLE/"}]},{"title":"DesignPatterns_Observer","slug":"DesignPatterns_Observer","date":"2018-06-06T08:09:58.000Z","updated":"2021-08-19T11:11:43.802Z","comments":true,"path":"2018/06/06/DesignPatterns_Observer/","link":"","permalink":"http://noteforme.github.io.com/2018/06/06/DesignPatterns_Observer/","excerpt":"","text":"原理图 ​ 奶站\\天气站 用户 Observer观察者模式/订阅模式 PUSH 模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//主题对象变化，通知所有的观察者//抽象观察者public interface Observer&#123; public void update(String str);&#125;//具体观察者public class ConcreteObserver implements Observer&#123; @Override public void update(String str) &#123; // TODO Auto-generated method stub System.out.println(str); &#125;&#125;//抽象主题public interface Subject&#123; public void addObserver(Observer observer); public void removeObserver(Observer observer); public void notifyObservers(String str);&#125;//具体主题public class ConcreteSubject implements Subject&#123; // 存放观察者 private List&lt;Observer&gt; list = new ArrayList&lt;Observer&gt;(); //注册观察者 @Override public void addObserver(Observer observer) &#123; // TODO Auto-generated method stub list.add(observer); &#125; //移除观察者 @Override public void removeObserver(Observer observer) &#123; // TODO Auto-generated method stub list.remove(observer); &#125; // 遍历所有观察者，并通知 @Override public void notifyObservers(String str) &#123; // TODO Auto-generated method stub for(Observer observer:list)&#123; observer.update(str); &#125; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; //一个主题 ConcreteSubject eatSubject = new ConcreteSubject(); //两个观察者 ConcreteObserver p1 = new ConcreteObserver(); ConcreteObserver p2 = new ConcreteObserver(); //观察者订阅主题 eatSubject.addObserver(p1); eatSubject.addObserver(p2); eatSubject.notifyOBservers(&quot;起来敲代码啦！！！&quot;); &#125;&#125; https://juejin.im/post/5bc96afff265da0aa94a4493 https://www.tutorialspoint.com/design_pattern/bridge_pattern.htm PULL模式 而拉模型是主题对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传递给观察者，让观察者自己去按需要取值。 https://www.bilibili.com/video/BV1W4411c77E?p=120","categories":[{"name":"DesignPatterns","slug":"DesignPatterns","permalink":"http://noteforme.github.io.com/categories/DesignPatterns/"}],"tags":[],"keywords":[{"name":"DesignPatterns","slug":"DesignPatterns","permalink":"http://noteforme.github.io.com/categories/DesignPatterns/"}]},{"title":"Singleton","slug":"DesignPatterns_Singleton","date":"2018-06-06T07:43:06.000Z","updated":"2021-08-19T11:11:43.802Z","comments":true,"path":"2018/06/06/DesignPatterns_Singleton/","link":"","permalink":"http://noteforme.github.io.com/2018/06/06/DesignPatterns_Singleton/","excerpt":"","text":"单例模式 作用：一个类只有一个实例，减少内存开销 kotlin12345678910class Singleton private constructor() &#123; private object HOLDER &#123; val INSTANCE = Singleton() &#125; companion object &#123; val instance: Singleton by lazy &#123; HOLDER.INSTANCE &#125; &#125;&#125; https://medium.com/swlh/singleton-class-in-kotlin-c3398e7fd76b 常用方式 1234567891011121314151617public class Singleton&#123; // 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 private static Singleton singleton=null; //私有构造方法，防止被实例化 private Singleton()&#123;&#125; public static Singleton getInstance()&#123; if(singleton==null)&#123; //多个线程在这里聚集就会产生多个对象 synonzied(Singleton.class)&#123; Thread.sleel(1) singleton = new Singleton(); &#125; &#125; return singleton; &#125; &#125; 123456789101112131415public class Singleton&#123; // 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 private static Singleton singleton=null; //私有构造方法，防止被实例化 private Singleton()&#123;&#125; public static Singleton getInstance()&#123; //这里加锁 粒度有问题 synonzied(Singleton.class)&#123; //这样会产生效率问题，多个线程在这空转等待获得锁 if(singleton==null)&#123; Thread.sleel(1) singleton = new Singleton(); &#125; &#125; return singleton; &#125; &#125; 源码有类似的 InputMethodManager，当然我们常用的方式是要传个Context上下文对象给单例类，记得有次面试的时候面试官说单例里面使用弱引用，如果是是为了避免内存泄漏我觉得是可以的，但是我觉得用这种方式更好 Context applicationContext = context.getApplicationContext(); 刚无意中发现Glide单例也是这样使用的。 双重检查模式123456789101112131415public class Singleton &#123; private volatile static Singleton singleton; //volatile 防止指令重排序,指令半初始化，CPU执行指令顺序可能不同 private Singleton ()&#123; &#125; public static Singleton getInstance() &#123; if (singleton== null) &#123; synchronized (Singleton.class) &#123; if (singleton== null) &#123; instance= new Singleton(); &#125; &#125; &#125; return singleton; &#125; &#125; 第1个if (singleton==null)如果去掉它，那么所有线程都会串行执行，效率低下，这样会产生效率问题，多个线程在这空转等待获得锁，所以两个 check 都是需要保留的。 第2个if (singleton==null)假如两个线程同时调用 getInstance() ,由于instance是空的，两个线程都通过第1个if (singleton null),接着锁机制存在，线程1先进入同步语句，并进入第二重if判断,线程2在外面等待. 线程1执行完 new Singleton()后退出synchronized,这时候如果没有 第2个if (singleton== null) 线程2也会创建一个实例，此时就破坏了单例原则. volatile作用防止 new Singleton()重排序 在 JVM 中上述语句至少做了以下这 3 件事 第一步是给 singleton 分配内存空间； 然后第二步开始调用 Singleton 的构造函数等，来初始化 singleton； 最后第三步，将 singleton 对象指向分配的内存空间（执行完这步 singleton 就不是 null 了）。 因为存在指令重排序的优化，也就是说第2 步和第 3 步的顺序是不能保证的，最终的执行顺序，可能是 1-2-3，也有可能是 1-3-2。 如果是 1-3-2，那么在第 3 步执行完以后，singleton 就不是 null 了，可是这时第 2 步并没有执行，singleton 对象未完成初始化，它的属性的值可能不是我们所预期的值。假设此时线程 2 进入 getInstance 方法，由于 singleton 已经不是 null 了，所以会通过第一重if (singleton==null) 检查并直接返回，但其实这时的 singleton 并没有完成初始化，所以使用这个实例的时候会报错. Enum方式和公有域方法在功能上相近，但是更简洁，无偿提供了序列化机制，绝对的防止多次实例化，可以面对复杂的序列化或者反射攻击，虽然没有广泛采用，但是 单元素的枚举类型已经成为实现 Singleton的最佳方法. 1234567891011121314151617public class Elvis_03 &#123; public static void main(String[] args) &#123; Elvis.INSTANCE.leaveTheBuilding(); &#125;&#125;/** * 这种方法太NB了, * Effective Java pag15 */enum Elvis &#123; INSTANCE; public void leaveTheBuilding() &#123; &#125;&#125; 嵌套类1234567891011public class Singleton3 &#123; private Singleton3() &#123;&#125; // 主要是使用了 嵌套类可以访问外部类的静态属性和静态方法 的特性 private static class Holder &#123; private static Singleton3 instance = new Singleton3(); &#125; public static Singleton3 getInstance() &#123; return Holder.instance; &#125;&#125; https://juejin.im/post/5bc96afff265da0aa94a4493","categories":[{"name":"DesignPatterns","slug":"DesignPatterns","permalink":"http://noteforme.github.io.com/categories/DesignPatterns/"}],"tags":[],"keywords":[{"name":"DesignPatterns","slug":"DesignPatterns","permalink":"http://noteforme.github.io.com/categories/DesignPatterns/"}]},{"title":"HashMap","slug":"HashMap","date":"2018-05-31T14:54:44.000Z","updated":"2021-08-19T11:11:43.912Z","comments":true,"path":"2018/05/31/HashMap/","link":"","permalink":"http://noteforme.github.io.com/2018/05/31/HashMap/","excerpt":"","text":"HashMapHash函数是指把⼀个⼤范围映射到⼀个⼩范围。把⼤范围映射到⼀个⼩范围的⽬的往往是为了 节省空间，使得数据容易保存。 HashMap扩容机制12345 int threshold; // 所能容纳的key-value对极限 final float loadFactor; // 负载因子 int modCount; int size; new HashMap&lt;Integer,String&gt;(2,0.75f) Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。 map初始化为一个长度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当put第二个key的时候，map就需要进行resize。 https://tech.meituan.com/2016/06/24/java-hashmap.html HashMap和HashTable的区别 HashTable是线程安全的 HashTable key不能为空，HashMap可以.存在数组为0的位置 HashMap的实现原理 HashMap数据结构？ JDK1.7 Table数组+ Entry链表 JDK1.8 Table数组+ Entry链表/红黑树（ 为什么用红黑树） 红黑树有自平衡的特点，可以防止不平衡情况的发生，所以可以始终将查找的时间复杂度控制在 O(log(n)) ​ HashMap采用Entry数组存放key-value,每个 key value组成一个实体，Entry类实际上是一个单向的链表结构，它有next指针指向下一 个实体， 1.8中链表大于8时会转成红黑树.长度降到 6 就转换回去. ​ HashMap源码理解 HashMap如何put数据（从HashMap源码角度讲解）？ 对key的Dashcode()做hash运算，计算index. 如果没碰撞直接放到bucket⾥ 如果碰撞了，以链表的形式存在buckets后 如果节点已经存在就替换old value(保证key的唯⼀性) 如果bucket满了(超过load factor*current capacity)，就要resize get数据 对key的hashCode()做hash运算，计算index; 如果在bucket⾥的第⼀个节点⾥直接命中，则直接返回； 如果有冲突，则通过key.equals(k)去查找对应的Entry;分为下面两种方式. 若为树，则在树中通过key.equals(k)查找，O(logn)； 若为链表，则在链表中通过key.equals(k)查找，O(n)。 HashMap怎么手写实现？ https://www.jianshu.com/p/985534b21089 HashTable实现原理 ConcurrentHashMap的实现原理 HashTable ConcurrentHashMap 区别Hashtable的实现是基于Dictionary抽象类的。Java5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。 https://www.bilibili.com/video/BV1kJ411C7hC?p=9&amp;spm_id_from=pageDriver TreeMap具体实现TreeMap是一个有序的key-value集合，是非线程安全的，基于红黑树（Red-Black tree）实现。其映射根据键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。其基本操作 containsKey、get、put 和 remove 的时间复杂度是 log(n) 。TreeMap是非同步的。 它的iterator 方法返回的迭代器是fail-fastl的。 https://www.cnblogs.com/nananana/p/10426377.html HashMap与HashSet的区别 基于 HashMap 实现的，底层采用 HashMap 来保存元素 HashSet实现了Set接口，它不允许集合中有重复的值 HashSet与HashMap怎么判断集合元素重复？ l nn为什么不一开始就使用红黑树因为红⿊树需要进⾏左旋，右旋，变⾊这些操作来保持平衡，⽽单链表不需要。当元素⼩于8个当时候，此时做查询操作，链表结构已经能保证查询性能。当元素⼤于8个的时候，此时需要红⿊树来加快查 询速度，但是新增节点的效率变慢了。因此，如果⼀开始就⽤红⿊树结构，元素太少，新增效率⼜⽐较慢，⽆疑这是浪费性能的。 什么时候退化为链表为6的时候退转为链表。中间有个差值7可以防⽌链表和树之间频繁的转换。假设⼀下，如果设计成链表个数超过8则链表转 换成树结构，链表个数⼩于8则树结构转换成链表，如果⼀个HashMap不停的插⼊、删除元素，链表个数在8左右徘徊，就会 频繁的发⽣树转链表、链表转树，效率会很低。 https://www.youtube.com/watch?v=jwL1W8zEuX4 https://www.bilibili.com/video/BV1if4y167eE?p=4 https://zhuanlan.zhihu.com/p/127147909 https://zhuanlan.zhihu.com/p/348756860 ArrayMapArrayMap类有两个非常重要的静态成员变量mBaseCache和mTwiceBaseCacheSize，用于ArrayMap所在进程的全局缓存功能： http://gityuan.com/2019/01/13/arraymap/ https://www.youtube.com/watch?v=I16lz26WyzQ SparseArray key是int类型的Map，Android再次提供效率更高的数据结构SparseArray，可避免自动装箱过程,SparseArray不需要保存key所对应的哈希值，所以比ArrayMap还能再节省1/3的内存。 SparseArray构造mKeys mValues两个数组，默认长度10，也可以自己定义initialCapacity 12345678910public SparseArray(int initialCapacity) &#123; if (initialCapacity == 0) &#123; mKeys = EmptyArray.INT; mValues = EmptyArray.OBJECT; &#125; else &#123; mValues = ArrayUtils.newUnpaddedObjectArray(initialCapacity); mKeys = new int[mValues.length]; &#125; mSize = 0; &#125; 12345678910111213141516171819202122232425262728public void put(int key, E value) &#123; // 二分查找,key在mKeys列表中对应的index,注意binarySearch返回做了 ~操作. //如果没找到，返回的是当前元素将要插入的位置 int i = ContainerHelpers.binarySearch(mKeys, mSize, key); if (i &gt;= 0) &#123; mValues[i] = value; //找到后给对应的value数组赋值 &#125; else &#123; i = ~i; if (i &lt; mSize &amp;&amp; mValues[i] == DELETED) &#123; mKeys[i] = key; mValues[i] = value; return; &#125; if (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123; gc(); // Search again because indices may have changed. i = ~ContainerHelpers.binarySearch(mKeys, mSize, key); &#125; //插入数据，内部做了排序 mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key); mValues = GrowingArrayUtils.insert(mValues, mSize, i, value); mSize++; &#125;&#125; 123456789public void delete(int key) &#123; int i = ContainerHelpers.binarySearch(mKeys, mSize, key); if (i &gt;= 0) &#123; if (mValues[i] != DELETED) &#123; mValues[i] = DELETED; //标记该数据为DELETE mGarbage = true; // 设置存在GC &#125; &#125;&#125; https://blog.csdn.net/zxt0601/article/details/78333328 http://www.jcodecraeer.com/a/anzhuokaifa/2017/0912/8504.html","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}],"tags":[],"keywords":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}]},{"title":"INTERVIEW-JAVA","slug":"INTERVIEW-JAVA","date":"2018-05-24T14:31:57.000Z","updated":"2021-08-19T11:11:43.980Z","comments":true,"path":"2018/05/24/INTERVIEW-JAVA/","link":"","permalink":"http://noteforme.github.io.com/2018/05/24/INTERVIEW-JAVA/","excerpt":"","text":"https://interview-q-a-1gdnkgkla15afdbe-1258598664.tcloudbaseapp.com/Java/HashMap%E5%8E%9F%E7%90%86-%E7%BE%8E%E5%9B%A2.html 面试题含答案 java基础面试知识点java中==和equals和hashCode的区别类型 基本类型：比较的是值是否相同； 引用类型：如果是 类、接口、数组的话,当他们用双等号（==）进行比较的时候，比较的是他们的引用，如果要比较堆中对象是否相同，那么就要重写equals方法了； 默认情况下（没有覆写equals方法）的equals方法都是调用Object类的equals方法，而Object的equals方法主要是用于判断对象的内存地址引用是不是同一个地址（是不是同一个对象）。 int、char、long各占多少字节数 byte 1字节 short 2字节 int 4字节 long 8字节 char 2字节 float 4字节 double 8字节 boolean false/true(理论上占用1bit,1/8字节，实际处理按1byte处理) int与integer的区别​ Integer 是int的包装类；int是基本数据类型; ​ Integer实际是对象的引用，int是直接存储数据值 谈谈对java多态(polymorphism)的理解,Java中实现多态的机制是什么 实现的机制是，父类或者接口定义的引用变量指向子类或者子类的实现， 执行期间判断所引用对象的实际类型，根据其实际的类型调用相应的方法。 编译时多态(静态多态)==重载 运行时多态（动态多态） 无论哪种方法，核心之处在对父类方法的改写或对接口方法的实现，以取得运行时不同的执行效果. https://docs.oracle.com/javase/tutorial/java/IandI/polymorphism.html https://cloud.tencent.com/developer/article/1447574 String、StringBuffer、StringBuilder区别 都是fianl类，不能被继承,底层都是 char[] value实现 String类长度是不可变的，substring()、 concat(),最终实现都是通过 new String(buf, true)实现的,StringBuffer,StringBuilder是通过操作本类的value实现的 StringBuffer类是线程安全的，StringBuilder不是线程安全的 String：字符串常量。 ​ 什么是内部类？内部类的作用​ 内部类: 一个类定义在另一个类的内部，就叫内部类 ​ 作用: 内部类 拥有外部类的所有访问权限，包括被private修饰的私有数据 内部类可以很好的隐藏实现 内部类可以实现多重继承 1234567891011121314151617181920212223242526272829303132333435363738394041//类一public class ClassA &#123; public String name()&#123; return &quot;liutao&quot;; &#125; public String doSomeThing()&#123; // doSomeThing &#125;&#125;//类二public class ClassB &#123; public int age()&#123; return 25; &#125;&#125;//类三public class MainExample&#123; private class Test1 extends ClassA&#123; public String name()&#123; return super.name(); &#125; &#125; private class Test2 extends ClassB&#123; public int age()&#123; return super.age(); &#125; &#125; public String name()&#123; return new Test1().name(); &#125; public int age()&#123; return new Test2().age(); &#125; public static void main(String args[])&#123; MainExample mi=new MainExample(); System.out.println(&quot;姓名:&quot;+mi.name()); System.out.println(&quot;年龄:&quot;+mi.age()); &#125;&#125; MainExample 类通过内部类拥有了 ClassA 和 ClassB 的两个类的继承关系。 而无需关注 ClassA 中的 doSomeThing 方法的实现。这就是比接口实现更有戏的地方 https://juejin.cn/post/6844903566293860366 抽象类和接口区别 Abstract class Interface 1) Abstract class can have abstract and non-abstract methods. Interface can have only abstract methods. Since Java 8, it can have default and static methods also. 2) Abstract class doesn’t support multiple inheritance. Interface supports multiple inheritance. 3) Abstract class can have final, non-final, static and non-static variables. Interface has only static and final variables. 4) Abstract class can provide the implementation of interface. Interface can’t provide the implementation of abstract class. 5) The abstract keyword is used to declare abstract class. The interface keyword is used to declare interface. 6) An abstract class can extend another Java class and implement multiple Java interfaces. An interface can extend another Java interface only. 7) An abstract class can be extended using keyword “extends”. An interface can be implemented using keyword “implements”. 8) A Java abstract class can have class members like private, protected, etc. Members of a Java interface are public by default. 9)Example: public abstract class Shape{ public abstract void draw(); } Example: public interface Drawable{ void draw(); } https://www.javatpoint.com/difference-between-abstract-class-and-interface ? 泛型中extends和super的区别 上界&lt;? extends T&gt;不能往里存，只能往外取，适合频繁往外面读取内容的场景。 下界&lt;? super T&gt;不影响往里存，但往外取只能放在Object对象里，适合经常往里面插入数据的场景 https://noteforme.github.io/2018/04/16/Generics/ string 转换成 integer的方式及原理 判断是否null或”” 判断第一位正负数，逐位获取值 ? https://blog.csdn.net/nobody_1/article/details/91488686 静态内部类的设计意图​ 非静态内部类编译后会隐含的保存着一个引用，改引用指向创建它的外围类，静态内部类没有， ​ 它不能使用任何外围类的非static成员变量和方法. final，finally，finalize的区别 Final : 用于申明属性，方法，类，表示属性不可变，方法不可以覆盖，类不能继承 final数组 Java 中数组也是对象 12345final int arr[] = &#123;1, 2, 3, 4, 5&#125;; // 注意，数组 arr 是 final 的 for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = arr[i]*10; System.out.println(arr[i]); &#125; 数组是对象的一种，现在数组是被 final 修饰的，所以它的意思是一旦被赋值之后，变量的引用不能修改。但是我们现在想证明的是，数组对象里面的内容可以修改 非数组对象 12345678class Test &#123; int p = 20; public static void main(String args[])&#123; final Test t = new Test(); t.p = 30; System.out.println(t.p); &#125;&#125; 把它用 final 修饰，然后去尝试改它里面成员变量 p 的值，并打印出结果，程序会打印出“30”。一开始 p 的值是 20，但是最后修改完毕变成了 30，说明这次修改是成功的。 以上我们就得出了一个结论，final 修饰一个指向对象的变量的时候，对象本身的内容依然是可以变化的。 https://kaiwu.lagou.com/course/courseInfo.htm?courseId=16#/detail/pc?id=311 Finally: 异常语句处理机构中，与try{}进行配合使用，不论try中的代码是否执行完，表示总是执行的部分 Finalize: Object类的一个方法，用于对象”消失”时，由JVM进行调用用于对对象进行垃圾回收，释放对象占用的资源. Serializable 和Parcelable 的区别，如何将一个Java对象序列化到文件里？ 两者最大的区别在于 存储媒介的不同，Serializable 使用 I/O 读写存储在硬盘上，而 Parcelable 是直接 在内存中读写。很明显，内存的读写速度通常大于 IO 读写，所以在 Android 中传递数据优先选择 Parcelable。 Serializable 会使用反射，序列化和反序列化过程需要大量 I/O 操作，也会创建很多临时对象， Parcelable 自已实现封送和解封（marshalled &amp;unmarshalled）操作不需要用反射，数据也存放在 Native 内存中，效率要快很多。 https://juejin.cn/post/6844903518826921991 父类的静态方法能否被子类重写 不能，静态方法只和类有关,JVM加载后先初始化static相关属性方法,重写依赖于类的实例. 成员内部类、局部内部类以及项目中的应用成员内部类 : 普通的内部类，不存在任何static的变量和方法； 局部内部类： 嵌套于方法和作用域内 12345678910111213141516171819public class Parcel5 &#123; public Destionation destionation(String str)&#123; class PDestionation implements Destionation&#123; private String label; private PDestionation(String whereTo)&#123; label = whereTo; &#125; public String readLabel()&#123; return label; &#125; &#125; return new PDestionation(str); &#125; public static void main(String[] args) &#123; Parcel5 parcel5 = new Parcel5(); Destionation d = parcel5.destionation(&quot;chenssy&quot;); &#125;&#125; 闭包和局部内部类的区别 Java中对象的生命周期​ 1、创建阶段(Created) 检测类是否被加载没有加载的先加载→为新生对象分配内存→将分配到的内存空间都初始化为零值→对对象进行必要的设置→执行&lt;init&gt;方法把对象进行初始化 对象的加载大小是类加载中就已经确定好了的，类加载过程就相当复杂了，如下图： 类加载过程.png 2、应用阶段(In Use) 至少有一个强引用使用着 3、不可见阶段(Invisible) 程序的执行已经超出了该对象的作用域了 4、不可达阶段(Unreachable) 程序不再持有该对象的任何强引用，这种情况下，该对象仍可能被JVM等系统下的某些已装载的静态变量或线程或JNI等强引用持有着，这些特殊的强引用被称为”GC root” 5、收集阶段(Collected) 垃圾回收器发现该对象已经处于“不可达阶段”并且垃圾回收器已经对该对象的内存空间重新分配做好准备时，则对象进入了“收集阶段”。如果该对象已经重写了finalize()方法，则会去执行该方法的终端操作。 6、终结阶段(Finalized) 当对象执行完finalize()方法后仍然处于不可达状态时，则该对象进入终结阶段。在该阶段是等待垃圾回收器对该对象空间进行回收。 7、对象空间重分配阶段(De-allocated) 垃圾回收器对该对象的所占用的内存空间进行回收或者再分配了，则该对象彻底消失了，称之为“对象空间重新分配阶段”。 链接：https://www.jianshu.com/p/72f5017c6649 JVMString特性Java虚拟机在内存中开辟出一块单独的区域 https://zhuanlan.zhihu.com/p/60643031 https://www.bilibili.com/video/BV1PJ411n7xZ?p=118 几个视频讲到用法，最好能用图画出来 https://www.iteye.com/blog/rednaxelafx-774673 哪些情况下的对象会被垃圾回收机制处理掉？ 可达性分析,GC Root向下搜索，产生一个reference chain 。当一个对象不能和任何GC Root产生关系时就被回收. 强引用 ：那垃圾回收器绝不会回收 软引用: 内存溢出时候对象回收 弱引用:下一次GC时候对象回收 虚引用：随时可能被回收 当前商业虚拟机的垃圾回收都采用分代收集算法，这种算法并没有什么新的思想，只是根据对象的存活周期将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾回收都有大批对象死去，只有少量存活，那就选用复制算法，只要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高，没有额外的空间对它进行分配担保，那就使用标记清理或者标记整理算法来进行回收。 https://noteforme.github.io/2021/01/05/JVM-GC/ https://noteforme.github.io/2020/04/18/JVM/ String为什么要设计成不可变的？ 便于实现字符串池 由于会大量的使用String常量，如果每一次声明一个String都创建一个String对象，那将会造成极大的空间资源的浪费。Java提出了String pool的概念，在堆中开辟一块存储空间String pool，当初始化一个String变量时，如果该字符串已经存在了，就不会去创建一个新的字符串变量，而是会返回已经存在了的字符串的引用。 如果字符串是可变的，某一个字符串变量改变了其值，那么其指向的变量的值也会改变，String pool将不能够实现！ https://www.cnblogs.com/wkfvawl/p/11693260.html java深入源码级的面试题讲一下常见编码方式？ ASCII码: 用一个字节的低7位表示，总共128个,031 是控制字符如换行回车删除等；32126 是打印字符，可以通过键盘输入并且能够显示出来 UTF-16: 固定两个字节表示一个字符：说到 UTF 必须要提到 Unicode（Universal Code 统一码），ISO 试图想创建一个全新的超语言字典，世界上所有的语言都可以通过这本字典来相互翻译。可想而知这个字典是多么的复杂，关于 Unicode 的详细规范可以参考相应文档。Unicode 是 Java 和 XML 的基础，下面详细介绍 Unicode 在计算机中的存储形式。UTF-16 具体定义了 Unicode 字符在计算机中存取方法。UTF-16 用两个字节来表示 Unicode 转化格式，这个是定长的表示方法，不论什么字符都可以用两个字节表示，两个字节是 16 个 bit，所以叫 UTF-16。UTF-16 表示字符非常方便，每两个字节表示一个字符，这个在字符串操作时就大大简化了操作，这也是 Java 以 UTF-16 作为内存的字符存储格式的一个很重要的原因。 UTF-8: 优化UTF-16,UTF-16 统一采用两个字节表示一个字符，虽然在表示上非常简单方便，但是也有其缺点，有很大一部分字符用一个字节就可以表示的现在要两个字节表示，存储空间放大了一倍，在现在的网络带宽还非常有限的今天，这样会增大网络传输的流量，而且也没必要。而 UTF-8 采用了一种变长技术，每个编码区域有不同的字码长度。不同类型的字符可以是由 1~6 个字节组成。UTF-8 有以下编码规则：如果一个字节，最高位（第 8 位）为 0，表示这是一个 ASCII 字符（00 - 7F）。可见，所有 ASCII 编码已经是 UTF-8 了。如果一个字节，以 11 开头，连续的 1 的个数暗示这个字符的字节数，例如：110xxxxx 代表它是双字节 UTF-8 字符的首字节。如果一个字节，以 10 开始，表示它不是首字节，需要向前查找才能得到当前字符的首字节 GBK 、ISO-8859-1、GB2312 https://www.cnblogs.com/mlan/p/7823375.html https://www.cnblogs.com/mlan/p/7823375.html utf-8编码中的中文占几个字节；int型几个字节？​ 少数是汉字每个占用3个字节，多数占用4个字节。 ​ https://blog.csdn.net/hellokatewj/article/details/24325653 ​ int类型 4个字节 静态代理和动态代理的区别，什么场景使用？​ 静态代理 : 编译的时候就已经存在， ​ 动态代理 ： 通过反射机制生成的代理对象 ​ https://noteforme.github.io/2021/01/14/DesignPattern-Proxy/ ​ https://www.jianshu.com/p/2f518a4a4c2b Java的异常体系非运行时异常 :编译期间可以检查到的异常, 像IoException,DataFormatException,CertificateException 运行时异常 : NullPointerException, ClassCastException,IndexOutOfBoundsException ? 谈谈你对解析与分派的认识。说说你对Java反射的理解​ 对于任何一个类都可以通过反射知道的它的属性和方法。 说说你对Java注解的理解​ 注解，对代码进行注明。使得程序在编译或者运行时，读取到注解并加以处理，以间接的改变程序的运行。 为什么Java里的匿名内部类只能访问final修饰的外部变量？​ 因为匿名内部类最终会被编译成一个单独的类，而被该类使用的变量会以构造函数参数的形式传递给该类。如果变量不定义为final的，参数在匿名内部类中可以被修改，进而造成和外部的变量不一致的问题，为了避免这种不一致的情况，规定匿名内部类只能访问final修饰的外部变量。 说说你对依赖注入的理解?​ 给予调用方它所需要的对象 泛型说一下泛型原理，并举例说明​ 泛型实现了参数化类型的概念，使代码可以应用于多种类型。 ​ 在泛型代码内部，无法获得任何有关泛型参数类型的信息。 容器常用数据结构简介数组 栈 队列 链表 图 树 哈希表 并发集合了解哪些？ConcurrentHashMap CopyOnWriteArrayList CopyOnWriteArraySet ArrayBlockingQueue LinkedBlockingQueue https://blog.csdn.net/u010942020/article/details/73610121 列举java的集合以及集合之间的继承关系 List,Set,Map的区别容器类介绍以及之间的区别（容器类估计很多人没听这个词，Java容器主要可以划分为4个部分：List列表、Set集合、Map映射、工具类（Iterator迭代器、Enumeration枚举类、Arrays和Collections），具体的可以看看这篇博文 Java容器类） List是一个有序的队列，每一个元素都有它的索引。Set是一个不允许有重复元素的集合。 Map是一个映射接口，即key-value键值对。 List和Map的实现方式以及存储方式 list ArrayList 查询快 . LinkedList 插入删除快 修改对象A的equals方法的签名，那么使用HashMap存放这个对象实例的时候，会调用哪个equals方法？ 集合Set实现Hash怎么防止碰撞1，如果hash码值不相同，说明是一个新元素，存储； 如果没有元素和传入对象（也就是add的元素）的hash值相等，那么就认为这个元素在table中不存在，将其添加进table； 2.1，如果hash码值相同，且equles判断相等，说明元素已经存在，不存； 2.2，如果hash码值相同，且equles判断不相等，说明元素不存在，存； 原文链接：https://blog.csdn.net/github_37130188/article/details/96508272 ​ https://noteforme.github.io/2018/05/31/HashMap/ HashMap 对key的Dashcode()做hash运算，计算index. 如果没碰撞直接放到bucket⾥ 如果碰撞了，以链表的形式存在buckets后 如果节点已经存在就替换old value(保证key的唯⼀性) 如果bucket满了(超过load factor*current capacity)，就要resize get数据 对key的hashCode()做hash运算，计算index; 如果在bucket⾥的第⼀个节点⾥直接命中，则直接返回； 如果有冲突，则通过key.equals(k)去查找对应的Entry;分为下面两种方式. 若为树，则在树中通过key.equals(k)查找，O(logn)； 若为链表，则在链表中通过key.equals(k)查找，O(n)。 ArrayMap​ 因为其会对key从小到大排序，使用二分法查询key对应在数组中的下标。 在添加、删除、查找数据的时候都是先使用二分查找法得到相应的index，然后通过index来进行添加、查找、删除等操作。 数据量不大 空间比时间重要 需要使用Map 在Android平台，相对来说，内存容量更宝贵。而且数据量不大。所以当需要使用key是Object类型的Map时，可以考虑使用ArrayMap来替换HashMap hashmap hashtable区别堆的结构 ​ 堆分为两种：最大堆和最小堆，两者的差别在于节点的排序方式。 在最大堆中，父节点的值比每一个子节点的值都要大。在最小堆中，父节点的值比每一个子节点的值都要小。这就是所谓的“堆属性”，并且这个属性对堆中的每一个节点都成立。https://www.jianshu.com/p/6b526aa481b1 堆和树的区别​ 左子节点必须比父节点小，右子节点必须必比父节点大。但是在堆中并非如此。在最大堆中两个子节点都必须比父节点小，而在最小堆中，它们都必须比父节点大。 堆和栈在内存中的区别是什么(解答提示：可以从数据结构方面以及实际实现方面两个方面去回答)？ 什么是深拷贝和浅拷贝 浅拷贝 是一个传址,也就是把a的值赋给b的时候同时也把a的地址赋给了b，当b（a）的值改变的时候，a（b）的值同时也会改变 深拷贝 ​ 深拷贝是指，拷贝对象的具体内容，二内存地址是自主分配的，拷贝结束之后俩个对象虽然存的值是一样的，但是内存地址不一样，俩个对象页互相不影响，互不干涉 手写链表逆序代码 讲一下对树，B+树的理解 讲一下对图的理解 判断单链表成环与否？ 链表翻转（即：翻转一个单项链表） 合并多个单有序链表（假设都是递增的）","categories":[],"tags":[{"name":"inter","slug":"inter","permalink":"http://noteforme.github.io.com/tags/inter/"}],"keywords":[]},{"title":"Concurrency_Locking","slug":"Concurrency_Locking","date":"2018-05-24T14:31:57.000Z","updated":"2021-08-19T11:11:43.765Z","comments":true,"path":"2018/05/24/Concurrency_Locking/","link":"","permalink":"http://noteforme.github.io.com/2018/05/24/Concurrency_Locking/","excerpt":"","text":"锁的7大类偏向锁/轻量级锁/重量级锁； 偏向锁 ​ 如果自始至终，对于这把锁都不存在竞争，那么其实就没必要上锁，只需要打个标记就行了，这就是偏向锁的思想。 轻量级锁 ​ JVM 开发者发现在很多情况下，synchronized 中的代码是被多个线程交替执行的，而不是同时执行的，也就是说并不存在实际的 竞争，或者是只有短时间的锁竞争，用 CAS 就可以解决，这种情况下，用完全互斥的重量级锁是没必要的。 重量级锁 ​ 重量级锁是互斥锁，它是利用操作系统的同步机制实现的，所以开销相对比较大。当多个线程直接有实际竞争，且锁竞争时间长的时候，轻量级锁不能满足需求，锁就会膨胀为重量级锁。重量级锁会让其他申请却拿不到锁的线程进入阻塞状态。 锁升级 synchronized锁升级 偏向锁： markword记录这个线程ID -》如果线程争用升级为自旋锁 -》10次以后升级为重量级锁 synchronized的monitor 锁同步代码块1234567public class SynTest &#123; public void synBlock() &#123; synchronized (this) &#123; System.out.println(&quot;lagou&quot;); &#125; &#125;&#125; 反编译后的字节码 123456789101112131415161718192021public void synBlock(); descriptor: ()V flags: ACC_PUBLIC Code: stack=2, locals=3, args_size=1 0: aload_0 1: dup 2: astore_1 3: monitorenter 4: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 7: ldc #3 // String lagou 9: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 12: aload_1 13: monitorexit 14: goto 22 17: astore_2 18: aload_1 19: monitorexit 20: aload_2 21: athrow 22: return synchronized 代码块实际上多了 monitorenter 和 monitorexit 指令，标红的第3、13、19行指令分别对应的是 monitorenter 和 monitorexit.可以把执行 monitorenter 理解为加锁，执行 monitorexit 理解为释放锁，每个对象维护着一个记录着被锁次数的计数器。未被锁定的对象的该计数器为 0。 monitorenter 执行 monitorenter 的线程尝试获得 monitor 的所有权，会发生以下这三种情况之一： a. 如果该 monitor 的计数为 0，则线程获得该 monitor 并将其计数设置为 1。然后，该线程就是这个 monitor 的所有者。 b. 如果线程已经拥有了这个 monitor ，则它将重新进入，并且累加计数。 c. 如果其他线程已经拥有了这个 monitor，那个这个线程就会被阻塞，直到这个 monitor 的计数变成为 0，代表这个 monitor 已经被释放了，于是当前这个线程就会再次尝试获取这个 monitor。 monitorexitmonitorexit 的作用是将 monitor 的计数器减 1，直到减为 0 为止。代表这个 monitor 已经被释放了，已经没有任何线程拥有它了，也就代表着解锁，所以，其他正在等待这个 monitor 的线程，此时便可以再次尝试获取这个 monitor 的所有权。 从上面也可看到 synchronized是可重入锁 synchronized 方法​ 同步代码块是使用 monitorenter 和 monitorexit 指令实现的。而对于 synchronized 方法，并不是依靠 monitorenter 和 monitorexit 指令实现的，被 javap 反汇编后可以看到，synchronized 方法和普通方法大部分是一样的，不同在于，这个方法会有一个叫作 ACC_SYNCHRONIZED 的 flag 修饰符，来表明它是同步方法。 123public synchronized void method() &#123; method body&#125; 反编译后的指令 12345678910111213141516 public synchronized void synMethod(); descriptor: ()V flags: ACC_PUBLIC, ACC_SYNCHRONIZED Code: stack=0, locals=1, args_size=1 0: return LineNumberTable: line 16: 0 被 synchronized 修饰的方法会有一个 ACC_SYNCHRONIZED 标志。当某个线程要访问某个方法的时候，会首先检查方法是否有 ACC_SYNCHRONIZED 标志，如果有则需要先获得 monitor 锁，然后才能开始执行方法，方法执行之后再释放 monitor 锁。其他方面， synchronized 方法和刚才的 synchronized 代码块是很类似的，例如这时如果其他线程来请求执行方法，也会因为无法获得 monitor 锁而被阻塞。 synchronized 和 Lock选择 如果能不用最好既不使用 Lock 也不使用 synchronized。因为在许多情况下你可以使用 java.util.concurrent 包中的机制，它会为你处理所有的加锁和解锁操作，也就是推荐优先使用工具类来加解锁。 如果 synchronized 关键字适合你的程序， 那么请尽量使用它，这样可以减少编写代码的数量，减少出错的概率。因为一旦忘记在 finally 里 unlock，代码可能会出很大的问题，而使用 synchronized 更安全。 如果特别需要 Lock 的特殊功能，比如尝试获取锁、可中断、超时功能等，才使用 Lock。 Lock12345678public interface Lock &#123; void lock(); void lockInterruptibly() throws InterruptedException; boolean tryLock(); boolean tryLock(long time, TimeUnit unit) throws InterruptedException; void unlock(); Condition newCondition();&#125; lock() lock() 是最基础的获取锁的方法,获取锁和释放锁都是显式的，不像 synchronized 那样是隐式的，所以 Lock 不会像 synchronized 一样在异常时自动释放锁（synchronized 即使不写对应的代码也可以释放）,使用 lock() 时必须由我们自己主动去释放锁，因此最佳实践是执行 lock() 后，首先在 try{} 中操作同步资源，如果有必要就用 catch{} 块捕获异常，然后在 finally{} 中释放锁，以保证发生异常时锁一定被释放. 12345678Lock lock = ...;lock.lock();try&#123; //获取到了被本锁保护的资源，处理任务 //捕获异常&#125;finally&#123; lock.unlock(); //释放锁&#125; tryLock() ​ 尝试获取锁，如果当前锁没有被其他线程占用，则获取成功，返回 true，否则返回 false，代表获取锁失败。该方法会立即返回，即便在拿不到锁时也不会一直等待，所以通常情况下，我们用 if 语句判断 tryLock() 的返回结果. 12345678910Lock lock = ...;if(lock.tryLock()) &#123; try&#123; //处理任务 &#125;finally&#123; lock.unlock(); //释放锁 &#125; &#125;else &#123; //如果不能获取锁，则做其他事情&#125; 这个方法可以方便的解决死锁问题 1234567891011121314151617181920public void tryLock(Lock lock1, Lock lock2) throws InterruptedException &#123; while (true) &#123; if (lock1.tryLock()) &#123; try &#123; if (lock2.tryLock()) &#123; try &#123; System.out.println(&quot;获取到了两把锁，完成业务逻辑&quot;); return; &#125; finally &#123; lock2.unlock(); &#125; &#125; &#125; finally &#123; lock1.unlock(); &#125; &#125; else &#123; Thread.sleep(new Random().nextInt(1000)); &#125; &#125; &#125; 如果代码中我们不用 tryLock() 方法,比如有两个线程同时调用这个方法，传入的 lock1 和 lock2 恰好是相反的，那么如果第一个线程获取了 lock1 的同时，第二个线程获取了 lock2，它们接下来便会尝试获取对方持有的那把锁，但是又获取不到，于是便会陷入死锁，使用tryLock()后，如果获取到了 lock1 但没有获取到 lock2，那么也会释放掉 lock1 tryLock(long time, TimeUnit unit) 使用 tryLock(long time, TimeUnit unit) 时，在等待了一段指定的超时时间后，线程会主动放弃这把锁的获取，避免永久等待；在等待的期间，也可以随时中断线程，这就避免了死锁的发生。 lockInterruptibly() 如果这个锁当前是可以获得的，那么这个方法会立刻返回,，但是如果这个锁当前是不能获得的（被其他线程持有），那么当前线程便会开始等待，除非它等到了这把锁或者是在等待的过程中被Thread的interrupt()方法中断了，否则这个线程便会一直在这里执行这行代码。一直尝试获取直到获取到为止。 相比于不能响应中断的 synchronized 锁，lockInterruptibly() 可以让程序更灵活，可以在获取锁的同时，保持对中断的响应。我们可以把这个方法理解为超时时间是无穷长的 tryLock(long time, TimeUnit unit)，因为 tryLock(long time, TimeUnit unit) 和 lockInterruptibly() 都能响应中断，只不过 lockInterruptibly() 永远不会超时。 123456789101112public void lockInterruptibly() &#123; try &#123; lock.lockInterruptibly(); try &#123; System.out.println(&quot;操作资源&quot;); &#125; finally &#123; lock.unlock(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; unlock() 最后要介绍的方法是 unlock() 方法，是用于解锁的，u方法比较简单，对于 ReentrantLock 而言，执行 unlock() 的时候，内部会把锁的“被持有计数器”减 1，直到减到 0 就代表当前这把锁已经完全释放了，如果减 1 后计数器不为 0，说明这把锁之前被“重入”了，那么锁并没有真正释放，仅仅是减少了持有的次数。 https://www.yinxiang.com/everhub/note/c27d346d-ed4d-4e7b-aef9-0b501a44deb7 https://www.bilibili.com/video/BV1NT4y1G7WE?p=5 https://www.bilibili.com/video/BV1qE411q7fk?p=10 https://www.cnblogs.com/aspirant/p/11470858.html 可重入锁/非可重入锁；​ 可重入锁 ： 可重入锁指的是线程当前已经持有这把锁了，能在不释放这把锁的情况下，再次获取这把锁。 ​ synchronized是可冲入锁 12345678910111213141516171819202122232425public class T &#123; synchronized void m1()&#123; System.out.println(&quot;m1 start&quot;); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; m2(); System.out.println(&quot;m1 end&quot;); &#125; private void m2() &#123; try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;m2&quot;); &#125; public static void main(String[] args) &#123; new T().m1(); &#125;&#125; 运行结果 123m1 startm2m1 end 如果synchronized不是可重入锁，执行m1()执行m2()会发生死锁, 为什么synchronized必须是可重入锁呢? 如果父类m2()是synchronized方法,子类重写m2()方法，调用子类m2(),接着调用super.m2()就会发生死锁 共享锁/独占锁 共享锁 共享锁指的是我们同一把锁可以被多个线程同时获得 独占锁 这把锁只能同时被一个线程获得 读写锁就最好地诠释了共享锁和独占锁的理念。读写锁中的读锁，是共享锁，而写锁是独占锁。读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。 整体思路是它有两把锁，第 1 把锁是写锁，获得写锁之后，既可以读数据又可以修改数据，而第 2 把锁是读锁，获得读锁之后，只能查看数据，不能修改数据。读锁可以被多个线程同时持有，所以多个线程可以同时查看数据。 我们在使用读写锁时遵守下面的获取规则： 如果有一个线程已经占用了读锁，则此时其他线程如果要申请读锁，可以申请成功。 如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁，因为读写不能同时操作。 如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，都必须等待之前的线程释放写锁，同样也因为读写不能同时，并且两个线程不应该同时写。 所以我们用一句话总结：要么是一个或多个线程同时有读锁，要么是一个线程有写锁，但是两者不会同时出现。也可以总结为：读读共享、其他都互斥（写写互斥、读写互斥、写读互斥）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 描述： 演示读写锁用法 */public class ReadWriteLockDemo &#123; private static final ReentrantReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock( false); private static final ReentrantReadWriteLock.ReadLock readLock = reentrantReadWriteLock .readLock(); private static final ReentrantReadWriteLock.WriteLock writeLock = reentrantReadWriteLock .writeLock(); private static void read() &#123; readLock.lock(); try &#123; System.out.println(Thread.currentThread().getName() + &quot;得到读锁，正在读取&quot;); Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(Thread.currentThread().getName() + &quot;释放读锁&quot;); readLock.unlock(); &#125; &#125; private static void write() &#123; writeLock.lock(); try &#123; System.out.println(Thread.currentThread().getName() + &quot;得到写锁，正在写入&quot;); Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(Thread.currentThread().getName() + &quot;释放写锁&quot;); writeLock.unlock(); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; new Thread(() -&gt; read()).start(); new Thread(() -&gt; read()).start(); new Thread(() -&gt; write()).start(); new Thread(() -&gt; write()).start(); &#125;&#125; 运行结果 12345678Thread-0得到读锁，正在读取Thread-1得到读锁，正在读取Thread-0释放读锁Thread-1释放读锁Thread-2得到写锁，正在写入Thread-2释放写锁Thread-3得到写锁，正在写入Thread-3释放写锁 读锁可以同时被多个线程获得，而写锁不能。 为什么要对读加锁 : 读本身是线程安全的，加读锁，主要是为了让写锁感知到，在有人读取的时候，不要同时写入。 ReentrantReadWriteLockTest.java 1234567891011121314151617181920212223242526272829303132333435private static ReentrantReadWriteLock reentrantLock = new ReentrantReadWriteLock();private static ReentrantReadWriteLock.ReadLock readLock = reentrantLock.readLock();private static ReentrantReadWriteLock.WriteLock writeLock = reentrantLock.writeLock();public static void read() &#123; readLock.lock(); try &#123; System.out.println(Thread.currentThread().getName() + &quot;获取读锁，开始执行&quot;); Thread.sleep(2000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; readLock.unlock(); System.out.println(Thread.currentThread().getName() + &quot;释放读锁&quot;); &#125;&#125;public static void write() &#123; writeLock.lock(); try &#123; System.out.println(Thread.currentThread().getName() + &quot;获取写锁，开始执行&quot;); Thread.sleep(2000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; writeLock.unlock(); System.out.println(Thread.currentThread().getName() + &quot;释放写锁&quot;); &#125;&#125;public static void main(String[] args) &#123; new Thread(() -&gt; read(), &quot;Thread1&quot;).start(); new Thread(() -&gt; read(), &quot;Thread2&quot;).start(); new Thread(() -&gt; write(), &quot;Thread3&quot;).start(); new Thread(() -&gt; write(), &quot;Thread4&quot;).start();&#125; 运行结果: Thread1获取读锁，开始执行Thread2获取读锁，开始执行Thread1释放读锁Thread2释放读锁Thread3获取写锁，开始执行Thread3释放写锁Thread4获取写锁，开始执行Thread4释放写锁 线程1和线程2可以同时获取读锁，而线程3和线程4只能依次获取写锁，因为线程4必须等待线程3释放写锁后才能获取到锁 https://blog.csdn.net/fanrenxiang/article/details/104312606 公平锁/非公平锁； 公平锁 线程就都会进入等待，开始排队，在等待队列里等待时间长的线程会优先拿到这把锁，有先来先得的意思，公平锁指的是按照线程请求的顺序，来分配锁 非公平锁 它会在一定情况下，忽略掉已经在排队的线程，发生插队现象，而非公平锁指的是不完全按照请求的顺序，在一定情况下，可以允许插队 公平锁 new ReentrantLock(false); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class FairAndUnfair &#123; public static void main(String args[]) &#123; PrintQueue printQueue = new PrintQueue(); Thread thread[] = new Thread[10]; for (int i = 0; i &lt; 10; i++) &#123; thread[i] = new Thread(new Job(printQueue), &quot;Thread &quot; + i); &#125; for (int i = 0; i &lt; 10; i++) &#123; thread[i].start(); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;class Job implements Runnable &#123; private PrintQueue printQueue; public Job(PrintQueue printQueue) &#123; this.printQueue = printQueue; &#125; @Override public void run() &#123; System.out.printf(&quot;%s: Going to print a job\\n&quot;, Thread.currentThread().getName()); printQueue.printJob(new Object()); System.out.printf(&quot;%s: The document has been printed\\n&quot;, Thread.currentThread().getName()); &#125;&#125;class PrintQueue &#123; private final Lock queueLock = new ReentrantLock(false); //非公平锁 public void printJob(Object document) &#123; queueLock.lock(); try &#123; Long duration = (long) (Math.random() * 10000); System.out.printf(&quot;%s: PrintQueue: Printing a Job during %d seconds\\n&quot;, Thread.currentThread().getName(), (duration / 1000)); Thread.sleep(duration); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; queueLock.unlock(); &#125; queueLock.lock(); try &#123; Long duration = (long) (Math.random() * 10000); System.out.printf(&quot;%s: PrintQueue: Printing a Job during %d seconds\\n&quot;, Thread.currentThread().getName(), (duration / 1000)); Thread.sleep(duration); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; queueLock.unlock(); &#125; &#125;&#125; ​ 运行结果 12345678910111213141516171819202122232425262728293031323334353637383940Thread 0: Going to print a jobThread 0: PrintQueue: Printing a Job during 8 secondsThread 1: Going to print a jobThread 2: Going to print a jobThread 3: Going to print a jobThread 4: Going to print a jobThread 5: Going to print a jobThread 6: Going to print a jobThread 7: Going to print a jobThread 8: Going to print a jobThread 9: Going to print a jobThread 0: PrintQueue: Printing a Job during 2 secondsThread 0: The document has been printedThread 1: PrintQueue: Printing a Job during 8 secondsThread 1: PrintQueue: Printing a Job during 8 secondsThread 1: The document has been printedThread 2: PrintQueue: Printing a Job during 7 secondsThread 2: PrintQueue: Printing a Job during 5 secondsThread 2: The document has been printedThread 3: PrintQueue: Printing a Job during 5 secondsThread 3: PrintQueue: Printing a Job during 0 secondsThread 3: The document has been printedThread 4: PrintQueue: Printing a Job during 5 secondsThread 4: PrintQueue: Printing a Job during 9 secondsThread 4: The document has been printedThread 5: PrintQueue: Printing a Job during 6 secondsThread 5: PrintQueue: Printing a Job during 6 secondsThread 5: The document has been printedThread 6: PrintQueue: Printing a Job during 1 secondsThread 6: PrintQueue: Printing a Job during 5 secondsThread 6: The document has been printedThread 7: PrintQueue: Printing a Job during 1 secondsThread 7: PrintQueue: Printing a Job during 1 secondsThread 7: The document has been printedThread 8: PrintQueue: Printing a Job during 6 secondsThread 8: PrintQueue: Printing a Job during 1 secondsThread 8: The document has been printedThread 9: PrintQueue: Printing a Job during 1 secondsThread 9: PrintQueue: Printing a Job during 0 secondsThread 9: The document has been printed 可以看到thread1释放锁后又重新获取到锁 ​ ReentrantLockTest.java 123456789101112131415161718192021private static final int COUNT = 100;private static int start = 1;static ReentrantLock lock = new ReentrantLock(true);public static void main(String[] args) &#123; Runnable task = () -&gt; &#123; for (; ; ) &#123; lock.lock(); try &#123; if (start &lt;= COUNT) &#123; System.out.println(Thread.currentThread().getName() + &quot;=&gt; &quot; + start++); &#125; else &#123; System.exit(0); &#125; &#125; finally &#123; lock.unlock(); &#125; &#125; &#125;; new Thread(task).start(); new Thread(task).start(); 运行结果: Thread-0=&gt; 1Thread-1=&gt; 2Thread-0=&gt; 3Thread-1=&gt; 4…Thread-1=&gt; 36Thread-1=&gt; 37Thread-1=&gt; 38Thread-1=&gt; 39 Thread-1=&gt; 40Thread-1=&gt; 41Thread-1=&gt; 42Thread-1=&gt; 43Thread-1=&gt; 44Thread-1=&gt; 45Thread-1=&gt; 46Thread-1=&gt; 47Thread-1=&gt; 48 Otherwise this lock does not guarantee any particular access order.可见公平锁不保证有序。 https://juejin.cn/post/6844903983308341261 https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantLock.html 悲观锁/乐观锁； 悲观锁 必须先拿到锁，以便达到“独占”的状态，当前线程在操作资源的时候，其他线程由于不能拿到锁. 它认为如果不锁住这个资源，别的线程就会来争抢，就会造成数据结果错误，所以悲观锁为了确保结果的正确性，会在每次获取并修改数据时，都把数据锁住，让其他线程无法访问该数据，这样就可以确保数据内容万无一失。 Java 中悲观锁的实现包括 synchronized 关键字和 Lock 相关类等，我们以 Lock 接口为例，例如 Lock 的实现类 ReentrantLock，类中的 lock() 等方法就是执行加锁，而 unlock() 方法是执行解锁。处理资源之前必须要先加锁并拿到锁，等到处理完了之后再解开锁，这就是非常典型的悲观锁思想。 synchronized 关键字和 Lock 接口 大喜大悲：数据库 数据库中同时拥有悲观锁和乐观锁的思想。例如，我们如果在 MySQL 选择 select for update 语句，那就是悲观锁，在提交之前不允许第三方来修改该数据，这当然会造成一定的性能损耗，在高并发的情况下是不可取的 相反，我们可以利用一个版本 version 字段在数据库中实现乐观锁。在获取及修改数据时都不需要加锁，但是我们在获取完数据并计算完毕，准备更新数据时，会检查版本号和获取数据时的版本号是否一致，如果一致就直接更新，如果不一致，说明计算期间已经有其他线程修改过这个数据了，那我就可以选择重新获取数据，重新计算，然后再次尝试更新数据。 乐观锁 利用 CAS 理念，在不独占资源的情况下，完成了对资源的修改。 为了确保数据正确性，在更新之前，会去对比在我修改数据期间，数据有没有被其他线程修改过：如果没被修改过，就说明真的只有我自己在操作，那我就可以正常的修改数据；如果发现数据和我一开始拿到的不一样了，说明其他线程在这段时间内修改过数据，那说明我迟了一步，所以我会放弃这次修改，并选择报错、重试等策略。 ​ 自旋锁/非自旋锁； 自旋锁 自旋锁的理念是如果线程现在拿不到锁，并不直接陷入阻塞或者释放 CPU 资源，而是开始利用循环，不停地尝试获取锁，这个循环过程被形象地比喻为“自旋” 阻塞和唤醒线程都是需要高昂的开销的，如果同步代码块中的内容不复杂，那么可能转换线程带来的开销比实际业务代码执行的开销还要大。 非自旋锁 如果它发现此时获取不到锁，它就把自己的线程切换状态，让线程休眠，然后 CPU 就可以在这段时间去做很多其他的事情，直到之前持有这把锁的线程释放了锁，于是 CPU 再把之前的线程恢复回来，让这个线程再去尝试获取这把锁。 123456789101112131415161718192021222324252627282930313233343536373839/** * 持有锁的线程，null表示锁未被线程持有 */private AtomicReference&lt;Thread&gt; ref = new AtomicReference&lt;&gt;();public void lock()&#123; Thread currentThread = Thread.currentThread(); while(!ref.compareAndSet(null, currentThread))&#123; //当ref为null的时候compareAndSet返回true，反之为false //通过循环不断的自旋判断锁是否被其他线程持有 &#125;&#125;public void unLock() &#123; Thread cur = Thread.currentThread(); if(ref.get() != cur)&#123; //exception ... &#125; ref.set(null);&#125;static int count = 0;public static void main(String[] args) throws InterruptedException &#123; ExecutorService executorService = Executors.newFixedThreadPool(100); CountDownLatch countDownLatch = new CountDownLatch(100); SimpleSpinningLock simpleSpinningLock = new SimpleSpinningLock(); for (int i = 0 ; i &lt; 100 ; i++)&#123; executorService.execute(() -&gt; &#123; simpleSpinningLock.lock(); ++count; simpleSpinningLock.unLock(); countDownLatch.countDown(); &#125;); &#125; countDownLatch.await(); System.out.println(count);&#125; 可中断锁/不可中断锁。第 7 种分类是可中断锁和不可中断锁。在 Java 中，synchronized 关键字修饰的锁代表的是不可中断锁，一旦线程申请了锁，就没有回头路了，只能等到拿到锁以后才能进行其他的逻辑处理。而我们的 ReentrantLock 是一种典型的可中断锁，例如使用 lockInterruptibly 方法在获取锁的过程中，突然不想获取了，那么也可以在中断之后去做其他的事情，不需要一直傻等到获取到锁才离开。 死锁 条件 互斥条件 : 任务使用的资源至少有一个是不能共享的；chopstick一次只能被一个Philosopher使用 请求保持条件: 至少有一个任务必须持有跟一个资源且正在等待获取一个当前被别的任务持有的资源 不可剥夺条件: 资源不能被任务抢占 环路等待条件: 必须有循环等待。一个任务等待其他任务所持有的资源，后者又等待另一个任务所持有的资源,使得大家都被锁住. 当两个（或多个）线程（或进程）相互持有对方所需要的资源，却又都不主动释放自己手中所持有的资源，导致大家都获取不到自己想要的资源 那么为什么会产生死锁呢? 学过操作系统的朋友应该都知道，死锁的产生必须具备以下四个条件 。 互斥条件: 指线程对己经获取到的资源进行排它性使用 ，即该资源同时只由 一个线程占用。如果 此时 还有其 他 线程请求获取该资源 ，则 请求者只能等待，直至占有资源 的 线程释放该资源。 .请求并持有条件 : 指一个线程己经持有了至少一个资源，但又提出了新的资源请求，而新资源己被其 他 线程占有，所 以 当前线程会被阻塞 ，但 阻塞 的同时 并不释放自 己己经获取的资源。 不可剥夺条件 : 指线程获取到的资源在自己使用完之前不能被其他线程抢占 ， 只有在自己使用完 毕后才 由 自 己释放该资源。 环路等待条件 : 指在发生死锁时 ，必然存在一个线程→资源的环形链 ，即线程集合{TO,TLT2，…，Tn}中的TO正在等待一个Tl占用的资源， Tl正在等待T2占 用的资源，……Tn正在等待己被 TO 占用的资源。 避免死锁要想避免死锁，只需要破坏掉至少一个构造死锁的必要条件即可， 但是学过操作系统 的读者应该都知道，目前只有请求并持有和环路等待条件是可 以被破坏 的。造成死锁的原因其实和申请资源的顺序有很大关系 ， 经典的哲学家吃饭问题 5位哲学家 ，5只筷子在他们之间. 筷子 12345678910111213141516171819202122232425262728public class Chopstick &#123; private boolean taken = false; public int getNumber() &#123; return number; &#125; public void setNumber(int number) &#123; this.number = number; &#125; private int number; public synchronized void take(int numChop) throws InterruptedException &#123; while (taken) &#123; Print.print(numChop+&quot; wait&quot;); wait(); &#125; taken = true; &#125; public synchronized void drop() &#123; taken = false; notifyAll(); &#125;&#125; 哲学家 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Philosopher implements Runnable &#123; private Chopstick left; private Chopstick right; private final int id; private final int ponderFactor; private Random rand = new Random(47); private void pause() throws InterruptedException &#123; if (ponderFactor == 0) return; TimeUnit.MILLISECONDS.sleep(rand.nextInt(ponderFactor * 250)); &#125; public Philosopher(Chopstick left, Chopstick right, int id, int ponderFactor) &#123; this.id = id; this.ponderFactor = ponderFactor; this.left = left; this.right = right; &#125; @Override public void run() &#123; try &#123; while (!Thread.interrupted()) &#123; Print.print(this + &quot; &quot; + &quot;need thinking &quot; + ponderFactor + &quot; 毫秒&quot;); pause(); //Philosopher becomes hungry Print.print(this + &quot; &quot; + &quot;grabbing right 第&quot; + (id + 1) + &quot; 号筷子&quot;); right.take(id + 1);// if (id == 2) &#123;// System.out.println(right.taken);// &#125; pause(); //拿起右边的筷子进入等待状态 Print.print(this + &quot; .&quot; + &quot;try grabbing left 第 &quot; + (id) + &quot; 号筷子&quot;); //尝试拿起左边的筷子 left.take(id); Print.print(this + &quot; &quot; + &quot;eating&quot;); pause(); right.drop(); left.drop(); &#125; &#125; catch (InterruptedException e) &#123; Print.print(this + &quot; &quot; + &quot;exiting via interrupt&quot;); &#125; &#125; @Override public String toString() &#123; return &quot;Philosopher&quot; + id; &#125;&#125; 运行 1234567891011121314151617181920212223242526public class DeadlockingDiningPhilosophers &#123; public static void main(String[] args) throws Exception &#123; int ponder = 5; //默认 Philosopher思考的时间 if (args.length &gt; 0) ponder = Integer.parseInt(args[0]); int size = 5; //默认筷子的个数 if (args.length &gt; 1) size = Integer.parseInt(args[1]); ExecutorService exec = Executors.newCachedThreadPool(); Chopstick[] sticks = new Chopstick[size]; for (int i = 0; i &lt; size; i++) sticks[i] = new Chopstick(); for (int i = 0; i &lt; size; i++) exec.execute(new Philosopher(sticks[i], sticks[(i + 1) % size], i, ponder));// if (args.length == 3 &amp;&amp; args[2].equals(&quot;timeout&quot;)) TimeUnit.SECONDS.sleep(5);// else &#123;// System.out.println(&quot;Press &#x27;&#x27;Enter to quit&quot;);// System.in.read();// &#125; exec.shutdownNow(); &#125;&#125; 结果 12345678910111213141516171819202122232425Philosopher0 need thinking 5 毫秒Philosopher3 need thinking 5 毫秒Philosopher2 need thinking 5 毫秒Philosopher1 need thinking 5 毫秒Philosopher4 need thinking 5 毫秒Philosopher0 grabbing right 第1 号筷子Philosopher3 grabbing right 第4 号筷子Philosopher2 grabbing right 第3 号筷子Philosopher1 grabbing right 第2 号筷子Philosopher4 grabbing right 第5 号筷子Philosopher0 .try grabbing left 第 0 号筷子Philosopher3 .try grabbing left 第 3 号筷子Philosopher2 .try grabbing left 第 2 号筷子Philosopher1 .try grabbing left 第 1 号筷子Philosopher4 .try grabbing left 第 4 号筷子2 wait3 wait4 wait0 wait1 waitPhilosopher1 exiting via interruptPhilosopher4 exiting via interruptPhilosopher0 exiting via interruptPhilosopher3 exiting via interruptPhilosopher2 exiting via interrupt 银行转账问题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class TransferMoney implements Runnable &#123; int flag; static Account a = new Account(800); static Account b = new Account(600); static class Account &#123; public Account(int balance) &#123; this.balance = balance; &#125; int balance; &#125; @Override public void run() &#123; if (flag == 1) &#123; transferMoney(a, b, 200); &#125; if (flag == 0) &#123; transferMoney(b, a, 200); &#125; &#125; public static void transferMoney(Account from, Account to, int amount) &#123; //先获取两把锁，然后开始转账 int fromHash = System.identityHashCode(from); int toHash = System.identityHashCode(to); System.out.println(Thread.currentThread().getName() + &quot; fromHash &lt; toHash &quot;+(fromHash &lt; toHash)); if (fromHash &lt; toHash) &#123; synchronized (from) &#123; System.out.println(Thread.currentThread().getName() + &quot; 获得锁A &quot; + from.balance); try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; &#125; synchronized (to) &#123; System.out.println(Thread.currentThread().getName() + &quot; 获得锁B &quot; + to.balance); if (from.balance - amount &lt; 0) &#123; System.out.println(Thread.currentThread().getName() + &quot; 余额不足，转账失败。&quot;); return; &#125;// from.balance -= amount;// to.balance += amount; System.out.println(Thread.currentThread().getName() + &quot; 成功转账&quot; + amount + &quot;元&quot;); &#125; &#125; &#125; else if (fromHash &gt; toHash) &#123; synchronized (to) &#123; System.out.println(Thread.currentThread().getName() + &quot; 获得锁A &quot; + to.balance); try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; &#125; synchronized (from) &#123; System.out.println(Thread.currentThread().getName() + &quot; 获得锁B &quot; + from.balance); if (from.balance - amount &lt; 0) &#123; System.out.println(Thread.currentThread().getName() + &quot; 余额不足，转账失败。&quot;); return; &#125;// from.balance -= amount;// to.balance += amount; System.out.println(Thread.currentThread().getName() + &quot; 成功转账&quot; + amount + &quot;元&quot;); &#125; &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; TransferMoney r1 = new TransferMoney(); TransferMoney r2 = new TransferMoney(); r1.flag = 1; r2.flag = 0; Thread t1 = new Thread(r1, &quot;t1&quot;); Thread t2 = new Thread(r2, &quot;t2&quot;); t1.start(); t2.start(); t1.join(); t2.join();// System.out.println(&quot;a的余额&quot; + a.balance);// System.out.println(&quot;b的余额&quot; + b.balance); &#125;&#125; 打印结构 t1 fromHash 1967932108 toHash 2072748565 fromHash &lt; toHash truet2 fromHash 2072748565 toHash 1967932108 fromHash &lt; toHash falset1 获得锁At1 获得锁Bt1 成功转账200元t2 获得锁Bt2 获得锁At2 成功转账200元a的余额500 b的余额500 使用 HashCode 的值来决定顺序 主要思想是，两个线程都先获取 锁A,再获取锁B,这样就不会有死锁了 主键 ID 具有唯一、不重复的特点 由主键 ID 大小来决定获取锁的顺序，就可以确保避免死锁。 CASAtomicStampedReference 在变量前面添加版本号，每次变量更新的时候都把版本号加1 AQShttps://www.cnblogs.com/dennyzhangdd/p/7218510.html 信号量12345678910111213141516171819202122232425262728293031323334353637383940public class SemaphoreTestMain &#123; static Semaphore sSemaphore = new Semaphore(6); public static void main(String[] args) &#123; final SemaphoreTestMain semaphoreTestMain = new SemaphoreTestMain(); for (int i = 0 ; i &lt; 1000;i++) &#123; Thread myThread = new Thread() &#123; @Override public void run() &#123; super.run(); try &#123; semaphoreTestMain.test(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; myThread.setName(&quot;threat index:&quot; + i); myThread.start(); &#125; &#125; public void test() throws InterruptedException &#123; sSemaphore.acquire(); System.out.println(Thread.currentThread().getName() + &quot;--in&quot;); Thread.sleep(1000); System.out.println(Thread.currentThread().getName() + &quot;--out&quot; ); sSemaphore.release(); &#125;&#125; https://www.bilibili.com/video/BV1B7411L7tE https://tech.meituan.com/2018/11/15/java-lock.html https://blog.csdn.net/javazejian/article/details/72828483#t2 https://tech.meituan.com/2018/11/15/java-lock.html","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}],"tags":[{"name":"concurrency","slug":"concurrency","permalink":"http://noteforme.github.io.com/tags/concurrency/"}],"keywords":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}]},{"title":"CaptureApp","slug":"CaptureApp","date":"2018-04-21T05:24:41.000Z","updated":"2021-08-31T09:04:01.733Z","comments":true,"path":"2018/04/21/CaptureApp/","link":"","permalink":"http://noteforme.github.io.com/2018/04/21/CaptureApp/","excerpt":"","text":"Fiddlerhttps://www.jianshu.com/p/4a8dae519efehttps://www.jianshu.com/p/99b6b4cd273c WireShark安装https://www.linuxidc.com/Linux/2016-08/134526.htm http://www.cnblogs.com/wangqiguo/p/4529250.htmlhttp://www.cnblogs.com/TankXiao/archive/2012/10/10/2711777.html https://juejin.im/post/5cc313755188252d6f11b463 手机抓包 https://juejin.im/post/5ddddd2a6fb9a07161483fb2 Charles抓包 https://www.jianshu.com/p/e8dd1091d6d7 https://www.cnblogs.com/ievjai/p/13512326.html","categories":[{"name":"TOOL","slug":"TOOL","permalink":"http://noteforme.github.io.com/categories/TOOL/"}],"tags":[],"keywords":[{"name":"TOOL","slug":"TOOL","permalink":"http://noteforme.github.io.com/categories/TOOL/"}]},{"title":"Generics","slug":"Generics","date":"2018-04-16T06:36:29.000Z","updated":"2021-09-12T09:08:07.207Z","comments":true,"path":"2018/04/16/Generics/","link":"","permalink":"http://noteforme.github.io.com/2018/04/16/Generics/","excerpt":"","text":"泛型类1234567891011121314151617181920212223public class Order&lt;T&gt; &#123; String orderName; int orderId; T orderT; public Order() &#123; &#125; public Order(String orderName, int orderId, T orderT) &#123; this.orderName = orderName; this.orderId = orderId; this.orderT = orderT; &#125; public T getOrderT() &#123; return orderT; &#125; public void setOrderT(T orderT) &#123; this.orderT = orderT; &#125;&#125; 子类不是泛型类 父类指明类型,由于子类在继承带泛型的父类时，指明了泛型类型，则实例化子类对象时，不再需要指明泛型。 123456789public class SubOrder extends Order&lt;Integer&gt; &#123;&#125;@Testpublic void test1()&#123; //由于子类在继承带泛型的父类时，指明了泛型类型，则实例化子类对象时，不再需要指明泛型。 SubOrder subOrder = new SubOrder(); subOrder.setOrderT(1122); &#125; 子父类关系类A是类B的父类，G和G二者不具备父子类关系,也不具任何关系。 类A是类B的父类，A是 B的父类。 反证法: https://www.bilibili.com/video/BV1fi4y1b7NM?p=11 子类是泛型类12345public class SubOrder1&lt;T&gt; extends Order&lt;T&gt; &#123;&#125;SubOrder1&lt;String&gt; sub2 = new SubOrder1&lt;&gt;();sub2.setOrderT(&quot;order...&quot;); 泛型方法123456789101112131415161718public class Person3&lt;T&gt; &#123; //泛型普通方法 public void show(T name) &#123; System.out.println(name + &quot;正在演讲&quot;); &#125; public &lt;M&gt; void show1(M name) &#123; System.out.println(name + &quot;正在演讲&quot;); &#125; //静态泛型方法中的类型占位符和类中的泛型占位符是没有关系的 public static &lt;W&gt; void show2(W name) &#123; System.out.println(name + &quot;：静态方法正在演讲!&quot;); &#125; public static &lt;E&gt; E show3(E name) &#123; return name; &#125;&#125; 泛型接口123interface PerInt&lt;T&gt; &#123; fun show(name: T)&#125; 泛型接口的实现类 可以指定具体的泛型接口的具体泛型类型 1234class PerImtImpl : PerInt&lt;String&gt; &#123; override fun show(name: String) &#123; &#125;&#125; 泛型接口的实现类，如果没有指定具体的泛型类型，必须要在这个实现类中声明一个泛型类型的占位符给接口用 1234class PerImtImpl01&lt;T&gt; : PerInt&lt;T&gt; &#123; override fun show(name: T) &#123; &#125;&#125; 类型擦除Java中的泛型基本上都是在编译器这个层次来实现的。在生成的Java字节码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会在编译器在编译的时候去掉。这个过程就称为类型擦除。 泛型的作用是能在编译期间就提示错误，而不是运行时。 1234val p1 = PerImtImpl01&lt;String&gt;()val p2 = PerImtImpl01&lt;Int&gt;()println(p1.javaClass == p2.javaClass)println(p1.javaClass === p2.javaClass) 通配符Java中的继承 ，在泛型中并不是父子类关系 12345678910111213141516class PerImtImpl01&lt;T&gt; : PerInt&lt;T&gt; &#123; var name: T get() &#123; return name &#125; set(value) &#123; name = value &#125; override fun show(name: T) &#123; &#125; fun show(p: PerImtImpl01&lt;*&gt;) &#123;//如果是T类型 编译报错，虽然Int:Number,但是在泛型中不存在继承关系 name = p.name as T &#125;&#125; 1234val p3 = PerImtImpl01&lt;Number&gt;()val p4 = PerImtImpl01&lt;Int&gt;()p3.name = 111p4.show(p3) 符号区别Java用 ？ Kotlin 用 * 无界通配符 意味着可以使用任何对象，因此使用它类似于使用原生类型 类A是类B的父类，G和G的公共的父类是: G&lt;?&gt; 遍历List12345678910111213141516171819202122232425@Test public void test2()&#123; List&lt;Object&gt; list1 = null; List&lt;String&gt; list2 = null; List&lt;?&gt; list = null; list = list1; list = list2; print(list1); print(list2); &#125; public void print(List&lt;?&gt; list)&#123; Iterator&lt;?&gt; iterator = list.iterator(); while (iterator.hasNext())&#123; Object o = iterator.next(); System.out.println(o); &#125; list.forEach(o -&gt; &#123; System.out.println(o); &#125;); &#125; 对于List 就不能向其添加数据。如果任何类型引用通过赋值给 List 能添加数据，那定义泛型就没意义了 123456789101112131415 List&lt;?&gt; list = null; ArrayList&lt;String&gt; list3 = new ArrayList&lt;&gt;(); list3.add(&quot;AA&quot;); list3.add(&quot;BB&quot;); list3.add(&quot;CC&quot;); list = list3; //添加(写入):对于List&lt;?&gt; 就不能向其添加数据，如果能添加数据，那定义泛型就没意义了。 //除了添加null之外// list.add(&quot;MED&quot;);// list.add(&quot;?&quot;); list.add(null); //可以获取数据，读取的数据类型为Object Object o = list.get(0); System.out.println(o); 上下界如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法 12345678910111213public class StaticGenerator&lt;T&gt; &#123; .... .... /** * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法） * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。 * 如：public static void show(T t)&#123;..&#125;,此时编译器会提示错误信息： &quot;StaticGenerator cannot be refrenced from static context&quot; */ public static &lt;T&gt; void show(T t)&#123; &#125;&#125; 上界&lt;? extends T&gt;不能往里存，只能往外取，适合频繁往外面读取内容的场景。 下界&lt;? super T&gt;不影响往里存，但往外取只能放在Object对象里，适合经常往里面插入数据的场景。 上界通配符 &lt;? extends T&gt;泛型中的继承 泛型中的继承不是Java中的继承。也就是说java中的父子类关系， 在泛型中 并不是父子类关系。 1234567891011121314151617181920212223class Fruit &#123;&#125;class Apple extends Fruit &#123;&#125;class Plate&lt;T&gt; &#123; T item; public Plate() &#123; &#125; public Plate(T item) &#123; this.item = item; &#125; public T get() &#123; return item; &#125; public void set(T item) &#123; this.item = item; &#125;&#125; ? extends Fruit赋值? extends Fruit 可以理解为 &lt;= Fruit List&lt;? extends Fruit&gt; 可以作为 List ， List的父类。 1234567891011121314151617// List&lt;Fruit&gt; list1 = new ArrayList&lt;Apple&gt;(); //编译报错，泛型具体类型 List&lt;Fruit&gt; ,ArrayList&lt;Apple&gt; 不存在继承关系 // ? extends Fruit 可以理解为 &lt;= Fruit // List&lt;? extends Fruit&gt; // 可以作为 List&lt;Apple&gt; ， List&lt;Fruit&gt;的父类。 List&lt;? extends Fruit&gt; list4 = new ArrayList&lt;Apple&gt;(); List&lt;? extends Fruit&gt; list5= new ArrayList&lt;Fruit&gt;();// List&lt;? extends Fruit&gt; list5 =new ArrayList&lt;Object&gt;(); //编译报错，Object类不在 &lt;= Fruit范围内 /** * 只能读取数据 , 不能修改数据 */ Fruit fruit = list4.get(0);// Apple apple =list2.get(0); //编译不通过， &lt;= Fruit范围，list1.get(0)实际类型可能是Fruit，是Apple的父类。// list1.add(new Apple()); //编译报错，&lt;= Fruit范围， List&lt;? extends Fruit&gt;实际类型可能比是GreenApple,比Apple范围还小，随意存不了数据 读取数据? extends Fruit 所以泛型最大的父类就是Fruit,子类型可以直接复制给父类 12345678 /** * 只能读取数据 , 不能修改数据 */ Fruit fruit = list4.get(0);// Apple apple =list2.get(0); //编译不通过， &lt;= Fruit范围，list1.get(0)实际类型可能是Fruit，是Apple的父类。// list1.add(new Apple()); //编译报错，&lt;= Fruit范围， List&lt;? extends Fruit&gt;实际类型可能比是GreenApple,比Apple范围还小，随意存不了数据 你会发现无法往里面设置任何数据，按道理说我们将泛型类型设置为? extend Fruit。按理说我们往里面添加Fruit的子类应该是可以的。但是Java编译器不允许这样操作。&lt;? extends Fruit&gt;会使往盘子里放东西的set()方法失效。但取东西get()方法还有效 原因是：Java编译期只知道容器里面存放的是Fruit和它的子类，具体是什么类型不知道，可能是Fruit？可能是Apple？也可能是Banana，RedApple，GreenApple？编译器在后面看到Plate&lt; Apple &gt;赋值以后，盘子里面没有标记为“苹果”。只是标记了一个占位符“CAP#1”，来表示捕获一个Fruit或者Fruit的派生类，具体是什么类型不知道。所有调用代码无论往容器里面插入Apple或者Meat或者Fruit编译器都不知道能不能和这个“CAP#1”匹配，所以这些操作都不允许。 一个Plate&lt;? extends Fruit&gt;的引用，可能是一个Plate 类型的盘子，要往这个盘子里放当然是不被允许的. 但是上界通配符是允许读取操作的。例如代码 这个我们很好理解，由于上界通配符设定容器中只能存放Fruit及其子类，那么获取出来的我们都可以隐式的转为Fruit基类。所以上界描述符Extends适合频繁读取的场景。 Java类型擦除只会擦除到Fruit类型,如果没有指明边界，那么类型参数将被擦除到Object. 写入数据可以发现任何数据都不能存入。[-∞,Fruit]范围，-∞不知道具体的类型小到多少 1list1.add(new Apple()); //编译报错，&lt;= Fruit范围， List&lt;? extends Fruit&gt;实际类型可能比是GreenApple,比Apple范围还小，随意存不了数据 下界通配符 &lt;? super T&gt; ? super Fruit赋值 ? super Fruit 可以理解为 &gt;= Fruit 12345678910 //只能修改数据，不能读取数据 // &lt;? super Fruit&gt; List&lt;? super Fruit&gt; list6 = new ArrayList&lt;Fruit&gt;(); // ? super Fruit 可以理解为 &gt;= Fruit List&lt;? super Fruit&gt; list7 = new ArrayList&lt;Object&gt;(); Object object = list6.get(0); //理论上不能读取，但是都到Object还是可以的// Food food = list2.get(0); //编译不通过，&gt;=Fruit范围，list2.get(0)实际类型可能是Object,不能赋值给小于它子类，所以只能是Object 读取数据123 Object object = list6.get(0); //理论上不能读取，但是都到Object还是可以的// Food food = list2.get(0); //编译不通过，&gt;=Fruit范围，list2.get(0)实际类型可能是Object,不能赋值给小于它子类，所以只能是Object 写入数据 ? super Fruit范围是是 [Fruit,+∞), 所以Fruit范围内的都可以添加 123 list6.add(new Fruit()); list6.add(new Apple()); //// list6.add(new Food()); // ? super Fruit范围是是 [Fruit,+∞), 所以Fruit范围内的都可以添加 下界通配符&lt;? super Fruit&gt;不影响往里面存储，但是读取出来的数据只能是Object类型。 下界通配符规定了元素最小的粒度，必须是Fruit或其基类，那么我往里面存储Fruit及其子类都是可以的，因为它都可以隐式的转化为Fruit类型。但是往外读就不好控制了，里面存储的都是Fruit及其基类，无法转型为任何一种类型，只有Object基类才能装下。 https://juejin.im/post/5b614848e51d45355d51f792 www.jianshu.com/p/dd34211f2565 https://itimetraveler.github.io/2016/12/27/%E3%80%90Java%E3%80%91%E6%B3%9B%E5%9E%8B%E4%B8%AD%20extends%20%E5%92%8C%20super%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/ https://www.bilibili.com/video/BV1xJ411n77R?p=7 kotlinout只能获取 不能修改 1234 var list:MutableList&lt;out Fruit&gt; = ArrayList&lt;Apple&gt;() // ? extends Fruit 实际类型可能比是Apple小// list.add(Apple()) 编译报错 var list2: ArrayList&lt;in Apple&gt; = ArrayList&lt;Fruit&gt;() // ? super Fruit 实际类型可能比是Apple大很多// list2.get(0) https://www.bilibili.com/video/BV1xv411k7Dd?p=4&amp;spm_id_from=pageDriver https://noteforme.github.io/2021/08/21/kotlin-object/#Out-In https://www.bilibili.com/video/BV1Hy4y1H7oS?p=7 泛型数组 可以声明带泛型的数组引用，但是不能直接创建带泛型的数组对象 123456789ArrayList&lt;Integer&gt; intList = new ArrayList&lt;&gt;();intList.add(100); ArrayList&lt;String&gt; strList = new ArrayList&lt;&gt;();strList.add(&quot;abc&quot;);listArr[0] = strList;String s = listArr[0].get(0);System.out.println(s); 可以通过java.lang.reflect.Array的newInstance(Class,int) 创建T[]数组 12345678910111213141516171819public class FruitArr&lt;T&gt; &#123; private T[] array; public FruitArr(Class&lt;T&gt; clz, int length) &#123; this.array = (T[]) Array.newInstance(clz, length); &#125; public void put(int index, T item) &#123; array[index] = item; &#125; public T get(int index)&#123; return array[index]; &#125; public T[] getArray()&#123; return array; &#125;&#125; 123456FruitArr&lt;String&gt; fruit = new FruitArr&lt;&gt;(String.class,3);fruit.put(0,&quot;苹果&quot;);fruit.put(1,&quot;西瓜&quot;);fruit.put(2,&quot;香蕉&quot;);String s1 = Arrays.toString(fruit.getArray());System.out.println(s1); ​ 泛型与反射123Class&lt;Person&gt; personClass = Person.class;Constructor&lt;Person&gt; constructor = personClass.getConstructor();Person person = constructor.newInstance(); ​ https://www.bilibili.com/video/BV1xJ411n77R?p=12 $i$f$withM 有时候看到$以为是操作符，其实就是$i$f$withM整体的变量","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}],"tags":[],"keywords":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}]},{"title":"token","slug":"token","date":"2018-03-29T09:41:28.000Z","updated":"2021-08-19T11:11:44.316Z","comments":true,"path":"2018/03/29/token/","link":"","permalink":"http://noteforme.github.io.com/2018/03/29/token/","excerpt":"","text":"rxjava 方式http://alighters.com/blog/2016/05/02/rxjava-plus-retrofitshi-xian-wang-luo-dai-li/http://alighters.com/blog/2016/08/22/rxjava-plus-retrofitshi-xian-zhi-demo/ 最流行的网络请求框架Rxjava2+Retrofit之Token处理 https://blog.csdn.net/jdsjlzx/article/details/52442113 https://blog.csdn.net/qq_20521573/article/details/76100558 拦截器做控制https://blog.csdn.net/u012771445/article/details/79750648 https://blog.csdn.net/bestlbw/article/details/53984647 https://www.jianshu.com/p/c325f5c32709 RxjavaPlugin处理tokenhttps://github.com/ssseasonnn/RxErrorHandler","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"RxJava01","slug":"RxJava01","date":"2018-03-28T09:58:39.000Z","updated":"2021-08-19T11:11:44.237Z","comments":true,"path":"2018/03/28/RxJava01/","link":"","permalink":"http://noteforme.github.io.com/2018/03/28/RxJava01/","excerpt":"","text":"RxJavaDescribe subscribeOn() 指定上游发送事件的线程, observeOn 指定的是下游接收事件的线程 多次指定上游的线程只有第一次指定的有效,就是subscribeOn()只有第一次有效,其余忽略 可以多次指定下游线程,每调用一次observeOn(),下游的线程就会切换一次 Demo在 AndroidDemo -&gt; RXLeran-&gt;RX基础-&gt;Rx线程切换 链式调用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758RetrofitFactory.create(ICommonApis.class) .imgUpServer(part) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .doOnNext(new Consumer&lt;PictureUp&gt;() &#123; @Override public void accept(PictureUp pictureUp) throws Exception &#123; List&lt;PictureUp.ModelListBean&gt; picList = pictureUp.getModel_list(); if (picList != null &amp;&amp; !picList.isEmpty()) &#123; String feet_id = picList.get(0).getFile_group_id(); //上传成功 if (!isEmpty(feet_id) &amp;&amp; mvpView != null) &#123; mvpView.upFeetId(feet_id); &#125; &#125; &#125; &#125;) .observeOn(Schedulers.io()) .flatMap(new Function&lt;PictureUp, ObservableSource&lt;BaseCount&gt;&gt;() &#123; @Override public ObservableSource&lt;BaseCount&gt; apply(PictureUp pictureUp) throws Exception &#123; List&lt;PictureUp.ModelListBean&gt; picList = pictureUp.getModel_list(); if (picList != null &amp;&amp; !picList.isEmpty()) &#123; String feet_id = picList.get(0).getFile_group_id(); //上传成功 if (!isEmpty(feet_id) &amp;&amp; mvpView != null) &#123; mvpView.upFeetId(feet_id); &#125;else &#123; return Observable.error(new Exception()); &#125; &#125; return RetrofitFactory.create(ICommonApis.class).offlineBoxInfo(requestBody); &#125; &#125;) .subscribe(new Consumer&lt;BaseCount&gt;() &#123; @Override public void accept(BaseCount baseCount) throws Exception &#123; if (mvpView == null) &#123; return; &#125; if (baseCount.getMeta().getStatusCode() == AUTH_FAILED) &#123; mvpView.unOfficeEquip(baseCount); &#125; else if (baseCount.getMeta().getStatusCode() == 0) &#123; mvpView.upSuccess(); &#125; else &#123; if (baseCount.getMeta() != null &amp;&amp; !isEmpty(baseCount.getMeta().getDescribe())) &#123; ToastUtil.showBiggerText(baseCount.getMeta().getDescribe()); &#125; &#125; &#125; &#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) throws Exception &#123; if (mvpView != null) &#123; mvpView.upUserInfoFailed(); &#125; &#125; &#125;); 123456789101112131415161718192021222324252627282930313233343536fun getImgScan() &#123; val request = RetrofitWeChatFactory.create(IApiStore::class.java) request.get_access_token() .flatMap &#123; request.getTicket(it.access_token, 2) &#125; .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(object : Observer&lt;WeChatSecond&gt; &#123; override fun onComplete() &#123; &#125; override fun onSubscribe(d: Disposable) &#123; &#125; override fun onNext(t: WeChatSecond) &#123; val noncestr = LoginNewActivity.getRandomString(8) val timeStamp = (System.currentTimeMillis() / 1000).toString() t.ticket?.let &#123; val string1 = String.format( &quot;appid=%s&amp;noncestr=%s&amp;sdk_ticket=%s&amp;timestamp=%s&quot;, WeChatAppID, noncestr, it, timeStamp ) val sha = EncryptUtils.getSHA(string1) mvpView.sign(noncestr, timeStamp, sha) &#125; &#125; override fun onError(e: Throwable) &#123; &#125; &#125;)&#125; http://yamlee.me/2020/03/11/2020-03-11-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3RxJava%E4%B8%8ERxKotlin/ http://reactivex.io/documentation/operators.html https://www.jianshu.com/p/fa1828d70192 https://www.cnblogs.com/fuyaozhishang/p/8697404.html Sample水管系列 https://github.com/ReactiveX/RxAndroidhttps://github.com/amitshekhariitbhu/RxJava2-Android-Sampleshttps://github.com/rengwuxian/RxJavaSample https://github.com/ssseasonnn/RxJava2Demo https://juejin.im/post/5b8f536c5188255c352d3528 RxJava 只看这一篇文章就够了(上) RxJava 只看这一篇文章就够了 (中) RxJava 只看这一篇文章就够了 (下) 使用MVP Dagger2 https://juejin.im/post/5d5ce44d5188252231108e68 https://juejin.im/user/590210f4ac502e0063d338f5/posts","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"http://noteforme.github.io.com/tags/RxJava/"}],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"INTERVIEW-ANSWER","slug":"INTERVIEW-ANSWER","date":"2018-03-12T04:44:01.000Z","updated":"2021-08-19T11:11:43.977Z","comments":true,"path":"2018/03/12/INTERVIEW-ANSWER/","link":"","permalink":"http://noteforme.github.io.com/2018/03/12/INTERVIEW-ANSWER/","excerpt":"","text":"阿里面试题1.android事件分发机制，请详细说下整个流程 事件分发（面试）.png 2.android view绘制机制和加载过程，请详细说下整个流程 1.ViewRootImpl会调用performTraversals(),其内部会调用performMeasure()、performLayout、performDraw()。 2.performMeasure()会调用最外层的ViewGroup的measure()–&gt;onMeasure(),ViewGroup的onMeasure()是抽象方法，但其提供了measureChildren()，这之中会遍历子View然后循环调用measureChild()这之中会用getChildMeasureSpec()+父View的MeasureSpec+子View的LayoutParam一起获取本View的MeasureSpec，然后调用子View的measure()到View的onMeasure()–&gt;setMeasureDimension(getDefaultSize(),getDefaultSize()),getDefaultSize()默认返回measureSpec的测量数值，所以继承View进行自定义的wrap_content需要重写。 3.performLayout()会调用最外层的ViewGroup的layout(l,t,r,b),本View在其中使用setFrame()设置本View的四个顶点位置。在onLayout(抽象方法)中确定子View的位置，如LinearLayout会遍历子View，循环调用setChildFrame()–&gt;子View.layout()。 4.performDraw()会调用最外层ViewGroup的draw():其中会先后调用background.draw()(绘制背景)、onDraw()(绘制自己)、dispatchDraw()(绘制子View)、onDrawScrollBars()(绘制装饰)。 5.MeasureSpec由2位SpecMode(UNSPECIFIED、EXACTLY(对应精确值和match_parent)、AT_MOST(对应warp_content))和30位SpecSize组成一个int,DecorView的MeasureSpec由窗口大小和其LayoutParams决定，其他View由父View的MeasureSpec和本View的LayoutParams决定。ViewGroup中有getChildMeasureSpec()来获取子View的MeasureSpec。 6.三种方式获取measure()后的宽高： 1.Activity#onWindowFocusChange()中调用获取 2.view.post(Runnable)将获取的代码投递到消息队列的尾部。 3.ViewTreeObservable. 自定义 View 的绘制顺序 3.android四大组件的加载过程，请详细介绍下 1.android四大组件的加载过程:这是我总结的一篇博客 4.Activity的启动模式 1.standard:默认标准模式，每启动一个都会创建一个实例， 2.singleTop：栈顶复用，如果在栈顶就调用onNewIntent复用，从onResume()开始 3.singleTask：栈内复用，本栈内只要用该类型Activity就会将其顶部的activity出栈 4.singleInstance：单例模式，除了3中特性，系统会单独给该Activity创建一个栈， 5.A、B、C、D分别是四种Activity的启动模式，那么A-&gt;B-&gt;C-&gt;D-&gt;A-&gt;B-&gt;C-&gt;D分别启动，最后的activity栈是怎么样的 1.这个题目需要深入了解activity的启动模式 2.最后的答案是：两个栈，前台栈是只有D，后台栈从底至上是A、B、C 6.Activity缓存方法 1.配置改变导致Activity被杀死，横屏变竖屏：在onStop之前会调用onSaveInstanceState()保存数据在重建Activity之后，会在onStart()之后调用onRestoreInstanceState(),并把保存下来的Bundle传给onCreate()和它会默认重建Activity当前的视图，我们可以在onCreate()中，回复自己的数据。 2.内存不足杀掉Activity，优先级分别是：前台可见，可见非前台，后台。 7.Service的生命周期，两种启动方法，有什么区别 1.context.startService() -&gt;onCreate()- &gt;onStart()-&gt;Service running–&gt;(如果调用context.stopService() )-&gt;onDestroy() -&gt;Service shut down 1.如果Service还没有运行，则调用onCreate()然后调用onStart()； 2.如果Service已经运行，则只调用onStart()，所以一个Service的onStart方法可能会重复调用多次。 3.调用stopService的时候直接onDestroy， 4.如果是调用者自己直接退出而没有调用stopService的话，Service会一直在后台运行。该Service的调用者再启动起来后可以通过stopService关闭Service。 2.context.bindService()-&gt;onCreate()-&gt;onBind()-&gt;Service running–&gt;onUnbind() -&gt; onDestroy() -&gt;Service stop 1.onBind将返回给客户端一个IBind接口实例，IBind允许客户端回调服务的方法，比如得到Service运行的状态或其他操作。 2.这个时候会把调用者和Service绑定在一起，Context退出了,Service就会调用onUnbind-&gt;onDestroy相应退出。 3.所以调用bindService的生命周期为：onCreate –&gt; onBind(只一次，不可多次绑定) –&gt; onUnbind –&gt; onDestory。 8.怎么保证service不被杀死 1.提升service优先级 2.提升service进程优先级 3.onDestroy方法里重启service 9.静态的Broadcast 和动态的有什么区别 1.动态的比静态的安全 2.静态在app启动的时候就初始化了 动态使用代码初始化 3.静态需要配置 动态不需要 4.生存期，静态广播的生存期可以比动态广播的长很多 5.优先级动态广播的优先级比静态广播高 10.Intent可以传递哪些数据类型 1.Serializable 2.charsequence: 主要用来传递String，char等 3.parcelable 4.Bundle 11.Json有什么优劣势、解析的原理 1.JSON的速度要远远快于XML 2.JSON相对于XML来讲，数据的体积小 3.JSON对数据的描述性比XML较差 4.解析的基本原理是：词法分析 12.一个语言的编译过程 1.词法分析：将一串文本按规则分割成最小的结构，关键字、标识符、运算符、界符和常量等。一般实现方法是自动机和正则表达式 2.语法分析：将一系列单词组合成语法树。一般实现方法有自顶向下和自底向上 3.语义分析：对结构上正确的源程序进行上下文有关性质的审查 4.目标代码生成 5.代码优化：优化生成的目标代码， 13.动画有哪几类，各有什么特点 1.动画的基本原理：其实就是利用插值器和估值器，来计算出各个时刻View的属性，然后通过改变View的属性来，实现View的动画效果。 2.View动画:只是影像变化，view的实际位置还在原来的地方。 3.帧动画是在xml中定义好一系列图片之后，使用AnimationDrawable来播放的动画。 4.View的属性动画： 1.插值器：作用是根据时间的流逝的百分比来计算属性改变的百分比 2.估值器：在1的基础上由这个东西来计算出属性到底变化了多少数值的类 14.Handler、Looper消息队列模型，各部分的作用 1.MessageQueue：读取会自动删除消息，单链表维护，在插入和删除上有优势。在其next()中会无限循环，不断判断是否有消息，有就返回这条消息并移除。 2.Looper：Looper创建的时候会创建一个MessageQueue，调用loop()方法的时候消息循环开始，loop()也是一个死循环，会不断调用messageQueue的next()，当有消息就处理，否则阻塞在messageQueue的next()中。当Looper的quit()被调用的时候会调用messageQueue的quit(),此时next()会返回null，然后loop()方法也跟着退出。 3.Handler：在主线程构造一个Handler，然后在其他线程调用sendMessage(),此时主线程的MessageQueue中会插入一条message，然后被Looper使用。 4.系统的主线程在ActivityThread的main()为入口开启主线程，其中定义了内部类Activity.H定义了一系列消息类型，包含四大组件的启动停止。 5.MessageQueue和Looper是一对一关系，Handler和Looper是多对一 15.怎样退出终止App 1.自己设置一个Activity的栈，然后一个个finish() 16.Android IPC:Binder原理 1.在Activity和Service进行通讯的时候，用到了Binder。 1.当属于同个进程我们可以继承Binder然后在Activity中对Service进行操作 2.当不属于同个进程，那么要用到AIDL让系统给我们创建一个Binder，然后在Activity中对远端的Service进行操作。 2.系统给我们生成的Binder： 1.Stub类中有:接口方法的id，有该Binder的标识，有asInterface(IBinder)(让我们在Activity中获取实现了Binder的接口，接口的实现在Service里，同进程时候返回Stub否则返回Proxy)，有onTransact()这个方法是在不同进程的时候让Proxy在Activity进行远端调用实现Activity操作Service 2.Proxy类是代理，在Activity端，其中有:IBinder mRemote(这就是远端的Binder)，两个接口的实现方法不过是代理最终还是要在远端的onTransact()中进行实际操作。 3.哪一端的Binder是副本，该端就可以被另一端进行操作，因为Binder本体在定义的时候可以操作本端的东西。所以可以在Activity端传入本端的Binder，让Service端对其进行操作称为Listener，可以用RemoteCallbackList这个容器来装Listener，防止Listener因为经历过序列化而产生的问题。 4.当Activity端向远端进行调用的时候，当前线程会挂起，当方法处理完毕才会唤醒。 5.如果一个AIDL就用一个Service太奢侈，所以可以使用Binder池的方式，建立一个AIDL其中的方法是返回IBinder，然后根据方法中传入的参数返回具体的AIDL。 6.IPC的方式有：Bundle（在Intent启动的时候传入，不过是一次性的），文件共享(对于SharedPreference是特例，因为其在内存中会有缓存)，使用Messenger(其底层用的也是AIDL，同理要操作哪端，就在哪端定义Messenger)，AIDL，ContentProvider(在本进程中继承实现一个ContentProvider，在增删改查方法中调用本进程的SQLite，在其他进程中查询)，Socket 17.描述一次跨进程通讯 1.client、proxy、serviceManager、BinderDriver、impl、service 2.client发起一个请求service信息的Binder请求到BinderDriver中，serviceManager发现BinderDiriver中有自己的请求 然后将clinet请求的service的数据返回给client这样完成了一次Binder通讯 3.clinet获取的service信息就是该service的proxy，此时调用proxy的方法，proxy将请求发送到BinderDriver中，此时service的 Binder线程池循环发现有自己的请求，然后用impl就处理这个请求最后返回，这样完成了第二次Binder通讯4.中间client可挂起，也可以不挂起，有一个关键字oneway可以解决这个 18.android重要术语解释 1.ActivityManagerServices，简称AMS，服务端对象，负责系统中所有Activity的生命周期 2.ActivityThread，App的真正入口。当开启App之后，会调用main()开始运行，开启消息循环队列，这就是传说中的UI线程或者叫主线程。与ActivityManagerServices配合，一起完成Activity的管理工作 3.ApplicationThread，用来实现ActivityManagerService与ActivityThread之间的交互。在ActivityManagerService需要管理相关Application中的Activity的生命周期时，通过ApplicationThread的代理对象与ActivityThread通讯。 4.ApplicationThreadProxy，是ApplicationThread在服务器端的代理，负责和客户端的ApplicationThread通讯。AMS就是通过该代理与ActivityThread进行通信的。 5.Instrumentation，每一个应用程序只有一个Instrumentation对象，每个Activity内都有一个对该对象的引用。Instrumentation可以理解为应用进程的管家，ActivityThread要创建或暂停某个Activity时，都需要通过Instrumentation来进行具体的操作。 6.ActivityStack，Activity在AMS的栈管理，用来记录已经启动的Activity的先后关系，状态信息等。通过ActivityStack决定是否需要启动新的进程。 7.ActivityRecord，ActivityStack的管理对象，每个Activity在AMS对应一个ActivityRecord，来记录Activity的状态以及其他的管理信息。其实就是服务器端的Activity对象的映像。 8.TaskRecord，AMS抽象出来的一个“任务”的概念，是记录ActivityRecord的栈，一个“Task”包含若干个ActivityRecord。AMS用TaskRecord确保Activity启动和退出的顺序。如果你清楚Activity的4种launchMode，那么对这个概念应该不陌生。 19.理解Window和WindowManager 1.Window用于显示View和接收各种事件，Window有三种类型：应用Window(每个Activity对应一个Window)、子Window(不能单独存在，附属于特定Window)、系统window(Toast和状态栏) 2.Window分层级，应用Window在1-99、子Window在1000-1999、系统Window在2000-2999.WindowManager提供了增删改View三个功能。 3.Window是个抽象概念：每一个Window对应着一个View和ViewRootImpl，Window通过ViewRootImpl来和View建立联系，View是Window存在的实体，只能通过WindowManager来访问Window。 4.WindowManager的实现是WindowManagerImpl其再委托给WindowManagerGlobal来对Window进行操作，其中有四个List分别储存对应的View、ViewRootImpl、WindowManger.LayoutParams和正在被删除的View 5.Window的实体是存在于远端的WindowMangerService中，所以增删改Window在本端是修改上面的几个List然后通过ViewRootImpl重绘View，通过WindowSession(每个应用一个)在远端修改Window。 6.Activity创建Window：Activity会在attach()中创建Window并设置其回调(onAttachedToWindow()、dispatchTouchEvent()),Activity的Window是由Policy类创建PhoneWindow实现的。然后通过Activity#setContentView()调用PhoneWindow的setContentView。 20.Bitmap的处理 1.当使用ImageView的时候，可能图片的像素大于ImageView，此时就可以通过BitmapFactory.Option来对图片进行压缩，inSampleSize表示缩小2^(inSampleSize-1)倍。 2.BitMap的缓存： 1.使用LruCache进行内存缓存。 2.使用DiskLruCache进行硬盘缓存。 3.实现一个ImageLoader的流程：同步异步加载、图片压缩、内存硬盘缓存、网络拉取 1.同步加载只创建一个线程然后按照顺序进行图片加载 2.异步加载使用线程池，让存在的加载任务都处于不同线程 3.为了不开启过多的异步任务，只在列表静止的时候开启图片加载 21.如何实现一个网络框架(参考Volley) 1.缓存队列,以url为key缓存内容可以参考Bitmap的处理方式，这里单独开启一个线程。 2.网络请求队列，使用线程池进行请求。 3.提供各种不同类型的返回值的解析如String，Json，图片等等。 22.ClassLoader的基础知识 1.双亲委托：一个ClassLoader类负责加载这个类所涉及的所有类，在加载的时候会判断该类是否已经被加载过，然后会递归去他父ClassLoader中找。 2.可以动态加载Jar通过URLClassLoader 3.ClassLoader 隔离问题 JVM识别一个类是由：ClassLoader id+PackageName+ClassName。 4.加载不同Jar包中的公共类： 1.让父ClassLoader加载公共的Jar，子ClassLoader加载包含公共Jar的Jar，此时子ClassLoader在加载公共Jar的时候会先去父ClassLoader中找。(只适用Java) 2.重写加载包含公共Jar的Jar的ClassLoader，在loadClass中找到已经加载过公共Jar的ClassLoader，也就是把父ClassLoader替换掉。(只适用Java) 3.在生成包含公共Jar的Jar时候把公共Jar去掉。 23.插件化框架描述：dynamicLoadApk为例子 1.可以通过DexClassLoader来对apk中的dex包进行加载访问 2.如何加载资源是个很大的问题，因为宿主程序中并没有apk中的资源，所以调用R资源会报错，所以这里使用了Activity中的实现ContextImpl的getAssets()和getResources()再加上反射来实现。 3.由于系统启动Activity有很多初始化动作要做，而我们手动反射很难完成，所以可以采用接口机制，将Activity的大部分生命周期提取成接口，然后通过代理Activity去调用插件Activity的生命周期。同时如果像增加一个新生命周期方法的时候，只需要在接口中和代理中声明一下就行。 4.缺点： 1.慎用this，因为在apk中使用this并不代表宿主中的activity，当然如果this只是表示自己的接口还是可以的。除此之外可以使用that代替this。 2.不支持Service和静态注册的Broadcast 3.不支持LaunchMode和Apk中Activity的隐式调用。 24.热修复：Andfix为例子 1.大致原理：apkpatch将两个apk做一次对比，然后找出不同的部分。可以看到生成的apatch了文件，后缀改成zip再解压开，里面有一个dex文件。通过jadx查看一下源码，里面就是被修复的代码所在的类文件,这些更改过的类都加上了一个_CF的后缀，并且变动的方法都被加上了一个叫@MethodReplace的annotation，通过clazz和method指定了需要替换的方法。然后客户端sdk得到补丁文件后就会根据annotation来寻找需要替换的方法。最后由JNI层完成方法的替换。 2.无法添加新类和新的字段、补丁文件很容易被反编译、加固平台可能会使热补丁功能失效 25.线程同步的问题，常用的线程同步 1.sycn：保证了原子性、可见性、有序性 2.锁：保证了原子性、可见性、有序性 1.自旋锁:可以使线程在没有取得锁的时候，不被挂起，而转去执行一个空循环。 1.优点:线程被挂起的几率减少，线程执行的连贯性加强。用于对于锁竞争不是很激烈，锁占用时间很短的并发线程。 2.缺点:过多浪费CPU时间，有一个线程连续两次试图获得自旋锁引起死锁 2.阻塞锁:没得到锁的线程等待或者挂起，Sycn、Lock 3.可重入锁:一个线程可多次获取该锁，Sycn、Lock 4.悲观锁:每次去拿数据的时候都认为别人会修改，所以会阻塞全部其他线程 Sycn、Lock 5.乐观锁:每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。cas 6.显示锁和内置锁:显示锁用Lock来定义、内置锁用synchronized。 7.读-写锁:为了提高性能，Java提供了读 3.volatile 1.只能保证可见性，不能保证原子性 2.自增操作有三步，此时多线程写会出现问题 4.cas 1.操作:内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做并返回false。 2.解释:本地副本为A，共享内存为V，线程A要把V修改成B。某个时刻线程A要把V修改成B，如果A和V不同那么就表示有其他线程在修改V，此时就表示修改失败，否则表示没有其他线程修改，那么把V改成B。 3.局限:如果V被修改成V1然后又被改成V，此时cas识别不出变化，还是认为没有其他线程在修改V，此时就会有问题 4.局限解决:将V带上版本。 5.线程不安全到底是怎么回事： 1.一个线程写，多个线程读的时候，会造成写了一半就去读 2.多线程写，会造成脏数据 26.Asynctask和线程池，GC相关（怎么判断哪些内存该GC，GC算法） 1.Asynctask：异步任务类，单线程线程池+Handler 2.线程池： 1.ThreadPoolExecutor：通过Executors可以构造单线程池、固定数目线程池、不固定数目线程池。 2.ScheduledThreadPoolExecutor：可以延时调用线程或者延时重复调度线程。 3.GC相关：重要 1.搜索算法： 1.引用计数 2.图搜索，可达性分析 2.回收算法： 1.标记清除复制：用于青年代 2.标记整理：用于老年代 3.堆分区： 1.青年区eden 80%、survivor1 10%、survivor2 10% 2.老年区 4.虚拟机栈分区： 1.局部变量表 2.操作数栈 3.动态链接 4.方法返回地址 5.GC Roots: 1.虚拟机栈(栈桢中的本地变量表)中的引用的对象 2.方法区中的类静态属性引用的对象 3.方法区中的常量引用的对象 4.本地方法栈中JNI的引用的对象 27.网络 1.ARP协议:在IP以太网中，当一个上层协议要发包时，有了该节点的IP地址，ARP就能提供该节点的MAC地址。 2.HTTP HTTPS的区别: 1.HTTPS使用TLS(SSL)进行加密 2.HTTPS缺省工作在TCP协议443端口 3.它的工作流程一般如以下方式: 1.完成TCP三次同步握手 2.客户端验证服务器数字证书，通过，进入步骤3 3.DH算法协商对称加密算法的密钥、hash算法的密钥 4.SSL安全加密隧道协商完成 5.网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改 3.http请求包结构，http返回码的分类，400和500的区别 1.包结构： 1.请求：请求行、头部、数据 2.返回：状态行、头部、数据 2.http返回码分类：1到5分别是，消息、成功、重定向、客户端错误、服务端错误 4.Tcp 1.可靠连接，三次握手，四次挥手 1.三次握手：防止了服务器端的一直等待而浪费资源，例如只是两次握手，如果s确认之后c就掉线了，那么s就会浪费资源 1.syn-c = x，表示这消息是x序号 2.ack-s = x + 1，表示syn-c这个消息接收成功。syn-s = y，表示这消息是y序号。 3.ack-c = y + 1，表示syn-s这条消息接收成功 2.四次挥手：TCP是全双工模式 1.fin-c = x , 表示现在需要关闭c到s了。ack-c = y,表示上一条s的消息已经接收完毕 2.ack-s = x + 1，表示需要关闭的fin-c消息已经接收到了，同意关闭 3.fin-s = y + 1，表示s已经准备好关闭了，就等c的最后一条命令 4.ack-c = y + 1，表示c已经关闭，让s也关闭 3.滑动窗口，停止等待、后退N、选择重传 4.拥塞控制，慢启动、拥塞避免、加速递减、快重传快恢复 28.数据库性能优化：索引和事务，需要找本专门的书大概了解一下29.13.APK打包流程和其内容 1.流程 1.aapt生成R文件 2.aidl生成java文件 3.将全部java文件编译成class文件 4.将全部class文件和第三方包合并成dex文件 5.将资源、so文件、dex文件整合成apk 6.apk签名 7.apk字节对齐 2.内容：so、dex、asset、资源文件 30.网络劫持的类型原理：可以百度一下了解一下具体概念 1.DNS劫持、欺骗、污染 2.http劫持：重定向、注入js，http注入、报文扩展 31.java类加载过程： 1.加载时机：创建实例、访问静态变量或方法、反射、加载子类之前 2.验证：验证文件格式、元数据、字节码、符号引用的正确性 3.加载：根据全类名获取文件字节流、将字节流转化为静态储存结构放入方法区、生成class对象 4.准备：在堆上为静态变量划分内存 5.解析：将常量池中的符号引用转换为直接引用 6.初始化：初始化静态变量 7.书籍推荐：深入理解java虚拟机，博客推荐：Java/Android阿里面试JVM部分理解 32.retrofit的了解 1.动态代理创建一个接口的代理类 2.通过反射解析每个接口的注解、入参构造http请求 3.获取到返回的http请求，使用Adapter解析成需要的返回值。 33.bundle的数据结构，如何存储 1.键值对储存 2.传递的数据可以是boolean、byte、int、long、float、double、string等基本类型或它们对应的数组，也可以是对象或对象数组。 3.当Bundle传递的是对象或对象数组时，必须实现Serializable 或Parcelable接口 34.listview内点击buttom并移动的事件流完整拦截过程： 1.点下按钮的时候： 1.产生了一个down事件，activity–&gt;phoneWindow–&gt;ViewGroup–&gt;ListView–&gt;botton,中间如果有重写了拦截方法，则事件被该view拦截可能消耗。 2.没拦截，事件到达了button，这个过程中建立了一条事件传递的view链表 3.到button的dispatch方法–&gt;onTouch–&gt;view是否可用–&gt;Touch代理 2.移动点击按钮的时候: 1.产生move事件，listView中会对move事件做拦截 2.此时listView会将该滑动事件消费掉 3.后续的滑动事件都会被listView消费掉 3.手指抬起来时候：前面建立了一个view链表，listView的父view在获取事件的时候，会直接取链表中的listView让其进行事件消耗。 35.service的意义：不需要界面，在后台执行的程序36.android的IPC通信方式，线程（进程间）通信机制有哪些 1.ipc通信方式：binder、contentprovider、socket 2.操作系统进程通讯方式：共享内存、socket、管道 37.操作系统进程和线程的区别 1.简而言之,一个程序至少有一个进程,一个进程至少有一个线程. 2.线程的划分尺度小于进程，使得多线程程序的并发性高。 3.另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 4.多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配 38.HashMap的实现过程：Capacity就是buckets的数目，Load factor就是buckets填满程度的最大比例。如果对迭代性能要求很高的话不要把capacity设置过大，也不要把load factor设置过小。 1.简单来说HashMap就是一个会自动扩容的数组链表 2.put过程 1.对key的hashCode()做hash，然后再计算index; 2.如果没碰撞直接放到bucket里； 3.如果碰撞了，以链表的形式存在buckets后； 4.如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树； 5.如果节点已经存在就替换old value(保证key的唯一性) 6.如果bucket满了(超过load factor*current capacity)，就要resize。 3.resize：当put时，如果发现目前的bucket占用程度已经超过了Load Factor所希望的比例，那么就会发生resize。在resize的过程，简单的说就是把bucket扩充为2倍，之后重新计算index，把节点再放到新的bucket中 4.get过程 1.根据key的hash算出数组下表 2.使用equals遍历链表进行比较 39.mvc、mvp、mvvm： 1.mvc:数据、View、Activity，View将操作反馈给Activity，Activitiy去获取数据，数据通过观察者模式刷新给View。循环依赖 1.Activity重，很难单元测试 2.View和Model耦合严重 2.mvp:数据、View、Presenter，View将操作给Presenter，Presenter去获取数据，数据获取好了返回给Presenter，Presenter去刷新View。PV，PM双向依赖 1.接口爆炸 2.Presenter很重 3.mvvm:数据、View、ViewModel，View将操作给ViewModel，ViewModel去获取数据，数据和界面绑定了，数据更新界面更新。 1.viewModel的业务逻辑可以单独拿来测试 2.一个view 对应一个 viewModel 业务逻辑可以分离，不会出现全能类 3.数据和界面绑定了，不用写垃圾代码，但是复用起来不舒服 40.java的线程如何实现 1.Thread继承 2.Runnale 3.Future 4.线程池 41.ArrayList 如何删除重复的元素或者指定的元素； 1.删除重复：Set 2.删除指定：迭代器 42.如何设计在 UDP 上层保证 UDP 的可靠性传输； 1.简单来讲，要使用UDP来构建可靠的面向连接的数据传输，就要实现类似于TCP协议的超时重传，有序接受，应答确认，滑动窗口流量控制等机制,等于说要在传输层的上一层（或者直接在应用层）实现TCP协议的可靠数据传输机制。 2.比如使用UDP数据包+序列号，UDP数据包+时间戳等方法，在服务器端进行应答确认机制，这样就会保证不可靠的UDP协议进行可靠的数据传输。 3.基于udp的可靠传输协议有：RUDP、RTP、UDT 43.Java 中内部类为什么可以访问外部类 1.因为内部类创建的时候，需要外部类的对象，在内部类对象创建的时候会把外部类的引用传递进去 44.设计移动端的联系人存储与查询的功能，要求快速搜索联系人，可以用到哪些数据结构？数据库索引，平衡二叉树(B树、红黑树)45.红黑树特点 1.root节点和叶子节点是黑色 2.红色节点后必须为黑色节点 3.从root到叶子每条路径的黑节点数量相同 46.linux异步和同步i/o: 1.同步：对于client，client一直等待，但是client不挂起：主线程调用 2.异步：对于client，client发起请求，service好了再回调client：其他线程调用，调用完成之后进行回调 3.阻塞：对于service，在准备io的时候会将service端挂起，直至准备完成然后唤醒service：bio 3.非阻塞：对于service，在准备io的时候不会将service端挂起，而是service一直去轮询判断io是否准备完成，准备完成了就进行操作：nio、linux的select、poll、epoll 4.多路复用io：非阻塞io的一种优化，java nio，用一个线程去轮询多个 io端口是否可用，如果一个可用就通知对应的io请求，这使用一个线程轮询可以大大增强性能。 1.我可以采用 多线程+ 阻塞IO 达到类似的效果，但是由于在多线程 + 阻塞IO 中，每个socket对应一个线程，这样会造成很大的资源占用。 2.而在多路复用IO中，轮询每个socket状态是内核在进行的，这个效率要比用户线程要高的多。 5.异步io：aio，用户线程完全不感知io的进行，所有操作都交给内核，io完成之后内核通知用户线程。 1.这种io才是异步的，2、3、4都是同步io，因为内核进行数据拷贝的过程都会让用户线程阻塞。 2.异步IO是需要操作系统的底层支持，也就是内核支持，Java 7中，提供了Asynchronous IO 47.ConcurrentHashMap内部实现，HashTable的实现被废弃的原因: 1.HashTable容器在竞争激烈的并发环境下表现出效率低下的原因，是因为所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。 2.ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。 48.HandlerThread是什么 1.MessageQueue + Looper + Handler 49.IntentService是什么 1.含有HandlerThread的Service，可以多次startService()来多次在子线程中进行 onHandlerIntent()的调用。 50.class和dex 1.dvm执行的是dex格式文件，jvm执行的是class文件，android程序编译完之后生产class文件。然后dex工具会把class文件处理成dex文件，然后把资源文件和.dex文件等打包成apk文件。 2.dvm是基于寄存器的虚拟机，而jvm执行是基于虚拟栈的虚拟机。寄存器存取速度比栈快的多，dvm可以根据硬件实现最大的优化，比较适合移动设备。 3.class文件存在很多的冗余信息，dex工具会去除冗余信息，并把所有的class文件整合到dex文件中。减少了I/O操作，提高了类的查找速度 51.内存泄漏 1.其他线程持有一个Listener，Listener操作activity。那么在线程么有完毕的时候，activity关闭了，原本是要被回收的但是，不能被回收。 2.例如Handler导致的内存泄漏，Handler就相当于Listener。 3.在activity关闭的时候注意停止线程，或者将Listener的注册取消 3.使用弱引用，这样即使Listener持有了activity，在GC的时候还是会被回收 4.工具:LeakCanary 52.过度绘制、卡顿优化: 1.过度绘制： 1.移除Window默认的Background：getWidow.setBackgroundDrawable(null); 2.移除XML布局文件中非必需的Background 3.减少布局嵌套(扁平化的一个体现，减少View数的深度，也就减少了View树的遍历时间，渲染的时候，前后期的工作，总是按View树结点来) 4.在引入布局文件里面，最外层可以用merge替代LinearLayout,RelativeLayout，这样把子UI元素直接衔接在include位置 5.工具：HierarchyViewer 查看视图层级 2.卡顿优化：16ms数据更新 53.apk瘦身: 1.classes.dex：通过代码混淆，删掉不必要的jar包和代码实现该文件的优化 2.资源文件：通过Lint工具扫描代码中没有使用到的静态资源 3.图片资源：使用tinypng和webP，下面详细介绍图片资源优化的方案,矢量图 4.SO文件将不用的去掉，目前主流app一般只放一个arm的so包 54.ANR的形成，各个组件上出现ARN的时间限制是多少 1.只要是主线程耗时的操作就会ARN 如io 2.broadcast超时时间为10秒 按键无响应的超时时间为5秒 前台service无响应的超时时间为20秒，后台service为200秒 55.Serializable和Parcelable 的区别 1.P 消耗内存小 2.网络传输用S 程序内使用P 3.S将数据持久化方便 4.S使用了反射 容易触发垃圾回收 比较慢 56.Sharedpreferences源码简述 1.储存于硬盘上的xml键值对，数据多了会有性能问题 2.ContextImpl记录着SharedPreferences的重要数据，文件路径和实例的键值对 3.在xml文件全部内加载到内存中之前，读取操作是阻塞的，在xml文件全部内加载到内存中之后，是直接读取内存中的数据 4.apply因为是异步的没有返回值, commit是同步的有返回值能知道修改是否提交成功 5.多并发的提交commit时，需等待正在处理的commit数据更新到磁盘文件后才会继续往下执行，从而降低效率; 而apply只是原子更新到内存，后调用apply函数会直接覆盖前面内存数据，从一定程度上提高很多效率。 3.edit()每次都是创建新的EditorImpl对象. 6.博客推荐：**全面剖析SharedPreferences** 57.操作系统如何管理内存的： 1.使用寄存器进行将进程地址和物理内存进行映射 2.虚拟内存进行内存映射到硬盘上增大内存 3.虚拟内存是进行内存分页管理 4.页表实现分页，就是 页+地址偏移。 5.如果程序的内存在硬盘上，那么就需要用页置换算法来将其调入内存中：先进先出、最近未使用最少等等 6.博客推荐：**现代操作系统部分章节笔记** 58.浏览器输入地址到返回结果发生了什么 1.DNS解析 2.TCP连接 3.发送HTTP请求 4.服务器处理请求并返回HTTP报文 5.浏览器解析渲染页面 6.连接结束 59.java泛型类型擦除发生在什么时候，通配符有什么需要注意的。 1.发生在编译的时候 2.PECS，extends善于提供精确的对象 A是B的子集，Super善于插入精确的对象 A是B的超集 3.博客推荐：**Effective Java笔记（不含反序列化、并发、注解和枚举）、android阿里面试java基础锦集** 60.activity的生命周期 1.a启动b，后退键再到a的生命周期流程：a.create–&gt;a.start–&gt;a.resume–&gt;a.pause–&gt;b.create–&gt;b.start–&gt;b.resume–&gt;b界面绘制–&gt;a.stop–&gt;b.pause–&gt;b.stop–&gt;b.destroy–&gt;a.restart–&gt;a.start–&gt;a.resume 2.意外销毁会调用saveInstance，重新恢复的时候回调用restoreInstance。储存数据的时候使用了委托机制，从activity–&gt;window–&gt;viewGroup–&gt;view 会递归调用save来保持本view的数据，restore则是递归恢复本view数据。我们可以在里面做一些自己需要的数据操作。 61.面试常考的算法 1.快排、堆排序为首的各种排序算法 2.链表的各种操作：判断成环、判断相交、合并链表、倒数K个节点、寻找成环节点 3.二叉树、红黑树、B树定义以及时间复杂度计算方式 4.动态规划、贪心算法、简单的图论 5.推荐书籍：算法导论，将图论之前的例子写一遍 62.Launcher进程启动另外一个进程的过程：启动一个app63.开源框架源码 1.Fresco 1.mvc框架： 1.Controller控制数据显示在Hierarchy中的Drawable的显隐 2.ImagePipeline在Controller中负责进行数据获取，返回的数据是CloseableImage 3.Drawee把除了初始化之外的操作全部交给Holder去做，Holder持有Controller和Hierarchy 2.Drawable层次以及绘制： 1.如果要绘制一次Drawable就调用invalidateSelf()来触发onDraw() 2.Drawable分为：容器类(保存一些Drawable)、自我绘制类(进度条)、图形变换类(scale、rotate、矩阵变换)、动画类(内部不断刷新，进行webp和gif的帧绘制) 3.ImagePipeline返回的CloseableImage是由一个个DrawableFactory解析成Drawable的 4.webp和gif动画是由jni代码解析的，然后其他静态图片是根据不同的android平台使用BitmapFactory来解析的 3.职责链模式：producer不做操作标n，表示只是提供一个consumer。获取图片–》解码图片缓存Producer–》后台线程Producer–》client图片处理producer(n)–》解码producer(n)–》旋转或剪裁producer(n)–》编码图片内存缓存producer–》读硬盘缓存producer–》写硬盘缓存producer(n)–》网络producer提供CloseableImage《–解码图片缓存consumer《–client图片处理consumer《–解码consumer《–旋转或剪裁consumer《–编码图片内存缓存consumer《–写硬盘缓存consumer《–图片数据 4.内存缓存： 1.一个CountingLruMap保存已经没有被引用的缓存条目，一个CountingLruMap保存所有的条目包括没有引用的条目。每当缓存策略改变和一定时间缓存配置的更新的时候，就会将 待销毁条目Map中的条目一个个移除，直到缓存大小符合配置。 2.这里的引用计数是用Fresco组件实现的引用计数器。 3.缓存有一个代理类，用来追踪缓存的存取。 4.CountingLruMap是使用LinkedHashMap来储存数据的。 5.硬盘缓存： 1.DefaultDiskStorage使用Lru策略。 2.为了不让所有的文件集中在一个文件中，创建很多命名不同的文件夹，然后使用hash算法把缓存文件分散 3.DiskStorageCache封装了DefaultDiskStorage，不仅进行缓存存取追踪，并且其在内存里面维持着一个 &lt;key,value&gt; 的键值对，因为文件修改频繁，所有只是定时刷新，因此如果在内存中找不到，还要去硬盘中找一次。 4.删除硬盘的缓存只出现在硬盘数据大小超限的时候，此时同时也会删除缓存中的key，所以不会出现内存中有key，但是硬盘上没有的情况。 5.在插入硬盘数据的时候，采用的是插入器的形式。返回一个Inserter，在Inserter.writeData()中传入一个CallBack(里面封装了客户端插入数据的逻辑和文件引用)，让内部实现调用CallBack的逻辑来插入文件数据，前面写的文件后缀是.temp,只有调用commit()之后才会修改后缀，让文件对客户端可见。 6.使用了java提供的FileTreeVisitor来遍历文件 6.对象池： 1.使用数组来存储一个桶，桶内部是一个Queue。数组下标是数据申请内存的byte大小，桶内部的Queue存的是内存块的。所以数组使用的是稀疏数组 2.申请内存的方式有两种 1.java堆上开辟的内存 2.ashme 的本地内存中开辟的内存 7.设计模式：Builder、职责链、观察者、代理、组合、享元、适配器、装饰者、策略、生产者消费者、提供者 8.自定义计数引用：类似c++智能指针 1.使用一个静态IdentityHashMap &lt;储存需要被计数引用的对象,其被引用的次数&gt; 2.用SharedReference分装需要被计数引用的对象，提供一个销毁资源的销毁器，提供一个静态工厂方法来复制自己，复制一个引用计数加一。提供一个方法销毁自己，表示自己需要变成无人引用的对象了，此时引用计数减一。 3.引用计数归零，销毁器将销毁资源，如bitmap的recycle或者是jni内存调用jni方法归还内存。 9.博客推荐：**Android Fresco源码文档翻译、从零开始撸一个Fresco之硬盘缓存、从零开始撸一个Fresco之gif和Webp动画、从零开始撸一个Fresco之内存缓存、从零开始撸一个Fresco之总结** 2.oKhttp： 1.同步和异步： 1.异步使用了Dispatcher来将存储在 Deque 中的请求分派给线程池中各个线程执行。 2.当任务执行完成后，无论是否有异常，finally代码段总会被执行，也就是会调用Dispatcher的finished函数，它将正在运行的任务Call从队列runningAsyncCalls中移除后，主动的把缓存队列向前走了一步。 2.连接池： 1.一个Connection封装了一个socket，ConnectionPool中储存s着所有的Connection，StreamAllocation是引用计数的一个单位 2.当一个请求获取一个Connection的时候要传入一个StreamAllocation，Connection中存着一个弱引用的StreamAllocation列表，每当上层应用引用一次Connection，StreamAllocation就会加一个。反之如果上层应用不使用了，就会删除一个。 3.ConnectionPool中会有一个后台任务定时清理StreamAllocation列表为空的Connection。5分钟时间，维持5个socket 3.选择路线与建立连接 1.选择路线有两种方式： 1.无代理，那么在本地使用DNS查找到ip，注意结果是数组，即一个域名有多个IP，这就是自动重连的来源 2.有代理HTTP：设置socket的ip为代理地址的ip，设置socket的端口为代理地址的端口 3.代理好处：HTTP代理会帮你在远程服务器进行DNS查询，可以减少DNS劫持。 2.建立连接 1.连接池中已经存在连接，就从中取出(get)RealConnection，如果没有命中就进入下一步 2.根据选择的路线(Route)，调用Platform.get().connectSocket选择当前平台Runtime下最好的socket库进行握手 3.将建立成功的RealConnection放入(put)连接池缓存 4.如果存在TLS，就根据SSL版本与证书进行安全握手 5.构造HttpStream并维护刚刚的socket连接，管道建立完成 4.职责链模式：缓存、重试、建立连接等功能存在于拦截器中网络请求相关，主要是网络请求优化。网络请求的时候遇到的问题 5.博客推荐：**Android数据层架构的实现 上篇、Android数据层架构的实现 下篇** 3.okio 1.简介； 1.sink：自己–》别人 2.source：别人–》自己 3.BufferSink：有缓存区域的sink 4.BufferSource：有缓存区域的source 5.Buffer：实现了3、4的缓存区域，内部有Segment的双向链表，在在转移数据的时候，只需要将指针转移指向就行 2.比java io的好处： 1.减少内存申请和数据拷贝 2.类少，功能齐全，开发效率高 3.内部实现： 1.Buffer的Segment双向链表，减少数据拷贝 2.Segment的内部byte数组的共享，减少数据拷贝 3.SegmentPool的共享和回收Segment 4.sink和source中被实际操作的其实是Buffer，Buffer可以充当sink和source 5.最终okio只是对java io的封装，所有操作都是基于java io 的 写在最后:能看到这里的人,我挺佩服你的.这篇文章是我在头条面试之前整理的,最后**80%**的题目都命中了,所以祝你好运. 不贩卖焦虑，也不标题党。分享一些这个世界上有意思的事情。题材包括且不限于：科幻、科学、科技、互联网、程序员、计算机编程。下面是我的微信公众号：世界上有意思的事，干货多多等你来看。 作者：何时夕链接：https://www.jianshu.com/p/cf5092fa2694来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 百度面试题电话面试 1234561. 安卓View绘制流程2. 事件分发机制3. JAVA基础思想4. 多线程和安全问题5. 安卓性能优化和兼容问题6. 再问一下常规的组件相关问题 现场笔试 1234567891011121314151617181920212223242526272829303132331 请描述安卓四大组建之间的关系，并说下安卓MVC的设计模式。2 线程中sleep()和wait()有和却别，各有什么含义 3 abstract和interface的区别?4 array,arrayList, List ,三者有何区别？5 hashtable和hashmap的区别,并简述Hashmap的实现原理6 StringBuilder和],String ,subString方法的细微差别 7 请写出四种以上你知道的设计模式，并介绍下实现原理 8 安卓子线程是否能更新UI，如果能请说明具体细节。9 ANR产生的原因和解决步骤10 JavaGC机制的原理和内存泄露11 安卓布局优化方案， 12 请在100个电话号码找出135的电话号码 注意 不能用正则，（类似怎么最好的遍历LogGat日志）13 Handler机制，请写出一种更新UI的方法和代码14 请解释安卓为啥要加签名机制。15 你觉得安卓开发最关键的技术在哪里？13 Handler机制，请写出一种更新UI的方法和代码14 请解释安卓为啥要加签名机制。15 你觉得安卓开发最关键的技术在哪里？ 一轮面试： 12345678910111213141516171819202122232425262728291 ANR 具体产生的类型有哪些，具体说下其产生的最大超时时间。2 多线程多点下载的过程3 http协议的理解和用法4 安卓解决线程并发问题5 你知道的数据结构有哪些，说下具体实现机制6 十六进制数据怎么和十进制和二进制之间转换7 谈下对Java OOP中多态的理解8 activty和Fragmengt之间怎么通信，Fragmengt和Fragmengt怎么通信9 怎么让自己的进程不被第三方应用杀掉，系统杀掉之后怎么能启动起来。10 说下平时开发中比较注意的一些问题， 答 ：可以熟说下svn和git的细节，和代码规范问题，和一些安全信息的问题等11 自定义view效率高于xml定义吗？说明理由。13 广播注册一般有几种，各有什么优缺点14 服务启动一般有几种，服务和activty之间怎么通信，服务和服务之间怎么通信15 布局优化主要哪些？具体优化？16 数据库的知识，包括本地数据库优化点。 二轮面试 123456789101112131415161718192021222324252627282930313233343536371 安卓事件分发机制，请详细说下整个流程2 安卓view绘制机制和加载过程，请详细说下整个流程3 activty的加载过程 请详细介绍下（不是生命周期切记）4 安卓采用自动垃圾回收机制，请说下安卓内存管理的原理 5 说下安卓虚拟机和java虚拟机的原理和不同点 6 多线程中的安全队列一般通过什么实现？线程池原理？（java）7 安卓权限管理，为何在清单中注册权限，安卓APP就可以使用，反之不可以（操作系统）8 socket短线重连怎么实现，心跳机制又是怎样实现，四次握手步骤有哪些（网络通讯原理）9 http中TCP和UDP有啥区别，说下HTTP请求的IP报文结构（计算机网络）10 你知道的安全加密有哪些？ （如果你说了一个加密，面试官就会接着跟进提问，所以之前你必须要会，不会的话背也要背下来）（安全加密）11 你知道的数据存储结构？堆栈和链表内部机制。（数据结构）12 说下Linux进程和线程的区别。进程调度优先级，和cpu调度进程关系。（操作系统） 13 请你详细说下你知道的一种设计模式，并解释下java的高内聚和低耦合。14 spring 的反射和代理，在安卓中应用场景（插件和ROM数据框架）15 JNI 调用过程中 混淆问题16 看过安卓源码吗，请说出一个你看过的API或者组建内部原理。17 android 5.0 6.0 以及7.0预测新特性18 hybrid混合开发，响应式编程等17为啥离职呢 对待加班看法18 你擅长什么，做了那些东西。 名企面试题Android基础 [Android 源码中的设计模式(你需要知道的设计模式全在这里)](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android 源码中的设计模式(你需要知道的设计模式全在这里).md) 全面了解Activity Service全面总结 IntentService使用详解和实例介绍 [Fragment 全解析](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Fragment 全解析.md) ContentProvider实例详解 BroadcastReceiver使用总结 Android异步任务机制之AsycTask Android启动过程图解 [Android 自定义View入门](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android 自定义View入门.md) [Android 自定义ViewGroup入门实践](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android 自定义ViewGroup入门实践.md) [Android 缓存机制](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android 缓存机制.md) [Android 数据存储五种方式使用与总结](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android 数据存储五种方式使用与总结.md) [Android 异步消息处理机制源码解析](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android 异步消息处理机制（Handler 、 Looper 、MessageQueue）源码解析.md) [Android View事件分发机制源码分析](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android View事件分发机制源码分析.md) [Android SQLite的使用入门](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android SQLite的使用入门.md) AIDL的使用情况和实例介绍 [Android 名企面试题及答案整理（一）](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android 名企面试题及答案整理（一）.md) 问题 Android5.0、6.0、7.0新特性 Android中弱引用与软引用的应用场景 Android长连接，怎么处理心跳机制 Asset目录与res目录的区别 Binder机制原理和底层实现 Json优劣势 ListView优化 android中图片缓存 两类动画 五大布局易混淆知识 保证service不被杀死 加速启动activity 怎样退出终止App activity切换动画 外链 布局性能优化(include, viewstub, merge) DOM、SAX、Pull解析XML Java基础 [ArrayList、LinkedList、Vector的区别](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] ArrayList、LinkedList、Vector的区别.md) [Collection包结构，与Collections的区别](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] Collection包结构，与Collections的区别.md) [Excption与Error包结构,OOM和SOF](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] Excption与Error包结构%2COOM和SOF.md) [HashMap和HashTable的区别](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] HashMap和HashTable的区别.md) [HashMap源码分析](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] HashMap源码分析.md) [Hashcode的作用](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] Hashcode的作用.md) [Map、Set、List、Queue、Stack的特点与用法](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] Map、Set、List、Queue、Stack的特点与用法.md) [Object有哪些公用方法？](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] Object有哪些公用方法？.md) [Override和Overload的使用规则和区别](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] Override和Overload的使用规则和区别.md) [Switch能否用string做参数？](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] Switch能否用string做参数？.md) [ThreadLocal的使用规则和源码分析](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] ThreadLocal的使用规则和源码分析.md) [ThreadPool用法与示例](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] ThreadPool用法与示例.md) [equals与==的区别](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] equals与%3D%3D的区别.md) [try catch finally，try里有return，finally还执行么？](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] try catch finally，try里有return，finally还执行么？.md) [九种基本数据类型的大小，以及他们的封装类](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] 九种基本数据类型的大小，以及他们的封装类.md) [从源码分析String、StringBuffer与StringBuilder区别和联系](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] 从源码分析String、StringBuffer与StringBuilder区别和联系.md) [多线程下生产者消费者问题的五种同步方法实现](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] 多线程下生产者消费者问题的五种同步方法实现.md) [实现多线程的两种方法](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] 实现多线程的两种方法.md) [接口（Interface）与 抽象类 （Abstract）使用规则和区别](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] 接口（Interface）与 抽象类 （Abstract）使用规则和区别.md) [方法锁、对象锁和类锁的意义和区别](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] 方法锁、对象锁和类锁的意义和区别.md) [四种引用，强弱软虚，用到的场景](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] 的四种引用，强弱软虚，用到的场景.md) [线程同步的方法：sychronized、lock、reentrantLock分析](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] 线程同步的方法：sychronized、lock、reentrantLock分析.md) [集合框架的层次结构和使用规则梳理](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] 集合框架的层次结构和使用规则梳理.md) [面向对象的三个特征与含义](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java] 面向对象的三个特征与含义.md) [static的作用和意义](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[java] static的作用和意义.md) [多态实现的JVM调用过程](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[java] 多态实现的JVM调用过程.md) wait()和sleep()的区别 git命令使用 Java与C++对比 外链 java反射 java回调 Java泛型 java 新特性 Java IO与NIO foreach与正常for循环效率对比 [数据结构](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/tree/master/data structure)基础 [九大基础排序总结与对比(排序算法一网打尽)](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data structure/[数据结构] 九大基础排序总结与对比.md) [AVL树和AVL旋转、哈夫曼树和哈夫曼编码](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data structure/[数据结构] AVL树和AVL旋转、哈夫曼树和哈夫曼编码.md) [B(B-)树、B+树、B树](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data structure/[数据结构] B(B-)树、B%2B树、B树.md) [Hash表、Hash函数及冲突解决](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data structure/[数据结构] Hash表、Hash函数及冲突解决.md) [KMP的一个简单解释](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data structure/[数据结构] KMP的一个简单解释.md) [二分查找与变种二分查找](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data structure/[数据结构] 二分查找与变种二分查找.md) [二叉树前中后、层次遍历算法](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data structure/[数据结构] 二叉树前中后、层次遍历算法.md) [图的BFS、DFS、prim、Dijkstra算法](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data structure/[数据结构] 图的BFS、DFS、prim、Dijkstra算法.md) [字符串操作](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data structure/[数据结构] 字符串操作.md) [数组与链表的优缺点和区别](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data structure/[数据结构] 数组与链表的优缺点和区别.md) [红黑树](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data structure/[数据结构] 红黑树.md) [队列和栈](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data structure/[数据结构] 队列和栈.md) 外链 海量数据处理 算法基础 二叉搜索树与双向链表 [二叉树中 和为某值 的所有路径](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/二叉树中 和为某值 的所有路径.md) 二叉树的镜像 二维数组中的查找 二进制中1的个数 从上往下打印二叉树 从尾到头打印链表 判断二叉搜索树的后序遍历序列 判断栈的弹出序列 判断树B是不是树A的子结构 包含min函数的栈 反转链表 变态跳台阶 合并两个排序链表 复杂链表的复制 字符串中空格替换 字符串的顺序全排列 数组中出现次数超过一半的数字 斐波那契数列 旋转数组的最小数字 浮点数的整数次方 用两个栈实现队列 矩形覆盖 调整数组顺序使奇数位于偶数前面 跳台阶 重建二叉树 链表中倒数第k个结点 顺时针打印矩阵 外链 分治算法 动态规划 贪心算法 分支限界法 作者：菜刀文链接：https://www.jianshu.com/p/735be5ece9e8来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 面试和必备的技能这里只简单列举一些东西，可能不是特别全，但是却特别适用，也不一定按照下面的流程，有可能是穿插的，也有可能都有，根据公司的规模以及面试官的心情而定（哈哈哈 ，你们就自求多福吧）。建议大家还是要将下面的东西全部掌握，没事写写代码，练练手，在项目中能用到的地方一定要用，有可能会遇到很多坑，一定要自己想办法填坑，之后回忆起这段经历，肯定可以敢理直气壮的跟别人讨论。如果你说的头头是道，那么对方会先输一层，然后在心里对你佩服。 一般情况下第一轮都是基础面试，需要扎实的基础 最常用的Android 基础知识 Java 基础知识 了解一些 常用东西的原理，例如：handler， thread 等 项目中的技术点 第二轮的时候需要了解更深层次的东西 Android 事件分发机制原理 Android 绘图机制原理 WindowManager 的相关知识 进程间传输方式 Java 内存管理机制 一些常用的 list,map 原理，以及子类之间的差别 能进入第三轮基本没什么问题，但是要注意以下问题 该轮一般是 老大或者部门负责人，问的问题一般都看 深度与广度 当问及薪水的时候，要说一个合适的，小公司随意，大公司一定要慎重，当心里没底的时候，可以告诉对方，让对方给一个合理的薪资。一般都是在原工资基础之上增长，听猎头说一般涨幅都在15%-30%，超 NB 的可以要30%及以上，如果感觉自己还不错的，挺厉害的，建议最高20%，一般人就定在15% 左右最靠谱。公司内部一般有一套机制，根据公司情况而定。 我们的面试原则就是拿到合理薪资，得到 offer 个人发展情况，这个问题很难回答，如果和公司方向不符合，极有可能和公司无缘。建议多试探性的问问公司缺少什么，你能否给予公司对应的东西。当然对于有自我追求的人，那可以放心大胆的提。我的方向就是架构师，哈哈哈，挺极端的，别学我哦。我感觉选择都是双向的，因此我知道自己需要的是什么。 你最擅长什么UI 还是其他什么？这个问题更不好回答。你要说你擅长 UI，是不是意味着你其他能力就不行？虽然我不知道面试官的用意，但是我能感觉到，这个问题不是那么好回答，我会回答说自己都行，来什么业务接什么需求。可能回答不太好，总之和公司的职位吻合就行，这样总不至于出错吧。 Android 高级面试题及答案 1.如何对 Android 应用进行性能分析 2.什么情况下会导致内存泄露 3.如何避免 OOM 异常 4.Android 中如何捕获未捕获的异常 5.ANR 是什么？怎样避免和解决 ANR（重要） 6.Android 线程间通信有哪几种方式 7.Devik 进程，linux 进程，线程的区别 8.描述一下 android 的系统架构 9.android 应用对内存是如何限制的?我们应该如何合理使用内存？ 10. 简述 android 应用程序结构是哪些 11.请解释下 Android 程序运行时权限与文件系统权限的区别 12.Framework 工作方式及原理，Activity 是如何生成一个 view 的，机制是什么 13.多线程间通信和多进程之间通信有什么不同，分别怎么实现 14.Android 屏幕适配 15.什么是 AIDL 以及如何使用 16.Handler 机制 17.事件分发机制 18.子线程发消息到主线程进行更新 UI，除了 handler 和 AsyncTask，还有什么 19.子线程中能不能 new handler？为什么 20.Android 中的动画有哪几类，它们的特点和区别是什么 21.如何修改 Activity 进入和退出动画 22.SurfaceView &amp; View 的区别 23.开发中都使用过哪些框架、平台 24.使用过那些自定义View 25.自定义控件：绘制圆环的实现过程 26.自定义控件：摩天轮的实现过程 28.流式布局的实现过程 29.第三方登陆 [30.第三方支付](","categories":[],"tags":[{"name":"inter","slug":"inter","permalink":"http://noteforme.github.io.com/tags/inter/"}],"keywords":[]},{"title":"TextView","slug":"TextView","date":"2018-03-04T13:16:56.000Z","updated":"2021-08-19T11:11:44.252Z","comments":true,"path":"2018/03/04/TextView/","link":"","permalink":"http://noteforme.github.io.com/2018/03/04/TextView/","excerpt":"","text":"TextView颜色变化 SpannableString https://juejin.im/entry/5729d28f1ea49300606854c9SpannableString有一个不方便的地方是截取字符串 TextView tvRegister = findViewById(R.id.tv_register); //将TextView的显示文字设置为SpannableString ​ tvRegister.setText(getClickableSpan()); ​ //设置该句使文本的超连接起作用 ​ tvRegister.setMovementMethod(LinkMovementMethod.getInstance()); ​ ​ private SpannableString getClickableSpan() &#123; ​ SpannableString spanTxt = new SpannableString(&quot;阅读并同意&lt;&lt;用户注册协议&gt;&gt;&quot;); ​ //设置文字的前景色 ​ spanTxt.setSpan(new ForegroundColorSpan(Color.GREEN),5, 15,Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); ​ spanTxt.setSpan(new ClickableSpan() &#123; ​ @Override ​ public void onClick(View widget) &#123; ​ Intent intent = new Intent(TextViewActivity.this, FirstActivity.class); ​ startActivity(intent); ​ &#125; ​ &#125;, 5, 15, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); ​ ​ ​ Html标签方式 TextView textView = (TextView) findViewById(R.id.text_for_test); String textSource = &quot;修改TextView中部分文字的&lt;font color=&#39;#ff0000&#39;&gt;&lt;big&gt;大&lt;/big&gt;&lt;small&gt;小&lt;/small&gt;&lt;/font&gt;和&lt;font color=&#39;#00ff00&#39;&gt;颜色&lt;/font&gt;，展示多彩效果！&quot;; textView.setText(Html.fromHtml(textSource)); http://www.jianshu.com/p/f6cef78e8652 https://github.com/liqy/TextViewDemo EditText style里面的配置 12&lt;item name=&quot;android:focusable&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:focusableInTouchMode&quot;&gt;true&lt;/item&gt; https://blog.csdn.net/u011630575/article/details/50775639 下划线颜色 https://blog.csdn.net/lindroid20/article/details/72551102 自定义解析器 https://my.oschina.net/ososchina/blog/3018393 密码输入框 https://github.com/li504799868/ZEditText","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"LeakMemory","slug":"LeakMemory","date":"2018-02-09T08:15:17.000Z","updated":"2021-08-19T11:11:44.095Z","comments":true,"path":"2018/02/09/LeakMemory/","link":"","permalink":"http://noteforme.github.io.com/2018/02/09/LeakMemory/","excerpt":"","text":"内存泄漏 https://mp.weixin.qq.com/s/tO1yxFs2qNQlQ2bJ8vGzQA https://www.jianshu.com/p/ac00e370f83d 内存泄漏总结 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class SampleActivity extends Activity &#123; /** * Instances of static inner classes do not hold an implicit * reference to their outer class. */ private static class MyHandler extends Handler &#123; private final WeakReference&lt;SampleActivity&gt; mActivity; public MyHandler(SampleActivity activity) &#123; mActivity = new WeakReference&lt;SampleActivity&gt;(activity); &#125; @Override public void handleMessage(Message msg) &#123; SampleActivity activity = mActivity.get(); if (activity != null) &#123; // ... &#125; &#125; &#125; private final MyHandler mHandler = new MyHandler(this); /** * Instances of anonymous classes do not hold an implicit * reference to their outer class when they are &quot;static&quot;. */ private static final Runnable sRunnable = new Runnable() &#123; @Override public void run() &#123; /* ... */ &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // Post a message and delay its execution for 10 minutes. mHandler.postDelayed(sRunnable, 1000 * 60 * 10); // Go back to the previous Activity. finish(); &#125;&#125; kotin Fragment方式 12345678910111213class MyHandler : Handler &#123; private var mFragment: WeakReference&lt;Any&gt; constructor(fragment: Fragment) &#123; mFragment = WeakReference(fragment) &#125; override fun handleMessage(msg: android.os.Message?) &#123; super.handleMessage(msg) val fragment = mFragment.get() as PayProFragment fragment.reloadPay() &#125; &#125; 内存泄漏处理-Handler 查找方式 https://www.jianshu.com/p/bdfd2a6b2681 ​ https://developer.android.com/studio/profile/memory-profiler leakcanaryhttps://square.github.io/leakcanary/recipes/ https://juejin.im/post/5d617d6851882575e8054fab 内存抖动Profiler https://www.bilibili.com/video/BV1oz4y1m7Gw?p=14 App瘦身 大图转成 webapp svg批量转换 设置 vectorDrawables.useSupportLibrary = true 然后 app:srcCompat = 否则会在每个drawable生成一个png图片，达不到效果了。 tink修改图片颜色 国际化 12345android&#123; defaultConfig&#123; resConfigs &#x27;en&#x27; //只适配英语 &#125;&#125; 这样只会保存 语言的映射 so库 一般像微信用Armeabi-v7a 虚拟机运行 还需要 x86 删除无用资源 12345debug&#123; minifyEnabled true // 删除无用代码 shrinkResource true //删除资源文件 minifyEnabled 为true,删除了无用代码，这个才知道删除哪些资源。 &#125;","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"Hilt","slug":"Hilt","date":"2018-01-23T07:11:40.000Z","updated":"2021-08-30T01:51:03.488Z","comments":true,"path":"2018/01/23/Hilt/","link":"","permalink":"http://noteforme.github.io.com/2018/01/23/Hilt/","excerpt":"","text":"https://mp.weixin.qq.com/s/OEX1d2cU1zGG5BBM-nANBg Hilt使用方式一1.生成组件 1234@HiltAndroidAppclass MyApp : Application() &#123; &#125; 建立绑定 通过@Inject告诉Dagger可以通过，构造方法创建实例 12345public class User &#123; @Inject public User() &#123; &#125;&#125; 注入对象 123456789101112@AndroidEntryPointpublic class HiltActivity extends AppCompatActivity &#123; @Inject User user; //inject注解作用在User变量上,注入对象实例 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_hilt); &#125;&#125; ​ 必须是ComponentActivity的子类 29021-29021/com.john.kot I/HiltActivity: user: com.john.kot.hilt.User@2c507f 方式二Module 不通过下面这种方式 12345public class User &#123; // @Inject 不在这里，而是在Module提交对象创建 public User() &#123; &#125;&#125; 123456789//Module装载到ApplicationComponent中@InstallIn(ApplicationComponent.class) //通过这种方式和组件关联@Modulepublic class AppModule &#123; @Provides User provideUser()&#123; return new User(); //Module提交对象创建 &#125;&#125; 29143-29143/com.john.kot I/HiltActivity: user: com.john.kot.hilt.User@43b8a20 默认标准组件","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"TEST_Espresso","slug":"TEST_Espresso","date":"2018-01-22T13:58:05.000Z","updated":"2021-09-09T02:14:47.285Z","comments":true,"path":"2018/01/22/TEST_Espresso/","link":"","permalink":"http://noteforme.github.io.com/2018/01/22/TEST_Espresso/","excerpt":"","text":"referencehttps://developer.android.com/training/testing/espresso/setup dependencies 1234androidTestImplementation &#x27;androidx.test.espresso:espresso-core:3.1.0&#x27; androidTestImplementation &#x27;androidx.test:runner:1.1.0&#x27; androidTestImplementation &#x27;androidx.test:rules:1.1.0&#x27; androidTestImplementation &#x27;androidx.test.ext:junit:1.1.1&#x27; practice 12345678910111213141516171819202122232425262728293031@Rule@JvmFieldval rule = ActivityTestRule(TestActivity::class.java)@Testfun useAppContext() &#123; val appContext = InstrumentationRegistry.getInstrumentation().targetContext assertEquals(&quot;com.john.kot&quot;, appContext.packageName)&#125;@Testfun user_can_enter_first_name()&#123; onView(withId(R.id.firstName)).perform(typeText(&quot;Daniel&quot;))&#125;@Testfun user_can_enter_last_name()&#123; onView(withId(R.id.lastName)).perform(typeText(&quot;Malone&quot;))&#125;@Testfun when_user_enters_first_and_last_name_check_to_confirm_that_message_is_correct()&#123; onView(withId(R.id.firstName)).perform(typeText(&quot;Jake&quot;)) onView(withId(R.id.lastName)).perform(typeText(&quot;Smith&quot;)) onView(withId(R.id.button)).perform(click()) onView(withId(R.id.message)).check(matches(withText(&quot;Welcome,Jake Smith&quot;)))&#125; junitJunit主要要做到Android.jar代码隔离，测试方式比较简单 12345678910111213141516171819202122232425public class CalculatorTest &#123; private Calculator mCalculator; @Before public void setUp() throws Exception &#123; mCalculator = new Calculator(); &#125; @Test public void testSum() throws Exception &#123; //expected: 6, sum of 1 and 5 assertEquals(6d, mCalculator.sum(1d, 5d), 0); &#125; @Test public void testSubstract() throws Exception &#123; assertEquals(1d, mCalculator.substract(5d, 4d), 0); &#125; @Test public void testDivide() throws Exception &#123; assertEquals(4d, mCalculator.divide(20d, 5d), 0); &#125; @Test public void testMultiply() throws Exception &#123; assertEquals(10d, mCalculator.multiply(2d, 5d), 0); &#125;&#125; Espresso测试 使用方式：https://developer.android.com/training/testing/espresso/setup.html#add-espresso-dependencieshttps://developer.android.com/training/testing/espresso/basics.html 12345678910111213141516171819202122232425262728&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.test.InstrumentActivity&quot;&gt; &lt;TextView android:id=&quot;@+id/tv_name&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;EditText android:id=&quot;@+id/et_name&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;@dimen/dimen_10&quot; android:hint=&quot;输入姓名&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/tv_name&quot; /&gt; &lt;Button android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;@dimen/dimen_10&quot; android:onClick=&quot;sayClick&quot; android:text=&quot;Say HELLO&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/et_name&quot; /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 12345public void sayClick(View v) &#123; TextView textView = findViewById(R.id.tv_name); EditText editText = findViewById(R.id.et_name); textView.setText(&quot;Say HELLO!&quot; + editText.getText().toString() + &quot;!&quot;);&#125; 1234567891011121314151617@RunWith(AndroidJUnit4.class)@LargeTestpublic class InstrumentActivityTest &#123; private static final String STRING_TO_BE_TYPED = &quot;Jon&quot;; @Rule public ActivityTestRule&lt;InstrumentActivity&gt; instrumentActivityTestRule = new ActivityTestRule&lt;&gt;(InstrumentActivity.class); @Test public void sayHelloTest() &#123; Espresso.onView(ViewMatchers.withId(R.id.et_name)).perform(ViewActions.typeText(STRING_TO_BE_TYPED), closeSoftKeyboard()); Espresso.onView(ViewMatchers.withText(&quot;Say HELLO&quot;)).perform(click()); String expectedText = &quot;Say HELLO!&quot; + STRING_TO_BE_TYPED + &quot;!&quot;; Espresso.onView(ViewMatchers.withId(R.id.tv_name)).check(ViewAssertions.matches(ViewMatchers.withText(expectedText))); &#125;&#125; https://testing.googleblog.com/2008/12/static-methods-are-death-to-testability.html https://www.jianshu.com/p/dc30338a3e84 https://www.jianshu.com/p/03118c11c199https://github.com/googlesamples/android-testing https://developer.android.com/training/testing 问题 class not found https://blog.csdn.net/xiaoluoli88/article/details/78657364","categories":[{"name":"TEST","slug":"TEST","permalink":"http://noteforme.github.io.com/categories/TEST/"}],"tags":[{"name":"Test","slug":"Test","permalink":"http://noteforme.github.io.com/tags/Test/"}],"keywords":[{"name":"TEST","slug":"TEST","permalink":"http://noteforme.github.io.com/categories/TEST/"}]},{"title":"TEST_MockK","slug":"TEST_MockK","date":"2018-01-22T10:04:40.000Z","updated":"2021-09-10T03:40:07.368Z","comments":true,"path":"2018/01/22/TEST_MockK/","link":"","permalink":"http://noteforme.github.io.com/2018/01/22/TEST_MockK/","excerpt":"","text":"Mockitohttps://www.javadoc.io/doc/org.mockito/mockito-core/3.10.0/org/mockito/ArgumentMatcher.html Mockito通过equals()方法，来对方法参数进行验证。但是有时候我们需要更加灵活的参数需求，比如，匹配任何的String类型的参数等等。参数匹配器就是一个能够满足这些需求的工具。 Mockito框架中的Matchers类内建了很多参数匹配器，我们常用的Mockito对象就是继承自Matchers。比如anyInt()匹配任何int类型的参数，anyString()匹配任何字符串… 如果使用了参数匹配器，那么所有的参数需要由匹配器来提供，否则将会报错。假如我们使用参数匹配器stubbing了mock对象的方法，那么在verify的时候也需要使用它 MatchersTest.java 123456789 public void argumentMatchersTest1() &#123; Map mapMock = mock(Map.class); when(mapMock.put(anyInt(), anyString())).thenReturn(&quot;world&quot;); mapMock.put(1, &quot;hello&quot;); verify(mapMock).put(anyInt(), eq(&quot;hello&quot;));// verify(mapMock).put(anyInt(), &quot;hello&quot;); verify(mapMock).put(anyInt(), anyString()); &#125; 自定义匹配器123456789101112131415161718192021222324@Testpublic void argumentMatchersTest2() &#123; List mock = mock(List.class); when(mock.addAll(argThat(new IsListOfTwoElements()))).thenReturn(true); mock.addAll(Arrays.asList(&quot;one&quot;, &quot;two&quot;)); verify(mock).addAll(argThat(new IsListOfTwoElements())); verify(mock).addAll(argThat(list -&gt; list.size() == 2));&#125;class IsListOfTwoElements implements ArgumentMatcher&lt;List&gt; &#123; @Override public boolean matches(List list) &#123; return list.size() == 2; &#125; public String toString() &#123; //printed in verification errors return &quot;[list of 2 elements]&quot;; &#125;&#125; 作用就是创建一个虚假得对象，在测试环境代替真实对象 验证这个对象的某些方法的调用情况，调用了多少次，参数是什么 指定这个对象的某些方法的行为，返回特定的值，或者是执行特定的动作 注意：Mockito不支持mock匿名类、final类、静态方法和private方法。 示例：https://static.javadoc.io/org.mockito/mockito-core/2.16.0/org/mockito/Mockito.html mock与spy的区别1234567891011 @Testpublic void mockDifSpy() throws Exception &#123; User userMock = mock(User.class); userMock.setNumber(2); int num = userMock.getNumber(); System.out.println(&quot;mock返回 &quot;+num); User userSpy = spy(User.class); userSpy.setNumber(5); System.out.println(&quot;spy返回 &quot;+userSpy.getNumber());&#125; mock返回 0 spy返回 5 mock : 如果不指定mock方法的特定行为，一个mock对象的所有非void方法都将返回默认值：int、long类型方法将返回0，boolean方法将返回false，对象方法将返回null等等；而void方法将什么都不做。 spy : spy对象的方法默认调用真实的逻辑，mock对象的方法默认什么都不做，或直接返回默认值。 https://www.jianshu.com/p/0a8bbfe6cba2 实例讲解 http://blog.csdn.net/qq_17766199/article/details/78450007 https://github.com/ChrisZou/android-unit-testing-tutorialhttps://github.com/qingmei2/Sample_AndroidTest 一个Android项目搞定所有主流架 mvp生成模板https://www.diycode.cc/topics/309https://github.com/boredream/DesignResCollection powermockhttps://blog.csdn.net/qq_17766199/article/details/78573390 Robolectrichttp://robolectric.org/getting-started/ Robolectric 123456789testImplementation &quot;org.robolectric:robolectric:3.8&quot;android &#123; testOptions &#123; unitTests &#123; includeAndroidResources = true &#125; &#125;&#125; MockkConstructor mocksverify失败 123456789101112131415161718192021 @Test fun `mock different constuctor`()&#123; mockkConstructor(MockCls::class) every &#123; constructedWith&lt;MockCls&gt;().add(1) &#125; returns 2 every &#123; constructedWith&lt;MockCls&gt;(OfTypeMatcher&lt;String&gt;(String::class)).add(2) // Mocks the constructor which takes a String &#125; returns 3 every &#123; constructedWith&lt;MockCls&gt;(EqMatcher(4)).add(any()) // Mocks the constructor which takes an Int &#125; returns 4 assertEquals(1, MockCls().add(1)) assertEquals(3, MockCls(&quot;2&quot;).add(2)) assertEquals(4, MockCls(4).add(7)) verify &#123; constructedWith&lt;MockCls&gt;().add(1) //这里不通过 // constructedWith&lt;MockCls&gt;(&quot;2&quot;).add(2) constructedWith&lt;MockCls&gt;(EqMatcher(4)).add(7) &#125; 为无返回值的方法分配默认行为把 every {…} 后面的 Returns 换成 just Runs ，就可以让 MockK 为这个没有返回值的方法分配一个默认行为。 1234567@Testfun testGetGoods() &#123; val goods = presenter!!.getGoods(1) every &#123; view.showLoading() &#125; just Runs verify &#123; view.showLoading() &#125; assertEquals(goods.name, &quot;纸巾&quot;)&#125; 为所有模拟对象的方法分配默认行为1234@Beforefun setUp() &#123; MockKAnnotations.init(this, relaxed = true)&#125; https://mockk.io/ https://www.jianshu.com/p/899e80120071 Annotation只要在 @Before 方法裡面加上 MockKAnnotations.init(this) 就能在外面用 Annotation 的方式 Mock 物件。 12345678910111213141516171819202122class KidAnnotationTest &#123; @MockK lateinit var mother: Mother lateinit var kid: Kid @Before fun setUp() &#123; val mother = mockk&lt;Mother&gt;() // 不使用Annotation的版本 MockKAnnotations.init(this) kid = Kid(mother) &#125; @Test fun wantMoney() &#123; every &#123; mother.giveMoney() &#125; returns 30 kid.wantMoney() assertEquals(30, kid.money) &#125;&#125; https://medium.com/joe-tsai/mockk-%E4%B8%80%E6%AC%BE%E5%BC%B7%E5%A4%A7%E7%9A%84-kotlin-mocking-library-part-2-4-4be059331110","categories":[{"name":"TEST","slug":"TEST","permalink":"http://noteforme.github.io.com/categories/TEST/"}],"tags":[{"name":"Test","slug":"Test","permalink":"http://noteforme.github.io.com/tags/Test/"}],"keywords":[{"name":"TEST","slug":"TEST","permalink":"http://noteforme.github.io.com/categories/TEST/"}]},{"title":"TouchEvent1","slug":"TouchEvent1","date":"2018-01-08T13:18:55.000Z","updated":"2021-09-06T08:00:01.493Z","comments":true,"path":"2018/01/08/TouchEvent1/","link":"","permalink":"http://noteforme.github.io.com/2018/01/08/TouchEvent1/","excerpt":"","text":"​ Android Touch Event Question手机屏幕是由一个个像素点渲染而成的，不同的布局类似于幕布一层层叠上去形成了屏幕上显示的效果，The action is from DOWN、MOVE、UP, How they formed while we used like longClick , touch, click? a button on the listview item，why the listview item don’t response while we click the button in a interview ? but I cann’t answer the key point. multible listview or recycleview in a Scrollview ,how to resolve it? Android provide NestedScrollView for us now,how does it work? AnswerImage clear I found it very useful when i looked it.it make me have global view.and then I read Activity ViewGroup and View source code from framework. But I found some place could do better ,so I draw another Image. 开发中常用的事件分发 ListView item 上有Button ,item上的onItemClick事件得不到响应，可以看看官方ViewGroup 描述 item Button 页面搜索 android:descendantFocusability android:descendantFocusability属性共有三个取值，分别为beforeDescendants：viewgroup会优先其子类控件而获取到焦点afterDescendants：viewgroup 只有当其子类控件不需要获取焦点时才获取焦点blocksDescendants：viewgroup 会覆盖子类控件而直接获得焦点 原因 : 在View onTouchEvent(MotionEvent event) 中,只要view可点击就返回true,事件就被消费掉了, set isClickable = true 才可以收到 action move up事件 1234567891011121314151617181920public boolean onTouchEvent(MotionEvent event) &#123; final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; final int action = event.getAction(); final boolean clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE; if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125; mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; // A disabled view that is clickable still consumes the touch // events, it just doesn&#x27;t respond to them. return clickable; &#125; &#125; 按钮是可以点击的直接被onTouchEvent消费 事件分发 https://juejin.im/post/6862254703837708302 https://www.jianshu.com/p/d82f426ba8f7 https://www.jianshu.com/p/e99b5e8bd67b https://www.jianshu.com/p/5279e887841b 滑动冲突 https://blog.csdn.net/gdutxiaoxu/article/details/52939127 https://www.jianshu.com/p/982a83271327 https://juejin.im/user/4336129588334958/posts https://www.bilibili.com/video/BV1fb4y1o7ey?from=search&amp;seid=11728197632179808067 https://www.bilibili.com/video/BV1fb4y1o7ey?p=5","categories":[{"name":"VIEW","slug":"VIEW","permalink":"http://noteforme.github.io.com/categories/VIEW/"}],"tags":[{"name":"TouchEvent","slug":"TouchEvent","permalink":"http://noteforme.github.io.com/tags/TouchEvent/"}],"keywords":[{"name":"VIEW","slug":"VIEW","permalink":"http://noteforme.github.io.com/categories/VIEW/"}]},{"title":"java_operators","slug":"java-operators","date":"2018-01-07T12:41:41.000Z","updated":"2021-08-19T11:11:44.300Z","comments":true,"path":"2018/01/07/java-operators/","link":"","permalink":"http://noteforme.github.io.com/2018/01/07/java-operators/","excerpt":"","text":"JAVA运算符 赋值运算符＆= 按位与赋值运算符 C＆= 2等价于C = C＆2 | = 按位或赋值操作符 C | = 2等价于C = C | 2 http://www.runoob.com/java/java-operators.html","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}],"tags":[{"name":"operators","slug":"operators","permalink":"http://noteforme.github.io.com/tags/operators/"}],"keywords":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}]},{"title":"Navigation_Drawer","slug":"NavigationDrawer","date":"2017-12-27T07:05:34.000Z","updated":"2021-08-19T11:11:44.128Z","comments":true,"path":"2017/12/27/NavigationDrawer/","link":"","permalink":"http://noteforme.github.io.com/2017/12/27/NavigationDrawer/","excerpt":"","text":"Drawer使用 业务 123456789101112131415161718192021222324252627282930313233343536373839private void initView() &#123; mPlanetTitles = getResources().getStringArray(R.array.recycle_array); mDrawerLayout = findViewById(R.id.drawer_layout); mDrawerList = findViewById(R.id.left_drawer); // Set the adapter for the list view mDrawerList.setAdapter(new ArrayAdapter&lt;String&gt;(this, R.layout.drawer_list_item, mPlanetTitles)); mDrawerList.setOnItemClickListener(new DrawerItemClickListener()); &#125; private class DrawerItemClickListener implements ListView.OnItemClickListener &#123; @Override public void onItemClick(AdapterView&lt;?&gt; adapterView, View view, int position, long l) &#123; selectItem(position); &#125; &#125; /** * Swaps fragments in the main content view */ private void selectItem(int position) &#123; // Create a new fragment and specify the planet to show based on position Fragment fragment = new PullToRefreshFragment(); // Insert the fragment by replacing any existing fragment FragmentManager fragmentManager = getFragmentManager(); fragmentManager.beginTransaction().replace(R.id.content_frame, fragment) .commit(); setTitle(mPlanetTitles[position]); mDrawerLayout.closeDrawer(mDrawerList); &#125; @Override public void setTitle(CharSequence title) &#123; super.setTitle(title);// getActionBar().setTitle(title); &#125; xml 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:id=&quot;@+id/drawer_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;com.jonzhou.mineutils.RecycleView.RecycleViewActivity&quot;&gt; &lt;FrameLayout android:id=&quot;@+id/content_frame&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; &lt;ListView android:id=&quot;@+id/left_drawer&quot; android:layout_width=&quot;240dp&quot; android:layout_height=&quot;match_parent&quot; android:layout_gravity=&quot;start&quot; android:background=&quot;#111&quot; android:choiceMode=&quot;singleChoice&quot; android:divider=&quot;@android:color/transparent&quot; android:dividerHeight=&quot;0dp&quot; /&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 原生用法 一般情况抽屉内容都不会很多所以就可以用 NavigationView替换ListView 1234567891011121314151617181920212223242526 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:id=&quot;@+id/drawer_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:fitsSystemWindows=&quot;true&quot; tools:openDrawer=&quot;start&quot;&gt; &lt;include layout=&quot;@layout/app_bar_navigation&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; &lt;android.support.design.widget.NavigationView android:id=&quot;@+id/nav_view&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:layout_gravity=&quot;start&quot; android:fitsSystemWindows=&quot;true&quot; app:headerLayout=&quot;@layout/nav_header_navigation&quot; app:menu=&quot;@menu/activity_navigation_drawer&quot; /&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 查看NavigationView,可以看到 headerLayout，menu分别时抽屉的上下两部分，activity_navigation_drawer最好别用这个名称，否则可能加载系统默认布局怎么改都没用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576 @Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_navigation); Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab); fab.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Snackbar.make(view, &quot;Replace with your own action&quot;, Snackbar.LENGTH_LONG) .setAction(&quot;Action&quot;, null).show(); &#125; &#125;); DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout); ActionBarDrawerToggle toggle = new ActionBarDrawerToggle( this, drawer, toolbar, R.string.navigation_drawer_open, R.string.navigation_drawer_close); drawer.addDrawerListener(toggle); toggle.syncState(); NavigationView navigationView = (NavigationView) findViewById(R.id.nav_view); navigationView.setNavigationItemSelectedListener(this);&#125;@Overridepublic void onBackPressed() &#123; DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout); if (drawer.isDrawerOpen(GravityCompat.START)) &#123; drawer.closeDrawer(GravityCompat.START); &#125; else &#123; super.onBackPressed(); &#125;&#125;@Overridepublic boolean onCreateOptionsMenu(Menu menu) &#123; // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.navigation, menu); return true;&#125;@Overridepublic boolean onOptionsItemSelected(MenuItem item) &#123; // Handle action bar item clicks here. The action bar will // automatically handle clicks on the Home/Up button, so long // as you specify a parent activity in AndroidManifest.xml. int id = item.getItemId(); //noinspection SimplifiableIfStatement if (id == R.id.action_settings) &#123; return true; &#125; return super.onOptionsItemSelected(item);&#125;@SuppressWarnings(&quot;StatementWithEmptyBody&quot;)@Overridepublic boolean onNavigationItemSelected(MenuItem item) &#123; // Handle navigation view item clicks here. int id = item.getItemId(); if (id == R.id.nav_camera) &#123; // Handle the camera action &#125; else if (id == R.id.nav_gallery) &#123; &#125; else if (id == R.id.nav_slideshow) &#123; &#125; DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout); drawer.closeDrawer(GravityCompat.START); return true;&#125; 动态修改 headLayout的内容 View headerLayout = navView.getHeaderView(0); TextView tevtView = headerLayout.findViewById(R.id.textView); tevtView.setText(&quot;nishiminglema &quot;); 注意 NavigationView也可以添加头部参考： https://segmentfault.com/a/1190000004151222 https://developer.android.com/reference/android/support/design/widget/NavigationView.html https://developer.android.com/reference/android/support/v4/widget/DrawerLayout.html https://developer.android.com/training/implementing-navigation/nav-drawer.html?hl=zh-cn","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[{"name":"Drawer","slug":"Drawer","permalink":"http://noteforme.github.io.com/tags/Drawer/"}],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"TAB_VIEWPAGER","slug":"TAB_VIEWPAGER","date":"2017-12-26T07:32:39.000Z","updated":"2021-08-19T11:11:44.238Z","comments":true,"path":"2017/12/26/TAB_VIEWPAGER/","link":"","permalink":"http://noteforme.github.io.com/2017/12/26/TAB_VIEWPAGER/","excerpt":"","text":"https://developer.android.com/reference/com/google/android/material/tabs/TabLayout ViewPagerTabLayout方式 动态 1234TabLayout tabLayout = ...; tabLayout.addTab(tabLayout.newTab().setText(&quot;Tab 1&quot;)); tabLayout.addTab(tabLayout.newTab().setText(&quot;Tab 2&quot;)); tabLayout.addTab(tabLayout.newTab().setText(&quot;Tab 3&quot;)); 静态 123456789101112&lt;com.google.android.material.tabs.TabLayout android:layout_height=&quot;wrap_content&quot; android:layout_width=&quot;match_parent&quot;&gt; &lt;com.google.android.material.tabs.TabItem android:text=&quot;@string/tab_text&quot;/&gt; &lt;com.google.android.material.tabs.TabItem android:icon=&quot;@drawable/ic_android&quot;/&gt; &lt;/com.google.android.material.tabs.TabLayout&gt; 滑动TAB12345678910&lt;androidx.viewpager.widget.ViewPager android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;com.google.android.material.tabs.TabLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;top&quot; /&gt; &lt;/androidx.viewpager.widget.ViewPager&gt; 设置Tab 12345678910111213TabLayout tabVp = rootView.findViewById(R.id.tab_vp);viewPager = rootView.findViewById(R.id.view_pager); framgents = new LinkedHashMap&lt;&gt;();framgents.put(&quot;项目详情&quot;, introFragment);framgents.put(&quot;相关图片&quot;, imageFragment);framgents.put(&quot;投资记录&quot;, rankFragment);titles = new LinkedList&lt;&gt;();titles.addAll(framgents.keySet());viewPager.setAdapter(new MyPagerAdapter(getFragmentManager()));tabVp.setupWithViewPager(viewPager); 默认设置 12mTabLayout.getTabAt(roomType).select();viewpager.setCurrentItem(1); https://segmentfault.com/a/1190000008753052 自定义TabItem tab_item.xml 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;TextView android:id=&quot;@+id/tv_item_title&quot; android:layout_width=&quot;40dp&quot; android:layout_height=&quot;40dp&quot; android:layout_gravity=&quot;center_horizontal&quot; android:background=&quot;@drawable/bg_tab_item_select&quot; android:gravity=&quot;center&quot; android:textColor=&quot;@drawable/bg_tab_item_select_txt&quot; android:textSize=&quot;@dimen/text_size_14&quot; /&gt; &lt;View android:id=&quot;@+id/view_line&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;1dp&quot; android:layout_gravity=&quot;center_vertical&quot; android:layout_marginLeft=&quot;@dimen/dimen_10&quot; android:layout_weight=&quot;1&quot; android:background=&quot;@android:color/darker_gray&quot; /&gt;&lt;/LinearLayout&gt; 1234567891011121314tabLayout = findViewById(R.id.tb_layout); for (int i = 0; i &lt; tabTitles.length; i++) &#123; tabLayout.addTab(tabLayout.newTab()); &#125; for (int i = 0; i &lt; tabTitles.length; i++) &#123; TabLayout.Tab tab = tabLayout.getTabAt(i); tab.setCustomView(R.layout.tab_item); TextView tvItemTitle = tab.getCustomView().findViewById(R.id.tv_item_title); tvItemTitle.setText(tabTitles[i]); if (i == tabTitles.length - 1) &#123; tab.getCustomView().findViewById(R.id.view_line).setVisibility(View.GONE); &#125; &#125; https://www.jianshu.com/p/ed129686f2cc https://blog.csdn.net/android_zhengyongbo/article/details/74726176 修改指示器颜色https://codeday.me/bug/20170629/35704.html 设置Tab选择背景https://blog.csdn.net/jdsjlzx/article/details/52171075 首先设置 tabGravity fill模式 center是居中 通过layer-list设置间距 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:state_selected=&quot;true&quot;&gt; &lt;layer-list&gt; &lt;item&gt; &lt;shape&gt; &lt;solid android:color=&quot;@android:color/transparent&quot; /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:left=&quot;@dimen/dimen_10&quot; android:right=&quot;@dimen/dimen_10&quot;&gt; &lt;shape android:shape=&quot;rectangle&quot;&gt; &lt;corners android:radius=&quot;3dp&quot; /&gt; &lt;solid android:color=&quot;#ffa2cb79&quot; /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;/layer-list&gt; &lt;/item&gt; &lt;item &gt; &lt;layer-list&gt; &lt;item&gt; &lt;shape&gt; &lt;solid android:color=&quot;@android:color/transparent&quot;&gt;&lt;/solid&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:left=&quot;@dimen/dimen_10&quot; android:right=&quot;@dimen/dimen_10&quot;&gt; &lt;shape android:shape=&quot;rectangle&quot;&gt; &lt;corners android:radius=&quot;3dp&quot; /&gt; &lt;solid android:color=&quot;#ffdddddd&quot; /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;/layer-list&gt; &lt;/item&gt;&lt;/selector&gt; ViewPager2migrationhttps://developer.android.com/training/animation/screen-slide-2#kotlin https://developer.android.com/training/animation/vp2-migration https://github.com/android/views-widgets-samples/tree/master/ViewPager2 123456&lt;androidx.viewpager2.widget.ViewPager2 android:id=&quot;@+id/view_pater2&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;0dp&quot; android:layout_marginTop=&quot;27dp&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; /&gt; 1view_pater2.adapter = ScreenSlidePagerAdapter(this) 12345678910private inner class ScreenSlidePagerAdapter(fa: Fragment) : FragmentStateAdapter(fa) &#123; override fun getItemCount(): Int = 2 override fun createFragment(position: Int): Fragment&#123; return if (position==1)&#123; BodyDataFragment.newInstance() &#125;else&#123; SleepFragment.newInstance() &#125; &#125;&#125;","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[{"name":"TabLayout","slug":"TabLayout","permalink":"http://noteforme.github.io.com/tags/TabLayout/"}],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"Keyboard","slug":"Keyboard","date":"2017-12-21T06:49:56.000Z","updated":"2021-08-19T11:11:44.095Z","comments":true,"path":"2017/12/21/Keyboard/","link":"","permalink":"http://noteforme.github.io.com/2017/12/21/Keyboard/","excerpt":"","text":"https://developer.android.com/training/keyboard-input/style.html 12345678910111213141516171819 static Timer timer = new Timer(); timer.schedule(new TimerTask() &#123; @Override public void run() &#123; showSoftKeyboard(etInvestMoney); &#125; &#125;, 200);private void showSoftKeyboard(View view) &#123; if (view.requestFocus()) &#123; InputMethodManager imm = (InputMethodManager) getActivity().getSystemService(Context.INPUT_METHOD_SERVICE); imm.showSoftInput(view, InputMethodManager.RESULT_UNCHANGED_SHOWN); &#125; &#125; http://www.jianshu.com/p/215b388a6e7d https://juejin.im/post/5eddf8456fb9a04804041738","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[{"name":"keyboard","slug":"keyboard","permalink":"http://noteforme.github.io.com/tags/keyboard/"}],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"proguard","slug":"proguard","date":"2017-12-18T23:29:23.000Z","updated":"2021-08-19T11:11:44.302Z","comments":true,"path":"2017/12/19/proguard/","link":"","permalink":"http://noteforme.github.io.com/2017/12/19/proguard/","excerpt":"","text":"ProGuard中间文件开启ProGuard，Android工程被Build后，会生成以下文件：\\app\\build\\outputs\\mapping\\release dump.txtapk文件中所有类的构成一览 mapping.txt记录了混淆后的名字与混淆前的名字的对应关系，每一次混淆结果和映射关系都不一样。当遇到Bug是，查看到的堆信息，要和混淆前的源码关联起来，所以管理这个文件很重要。retrace.bat -verbose mapping.txt stacktrace.txt com.rensanning.example.androidsample.User -&gt; com.rensanning.example.androidsample.g: java.lang.String name -&gt; a java.lang.String hometown -&gt; b java.util.ArrayList getUsers() -&gt; a seeds.txt未被混淆的类和方法一览 usage.txt记录了从apk文件中删掉的代码。这个文件一定要认真确认，是否这些代码真的是多余的。 https://www.jianshu.com/p/6a07046e65f4 http://blog.csdn.net/guolin_blog/article/details/50451259https://developer.android.com/studio/build/shrink-code.html?hl=zh-cn https://mp.weixin.qq.com/s/WmJyiA3fDNriw5qXuoA9MA apktool 判断是否混淆 最快的方式 把Apk后缀改成 zip ,解压后把 classes.dex 文件拖到 jadx里面 https://blog.csdn.net/xiaohai695943820/article/details/72367896 https://www.itread01.com/content/1548717866.html 反编译工具介绍 https://www.cnblogs.com/zhen-android/p/7830249.html","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[{"name":"proguard","slug":"proguard","permalink":"http://noteforme.github.io.com/tags/proguard/"}],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"NewFeatures","slug":"NewFeatures","date":"2017-12-17T14:26:11.000Z","updated":"2021-08-19T11:11:44.178Z","comments":true,"path":"2017/12/17/NewFeatures/","link":"","permalink":"http://noteforme.github.io.com/2017/12/17/NewFeatures/","excerpt":"","text":"ANDROID新特性 apk安装 StrictMode API政策 在AndroidManifest.xml添加 12345678&lt;provider android:name=&quot;android.support.v4.content.FileProvider&quot; android:authorities=&quot;$&#123;applicationId&#125;.fileProvider&quot; // com.cqian是包名 android:grantUriPermissions=&quot;true&quot; android:exported=&quot;false&quot;&gt; &lt;meta-data android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot; android:resource=&quot;@xml/provider_install&quot;/&gt; &lt;/provider&gt; 编写provider_install.xml文件 新建xml指定共享目录 有下面几种存储方式, name不变，path就是下面得apkCacheFile 12345678910&lt;files-path name=&quot;name&quot; path=&quot;path&quot; /&gt; 物理路径相当于Context.getFilesDir() + /path/ &lt;cache-path name=&quot;name&quot; path=&quot;path&quot; /&gt; 物理路径相当于Context.getCacheDir() + /path/ &lt;external-path name=&quot;name&quot; path=&quot;path&quot; /&gt; 物理路径相当于Environment.getExternalStorageDirectory() + /path/ &lt;external-files-path name=&quot;name&quot; path=&quot;path&quot; /&gt; 物理路径相当于Context.getExternalFilesDir(String) + /path/ &lt;external-cache-path name=&quot;name&quot; path=&quot;path&quot; /&gt; 物理路径相当于Context.getExternalCacheDir() + /path/ 由于我的存储目录用这个，apkCacheFile是SDk卡上得目录名称 String downFile = context.getExternalCacheDir() + &quot;apkCacheFile&quot; 123&lt;external-cache-path name=&quot;name&quot; path=&quot;apkCacheFile&quot; /&gt; 安装APK 就这个安装方法 12345678910111213141516171819private static void installApk(Context context, File apkFile) &#123; Intent intent = new Intent(); // 由于没有在Activity环境下启动Activity,设置下面的标签 intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); intent.setAction(Intent.ACTION_VIEW); String type = &quot;application/vnd.android.package-archive&quot;; Uri uri; if (Build.VERSION.SDK_INT &gt;= 24) &#123; // 参数2 清单文件中provider节点里面的authorities ; 参数3 共享的文件,即apk包的file类 uri = FileProvider.getUriForFile(context, &quot;getPackageName().fileProvider&quot;, apkFile); //对目标应用临时授权该Uri所代表的文件 intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); &#125; else &#123; uri = Uri.fromFile(apkFile); &#125; intent.setDataAndType(uri, type); context.startActivity(intent); &#125; https://developer.android.google.cn/about/versions/nougat/android-7.0-changes.html http://blog.csdn.net/github_2011/article/details/74297460 图片拍照Android P veridex工具使用 win10安装ubuntu https://www.linuxidc.com/Linux/2018-03/151256.htm 对test.apk进行扫描 ./appcompat.sh –dex-file=test.apk 在cmd里敲bash，找到/mnt，你会发现下面有c d e f ，这些就是你win下的硬盘，你可以直接对win下的文件进行操作，包括执行一些linux指令或者编译Linux程序 用mv /mnt/x/a/b-c.zip /home/user/b.zip这类命令 示例: http://www.10tiao.com/html/227/201812/2650244825/1.html android 11适配https://juejin.im/post/6860370635664261128","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[{"name":"AndroidNewFeatures","slug":"AndroidNewFeatures","permalink":"http://noteforme.github.io.com/tags/AndroidNewFeatures/"}],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"Dialog","slug":"Dialog ","date":"2017-12-11T02:15:44.000Z","updated":"2021-08-19T11:11:43.802Z","comments":true,"path":"2017/12/11/Dialog /","link":"","permalink":"http://noteforme.github.io.com/2017/12/11/Dialog%20/","excerpt":"","text":"Dialoghttps://developer.android.com/guide/topics/ui/dialogs.htmlhttps://developer.android.com/reference/android/app/DialogFragment.html 中间弹出12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class UpdateDialogFragment extends DialogFragment implements View.OnClickListener &#123; public static final String UPDATE_MSG = &quot;UPDATE_MSG&quot;; private UpdateBean updateMsg; public static DialogFragment newInstance(UpdateBean updateBean) &#123; UpdateDialogFragment upDialog = new UpdateDialogFragment(); Bundle bundle = new Bundle(); bundle.putParcelable(UPDATE_MSG, updateBean); upDialog.setArguments(bundle); return upDialog; &#125; @Override public Dialog onCreateDialog(Bundle savedInstanceState) &#123; updateMsg = getArguments().getParcelable(UPDATE_MSG); AlertDialog.Builder builder = new AlertDialog.Builder(getActivity()); // Get the layout inflater LayoutInflater inflater = getActivity().getLayoutInflater(); // Inflate and set the layout for the dialog // Pass null as the parent view because its going in the dialog layout View view = inflater.inflate(R.layout.dialog_update, null); TextView tvUpdatetitle = (TextView) view.findViewById(R.id.tv_update_title); TextView tvUpDescribe = (TextView) view.findViewById(R.id.tv_up_describe); tvUpDescribe.setText(updateMsg.getDesc()); TextView tvUpdateYes = (TextView) view.findViewById(R.id.tv_update_yes); TextView tvUpdateNo = (TextView) view.findViewById(R.id.tv_update_no); tvUpdateYes.setOnClickListener(this); tvUpdateNo.setOnClickListener(this); builder.setView(view); // Add action buttons return builder.create(); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.tv_update_yes: mListener.onDialogPositiveClick(this,updateMsg); break; case R.id.tv_update_no: mListener.onDialogNegativeClick(this); break; &#125; &#125; /* The activity that creates an instance of this dialog fragment must * implement this interface in order to receive event callbacks. * Each method passes the DialogFragment in case the host needs to query it. */ public interface NoticeDialogListener &#123; void onDialogPositiveClick(DialogFragment dialog,UpdateBean updateBean); void onDialogNegativeClick(DialogFragment dialog); &#125; // Use this instance of the interface to deliver action events NoticeDialogListener mListener; // Override the Fragment.onAttach() method to instantiate the NoticeDialogListener @Override public void onAttach(Activity activity) &#123; super.onAttach(activity); // Verify that the host activity implements the callback interface try &#123; // Instantiate the NoticeDialogListener so we can send events to the host mListener = (NoticeDialogListener) activity; &#125; catch (ClassCastException e) &#123; // The activity doesn&#x27;t implement the interface, throw exception throw new ClassCastException(activity.toString() + &quot; must implement NoticeDialogListener&quot;); &#125; &#125;&#125; 底部弹出https://github.com/umano/AndroidSlidingUpPanelhttps://material.io/guidelines/components/dialogs.html#dialogs-specs http://www.jianshu.com/p/0a7383e0ad0f guide usehttps://blog.csdn.net/u014626094/article/details/105430981 https://mp.weixin.qq.com/s/VadRKHau_YBsV8miFiggEw","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"LOG","slug":"LOG","date":"2017-12-09T08:41:05.000Z","updated":"2021-08-19T11:11:44.095Z","comments":true,"path":"2017/12/09/LOG/","link":"","permalink":"http://noteforme.github.io.com/2017/12/09/LOG/","excerpt":"","text":"Timber 添加库 implementation &#39;com.jakewharton.timber:timber:4.6.0&#39; **注意 **: 一开始日志打印不了还以为 okhttplogger冲突，BuildConfig需要导入项目的包import com.jonzhou.nytime.BuildConfig;，而不是Timber或其他的包 12345678910111213141516171819202122232425262728293031323334public class MyApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); if (BuildConfig.DEBUG) &#123; Timber.plant(new Timber.DebugTree()); &#125; else &#123; Timber.plant(new CrashReportingTree()); &#125; &#125; /** * A tree which logs important information for crash reporting. */ private static class CrashReportingTree extends Timber.Tree &#123; @Override protected void log(int priority, String tag, @NonNull String message, Throwable t) &#123; if (priority == Log.VERBOSE || priority == Log.DEBUG) &#123; return; &#125; FakeCrashLibrary.log(priority, tag, message); if (t != null) &#123; if (priority == Log.ERROR) &#123; FakeCrashLibrary.logError(t); &#125; else if (priority == Log.WARN) &#123; FakeCrashLibrary.logWarning(t); &#125; &#125; &#125; &#125;&#125; 使用 jake的例子 LintActivity 123456789101112131415161718192021222324252627282930313233343536373839 // LogNotTimber Log.d(&quot;TAG&quot;, &quot;msg&quot;); Log.d(&quot;TAG&quot;, &quot;msg&quot;, new Exception()); android.util.Log.d(&quot;TAG&quot;, &quot;msg&quot;); android.util.Log.d(&quot;TAG&quot;, &quot;msg&quot;, new Exception()); // StringFormatInTimber Timber.w(String.format(&quot;%s&quot;, getString())); Timber.w(format(&quot;%s&quot;, getString())); // ThrowableNotAtBeginning Timber.d(&quot;%s&quot;, new Exception()); // BinaryOperationInTimber String foo = &quot;foo&quot;; String bar = &quot;bar&quot;; Timber.d(&quot;foo&quot; + &quot;bar&quot;); Timber.d(&quot;foo&quot; + bar); Timber.d(foo + &quot;bar&quot;); Timber.d(foo + bar); // TimberArgCount Timber.d(&quot;%s %s&quot;, &quot;arg0&quot;); Timber.d(&quot;%s&quot;, &quot;arg0&quot;, &quot;arg1&quot;); Timber.tag(&quot;tag&quot;).d(&quot;%s %s&quot;, &quot;arg0&quot;); Timber.tag(&quot;tag&quot;).d(&quot;%s&quot;, &quot;arg0&quot;, &quot;arg1&quot;); // TimberArgTypes Timber.d(&quot;%d&quot;, &quot;arg0&quot;); Timber.tag(&quot;tag&quot;).d(&quot;%d&quot;, &quot;arg0&quot;); // TimberTagLength Timber.tag(&quot;abcdefghijklmnopqrstuvwx&quot;); Timber.tag(&quot;abcdefghijklmnopqrstuvw&quot; + &quot;x&quot;); // TimberExceptionLogging Timber.d(new Exception(), new Exception().getMessage()); Timber.d(new Exception(), &quot;&quot;); Timber.d(new Exception(), null); */&#125;private String getString() &#123; return &quot;foo&quot;;&#125; Xlog1 . 环境配置 安装 pyelliptic1.5.7 sudo python setup.py install 解码日志 python mars/log/crypt/decode_mars_nocrypt_log_file.py MarsSample_20200417.xlog 但是现在碰到了问题 mq初始化有日志，接收消息没有日志，可能在不同的线程里，需要做处理","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"Permission","slug":"Permission","date":"2017-12-02T12:11:32.000Z","updated":"2021-08-19T11:11:44.203Z","comments":true,"path":"2017/12/02/Permission/","link":"","permalink":"http://noteforme.github.io.com/2017/12/02/Permission/","excerpt":"","text":"https://developer.android.com/training/permissions/requesting https://developer.android.com/guide/topics/permissions/overview#normal-dangerous 权限管理Normal permissionsDangerous permissions Android11权限申请申请位置权限，先申请前台，后申请后台权限。 https://zhuanlan.zhihu.com/p/275758740 基本使用123456789101112131415161718192021222324252627282930313233343536373839 public static final int PERMISSION_REQUEST_CODE = 1000; void requestPermission() &#123; // Here, thisActivity is the current activity if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; //则每次执行需要这一权限的操作时您都必须检查自己是否具有该权限 if (ActivityCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; // Should we show an explanation? if (ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.WRITE_EXTERNAL_STORAGE)) &#123;// 当某条权限之前已经请求过，并且用户已经拒绝了该权限时 //异步向用户显示解释，这里先弹出解释框，再请求权限. Log.d(TAG, &quot;用户看到解释后，再次常识请求权限&quot;); ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, PERMISSION_REQUEST_CODE); &#125; else &#123; //无需解释，首次请求许可 ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, PERMISSION_REQUEST_CODE); Log.d(TAG, &quot;requestPermissions&quot;); &#125; &#125; else &#123; //权限已经授予 Log.d(TAG, &quot;requestPermissions is ok&quot;); &#125; &#125; &#125; @Override public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode) &#123; case PERMISSION_REQUEST_CODE: &#123; // If request is cancelled, the result arrays are empty. 如果取消请求，则grantResult 为空 if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; Log.d(TAG, &quot;onRequestPermissionResult:ok&quot;); &#125; else &#123; Log.d(TAG, &quot;onRequestPermissionResult:no&quot;); &#125; return; &#125; &#125; &#125; 注意:需要在androidmanifest.xml声明 否则一直返回false 12&lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt; 1、检查权限是否授予。 12Activity.javapublic int checkSelfPermission(permission) 2、申请权限。 12Activity.java public final void requestPermissions( new String[permission1,permission2,...], requestCode) 这个时候，会弹出系统授权弹窗（授权弹窗是不支持自定义的，原因理所当然）。 3、权限回调。 用户在系统弹窗里面选择后，结果会通过Activity的 onRequestPermissionsResult方法回调APP。 123public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; //继续执行逻辑或者提示权限获取失败&#125; 4、权限说明。 用户如果选择了拒绝，下一次在需要声明该权限的时候，Google建议APP开发者给予用户更多的说明，因此提供了下面这个API,这个方法返回值在使用过程中会发现有点纠结（具体解析见下面代码块说明）。 1234567public boolean shouldShowRequestPermissionRationale(permission)&#123; 1、APP没有申请这个权限的话，返回false 2、用户拒绝时，勾选了不再提示的话，返回false 3、用户拒绝，但是没有勾选不再提示的话，返回true 因此如果想在第一次就给用户提示，需要记录权限是否申请过，没有申请过的话，强制弹窗提示，而不能根据这个方法的返回值来。&#125; 这个 看情况选用 参考 https://juejin.im/entry/58b2e490ac502e0069d9ae62 https://developer.android.com/guide/topics/security/permissions?hl=zh-cn#normal-dangerous http://www.10tiao.com/html/227/201610/2650237473/1.html PERMISSION​ 12345678910111213141516171819&lt;!-- 这个权限用于进行网络定位--&gt; &lt;permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot;&gt;&lt;/permission&gt; &lt;!-- 这个权限用于访问GPS定位--&gt; &lt;permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot;&gt;&lt;/permission&gt; &lt;!-- 用于访问wifi网络信息，wifi信息会用于进行网络定位--&gt; &lt;permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot;&gt;&lt;/permission&gt; &lt;!-- 获取运营商信息，用于支持提供运营商信息相关的接口--&gt; &lt;permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;&gt;&lt;/permission&gt; &lt;!-- 这个权限用于获取wifi的获取权限，wifi信息会用来进行网络定位--&gt; &lt;permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot;&gt;&lt;/permission&gt; &lt;!-- 用于读取手机当前的状态--&gt; &lt;permission android:name=&quot;android.permission.READ_PHONE_STATE&quot;&gt;&lt;/permission&gt; &lt;!-- 写入扩展存储，向扩展卡写入数据，用于写入离线定位数据--&gt; &lt;permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;&gt;&lt;/permission&gt; &lt;!-- 访问网络，网络定位需要上网--&gt; &lt;permission android:name=&quot;android.permission.INTERNET&quot; /&gt; &lt;!-- SD卡读取权限，用户写入离线定位数据--&gt; &lt;permission android:name=&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot;&gt;&lt;/permission&gt; One-time permissionsStarting in Android 11 (API level 30), whenever your app requests a permission related to location, microphone, or camera, the user-facing permissions dialog contains an option called Only this time. If the user selects this option in the dialog, your app is granted a temporary one-time permission. Permission groups If the app has already been granted another dangerous permission in the same permission group, the system immediately grants the permission without any interaction with the user. For example, if an app had previously requested and been granted the READ_CONTACTS permission, and it then requests WRITE_CONTACTS, the system immediately grants that permission without showing the permissions dialog to the user. Caution: Future versions of the Android SDK might move a particular permission from one group to another. Therefore, don’t base your app’s logic on the structure of these permission groups. For example, READ_CONTACTS is in the same permission group as WRITE_CONTACTS as of Android 8.1 (API level 27). If your app requests the READ_CONTACTS permission, and then requests the WRITE_CONTACTS permission, don’t assume that the system can automatically grant the WRITE_CONTACTS permission. 多权限申请https://github.com/permissions-dispatcher/PermissionsDispatcher https://github.com/googlesamples/android-RuntimePermissions https://www.jianshu.com/p/a51593817825 https://developer.android.com/training/permissions/requesting livedata https://mp.weixin.qq.com/s/Hw_FI0GRpUDWJ1NwjK652w https://mp.weixin.qq.com/s/7RpGzTjXo9rnHRCVEnrYWQ https://mp.weixin.qq.com/s/i8K-6CSxYuLanR4x1WNSGA https://mp.weixin.qq.com/s/gaSmpT5UQLqNa4Ck0r0eOg http://blog.csdn.net/huaiyiheyuan/article/details/52473984https://developer.android.com/training/permissions/requesting.html Android 10权限在后台运行时访问设备位置信息需要权限 &lt;uses-permission android:name=&quot;android.permission.ACCESS_BACKGROUND_LOCATION&quot;/&gt; 该权限允许应用程序在后台访问位置。如果请求此权限，则还必须请求ACCESS_FINE_LOCATION 或 ACCESS_COARSE_LOCATION权限。只请求此权限无效果 在Android 10的设备上，如果你的应用的 targetSdkVersion &lt; 29，则在请求ACCESS_FINE_LOCATION 或ACCESS_COARSE_LOCATION权限时，系统会自动同时请求ACCESS_BACKGROUND_LOCATION。在请求弹框中，选择“始终允许”表示同意后台获取位置信息，选择“仅在应用使用过程中允许”或”拒绝”选项表示拒绝授权。 如果你的应用的 targetSdkVersion &gt;= 29，则请求ACCESS_FINE_LOCATION 或 ACCESS_COARSE_LOCATION权限表示在前台时拥有访问设备位置信息的权限。在请求弹框中，选择“始终允许”表示前后台都可以获取位置信息，选择“仅在应用使用过程中允许”只表示拥有前台的权限。 https://developer.android.com/about/versions/10/privacy/changes https://juejin.im/post/6844904073024503822#heading-5","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"English","slug":"English","date":"2017-11-23T11:28:27.000Z","updated":"2021-08-19T11:11:43.803Z","comments":true,"path":"2017/11/23/English/","link":"","permalink":"http://noteforme.github.io.com/2017/11/23/English/","excerpt":"","text":"Book感谢楼主楼主 Dicthttps://forum.freemdict.com/ https://mdx.mdict.org/ https://mdx.mdict.org/%E6%8C%89%E8%AF%8D%E5%85%B8%E8%AF%AD%E7%A7%8D%E6%9D%A5%E5%88%86%E7%B1%BB/ https://freemdict.com/ https://mdict.org/ 划词翻译https://www.bilibili.com/video/av16816801/ https://www.youtube.com/watch?v=SIojtnMplHc https://www.bilibili.com/video/av455529337 English grammar in usehttps://dl.304304.xyz/uploads/Ludovicus/%E8%8B%B1%E8%AF%AD-%E6%90%AC%E8%BF%90/ 安装完air,然后从安装文件选择资源grammar in use右键选择 windows 7安装 点击brower 选择安装的文件","categories":[{"name":"ENGLISH","slug":"ENGLISH","permalink":"http://noteforme.github.io.com/categories/ENGLISH/"}],"tags":[],"keywords":[{"name":"ENGLISH","slug":"ENGLISH","permalink":"http://noteforme.github.io.com/categories/ENGLISH/"}]},{"title":"ubuntu_server","slug":"ubuntu-server","date":"2017-11-20T13:11:58.000Z","updated":"2021-08-19T11:11:44.318Z","comments":true,"path":"2017/11/20/ubuntu-server/","link":"","permalink":"http://noteforme.github.io.com/2017/11/20/ubuntu-server/","excerpt":"","text":"Linux下上传http://www.jianshu.com/p/c3e4f96ced97在html目录下放文件就可以了 scp /home/jon/桌面/img.jpg root@45.77.222.97:/var/www/html/ nexus-3.20.0-04: not a regular file scp -r /home/jon/桌面/img.jpg root@45.77.222.97:/var/www/html/ windows下上传 安装Xshell 给ubuntu安装管理器 apt-get install -y lrzsz https://www.linuxidc.com/Linux/2015-05/117975.ht、 rz命令上传，会弹出一个框选择文件 查看图片 http://45.77.222.97/homedetail_pic.png JDK Environment ubuntu when I wget tar.gz from oracle office. I couldn’t tar tar.gz ,so I upload one. scp jdk-11.0.5_linux-x64_bin.tar.gz root@xxx/opt/java/ tar -zxvf FileName.tar.gz Edit /etc/profile, touch it if not have, 或者直接在根目录‘ cd / ’输入下面的这些，也可以，具体写入到哪先不管了 #set java JDK export JAVA_HOME=/opt/java/jdk1.8.0_231 export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar export PATH=$JAVA_HOME/bin:$PATH make it work source /etc/profile set jdk. on Mac 123Open ~/.bash_profile export JAVA_HOME=$(/usr/libexec/java_home)source ~/.bash_profile 在64位机器上跑x86的jdk一直提示 -bash: /opt/jdk/jdk1.8.0_231/bin/java: No such file or directory free -m","categories":[{"name":"TOOL","slug":"TOOL","permalink":"http://noteforme.github.io.com/categories/TOOL/"}],"tags":[],"keywords":[{"name":"TOOL","slug":"TOOL","permalink":"http://noteforme.github.io.com/categories/TOOL/"}]},{"title":"View_OVER","slug":"View_OVER","date":"2017-11-12T13:24:33.000Z","updated":"2021-08-19T11:11:44.280Z","comments":true,"path":"2017/11/12/View_OVER/","link":"","permalink":"http://noteforme.github.io.com/2017/11/12/View_OVER/","excerpt":"","text":"自定义View函数调用流程 构造函数执行一次 onMeasure(), onLayout(), onDraw()都可能运行很多次。 所以onMeasure() 用的变量不能在构造方法初始化。 http://gcssloop.github.io/customview/CustomViewProcess 窗口显示 每个Activity包含一个Window对象，Android中window对象由PhoneWindow实现，PhoneWindow将一个DecorView设置为整个应用窗口的根View,DecorView作为窗口界面的顶层视图，封装了窗口操作的通用方法，DecorView将要显示的具体内容显示在PhoneWindow上，这里所有的View监听事件通过WindowMangerService来接收,通过Activity对象来回调相应的onCLicklistener.显示是将屏幕分成两部分，一个TitleView，另一个是ContentView. Measure如果是原始的 View,通过measure方法就完成了测量过程,如果是ViewGroup,除了完成自己的测量外，还需要遍历所有的子View,各个子元素再去递归执行这个流程. View OnMeasure()方法1234567891011121314151617181920val widthMode = MeasureSpec.getMode(widthMeasureSpec);val widthSize = MeasureSpec.getSize(widthMeasureSpec); widthSize父控件留个子空间的最大宽度val heightMode = MeasureSpec.getMode(heightMeasureSpec);val heightSize = MeasureSpec.getSize(heightMeasureSpec);var width = 10var height = 10if (widthMode == MeasureSpec.EXACTLY) &#123; //如果match_parent或者具体的值，直接赋值 width = widthSize&#125; else if (widthMode == MeasureSpec.AT_MOST) &#123; //w，我们要得到控件需要多大的尺寸 width = paddingLeft + mBound.width() + paddingRight&#125;//高度跟宽度处理方式一样if (heightMode == MeasureSpec.EXACTLY) &#123; height = heightSize&#125; else if (heightMode == MeasureSpec.AT_MOST) &#123; height = paddingTop + mBound.height() + paddingBottom&#125;setMeasuredDimension(width, height) 理解onMeasure https://blog.csdn.net/tuke_tuke/article/details/73302595 加载布局 onSizeChanged因为View的大小不仅由View本身控制，而且受父控件的影响，所以我们在确定View大小的时候最好使用系统提供的onSizeChanged回调函数。它又四个参数，分别为 宽度，高度，上一次宽度，上一次高度。这个函数比较简单，我们只需关注 宽度(w), 高度(h) 即可，这两个参数就是View最终的大小。 链接：https://juejin.cn/post/6844903448186454030 Layoutpublic void layout(int l, int t, int r, int b) 该控件的左 上 右 下边距 ScrollerscrollTo scrollBy在 View 类中，有两个变量 mScrollX 和 mScrollY，它们记录的是 View 的内容的偏移值。mScrollX 和 mScrollY 的默认值都是 0，即默认不偏移。另外我们需要知道一点，向左滑动，mScrollX 为正数，反正为负数。假设我们令 mScrollX = 10，那么该 View 的内容会相对于原来向左偏移 10px。 看看系统的 View 类中的源码： 123456789101112131415161718public class View &#123; /** * The offset, in pixels, by which the content of this view is scrolled * horizontally. * &#123;@hide&#125; */ protected int mScrollX; //整个滑动过程的 X移动范围 /** * The offset, in pixels, by which the content of this view is scrolled * vertically. * &#123;@hide&#125; */ protected int mScrollY; &#125; 滑动绝对距离 1public void scrollTo(int x, int y) 滑动相对距离 1public void scrollBy(int x, int y) Scroller辅助类HorizontalScrollViewEx 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113public class HorizontalScrollViewEx extends ViewGroup &#123; private static final String TAG = &quot;HorizontalScrollViewEx&quot;; private int mChildrenSize; private int mChildWidth; private int mChildIndex; // 分别记录上次滑动的坐标 private int mLastX = 0; private int mLastY = 0; // 分别记录上次滑动的坐标(onInterceptTouchEvent) private int mLastXIntercept = 0; private int mLastYIntercept = 0; private Scroller mScroller; private VelocityTracker mVelocityTracker; public HorizontalScrollViewEx(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; private void init() &#123; mScroller = new Scroller(getContext()); mVelocityTracker = VelocityTracker.obtain(); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; mVelocityTracker.addMovement(event); int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; if (!mScroller.isFinished()) &#123; mScroller.abortAnimation(); &#125; break; &#125; case MotionEvent.ACTION_MOVE: &#123; int deltaX = x - mLastX; int deltaY = y - mLastY; scrollBy(-deltaX, 0); break; &#125; case MotionEvent.ACTION_UP: &#123; int scrollX = getScrollX();// int scrollToChildIndex = scrollX / mChildWidth; mVelocityTracker.computeCurrentVelocity(1000); float xVelocity = mVelocityTracker.getXVelocity(); if (Math.abs(xVelocity) &gt;= 50) &#123; mChildIndex = xVelocity &gt; 0 ? mChildIndex - 1 : mChildIndex + 1; &#125; else &#123; mChildIndex = (scrollX + mChildWidth / 2) / mChildWidth; &#125; mChildIndex = Math.max(0, Math.min(mChildIndex, mChildrenSize - 1)); Log.d(TAG, &quot;xVelocity &quot;+xVelocity+ &quot; mChildIndex &quot; +mChildIndex +&quot; mChildWidth &quot; + mChildWidth); int dx = mChildIndex * mChildWidth - scrollX; Log.d(TAG, &quot; scrollX &quot; + scrollX + &quot; dx &quot; + dx); smoothScrollBy(dx, 0); mVelocityTracker.clear(); break; &#125; default: break; &#125; mLastX = x; mLastY = y; return true; &#125; @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; Log.d(TAG, &quot;left &quot; + l + &quot; top &quot; + t + &quot; right &quot; + r + &quot; bottom &quot; + b); int childLeft = 0; final int childCount = getChildCount(); mChildrenSize = childCount; for (int i = 0; i &lt; childCount; i++) &#123; final View childView = getChildAt(i); if (childView.getVisibility() != View.GONE) &#123; final int childWidth = childView.getMeasuredWidth(); mChildWidth = childWidth; childView.layout(childLeft, 0, childLeft + childWidth, childView.getMeasuredHeight()); childLeft += childWidth; &#125; &#125; &#125; private void smoothScrollBy(int dx, int dy) &#123; mScroller.startScroll(getScrollX(), 0, dx, 0, 500); invalidate(); &#125; @Override public void computeScroll() &#123; if (mScroller.computeScrollOffset()) &#123; Log.d(TAG,&quot;getCurrX &quot;+mScroller.getCurrX() + &quot;mScroller.getCurrY() &quot; +mScroller.getCurrY()); scrollTo(mScroller.getCurrX(), mScroller.getCurrY()); postInvalidate(); &#125; &#125; @Override protected void onDetachedFromWindow() &#123; mVelocityTracker.recycle(); super.onDetachedFromWindow(); &#125;&#125; 可知View的scrollTo()、scrollBy()是瞬间完成的，当我们的手指在屏幕上移动时，内容会跟着手指滑动，但是当我们手指一抬起时，滑动就会停止,为使得滚动更加平滑,Scroller只是计算辅助类，它的startScroll()和computeScrollOffset()方法中也只是对一些轨迹参数进行设置和计算，真正需要进行滑动还是得通过View的scrollTo()、scrollBy()方法 123// 开始滚动，并记下当前时间点作为开始滚动的时间点startX startY，滑动时起点偏移量，public void startScroll(int startX, int startY, int dx, int dy, int duration) 开始一个动画控制，由(startX , startY)在duration时间内前进(dx,dy)个单位，即到达偏移坐标为(startX+dx , startY+dy)处。 滑动日志,startX+dx是1080 2160,印证了上面的判断 12com.ryg.chapter_3 D/HorizontalScrollViewEx: scrollX 821 dx 259com.ryg.chapter_3 D/HorizontalScrollViewEx: scrollX 2007 dx 153 实际滑动处理类，Scroller类应该有个插值器，提供滑动控制 12345678@Overridepublic void computeScroll() &#123; if (mScroller.computeScrollOffset()) &#123; Log.d(TAG,&quot;getCurrX &quot;+mScroller.getCurrX() + &quot;mScroller.getCurrY() &quot; +mScroller.getCurrY()); scrollTo(mScroller.getCurrX(), mScroller.getCurrY()); postInvalidate(); &#125;&#125; http://chanthuang.github.io/2016/08/31/Android-View-%E7%9A%84%E6%BB%9A%E5%8A%A8%E5%8E%9F%E7%90%86%E5%92%8C-Scroller%E3%80%81VelocityTracker-%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/ https://www.jianshu.com/p/f10809e1964b DrawPaint 为了展示方便，容易看出效果，之前使用的模式一直为填充模式，实际上画笔有三种模式，如下： 123STROKE //描边FILL //填充FILL_AND_STROKE //描边加填充 为了区分三者效果我们做如下实验： 123456789101112131415Paint paint = new Paint();paint.setColor(Color.BLUE);paint.setStrokeWidth(40); //为了实验效果明显，特地设置描边宽度非常大// 描边paint.setStyle(Paint.Style.STROKE);canvas.drawCircle(200,200,100,paint);// 填充paint.setStyle(Paint.Style.FILL);canvas.drawCircle(200,500,100,paint);// 描边加填充paint.setStyle(Paint.Style.FILL_AND_STROKE);canvas.drawCircle(200, 800, 100, paint); 画布坐标操作 1canvas.scale(1,-1); // 翻转Y轴 自定义属性类别 boolean 表示attr取值为true或者falsecolor 表示attr取值是颜色类型，例如#ff3344,或者是一个指向color的资源id，例如R.color.colorAccent.dimension 表示 attr 取值是尺寸类型，例如例如取值16sp、16dp，也可以是一个指向dimen的资源id，例 如R.dimen.dp_16float 表示attr取值是整形或者浮点型fraction 表示 attr取值是百分数类型，只能以%结尾，例如30%integer 表示attr取值是整型string 表示attr取值是String类型，或者一个指向String的资源id，例如R.string.testStringreference 表示attr取值只能是一个指向资源的id。enum 表示attr取值只能是枚举类型。 refrence , 表示attr取值只能是一个指向资源的id。 注意 dimension , 1234val a = context!!.obtainStyledAttributes(attrs, R.styleable.ViewBodySleep , defStyleAttr, 0) linePaint.textSize = a.getDimensionPixelSize(R.styleable.ViewBodySleep_vbltextsize,21).toFloat() indexPaint.textSize = a.getDimensionPixelSize(R.styleable.ViewBodySleep_vbltextsize,21).toFloat() a.recycle() https://github.com/GcsSloop/AndroidNote/tree/master/CustomView https://www.sunzn.com/2017/08/21/%E8%87%AA%E5%AE%9A%E4%B9%89-View-%E5%9F%BA%E7%A1%80-%E8%A7%92%E5%BA%A6%E4%B8%8E%E5%BC%A7%E5%BA%A6/ setWillNotDrawViewGroup默认情况下，出于性能考虑，会被设置成WILL_NOT_DROW，这样，ondraw就不会被执行了。 如果我们想重写一个viewgroup的ondraw方法，有两种方法： 1，构造函数中，给viewgroup设置一个颜色。 2，构造函数中，调用setWillNotDraw（false），去掉其WILL_NOT_DRAW flag。 在viewgroup初始化的时候，它调用了一个私有方法：initViewGroup，它里面会有一句setFlags（WILLL_NOT_DRAW,DRAW_MASK）;相当于调用了setWillNotDraw（true），所以说，对于ViewGroup，他就认为是透明的了，如果我们想要重写onDraw，就要调用setWillNotDraw（false）。 https://www.jianshu.com/p/7df7e8a0b1a6 https://juejin.im/post/5e6e0b91f265da5716712288 RelativeLayout就是拓扑排序，用到了不光是树，还有图。所以数据结构与算法真的非常重要，他会让你的学习不会再那么枯燥。 childview https://www.jianshu.com/p/c84693096e41 https://mp.weixin.qq.com/s/psrDADxwl782Fbs_vzxnQg UI 优化系列专题https://www.jianshu.com/p/ea464eb15436 淘宝详情onLayout 两个子view切换绘制 https://juejin.cn/post/6844903828035207182","categories":[{"name":"VIEW","slug":"VIEW","permalink":"http://noteforme.github.io.com/categories/VIEW/"}],"tags":[{"name":"VIEW","slug":"VIEW","permalink":"http://noteforme.github.io.com/tags/VIEW/"}],"keywords":[{"name":"VIEW","slug":"VIEW","permalink":"http://noteforme.github.io.com/categories/VIEW/"}]},{"title":"View_CanvasApi","slug":"View_CanvasApi","date":"2017-11-12T04:34:50.000Z","updated":"2021-08-19T11:11:44.279Z","comments":true,"path":"2017/11/12/View_CanvasApi/","link":"","permalink":"http://noteforme.github.io.com/2017/11/12/View_CanvasApi/","excerpt":"","text":"Canvas的常用操作速查表 操作类型 相关API 备注 绘制颜色 drawColor, drawRGB, drawARGB 使用单一颜色填充整个画布 绘制基本形状 drawPoint, drawPoints, drawLine, drawLines, drawRect, drawRoundRect, drawOval, drawCircle, drawArc 依次为 点、线、矩形、圆角矩形、椭圆、圆、圆弧 绘制图片 drawBitmap, drawPicture 绘制位图和图片 绘制文本 drawText, drawPosText, drawTextOnPath 依次为 绘制文字、绘制文字时指定每个文字位置、根据路径绘制文字 绘制路径 drawPath 绘制路径，绘制贝塞尔曲线时也需要用到该函数 顶点操作 drawVertices, drawBitmapMesh 通过对顶点操作可以使图像形变，drawVertices直接对画布作用、 drawBitmapMesh只对绘制的Bitmap作用 画布剪裁 clipPath, clipRect 设置画布的显示区域 画布快照 save, restore, saveLayerXxx, restoreToCount, getSaveCount 依次为 保存当前状态、 回滚到上一次保存的状态、 保存图层状态、 回滚到指定状态、 获取保存次数 画布变换 translate, scale, rotate, skew 依次为 位移、缩放、 旋转、错切 Matrix(矩阵) getMatrix, setMatrix, concat 实际画布的位移，缩放等操作的都是图像矩阵Matrix，只不过Matrix比较难以理解和使用，故封装了一些常用的方法。 PS： Canvas常用方法在上面表格中已经全部列出了，当然还存在一些其他的方法未列出，具体可以参考官方文档 Canvas Use CanvasPath lineTo简单实现 12345canvas.translate(DeviceUtil.mWidth / 2, DeviceUtil.mHeight / 2); //原点移动到屏幕中心 Path path = new Path(); path.lineTo(200, 200); path.lineTo(200, 0); canvas.drawPath(path, mPaint); 从字面意思 lineto,顾名思义肯定就有from的坐标点，再看这个借的图，第一条线是从原点开始的，第二条线是从A开始的， 1path.close(); //形成封闭的图形 这些操作都可以叠加 Rect RectF区别: Rect是使用int类型作为数值，RectF是使用float类型作为数值。 四个参数是 矩形左上角和右下角两个点的坐标 画线 1234Path path = new Path();path.moveTo(100, 100);path.rLineTo(100, 200);canvas.drawPath(path, mPaint); Draw Circle 画笔 1234mPaint = new Paint();mPaint.setColor(Color.BLUE);mPaint.setStyle(Paint.Style.FILL); // Fill是空心圆 ，STROKE实心圆,空心圆就需要设置setStrokeWidth这个属性 canvas.drawCircle(getWidth()/2,getHeight()/2,getWidth()/2,mPaint); public void drawArc(RectF oval, float startAngle, float sweepAngle, boolean useCenter, Paint paint) oval :指定圆弧的外轮廓矩形区域。startAngle: 圆弧起始角度，单位为度。sweepAngle: 圆弧扫过的角度(起始位置 X轴)，顺时针方向，单位为度,从右中间开始为零度。useCenter: 如果为True时，在绘制圆弧时将圆心包括在内，通常用来绘制扇形 RectF是矩形的内接圆,left top right bottom分别对象 左上角和右下角 坐标 drawText坐标(0,0)位于左下角 1canvas?.drawText(&quot;测试文字&quot;,0f,0f,mPaint) measure textSize 123456val kgRect = Rect()var kgText = &quot;hello world&quot;mDialPaint.getTextBounds(kgText,0,kgText.length,kgRect)var txtHeight = kgRect.height()var txtWidth = kgRect.width() 123456canvas.drawPoint(200, 200, mPaint); canvas.drawPoints(new float[]&#123; //绘制一组点，坐标位置由float数组指定 500, 500, 500, 600, 500, 700 &#125;, mPaint); 位移(translate) 1234567// 在坐标原点绘制一个黑色圆形 canvas.translate(200, 200); canvas.drawCircle(0, 0, 100, mPaint); // 在坐标原点绘制一个蓝色圆形 mPaint.setColor(Color.BLUE); canvas.translate(200, 200); canvas.drawCircle(0, 0, 100, mPaint); 缩放(scale) 12345678910111213141516canvas.translate(mWidth / 2, mHeight / 2); RectF rect = new RectF(0, -400, 400, 0); // 矩形区域 mPaint.setColor(Color.BLACK); // 绘制黑色矩形 canvas.drawRect(rect, mPaint); canvas.scale(-0.5f, -0.5f); // 画布缩放 &lt;-- 缩放中心向右偏移了200个单位 mPaint.setColor(Color.BLUE); // 绘制蓝色矩形 canvas.drawRect(rect, mPaint); RectF rect = new RectF(-400, -400, 400, 400); canvas.drawRect(rect, mPaint); for (int i = 0; i &lt; 20; i++) &#123; canvas.scale(0.9f, 0.9f); canvas.drawRect(rect, mPaint); &#125; 旋转(rotate) 1canvas.rotate(180); drawPicture 三个方法 public void drawPicture (Picture picture) public void drawPicture (Picture picture, Rect dst) public void drawPicture (Picture picture, RectF dst) drawBitmap 三个方法 // 第一种 public void drawBitmap (Bitmap bitmap, Matrix matrix, Paint paint) // 第二种 public void drawBitmap (Bitmap bitmap, float left, float top, Paint paint) // 第三种 public void drawBitmap (Bitmap bitmap, Rect src, Rect dst, Paint paint) public void drawBitmap (Bitmap bitmap, Rect src, RectF dst, Paint paint) 直接看第三种方法 1234567// 指定图片绘制区域(左上角的四分之一)Rect src = new Rect(0, 0, bitmap.getWidth() / 2, bitmap.getHeight() / 2);// 指定图片在屏幕上显示的区域Rect dst = new Rect(0, 0, 400, 500);//绘制图片canvas.drawBitmap(bitmap, src, dst, null); Angle 在常见的数学坐标系中角度增大方向为逆时针， 在默认的屏幕坐标系中角度增大方向为顺时针。 sweepAngle扫过的角度 12drawArc(@NonNull RectF oval, float startAngle, float sweepAngle, boolean useCenter, @NonNull Paint paint) canvas?.drawArc(rectF,0f,145f,false,mDialPaint) save restoreSaveRestoreView 12345 canvas?.drawLine(0f,200f,700f,200f,linePaint)// canvas?.save() //将画布状态保存 canvas?.rotate(90f, px / 2, py / 2);// canvas?.restore();//恢复画布状态 这个操作能撤销到 上次保存的画布状态 canvas?.drawLine(0f,400f,700f,400f,bgPaint) 运行效果： 打开注释后的运行效果，这样运行后相当于 没有发生选择画布这件事。 saveslayer 图层https://blog.csdn.net/cquwentao/article/details/51423371 https://www.jianshu.com/p/0bd672626c8d Canvas demo https://medium.com/better-programming/learn-all-android-canvas-draw-functions-dd5d6595884a","categories":[{"name":"VIEW","slug":"VIEW","permalink":"http://noteforme.github.io.com/categories/VIEW/"}],"tags":[{"name":"VIEW","slug":"VIEW","permalink":"http://noteforme.github.io.com/tags/VIEW/"}],"keywords":[{"name":"VIEW","slug":"VIEW","permalink":"http://noteforme.github.io.com/categories/VIEW/"}]},{"title":"Gogs","slug":"Gogs","date":"2017-11-12T01:08:56.000Z","updated":"2021-08-19T11:11:43.902Z","comments":true,"path":"2017/11/12/Gogs/","link":"","permalink":"http://noteforme.github.io.com/2017/11/12/Gogs/","excerpt":"","text":"ubuntu 17.04 Gogs搭建git服务器 gogs Install创建git用户12345678910sudo apt-get upgradesudo adduser git //创建用户 密码 ******* (1234)su git//切换到git用户cd ~ //进入用户git根目录git --version //检查git是否安装 修改git密码 到root下 passwd git 然后输入密码http://wangchujiang.com/linux-command/c/passwd.html # 创建数据库 这个可以选择默认的sqlite3救不需要安装mysql 123456mysql -u root -pmysql&gt; SET GLOBAL storage_engine = &#x27;InnoDB&#x27;;mysql&gt; CREATE DATABASE gogs CHARACTER SET utf8 COLLATE utf8_bin;mysql&gt; GRANT ALL PRIVILEGES ON gogs.* TO ‘root’@‘localhost’ IDENTIFIED BY ‘itadmin’;mysql&gt; FLUSH PRIVILEGES;mysql&gt; QUIT； ## 安装golang环境(可以忽略) 1234567891011121314su git环境变量export GOROOT=$HOME/go //目录下export GOARCH=amd64 #系统位数，386表示32位系统，amd64表示64位系统。export GOOS=linux #系统类型export PATH=$PATH:$GOROOT/bin//使环境变量生效：source ~/.bashrcwget https://github.com/gogits/gogs/releases/download/v0.11.29/go1.9.2.linux-amd64.tar.gztar zxvf go1.9.2.linux-amd64.tar.gzmv go $GOROOT //这一步有点问题，已存在文件go env //测试这个一步 倒是没问题 安装Gogs123456su git cd ~wget https://github.com/gogits/gogs/releases/download/v0.11.29/linux_amd64.tar.gztar zxvf linux_amd64.tar.gz //解压后会右gogs文件 cd gogs ./gogs web 安装配置浏览器输入 http://yourip:3000/install 进行配置 如图 把localhost改成yourip 后台运行1234su gitcd /home/git/gogs nohup ./gogs web&amp; 参考：雨巷前端 雨巷前端 重启查找gogs目录 find / -name &#39;gogs&#39; 然后按照后台运行 Gogs upgrade sudo su - git cd ~ pwd ls mv gogs gogs_old wget https://dl.gogs.io/0.11.91/gogs_0.11.91_linux_amd64.tar.gz tar -zxvf gogs_0.11.91_linux_amd64.tar.gz ls cp -R gogs_old/{custom,data,log} gogs cd gogs ./gogs web https://gogs.io/docs/upgrade/upgrade_from_binary clone地址为 localhost问题 /home/git/gogs/custom/conf下把app.ini，DOMAIN ROOT_URL 改成主机ip Draw12/root/DRAW/apache-tomcat-8.5.65/bin./startup.sh","categories":[{"name":"LINUX","slug":"LINUX","permalink":"http://noteforme.github.io.com/categories/LINUX/"}],"tags":[],"keywords":[{"name":"LINUX","slug":"LINUX","permalink":"http://noteforme.github.io.com/categories/LINUX/"}]},{"title":"background_draw (背景图形绘制)","slug":"background_draw","date":"2017-11-03T01:59:57.000Z","updated":"2021-08-19T11:11:44.298Z","comments":true,"path":"2017/11/03/background_draw/","link":"","permalink":"http://noteforme.github.io.com/2017/11/03/background_draw/","excerpt":"","text":"** 为了提高App性能，经常会用到代码写背景 ** 基本属性 solid : 填充内容 stroke: 绘制边框 代码里设置颜色 Color.parseColor(&quot;#fa6d62&quot;) 点击选中状态 android:state_pressed 是否按下，如一个按钮触摸或者点击。 android:state_focused 是否取得焦点，比如用户选择了一个文本框。 android:state_hovered 光标是否悬停，通常与focused state相同，它是4.0的新特性 android:state_selected 被选中，它与focus state并不完全一样，如一个list view 被选中的时候，它里面的各个子组件可能通过方向键，被选中了。 android:state_checkable 组件是否能被check。如：RadioButton是可以被check的。 android:state_checked 被checked了，如：一个RadioButton可以被check了。 android:state_enabled 能够接受触摸或者点击事件 android:state_activated 被激活(这个麻烦举个例子，不是特明白) android:state_window_focused 应用程序是否在前台，当有通知栏被拉下来或者一个对话框弹出的时候应用程序就不在前台了 注意:如果有多个item，那么程序将自动从上到下进行匹配，最先匹配的将得到应用。（不是通过最佳匹配） 如果一个item没有任何的状态说明，那么它将可以被任何一个状态匹配。 https://blog.csdn.net/yinbucheng/article/details/52922759 seleced用于单选，checked用于多选, selected是选择很多项，但是只取当前的项，即最后一个选中的 checked是选中很多项，都选中。 shape layer-list selector设置Button按钮背景 12345678910&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;corners android:radius=&quot;20dp&quot; /&gt; &lt;!-- 边框的颜色--&gt; &lt;stroke android:width=&quot;2dp&quot; android:color=&quot;#009cff&quot; /&gt; &lt;!--填充的颜色 --&gt; &lt;solid android:color=&quot;@android:color/transparent&quot; /&gt;&lt;/shape&gt; shape &lt;shape android:shape=&quot;rectangle&quot;&gt; &lt;solid android:color=&quot;#2e97f3&quot; /&gt; //填充颜色 &lt;stroke android:width=&quot;2dp&quot; //描边宽度 android:color=&quot;#2e97f3&quot; /&gt; //描边颜色 &lt;/shape&gt; layer-list&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item&gt; &lt;shape android:shape=&quot;rectangle&quot;&gt; &lt;solid android:color=&quot;#2e97f3&quot; /&gt; &lt;stroke android:width=&quot;2dp&quot; android:color=&quot;#2e97f3&quot; /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:top=&quot;50dp&quot;&gt; &lt;shape android:shape=&quot;rectangle&quot;&gt; &lt;solid android:color=&quot;@android:color/holo_green_dark&quot; /&gt; &lt;padding android:left=&quot;50dp&quot;/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:top=&quot;100dp&quot;&gt; &lt;shape android:shape=&quot;rectangle&quot;&gt; &lt;solid android:color=&quot;@android:color/holo_orange_light&quot; /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;/layer-list&gt; LayerDrawable 是管理其他可绘制对象阵列的可绘制对象。列表中的每个可绘制对象按照列表的顺序绘制，列表中的最后一个可绘制对象绘于顶部。每个可绘制对象由单一 元素内的 元素表示。我们需要注意的是layer-list中有item的先后顺序会影响展示效果，不同顺序的效果可能大相径庭，因为，后面的item总是在之前的item之上并覆盖显示。 selector 底部选择器 123456789101112131415161718192021 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:state_selected=&quot;true&quot;&gt; &lt;layer-list&gt; &lt;item&gt; &lt;color android:color=&quot;#2e97f3&quot; /&gt; &lt;/item&gt; &lt;item android:bottom=&quot;5dp&quot; android:drawable=&quot;@color/white&quot; /&gt; &lt;/layer-list&gt; &lt;/item&gt; &lt;item&gt; &lt;layer-list&gt; &lt;item&gt; &lt;color android:color=&quot;#2e97f3&quot; /&gt; &lt;/item&gt; &lt;item android:drawable=&quot;@color/white&quot; /&gt; &lt;/layer-list&gt; &lt;/item&gt;&lt;/selector&gt; 参考 https://keeganlee.me/post/android/20150909 背景选择器 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:drawable=&quot;@drawable/bg_circle_tab_yellow&quot; android:state_selected=&quot;true&quot; /&gt; &lt;item android:drawable=&quot;@drawable/bg_circle_tab_gray&quot; /&gt;&lt;/selector&gt; 字体颜色选择器 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:color=&quot;@color/white&quot; android:state_selected=&quot;true&quot; /&gt; &lt;item android:color=&quot;#999999&quot; /&gt;&lt;/selector&gt; 后面的item在之前的item上显示，所有前面设置的padding,后面叠加形成图层 http://blog.csdn.net/xiehuimx/article/details/70242676https://developer.android.com/guide/topics/resources/drawable-resource.html#Transition 首页阴影效果office前端时间一直找这种资料，效果一直不如意，不得已用了图片，真是 踏破铁鞋无觅处https://developer.android.com/training/material/shadows-clipping.html 123456789 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;rectangle&quot;&gt; &lt;stroke android:width=&quot;1dp&quot; android:color=&quot;#f9fafc&quot; /&gt; &lt;corners android:radius=&quot;2dp&quot; /&gt; &lt;solid android:color=&quot;@color/white&quot; /&gt;&lt;/shape&gt; 不过这种方法还是差强人意 another可以试试下面这种方式 http://blog.csdn.net/u011421608/article/details/51923812http://yifeng.studio/2017/02/26/android-elevation-and-shadow/ 画虚线&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;line&quot;&gt; &lt;!-- jon 虚线--&gt; &lt;size android:height=&quot;1dp&quot; /&gt; &lt;stroke android:width=&quot;1dp&quot; android:color=&quot;@color/white&quot; android:dashGap=&quot;2dp&quot; android:dashWidth=&quot;4dp&quot; /&gt; &lt;!-- dashwidth是指- - -中每一个-的宽度--&gt; &lt;!-- dashGap是指虚线中每一个间隔的宽度 --&gt; height比height高 关闭硬件加速 android:layerType=”software” 12345&lt;View android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;10dp&quot; android:layout_below=&quot;@+id/rl_time_day&quot; android:background=&quot;@drawable/bg_dash_line&quot; /&gt; 参考： https://lianyuchen.github.io/2017/05/09/%E5%85%B3%E4%BA%8Eshape%E7%94%BB%E8%99%9A%E7%BA%BF/ http://www.jianshu.com/p/75cc93195f7a?from=jiantop.com https://keeganlee.me/post/android/20150909 LinearLayout默认横线 android:divider=&quot;@drawable/shape_line android:dividerPadding=&quot;@dimen/dimen_15&quot; 123* shape_line.xml &lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;solid android:color=&quot;@color/line_color&quot; /&gt; &lt;size android:height=&quot;0.5dp&quot; /&gt; &lt;/shape&gt; https://blog.csdn.net/BingShuShu/article/details/51444206","categories":[{"name":"VIEW","slug":"VIEW","permalink":"http://noteforme.github.io.com/categories/VIEW/"}],"tags":[],"keywords":[{"name":"VIEW","slug":"VIEW","permalink":"http://noteforme.github.io.com/categories/VIEW/"}]},{"title":"tool_imgResource","slug":"tool-imgResource","date":"2017-10-21T00:53:39.000Z","updated":"2021-08-19T11:11:44.316Z","comments":true,"path":"2017/10/21/tool-imgResource/","link":"","permalink":"http://noteforme.github.io.com/2017/10/21/tool-imgResource/","excerpt":"","text":"有时候想写点东西 苦于没有素材 https://icons8.com/http://www.iconfont.cn https://icomoon.io/http://fontello.com/ 也可以导入矢量图https://developer.android.com/studio/write/vector-asset-studio.html?hl=zh-cn https://material.io/icons/ 官方图","categories":[{"name":"TOOL","slug":"TOOL","permalink":"http://noteforme.github.io.com/categories/TOOL/"}],"tags":[],"keywords":[{"name":"TOOL","slug":"TOOL","permalink":"http://noteforme.github.io.com/categories/TOOL/"}]},{"title":"GIT_SSHKEY","slug":"Git_SSKEY","date":"2017-10-19T01:28:15.000Z","updated":"2021-08-20T02:53:21.066Z","comments":true,"path":"2017/10/19/Git_SSKEY/","link":"","permalink":"http://noteforme.github.io.com/2017/10/19/Git_SSKEY/","excerpt":"","text":"原理http://skypegnu1.blog.51cto.com/8991766/1641064 多平台配置SSH正常情况会哟几个平台的配置情况,ssh操作方式 用户信息设置在config后加上 –global 即可全局设置用户名和邮箱，否则就是局部的。有时候用手输入才有用 $ git config –global user.name “John Doe” $ git config –global user.email &#x6a;&#111;&#104;&#x6e;&#100;&#111;&#x65;&#x40;&#x65;&#120;&#97;&#109;&#x70;&#108;&#101;&#x2e;&#x63;&#x6f;&#109; 检查配置信息 git config --list 生成sshkey如果视其他平台生成时就要修改名称了 ssh-keygen -t rsa -b 4096 -C “&#x79;&#111;&#x75;&#x72;&#x5f;&#101;&#x6d;&#x61;&#x69;&#x6c;&#x40;&#x65;&#120;&#97;&#109;&#x70;&#x6c;&#x65;&#46;&#x63;&#111;&#109;“Enter file in which to save the key (/home/jon/.ssh/id_rsa): /home/jon/.ssh/id_rsa.Oschinacat ~/.ssh/id_rsa.li | clip Adding your SSH key to the ssh-agent start the ssh-agent in the background $ eval $(ssh-agent -s) Agent pid 59566 $ ssh-add ~/.ssh/id_rsa.li gitbash下把生成的id_rsa.pub 添加到sshkey oschina 测试连接：$ ssh -T git@git.oschina.net github 测试连接: $ ssh -T git@github.com如果出现: Hi username! You’ve successfully authenticated, but GitHub does not provide shell access. 配置成功 不同平台 不同的rsa.key 我前面的key重新命名，clone项目还是有问题 解决方法: 在 .ssh目录下 新建config文件 添加 Host github HostName github.com User Jon IdentityFile ~/.ssh/id_rsa.li 不同的平台，相同的rsa.key (推荐)复制id_rsa.pub填入 clip &lt; ~/.ssh/id_rsa.pub 参考：github生成方式https://help.github.com/articles/about-ssh/ gitlab生成方式https://gitlab.com/help/ssh/README oschina方式:http://git.mydoc.io/?t=154712 gogs:参考github,配置sskey后还需要用账号登陆 问题 类似下面错误使用 git push -u origin master git push -f origin master ! [rejected] master -&gt; master (fetch first)error: failed to push some refs to ‘https://github.com/aniruddhabarapatre/learn-rails.git&#39;hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushing 参考：https://stackoverflow.com/questions/20939648/issue-pushing-new-code-in-github 生成key时，我改成了 id_rsaOschina android studio 最后push 时 authentication id_rsaOschina using key failed报错 方法: AndroidStudio -&gt; File -&gt; Settings -&gt;Git -&gt; SSH executable : built-in 改成Native 参考:https://stackoverflow.com/questions/24688700/android-studio-push-failed-fatal-could-not-read-from-remote-repository GitHub CLI 配置 在windows平台 git auth login 授权 要用windows命令行工具。","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://noteforme.github.io.com/tags/Git/"}],"keywords":[]},{"title":"GIT_BRANCH","slug":"Git_BRANCH","date":"2017-10-19T01:24:09.000Z","updated":"2021-08-19T11:11:43.897Z","comments":true,"path":"2017/10/19/Git_BRANCH/","link":"","permalink":"http://noteforme.github.io.com/2017/10/19/Git_BRANCH/","excerpt":"","text":"官方文档https://git-scm.com/book/en/v2http://iissnan.com/progit/ Git基本操作github上传项目 分支创建 1234git branch Dev1.10 git push origin Dev1.10 // 提交该分支到远程仓库git pull origin dev //从远程获取分支 下面是对已有项目的提交 12345678mkdir EffectiveJavacd EffectiveJavagit inittouch README.mdgit add README.mdgit commit -m &quot;first commit&quot;git remote add origin git@gitee.com:huaiyi/EffectiveJava.gitgit push -u origin master 分支提交到远程仓库$ git push origin v1.0.0 commit Git撤销git commit 但是未git push的修改 找到上次git commit的 id git log 找到你想撤销的commit_id git reset –hard commit_id 完成撤销,同时将代码恢复到前一commit_id 对应的版本。 git reset commit_id 完成Commit命令的撤销，但是不对代码修改进行撤销，可以直接通过git commit 重新提交对本地代码的修改。 git分支简介 http://blog.csdn.net/hyr83960944/article/details/36185231 合并分支合并hotfix到dev 12$ git checkout // 先切换到dev $ git merge hotfix 合并分支 获取本地没有的远程分支1git branch -r #查看远程分支 或 git branch -a #查看所有分支 会显示 1234567origin/HEAD -&gt; origin/masterorigin/daily/1.2.2origin/daily/1.3.0origin/daily/1.4.1origin/developorigin/feature/daily-1.0.0origin/master 然后直接 1git checkout origin/daily/1.4.1 https://gaohaoyang.github.io/2016/07/07/git-clone-not-master-branch/ 官方 显示远程仓库 $ git remote show origin 1. 本地分支重命名(还没有推送到远程) 1git branch -m oldName newName 2. 远程分支重命名 (已经推送远程-假设本地分支和远程对应分支名称相同) a. 重命名远程分支对应的本地分支 1git branch -m oldName newName b. 删除远程分支 1git push --delete origin oldName c. 删除本地分支 ` git branch -d v1.0.0 ` 获取远程其他分支 ​ 修复已发布版本bug修复bug主要以下几步: 使用git reset –hard 命令退回到发布标签对应的版本 使用git checkout -b BugFix新建一个BugFix的分支，原分支前进到最新提交版本 使用git checkout BugFix切换到BugFix分支，修改bug，重新发布并使用git tag打标签 git reaset –hard 切换主干最新的分支 使用git merge合并BugFix分支到主分支 参考:https://blog.masterliu.net/git-retag/ 标签是一个文件快照，并不是真拉出一份代码放在了那里 12D:\\Project\\ASProjects\\cqianjia&gt;git tagv1.0.2 参考: http://gepeiyu.com/2017/06/28/git-tag-oldversion-debug/ 还有一种情况是在最新提交版本修复bug git stash https://www.jianshu.com/p/54b8ea4317cc https://qiita.com/hudichao/items/d665cd769ed1d2ce832a 远程仓库更新到本地12$ git fetch origin$ git merge origin/hexo 或者合并 1$ git pull origin hexo http://www.ruanyifeng.com/blog/2014/06/git_remote.html fork后的项目处理 https://gaohaoyang.github.io/2015/04/12/Syncing-a-fork/ 忽略文件已提交的文件 对于单个文件处理 假如要忽略 .idea/misc.xml文件，.gitignore可以添加 /.idea/* 把.idea文件过滤 主要是 git rm --cached .idea/misc.xml 然后提交修改,每次手输入才有用? 对文件夹的处理,比如common-bankcard 12git rm -r --cached common-bankcardgit rm --cached *idea/* Git仓库迁移 迁移git仓库 原来托管于github,clone一份裸版本库 git clone --bare git@gitee.com:huaiyi/CQJ.git 在新的版本库(gitlab)里面创建一个新的项目，例如 cqianjia 推送刚才clone的镜像到gitlab服务器 12cd CQJ.git/git push --mirror git@45.77.22.97:root/cqianjia.git mirror 克隆出来的裸版本对上游版本库进行了注册，这样可以在裸版本库中使用git fetch命令和上游版本库进行持续同步 删除本地代码 12cd ..rm -rf project.git 到新的服务器clone到本地就Ok了 git clone git@45.77.22.97:root/cqianjia.git 参考: https://my.oschina.net/kind790/blog/510601 git clone 所有分支 这种方式有一个弊端，切换分支后 工程名没了， 还是慢慢摸索吧 ! 123git branch -r | grep -v &#x27;\\-&gt;&#x27; | while read remote; do git branch --track &quot;$&#123;remote#origin/&#125;&quot; &quot;$remote&quot;; donegit fetch --allgit pull --all 参考: http://blog.csdn.net/allangold/article/details/78028709 修改远程仓库地址 github创建 New项目，项目地址是 &#x67;&#x69;&#116;&#64;&#103;&#x69;&#116;&#104;&#117;&#98;&#x2e;&#99;&#x6f;&#109;:BlogForMe/News.git 修改远程服务器地址 ：git remote set-url origin git@github.com:BlogForMe/News.git 推送到远程服务器 : git push origin http://jcpplus.github.io/2015/07/23/modify-remote-url/ GIT标签 查看所有的版本​ git tag 查看远程分支 git ls-remote --tags 创建标签 git tag -a v1.0.2 -m &quot;my version 1.0.2&quot; -m 选项指定了一条将会存储在标签中的信息 创建Tag 123git tag -a v1.0.0 -m &quot;my version 1.0.0&quot;git push origin v1.0.0 //推送到远程分支git push origin --tags //推送所有的标签 删除tag 1234567 git tag -d &lt;tagname&gt; git push origin :refs/tags/&lt;tagname&gt;例如 git push origin :refs/tags/v1.0.2 git tag -d v1.0.2 检出标签 检出标签 Checkout Git Tagshttps://devconnected.com/how-to-checkout-git-tags/ 1234git fetch --all --tagsgit checkout tags/v1.0 -b v1.0-branch //git checkout tags/v2.1.1 -b v2.1.1-branchgit log --oneline --graph //You can inspect the state of your branch by using the “git log” command. Make sure that the HEAD pointer (the latest commit) is pointing to your annotated tag. checkout remote tag12345678910git fetch --all --tagsgit ls-remote --tags refs/tags/v2.5.8^&#123;&#125; refs/tags/v2.5.9 refs/tags/v2.5.9^&#123;&#125;git checkout refs/tags/v2.5.9 -b v2.5.9-branch //-b 后面是自定义的分支名称 这个自定义 在 Git 中你并不能真的检出一个标签，因为它们并不能像分支一样来回移动。 如果你想要工作目录与仓库中特定的标签版本完全一样，可以使用 git checkout -b [branchname] [tagname] 在特定的标签上创建一个新分支： $ git checkout -b version2 v2.0.0 Switched to a new branch ‘version2’ 当然，如果在这之后又进行了一次提交，version2 分支会因为改动向前移动了，那么 version2 分支就会和 v2.0.0 标签稍微有些不同，这时就应该当心了。 修复已发布版本\bBughttp://gepeiyu.com/2017/06/28/git-tag-oldversion-debug/ git stash经常有这样的事情发生，当你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作。问题是，你不想提交进行了一半的工作，否则以后你无法回到这个工作点。解决这个问题的办法就是git stash命令。 git stash save &#39;暂存备注信息&#39; //进入暂存状态,此时执行 git status 已经没有要提交的了 git checkout 切换到要修改的分支上 ,修改完 完成后回到原来的开发分支上，git stash apply 获取最近暂存内容 git stash drop stash@&#123;1&#125; apply 选项只尝试应用储藏的工作——储藏的内容仍然在栈上。要移除它，你可以运行 git stash drop，加上你希望移除的储藏的名字： git stash 可以进行多次暂存,多次存后 git stash list长下面这样,可以用 · git stash apply stash@{1}· 获取某次暂存的内容 stash@{0}: WIP on dev: 3d01a6c Patient Entity数据库删除stash@{1}: WIP on dev: b6a688e 跑起来提交 取消储藏 git stash show -p stash@&#123;0&#125; | git apply -R 如果没指定具体的标签 取消最近的 这个和git stash drop的区别是 取消的是文件内容，stash标签还在 https://git-scm.com/docs/git-stash 注意是 stash@{0} 不是 3d01a6c git branch 分支名 hash(历史版本) update forked project https://blog.csdn.net/qq1332479771/article/details/56087333 获取暂存 git stash apply stash@{0} // don‘t remove stash git stash pop stash@{0} SVN SVN不能添加文件:https://blog.csdn.net/yujiayinshi/article/details/51381942 github提速www.github.com 替换为 www.github.com.cnpmjs.org https://github.com/flutter/flutter.git git clone https://github.com.cnpmjs.org/love-flutter/flutter-column.git","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://noteforme.github.io.com/tags/Git/"}],"keywords":[]},{"title":"hot_patch（热更新）","slug":"hot-patch","date":"2017-10-17T07:25:56.000Z","updated":"2021-08-19T11:11:44.300Z","comments":true,"path":"2017/10/17/hot-patch/","link":"","permalink":"http://noteforme.github.io.com/2017/10/17/hot-patch/","excerpt":"","text":"为了预防项目紧急问题，使用热更新比发版要好点 热更新选择 VitrualApk 滴滴开源的方案，之前的dynamic-load-apk推动的热更新的发展,不过这个开源没多久，准备后面迁移到这上面来 Tinker-Bugly 这个很不错免费，就是只支持 冷启动，配合bugly教程用起来方便 sophix 这个支持热启动 配置也方便，不过5万设备以上就要收费，对于收费我觉得也无可厚非，毕竟是别人的劳动成果， 作为开发者的角度，还是开源最好，以后可以学习下。 所以先选择Tinker-Bugly 接入 按照接入文档 配合Demo接入配置，然后就开始做自己的app 定义 修改appid bugly平台申请后的 AppId 123// 这里实现SDK初始化，appId替换成你的在Bugly平台申请的appId // 调试时，将第三个参数改为true Bugly.init(getApplication(), &quot;f7b6508f55&quot;, true); 第三个参数设置 log是否展示 tinkerId 每次修改 基线版本和 补丁版本都要修改 tinkerId 12tinkerId = &quot;1.0.6-patch&quot; 点击 assembleDebug 生成 基线版本 https://bugly.qq.com/docs/user-guide/instruction-manual-android-hotfix-demo/ 1实际应用中，请注意保存线上发布版本的基准apk包、mapping文件、R.txt文件，如果线上版本有bug，就可以借助我们tinker-support插件进行补丁包的生成。 修改 def baseApkDir , 修改 tinkerId 修改bug baseApkDir是根据基线版本生成的目录 修改tinkerId 编译patch包 点击 buildTinkerPatchRelease，生成patch_signed_7zip.apk上传,然后重启就可以了 对于开发设备和全量设备 修改 12//指定为开发设备 Bugly.setIsDevelopmentDevice(getApplication(),true); 参考 ： https://bugly.qq.com/docs/user-guide/instruction-manual-android-hotfix/ https://github.com/Tencent/tinker https://github.com/BuglyDevTeam/Bugly-Android-Demo UncaughtExceptionHandler Bugly冲突 不上报日志https://blog.csdn.net/ZPCrobot/article/details/97390156 从零开始实现一个插件化框架https://blog.csdn.net/qq_22090073/article/details/103946596 https://www.jianshu.com/p/af8c47fabb12","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"","slug":"ConstraintLayout","date":"2017-10-15T02:37:39.000Z","updated":"2021-08-19T11:11:43.766Z","comments":true,"path":"2017/10/15/ConstraintLayout/","link":"","permalink":"http://noteforme.github.io.com/2017/10/15/ConstraintLayout/","excerpt":"","text":"introducehttps://developer.android.com/reference/androidx/constraintlayout/widget/ConstraintLayout Here is the list of available constraints (Fig. 2):layout_constraintLeft_toLeftOflayout_constraintLeft_toRightOflayout_constraintRight_toLeftOflayout_constraintRight_toRightOflayout_constraintTop_toTopOflayout_constraintTop_toBottomOflayout_constraintBottom_toTopOflayout_constraintBottom_toBottomOflayout_constraintBaseline_toBaselineOf //元素对齐layout_constraintStart_toEndOf 控件开始位置 相对另一控件的结束位置layout_constraintStart_toStartOflayout_constraintEnd_toStartOflayout_constraintEnd_toEndOf They all take a reference id to another widget, or the parent (which will reference the parent container, i.e. the ConstraintLayout): 12&lt;Button android:id=&quot;@+id/buttonB&quot; ... app:layout_constraintLeft_toLeftOf=&quot;parent&quot; /&gt; layout_constraintBaseline_toBaselineOf : 表示此控件与某个空间水平对齐 MarginsIf side margins are set, they will be applied to the corresponding constraints (if they exist) (Fig. 3), enforcing the margin as a space between the target and the source side. The usual layout margin attributes can be used to this effect: android:layout_marginStartandroid:layout_marginEndandroid:layout_marginLeftandroid:layout_marginTopandroid:layout_marginRightandroid:layout_marginBottomNote that a margin can only be positive or equals to zero, and takes a Dimension. Margins when connected to a GONE widgetWhen a position constraint target’s visibility is View.GONE, you can also indicate a different margin value to be used using the following attributes: layout_goneMarginStartlayout_goneMarginEndlayout_goneMarginLeftlayout_goneMarginToplayout_goneMarginRightlayout_goneMarginBottom Centering positioning and biasA useful aspect of ConstraintLayout is in how it deals with “impossible” constrains. For example, if we have something like: 123456&lt;android.support.constraint.ConstraintLayout ...&gt; &lt;Button android:id=&quot;@+id/button&quot; ... app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent/&gt;&lt;/&gt; Start_End12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; //全局居中 &lt;android.support.v7.widget.AppCompatButton android:id=&quot;@+id/button1&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:text=&quot;button1&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; //底部以父布局的底部为约束 app:layout_constraintEnd_toEndOf=&quot;parent&quot; //右侧结束以父布局的右侧为约束 app:layout_constraintStart_toStartOf=&quot;parent&quot; //左侧起始以父布局的左侧为约束 app:layout_constraintTop_toTopOf=&quot;parent&quot;/&gt; //顶部以父布局的顶部为约束 &lt;android.support.v7.widget.AppCompatButton android:id=&quot;@+id/button2&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:layout_marginLeft=&quot;30dp&quot; android:layout_marginTop=&quot;30dp&quot; android:text=&quot;button2&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot;/&gt; // 以 button2 为约束的纵向居中 &lt;android.support.v7.widget.AppCompatButton android:id=&quot;@+id/button3&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;button3&quot; app:layout_constraintBottom_toBottomOf=&quot;@id/button2&quot; //底部以button2的底部为约束 app:layout_constraintStart_toEndOf=&quot;@id/button2&quot; app:layout_constraintTop_toTopOf=&quot;@id/button2&quot;/&gt; //顶部以button2的顶部为约束&lt;/android.support.constraint.ConstraintLayout&gt; Guideline使用https://developer.android.com/reference/android/support/constraint/Guideline.html 12app:layout_constraintGuide_percent=&quot;0.2&quot;app:layout_constraintGuide_begin=&quot;100dp&quot; 特色属性 layout_constraintDimensionRatio 指定高度，宽度随着宽高比自适应 1234567&lt;ImageView android:id=&quot;@+id/iv_img01&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@mipmap/img_1&quot; app:layout_constraintDimensionRatio=&quot;1:1&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; /&gt; layout_constraintHorizontal_bias 先设置约束 12app:layout_constraintLeft_toLeftOf=&quot;parent&quot;app:layout_constraintRight_toRightOf=&quot;parent&quot; 然后是比例应用 居中显示 : 四个方向添加约束 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/constraint_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@color/white&quot; app:layout_constraintBottom_toBottomOf=&quot;@+id/constraint_layout&quot; app:layout_constraintEnd_toEndOf=&quot;@id/constraint_layout&quot; app:layout_constraintStart_toStartOf=&quot;@id/constraint_layout&quot; app:layout_constraintTop_toTopOf=&quot;@+id/constraint_layout&quot;&gt; &lt;/Button&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 相对邻里控件 居中 123456789101112131415161718192021222324252627282930313233&lt;android.support.constraint.ConstraintLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:paddingLeft=&quot;@dimen/dimen_16&quot; android:paddingRight=&quot;@dimen/dimen_16&quot;&gt; &lt;TextView android:id=&quot;@+id/tv_calculate_date&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@drawable/bg_rectangle_blue&quot; android:paddingBottom=&quot;4dp&quot; android:paddingLeft=&quot;@dimen/dimen_16&quot; android:paddingRight=&quot;@dimen/dimen_16&quot; android:paddingTop=&quot;4dp&quot; android:text=&quot;三个月&quot; android:textColor=&quot;@color/white&quot; android:textSize=&quot;@dimen/text_size_12&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; /&gt; &lt;TextView android:id=&quot;@+id/tv_calculate_money&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;@dimen/dimen_16&quot; android:text=&quot;￥ 2000&quot; android:textColor=&quot;#0097fc&quot; android:textSize=&quot;@dimen/text_size_12&quot; app:layout_constraintBottom_toBottomOf=&quot;@+id/tv_calculate_date&quot; app:layout_constraintTop_toTopOf=&quot;@+id/tv_calculate_date&quot; /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; chain 3个Button 两两依赖,相当于组成了一个链 Button均分 width = match_constraint (0dp) 1234567891011121314151617181920212223&lt;Button android:id=&quot;@+id/bt_00&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button_00&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toLeftOf=&quot;@+id/bt_01&quot; /&gt; &lt;Button android:id=&quot;@+id/bt_01&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button_01&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/bt_00&quot; app:layout_constraintRight_toLeftOf=&quot;@+id/bt_02&quot; /&gt; &lt;Button android:id=&quot;@+id/bt_02&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button_02&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/bt_01&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; /&gt; app:layout_constraintHorizontal_weight=&quot;2&quot;看属性也可以猜到是干嘛用的了. 12345678910111213141516171819202122232425262728293031&lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=&quot;match_parent&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/guideline_00&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;Button android:id=&quot;@+id/bt_00&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button_00&quot; app:layout_constraintHorizontal_weight=&quot;2&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toLeftOf=&quot;@+id/bt_01&quot; /&gt; &lt;Button android:id=&quot;@+id/bt_01&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button_01&quot; app:layout_constraintHorizontal_weight=&quot;1&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/bt_00&quot; app:layout_constraintRight_toLeftOf=&quot;@+id/bt_02&quot; /&gt; &lt;Button android:id=&quot;@+id/bt_02&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; app:layout_constraintHorizontal_weight=&quot;1&quot; android:text=&quot;Button_02&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/bt_01&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; /&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; Button均份 宽度不为match_constraint 1234567891011121314151617181920212223&lt;Button android:id=&quot;@+id/bt_10&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button_00&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toLeftOf=&quot;@+id/bt_11&quot; /&gt; &lt;Button android:id=&quot;@+id/bt_11&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button_01&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/bt_10&quot; app:layout_constraintRight_toLeftOf=&quot;@+id/bt_12&quot; /&gt; &lt;Button android:id=&quot;@+id/bt_12&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button_02&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/bt_11&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; /&gt; layout_constraintHorizontal_chainStyle 这个属性默认是 spread，还有另外两种方式 packed 和spread_inside packed 123456789101112131415161718192021222324&lt;Button android:id=&quot;@+id/bt_20&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button_20&quot; app:layout_constraintHorizontal_chainStyle=&quot;packed&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toLeftOf=&quot;@+id/bt_21&quot; /&gt; &lt;Button android:id=&quot;@+id/bt_21&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button_21&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/bt_20&quot; app:layout_constraintRight_toLeftOf=&quot;@+id/bt_22&quot; /&gt; &lt;Button android:id=&quot;@+id/bt_22&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button_22&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/bt_21&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; /&gt; spread_inside : width = wrap_content spread_inside : width = 0dp 代码 概述 经过上面的实践，再来张官方的图就好理解了 1、 Spread: The views are evenly distributed (after margins are accounted for). This is the default.2 、 Spread inside: The first and last view are affixed to the constraints on each end of the chain and the rest are evenly distributed.３、Weighted: When the chain is set to either spread or spread inside, you can fill the remaining space by setting one or more views to “match constraints” (0dp). By default, the space is evenly distributed between each view that’s set to “match constraints,” but you can assign a weight of importance to each view using the layout_constraintHorizontal_weight and layout_constraintVertical_weight attributes. If you’re familiar with layout_weight in a linear layout, this works the same way. So the view with the highest weight value gets the most amount of space; views that have the same weight get the same amount of space.４、Packed: The views are packed together (after margins are accounted for). You can then adjust the whole chain’s bias (left/right or up/down) by changing the chain’s head view bias. 参考:https://developer.android.com/training/constraint-layout/index.html最后就是边应用边理解了 Barrier用于控制 Barrier 相对于给定的 View 的位置， app:barrierDirection=”right”,表示barrier在constraint_referenced_ids给定ID的右侧,constraint_referenced_ids的id就是左侧的这些控件 输入信息挺有用的 https://mp.weixin.qq.com/s/QIuww9b0TsNjajEUS8c2fg 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;android.support.constraint.ConstraintLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;@dimen/dimen_11&quot;&gt; &lt;TextView android:id=&quot;@+id/tv_order_num&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;订单编号：10002220000001234&quot; android:textColor=&quot;#ff999999&quot; android:textSize=&quot;19sp&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; /&gt; &lt;TextView android:id=&quot;@+id/tv_order_pro&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;@dimen/dimen_11&quot; android:text=&quot;订购产品：爱达康高血压监护服务&quot; android:textColor=&quot;#ff666666&quot; android:textSize=&quot;21sp&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/tv_order_num&quot; /&gt; &lt;TextView android:id=&quot;@+id/tv_service_team&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;服务团队：爱达康远程监护团队&quot; android:textColor=&quot;#ff666666&quot; android:textSize=&quot;21sp&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/tv_order_pro&quot; /&gt; &lt;TextView android:id=&quot;@+id/tv_period_valid&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;有效期：2019-03-01至2019-12-31&quot; android:textColor=&quot;#ff999999&quot; android:textSize=&quot;19sp&quot; app:layout_constraintStart_toEndOf=&quot;@+id/barrier&quot; /&gt; &lt;TextView android:id=&quot;@+id/tv_order_time&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;@dimen/dimen_11&quot; android:text=&quot;订购时间：2019-03-11 12:00:00&quot; android:textColor=&quot;#ff666666&quot; android:textSize=&quot;21sp&quot; app:layout_constraintStart_toEndOf=&quot;@+id/barrier&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/tv_period_valid&quot; /&gt; &lt;TextView android:id=&quot;@+id/tv_order_count&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;订购数量：500次&quot; android:textColor=&quot;#ff666666&quot; android:textSize=&quot;21sp&quot; app:layout_constraintStart_toEndOf=&quot;@+id/barrier&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/tv_order_time&quot; /&gt; &lt;android.support.constraint.Barrier android:id=&quot;@+id/barrier&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; app:barrierDirection=&quot;right&quot; app:constraint_referenced_ids=&quot;tv_order_num,tv_order_pro,tv_service_team&quot; /&gt; &lt;/android.support.constraint.ConstraintLayout&gt; 对chain讲解详细http://blog.csdn.net/zxt0601/article/details/72683379 https://blog.csdn.net/lmj623565791/article/details/78011599 Group​ 1234567&lt;androidx.constraintlayout.widget.Group android:id=&quot;@+id/gp_1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:visibility=&quot;gone&quot; app:constraint_referenced_ids=&quot;cl_h4,cl_h2&quot; /&gt; 1((Group)findViewById(R.id.gp_1)).setVisibility(View.GONE); ​ findViewById(R.id.gp_2).setVisibility(View.INVISIBLE); doesnt not work","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[{"name":"ConstraintLayout","slug":"ConstraintLayout","permalink":"http://noteforme.github.io.com/tags/ConstraintLayout/"}],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"tool_pc_phone","slug":"tool-miflash","date":"2017-10-13T15:22:47.000Z","updated":"2021-08-19T11:11:44.317Z","comments":true,"path":"2017/10/13/tool-miflash/","link":"","permalink":"http://noteforme.github.io.com/2017/10/13/tool-miflash/","excerpt":"","text":"mi救砖前两天不小心把 新买的小米４给刷成黑砖了，我的操作是双击磁盘模式工具目录里的“清除fastboot进磁盘操作.bat”进入磁盘模式 使用这种方式把fastboot清掉了，然后手机都没法进入fastboot模式，插入电脑无法识别 我的方法进入方法三：通过线刷升级 点以下链接 http://www.miui.com/shuaji-393.html,下载通用刷机工具，安装后(需要 一段时间)，插上已成砖手机，windows设备管理器 端口我的显示9006 下载fastboot完整包 也是在上面链接路径下面 下载 miflash 我下载的是15版的miflash 新版 .bat文件不同会报各种错误 链接: https://pan.baidu.com/s/1pKPLJdD 密码: 94mi 救活 选择下载的fastboot包，刷机，然后是等待 看到一篇文章高通下教程 http://www.miui.com/thread-2689657-1-1.html Thinkpad更换固态硬盘 视频教程: https://v.qq.com/x/page/k0157zxhob1.html https://www.youtube.com/watch?v=Qgh5v6ccMOg http://v.youku.com/v_show/id_XMzE3NTU5MjA4OA==.html?spm=a2hzp.8244740.0.0 文字教程: http://www.xinxunwei.com/bjbcj/2016/0119/5261.html Ubuntu系统安装: https://blog.csdn.net/dkh_321/article/details/79304377","categories":[{"name":"TOOL","slug":"TOOL","permalink":"http://noteforme.github.io.com/categories/TOOL/"}],"tags":[],"keywords":[{"name":"TOOL","slug":"TOOL","permalink":"http://noteforme.github.io.com/categories/TOOL/"}]},{"title":"Toolbar","slug":"Toolbar","date":"2017-10-12T08:35:05.000Z","updated":"2021-08-19T11:11:44.252Z","comments":true,"path":"2017/10/12/Toolbar/","link":"","permalink":"http://noteforme.github.io.com/2017/10/12/Toolbar/","excerpt":"","text":"官网教程 https://developer.android.com/training/appbar/setting-up.html?hl=zh-cn toolbar整体设置 参考:http://blog.csdn.net/a553181867/article/details/51336899 颜色设置 AppTheme下的设置 12345678&lt;application android:name=&quot;.application.NBBApplication&quot; android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/icon&quot; android:label=&quot;@string/app_name&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/AppTheme&quot;&gt; Toolbar颜色:&lt;item name=&quot;colorPrimary&quot;&gt;@color/toolbar_color&lt;/item&gt; 状态栏设置 :&lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;true&lt;/item&gt; 在 API 19 及更高版本上，Toolbar 内容延伸至状态栏上去了, statebar把toolbar给覆盖了 要解决这个问题就需要下面的属性 android:fitsSystemWindows =”true” 这个属性能保持与statebar一定 的padding,能解决上面windowTranslucentStatus的重叠问题 参考: 亦枫 去掉阴影线 toolbar底部会有一条阴影线,通过AppBarLayout标签下的app:elevation=”0dp”去掉 自定义返回键 mToolbar.setNavigationIcon(R.mipmap.ic_back);//自定义返回键 或者这样设置 app:navigationIcon=&quot;@mipmap/ic_back&quot; toolbar.xml解读123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.design.widget.AppBarLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:elevation=&quot;0dp&quot;&gt; //设置仰角,0dp可以去掉底部的线 &lt;android.support.v7.widget.Toolbar android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; android:minHeight=&quot;?actionBarSize&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.ActionBar&quot; //toolbar主题 app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;&gt; &lt;TextView android:id=&quot;@+id/tb_title&quot; style=&quot;@style/TextAppearance.AppCompat.Widget.ActionBar.Title&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:text=&quot;标题&quot; android:textColor=&quot;#333333&quot; android:textSize=&quot;18sp&quot; /&gt; &lt;/android.support.v7.widget.Toolbar&gt;&lt;/android.support.design.widget.AppBarLayout&gt; 还有一种方式是在application设置，这样就不用集成baseActivityhttps://www.diycode.cc/topics/783 menu设置AppBarLayout下的 app:theme=&quot;@style/toolbar_menu&quot;用于设置menu menu字体颜色需要设置 app:theme ,用 android:theme不起作用. &lt;item name=&quot;android:actionMenuTextColor&quot;&gt;@color/text_my_black&lt;/item&gt; menu事件@Override public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.menu_login, menu); menu.findItem(R.id.item_right_text).setTitle(&quot;注册&quot;); //设置文字 return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; break; &#125; return super.onOptionsItemSelected(item); &#125; https://blog.csdn.net/guyuealian/article/details/51721167 问题使用toolbar过程中遇到了一些问题 问题 1 弹出键盘后 editext不见了，应该是toolbar被拉伸了 暂时解决方式: &lt;activity android:name=&quot;.activity.WebActivity&quot; android:hardwareAccelerated=&quot;true&quot; android:screenOrientation=&quot;portrait&quot; android:windowSoftInputMode=&quot;adjustPan&quot; /&gt; https://github.com/CoolThink/StatusBarAdapt/issues/2 fragment使用toolbarhttp://wuxiaolong.me/2015/12/21/fragmentToolbar/ 参考郭霖公号:http://blog.csdn.net/james_shu/article/details/61661217 http://yifeng.studio/2016/10/12/android-toolbar/http://www.bijishequ.com/detail/239876 三条线的颜色修改1234&lt;style name=&quot;DrawerArrowStyle&quot; parent=&quot;Base.Widget.AppCompat.DrawerArrowToggle&quot;&gt; &lt;item name=&quot;spinBars&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;color&quot;&gt;@android:color/white&lt;/item&gt;&lt;/style&gt; 具体可以查看mineutil:PopupWindowActivity 溢出菜单三个点离右边的距离 AppTheme中设置 1234567&lt;item name=&quot;android:actionOverflowButtonStyle&quot;&gt;@style/OverflowMenuStyle&lt;/item&gt; &lt;style name=&quot;OverflowMenuStyle&quot; parent=&quot;Widget.AppCompat.Light.PopupMenu.Overflow&quot;&gt; &lt;item name=&quot;overlapAnchor&quot;&gt;false&lt;/item&gt; &lt;!--把该属性改为false即可使menu位置位于toolbar之下--&gt; &lt;item name=&quot;android:src&quot;&gt;@mipmap/doc_ic_new_patient&lt;/item&gt; &lt;item name=&quot;android:paddingRight&quot;&gt;15dp&lt;/item&gt; &lt;/style&gt; https://blog.csdn.net/hard_working1/article/details/77333893 https://juejin.im/post/5e5898346fb9a07cd248d179 https://github.com/luckybilly/Gloading/blob/master/README-zh-CN.md","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"DesignPattern-Builder","slug":"DesignPattern_Builder","date":"2017-10-07T09:45:46.000Z","updated":"2021-08-19T11:11:43.801Z","comments":true,"path":"2017/10/07/DesignPattern_Builder/","link":"","permalink":"http://noteforme.github.io.com/2017/10/07/DesignPattern_Builder/","excerpt":"","text":"Builder模式不直接生成想要的对象，而是让客户端利用所有必要的参数调用构造器（或者静态工厂），得到一个builder对象，然后客户端在builder对象上调用类似于setter的方法，来设置每个相关的可选参数 既能保证像重叠构造器模式那样的安全性，也能保证像JavaBeans模式那么好的可读性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class NutritionFacts_03_Builder &#123; private final int servingSize; private final int servings; private final int calories; private final int fat; private final int sodium; private final int carbohydrate; public static class Builder&#123; //Required parameters private final int servingSize; private final int servings; //Optional parameters = initialized to default values private int calories = 0; private int fat = 0; private int carbohydrate = 0; private int sodium = 0; public Builder(int servingSize, int servings) &#123; this.servingSize = servingSize; this.servings = servings; &#125; public Builder calories(int val)&#123; calories = val; return this; &#125; public Builder fat(int val)&#123; this.fat = fat; return this; &#125; public Builder carbohydrate(int val)&#123; carbohydrate = val; return this; &#125; public Builder sodium(int val)&#123; sodium = val; return this; &#125; public NutritionFacts_03_Builder build()&#123; return new NutritionFacts_03_Builder(this); &#125; &#125; private NutritionFacts_03_Builder(Builder builder) &#123; this.servingSize = builder.servingSize; this.servings = builder.servings; this.calories = builder.calories; this.fat = builder.fat; this.sodium = builder.sodium; this.carbohydrate = builder.carbohydrate; &#125; public static void main(String[] args) &#123; NutritionFacts_03_Builder cocaCola = new NutritionFacts_03_Builder.Builder(240,9) .calories(100).sodium(35).carbohydrate(27).build(); &#125;&#125; 返回的this时怎么替代对象的 对象创建更加灵活当 isRef 为 true 的时候，arg 表示 String 类型的 refBeanId，type 不需要设置；当 isRef 为 false 的时候，arg、type 都需要设置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class ConstructorArg &#123; private boolean isRef; private Class type; private Object arg; private ConstructorArg(Builder builder) &#123; this.isRef = isRef; this.type = type; this.arg = arg; &#125; public static class Builder &#123; private static boolean isRef; private static Class type; private static Object arg; public Builder(boolean isRef) &#123; this.isRef = isRef; &#125; public Builder setType(Class type) &#123; this.type = type; return this; &#125; public Builder setArg(Object arg) &#123; this.arg = arg; return this; &#125; public ConstructorArg build() &#123; if (isRef) &#123; if (!(arg instanceof String)) &#123; //这里refBeanId是ConstructorArg吗？只是判断了下arg类型是否为String throw new IllegalArgumentException(&quot;当 isRef 为 true 的时候，arg 表示 String 类型refBeanId&quot;); &#125; if (type != null) &#123; throw new IllegalArgumentException(&quot;当 isRef 为 true 的时候，type 不需要设置&quot;); &#125; &#125; if (!isRef) &#123; if (arg == null || type == null) &#123; throw new IllegalArgumentException(&quot;当 isRef 为 false 的时候，arg、type 都需要设置&quot;); &#125; &#125; return new ConstructorArg(this); &#125; &#125;&#125;","categories":[{"name":"DesignPatterns","slug":"DesignPatterns","permalink":"http://noteforme.github.io.com/categories/DesignPatterns/"}],"tags":[],"keywords":[{"name":"DesignPatterns","slug":"DesignPatterns","permalink":"http://noteforme.github.io.com/categories/DesignPatterns/"}]},{"title":"Fragment","slug":"Fragment","date":"2017-10-05T11:54:50.000Z","updated":"2021-08-19T11:11:43.804Z","comments":true,"path":"2017/10/05/Fragment/","link":"","permalink":"http://noteforme.github.io.com/2017/10/05/Fragment/","excerpt":"","text":"https://developer.android.com/reference/android/app/Fragment.html https://developer.android.com/guide/components/fragments.html https://wizardforcel.gitbooks.io/w3school-android/content/77.htmlhttps://juejin.im/post/5901b564570c35005804424b Lifecyclehttps://developer.android.com/guide/fragments/lifecycle onViewCreated(View view, Bundle savedInstanceState) Called immediately after onCreateView(android.view.LayoutInflater, android.view.ViewGroup, android.os.Bundle) has returned, but before any saved state has been restored in to the view. fragment回调123456789101112var mListener: IFeedBackListener? = nulloverride fun onAttach(context: Context) &#123; super.onAttach(context) if (parentFragment is IFeedBackListener) &#123; mListener = parentFragment as IFeedBackListener &#125; else if (context is IFeedBackListener) &#123; mListener = context &#125; else &#123; throw RuntimeException(context?.toString() + &quot; must implement ISelectListener&quot;) &#125;&#125; https://noteforme.github.io/2017/10/05/Fragment/ Fragment重叠 横竖屏切换 被系统回收（复现 进入开发者选项 -》不保留活动） https://www.jianshu.com/p/c12a98a36b2b BottomNavigationView error使用BottomNavigationView出现很严重的问题,很久才找到原因 12Caused by: android.view.InflateException: Binary XML file line #16: Binary XML file line #16: Error inflating class com.google.android.material.bottomnavigation.BottomNavigationView Caused by: android.view.InflateException: Binary XML file line #16: Error inflating class com.google.android.material.bottomnavigation.BottomNavigationView 因为 AndroidManifest.xml application下的android:theme=”@style/AppTheme”多出了,把下面的删除了就好了. 123&lt;item name=&quot;android:textColorSecondary&quot;&gt;#ffffff&lt;/item&gt;&lt;item name=&quot;android:actionOverflowButtonStyle&quot;&gt;@style/OverflowMenuStyle&lt;/item&gt;&lt;item name=&quot;android:listDivider&quot;&gt;@drawable/divider&lt;/item&gt; 重叠原因 旋转屏幕时候，创建的homeFragment会被回收,在销毁前，执行了onSaveInstanceState(Bundle outState)这个方法。这个方法会保存activity的一些信息，其中就包括添加过的fragment，Activity重建后，再次初始化homeFragment，接着显示，导致了重叠的问题。 代码验证1234567891011121314151617181920private fun initFragment() &#123; if (homeFragment == null) &#123; homeFragment = HomeFragment() addFragment(homeFragment!!) showFragment(homeFragment) &#125;&#125;override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) Timber.d(&quot;onCreate() $homeFragment&quot;) initFragment() Timber.d(&quot;initFragment() $homeFragment&quot;) &#125; override fun onDestroy() &#123; super.onDestroy() Timber.tag(TAG).d(&quot;onDestroy() homeFragment $homeFragment&quot;) &#125; 日志 12345678910111213141516D/TabBottomActivity LaunchModeActivity: onCreate() taskId 641D/TabBottomActivity LaunchModeActivity: onCreate() homeFragment nullD/TabBottomActivity LaunchModeActivity: initFragment() homeFragment HomeFragment&#123;1adc3fa&#125; (b0660244-39c4-4104-b558-f5384c7adb0d) id=0x7f09010e&#125;D/TabBottomActivity LaunchModeActivity: onStart()D/TabBottomActivity LaunchModeActivity: onResume()D/TabBottomActivity LaunchModeActivity: onPause()D/TabBottomActivity LaunchModeActivity: onSaveInstanceState()D/TabBottomActivity LaunchModeActivity: onStop()D/TabBottomActivity LaunchModeActivity: onDestroy()D/TabBottomActivity LaunchModeActivity: onDestroy() homeFragment HomeFragment&#123;1adc3fa&#125; (d84f5956-fa2c-4cd2-8397-0904040d2a6f)&#125;D/TabBottomActivity LaunchModeActivity: onCreate() taskId 641D/TabBottomActivity LaunchModeActivity: onCreate() homeFragment nullD/TabBottomActivity LaunchModeActivity: initFragment() homeFragment HomeFragment&#123;ac076db&#125; (f8ee348b-6ff7-4b1e-ba27-6e47e848f623) id=0x7f09010e&#125;D/TabBottomActivity LaunchModeActivity: onStart()D/TabBottomActivity LaunchModeActivity: onRestoreInstanceState()D/TabBottomActivity LaunchModeActivity: onResume() 从 initFragment（） 1adc3fa , ac076db 可以看到，HomeFrgment重新创建了. 处理方法 onSaveInstanceState 不保存信息 123 override fun onSaveInstanceState(outState: Bundle) &#123;// super.onSaveInstanceState(outState) &#125; 这种方式的弊端就是，切换后总是回到首页. onSaveInstanceState() 保存Fragment 123456789101112131415161718192021222324252627282930override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) if (savedInstanceState != null) &#123; /*获取保存的fragment 没有的话返回null*/ homeFragment = supportFragmentManager.getFragment(savedInstanceState, HOME_FRAGMENT_KEY) as HomeFragment? healthFragment = supportFragmentManager.getFragment(savedInstanceState, DASHBOARD_FRAGMENT_KEY) as HealthFragment? personFragment = supportFragmentManager.getFragment(savedInstanceState, NOTICE_FRAGMENT_KEY) as PersonFragment? addToList(homeFragment) addToList(healthFragment) addToList(personFragment) &#125; else &#123; initFragment() &#125; &#125; override fun onSaveInstanceState(outState: Bundle) &#123; super.onSaveInstanceState(outState) Timber.d(&quot;MainActivity onSaveInstanceState&quot;) /*fragment不为空时 保存*/if (homeFragment != null) &#123; supportFragmentManager.putFragment(outState!!, HOME_FRAGMENT_KEY, homeFragment!!) &#125; if (healthFragment != null) &#123; supportFragmentManager.putFragment(outState!!, DASHBOARD_FRAGMENT_KEY, healthFragment!!) &#125; if (personFragment != null) &#123; supportFragmentManager.putFragment(outState!!, NOTICE_FRAGMENT_KEY, personFragment!!) &#125; &#125; 这种方式，可以解决问题，但是打印的日志HomeFragment还是不一样，是什么情况？ 12345678910111213141516171819202122232425D/TabBottomActivity LaunchModeActivity: onCreate() taskId 4437 D/TabBottomActivity LaunchModeActivity: initFragment() homeFragment HomeFragment&#123;dc2914d&#125; (5f30b0dd-a8d2-4b3c-a27f-1d160a9da58e) id=0x7f09010e&#125; D/TabBottomActivity LaunchModeActivity: onStart() D/TabBottomActivity LaunchModeActivity: onResume() D/TabBottomActivity$onCreate: navigation_health D/TabBottomActivity LaunchModeActivity: onPause() D/TabBottomActivity LaunchModeActivity: onSaveInstanceState() D/TabBottomActivity: MainActivity onSaveInstanceState D/TabBottomActivity LaunchModeActivity: onStop() D/TabBottomActivity LaunchModeActivity: onDestroy() D/TabBottomActivity LaunchModeActivity: onDestroy() homeFragment HomeFragment&#123;dc2914d&#125; (ab276ea2-5fa2-4d79-b6a6-af7143b114e8)&#125; D/TabBottomActivity LaunchModeActivity: onCreate() taskId 4437 D/TabBottomActivity: fragmentList数量1 D/TabBottomActivity: fragmentList数量2 D/TabBottomActivity: fragmentList数量2 D/TabBottomActivity LaunchModeActivity: initFragment() homeFragment HomeFragment&#123;9139494&#125; (5f30b0dd-a8d2-4b3c-a27f-1d160a9da58e) id=0x7f09010e&#125; D/TabBottomActivity LaunchModeActivity: onStart() D/TabBottomActivity LaunchModeActivity: onRestoreInstanceState() D/TabBottomActivity LaunchModeActivity: onResume() D/TabBottomActivity LaunchModeActivity: onPause() D/TabBottomActivity LaunchModeActivity: onSaveInstanceState() D/TabBottomActivity: MainActivity onSaveInstanceState D/TabBottomActivity LaunchModeActivity: onStop() D/TabBottomActivity LaunchModeActivity: onDestroy() D/TabBottomActivity LaunchModeActivity: onDestroy() homeFragment HomeFragment&#123;9139494&#125; (cadcb63f-8516-4d44-8f3c-75b0c8e9f27f)&#125; https://blog.csdn.net/yuzhiqiang_1993/article/details/75014591 https://www.jianshu.com/p/78ec81b42f92 下面这种方式没理解https://www.jianshu.com/p/d9143a92ad94 https://www.jianshu.com/p/c12a98a36b2b 横竖屏切换，Fragment实例复用setRetainInstance=trueretainInstance = true已经过期，改用ViewModel LifeFragment 1234override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) retainInstance = true&#125; 12345678private fun initFragment() &#123; var lifeFragment = supportFragmentManager.findFragmentById(R.id.fl_content) if (lifeFragment == null) &#123; lifeFragment = LifeFragment() supportFragmentManager.beginTransaction().add(R.id.fl_content, lifeFragment).commit() &#125; Timber.d(&quot;LifeFragment $lifeFragment&quot;)&#125; 切换屏幕后 LifeFragment,ondestroy()没志行,后面的Oncreate()也没有创建. 12345678910111213141516171819D/LifeActivity LaunchModeActivity: onCreate() taskId 599D/LifeActivity: LifeFragment LifeFragment&#123;6a86311&#125; (70133a14-6dcf-4f8b-beee-6cd31d6623ba) id=0x7f090109&#125;D/LifeFragment LaunchModeFragment: onAttach(Context context)D/LifeFragment LaunchModeFragment: onCreate() savedInstanceState nullD/LifeFragment LaunchModeFragment: onCreateView()D/LifeFragment LaunchModeFragment: onActivityCreated()D/LifeFragment LaunchModeFragment: onStart()D/LifeFragment LaunchModeFragment: onResume()D/LifeFragment LaunchModeFragment: onPause() D/LifeFragment LaunchModeFragment: onStop()D/LifeFragment LaunchModeFragment: onDestroyView()D/LifeFragment LaunchModeFragment: onDetach()D/LifeFragment LaunchModeFragment: onAttach(Context context)D/LifeActivity LaunchModeActivity: onCreate() taskId 599D/LifeActivity: LifeFragment LifeFragment&#123;6a86311&#125; (70133a14-6dcf-4f8b-beee-6cd31d6623ba) id=0x7f090109&#125;D/LifeFragment LaunchModeFragment: onCreateView()D/LifeFragment LaunchModeFragment: onActivityCreated()D/LifeFragment LaunchModeFragment: onStart()D/LifeFragment LaunchModeFragment: onResume() Fragment懒加载Fragment和ViewPager一起使用会有个预加载机制，会把旁白的Fragment的生命周期方法前半段先执行，然后执行自身的生命周期方法 在项目终从其他页面回到MainAcitivty的时候，三个页面的生命周期方法都跑了一遍 123456 D/FinanceFragment Test: onStart()D/WealthFragment Test: onStart()D/MineFragment Test: onStart()D/FinanceFragment Test: onResume()D/WealthFragment Test: onResume()D/MineFragment Test: onResume() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475 private boolean isPrepared; //判断view是否加载完成,在视图未初始化的时候，在lazyLoad当中就使用的话，就会有空指针的异常 private boolean isVisible; //判断当前Fragment是否可见状态,标志已经初始化完成，因为setUserVisibleHint是在onCreateView之前调用的 @Override public void onViewCreated(View view, @Nullable Bundle savedInstanceState) &#123; super.onViewCreated(view, savedInstanceState); isPrepared = true; lazyLoad(); &#125; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) &#123;// Log.d(TAG + &quot; Test&quot;, &quot; onCreateView()&quot;); if (rootView == null) &#123; int view = setLayoutId(); if (view != 0) &#123; rootView = inflater.inflate(view, container, false); &#125; &#125; else &#123; ViewGroup parent = (ViewGroup) rootView.getParent(); if (parent != null) &#123; parent.removeView(rootView); &#125; &#125; initView(rootView); return rootView; &#125; // http://www.10tiao.com/html/565/201702/2247483988/1.html // 标志位，标志已经初始化完成，因为setUserVisibleHint是在onCreateView之前调用的， // 在视图未初始化的时候，在lazyLoad当中就使用的话，就会有空指针的异常 private boolean isPrepared; //标志当前页面是否可见 private boolean isVisible; @Override public void setUserVisibleHint(boolean isVisibleToUser) &#123; super.setUserVisibleHint(isVisibleToUser);// Log.d(TAG + &quot; Test&quot;, &quot; setUserVisibleHint() is Visible : ? &quot; + isVisibleToUser); if (getUserVisibleHint()) &#123; isVisible = true; onVisible(); &#125; else &#123; isVisible = false; onInvisible(); &#125; &#125; protected void onInvisible() &#123; &#125; protected void onVisible() &#123; lazyLoad(); &#125; private void lazyLoad() &#123; if (!isVisible || !isPrepared) &#123; return; &#125; requestData(); &#125; /** * 请求数据 */ protected void requestData() &#123; Log.d(TAG + &quot; Test&quot;, &quot; requestData &quot;); &#125; 参考: http://www.10tiao.com/html/565/201702/2247483988/1.html Activity dialogFragment 的事件回调1234567891011121314151617interface ISelectListener &#123; fun getItemPosition(position: Int)&#125;var mListener: ISelectListener? = nulloverride fun onAttach(context: Context) &#123; super.onAttach(context) if (parentFragment is ISelectListener)&#123; mListener = parentFragment as ISelectListener &#125;else if (context is ISelectListener) &#123; mListener = context &#125; else &#123; throw RuntimeException(context!!.toString() + &quot; must implement ISelectListener&quot;) &#125;&#125; https://developer.android.com/guide/components/fragments.html onHiddenChanged切换刷新使用hide()/show()发现生命周期基本不执行，不过可以用到这个onHiddenChanged(); 看下执行的生命周期; 从 SecondFragment 页面开始到 -&gt;FirstFragment 07-18 15:53:25.128 7758-7758/com.mineutils D/SecondFragment: onAttach(Context context)07-18 15:53:25.129 7758-7758/com.mineutils D/SecondFragment: onCreate()07-18 15:53:25.142 7758-7758/com.mineutils D/SecondFragment: onCreateView()07-18 15:53:25.148 7758-7758/com.mineutils D/SecondFragment: onViewCreated onActivityCreated() onStart()​ onResume() 07-18 15:53:34.200 7758-7758/com.mineutils D/SecondFragment: onHiddenChanged hidden true07-18 15:53:34.207 7758-7758/com.mineutils D/FirstFragment: onCreateView()07-18 15:53:34.208 7758-7758/com.mineutils D/FirstFragment: onViewCreated onActivityCreated()​ onStart() 07-18 15:53:53.968 7758-7758/com.mineutils D/FirstFragment: onHiddenChanged hidden true07-18 15:53:53.968 7758-7758/com.mineutils D/SecondFragment: onHiddenChanged hidden false https://blog.csdn.net/cml_blog/article/details/41411451 fragment常用特性commitAllowingStateLoss VS commit()区别https://huxian99.github.io/2016/08/28/cj3qymo360000owxk9zp17alo/ Fragment之间传递数据 Fragment.setArguments()方法传递bundle findFragmentById()找到tag,然后直接操作Framgent 123456789101112131415161718public void onArticleSelected(int position) &#123; ArticleFragment articleFrag = (ArticleFragment) getSupportFragmentManager().findFragmentById(R.id.article_fragment); if (articleFrag != null) &#123; articleFrag.updateArticleView(position); &#125; else &#123; ArticleFragment newFragment = new ArticleFragment(); Bundle args = new Bundle(); args.putInt(ArticleFragment.ARG_POSITION, position); newFragment.setArguments(args); FragmentTransaction transaction = getSupportFragmentManager().beginTransaction(); transaction.replace(R.id.fragment_container, newFragment); transaction.addToBackStack(null); transaction.commit(); &#125; &#125; 接口回调 ViewModel Livedata 给已经创建frament传递数据也是直接 Fragment.refresh(),第一行代码第三版P227，也是这样做的。 fragment回退栈tx.addToBackStack(null); 添加回退功能，类似Activity压栈的过程 https://www.jianshu.com/p/fe16553ca2ca https://blog.csdn.net/zhiyuan0932/article/details/52593039 Fragment控制父Fragment展示 Communication between nested fragments in Android https://blog.csdn.net/u011481547/article/details/71552720 Fragmet全局流程图 https://kotlintc.com/articles/5693 https://mp.weixin.qq.com/s/MOWdbI5IREjQP1Px-WJY1Q https://juejin.im/post/5bcd58b6e51d45404c71d23f https://mp.weixin.qq.com/s/_hdbMOA2TVvX4jFnMu15bg","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"onActivityResult","slug":"onActivityResult","date":"2017-09-26T06:01:53.000Z","updated":"2021-08-19T11:11:44.302Z","comments":true,"path":"2017/09/26/onActivityResult/","link":"","permalink":"http://noteforme.github.io.com/2017/09/26/onActivityResult/","excerpt":"","text":"传统方式单个页面跳转 主要有三个方法实现 startActivityForResult(@RequiresPermission Intent intent, int requestCode) setResult(int resultCode, Intent data) onActivityResult(int requestCode, int resultCode, Intent data) 下面是简单例子跳转MainActivity 目标SecondAcitivty 其中数据传递很简单,特别注意requestCode，resultCode不同的区分的区别 requestCode：假设 MainActivity button1 button2到SecondAcitivty,回来的在onActivityResult就需要 判断是哪个button点击的 resultCode: 假设MainActivity button1跳转到SecondAcitivty, button2到ThirdActiivty,回来后onActivityResult 就需要判断是哪个Activity回来的 参考:http://blog.csdn.net/jiangwei0910410003/article/details/16983049 注意:onActivityResult方法用的算比较普遍，刚好有个困惑，回传数据时intent.putExtra(&quot;text&quot;,122); 使用 String couponId = data.getStringExtra(&quot;text&quot;); 接收时为null,里面跳转和回传,存的值是int类型，获取string类型 Fragment接收onActivityResult必须使用Fragment 的 startActivityForResult()* 12345public static void startForResult(Activity activity, Fragment fragment) &#123; Intent intent = new Intent(activity, LoginActivity.class); fragment.startActivityForResult(intent, REQUEST_CODE_MINE_FRAGMENT); &#125; setResult(RESULT_OK, result); ,finish()后 onActivityResult 返回 resultCode Activity嵌套Fragment,他们各自发起startActivityForResult发起数据请求结论 Fragment发起 Fragment onActivityResult能接收。Activity onActivityResult能接收,但是requestCode不正确。 Activity发起 Fragment不能接收。 Activity onActivityResult能接收。 代码验证FirstResultActivity 12345678910111213141516171819val requestCode = 1000 override fun initView() &#123; super.initView() val intent = Intent(this, SecondResultActivity::class.java) findViewById&lt;View&gt;(R.id.bt_activity).setOnClickListener &#123; startActivityForResult(intent, requestCode) Timber.i(&quot;startActivityForResult $requestCode&quot;) &#125; &#125; override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) &#123; super.onActivityResult(requestCode, resultCode, data) Timber.d(&quot;onActivityResult resultCode $requestCode resultCode $resultCode data $&#123;data?.getStringExtra(SecondResultActivity.sData)&#125;&quot;) &#125; private fun initFragment() &#123; val ftn = supportFragmentManager.beginTransaction().replace(R.id.fl_content, newInstance(&quot;数据&quot;)) ftn.commit() &#125; ResultOkFragment 123456789101112131415161718private val requestCode: Int = 2000override fun onActivityCreated(savedInstanceState: Bundle?) &#123; super.onActivityCreated(savedInstanceState) val intent = Intent(context, SecondResultActivity::class.java) bt_fragment.setOnClickListener &#123; startActivityForResult(intent, requestCode) Timber.d(&quot;startActivityForResult $requestCode&quot;) &#125;&#125;override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) &#123; super.onActivityResult(requestCode, resultCode, data) Timber.d(&quot;onActivityResult resultCode $requestCode resultCode $resultCode data $&#123;data?.getStringExtra(SecondResultActivity.sData)&#125;&quot;)&#125; SecondResultActivity 12setResult(21, new Intent().putExtra(sData, &quot;我要回调啦!!!&quot;));finish(); Activity发起 12I/FirstResultActivity$initView: startActivityForResult 1000D/FirstResultActivity: onActivityResult resultCode 1000 resultCode 21 data 我要回调啦!!! Fragment发起 123D/ResultOkFragment$onActivityCreated: startActivityForResult 2000D/ResultOkFragment: onActivityResult resultCode 2000 resultCode 21 data 我要回调啦!!!D/FirstResultActivity: onActivityResult resultCode 329680 resultCode 21 data 我要回调啦!!! 跳转多个页面 回来中间页面不能finish，也需要在onActivityResult方法内部 起到桥梁作用，回传数据 http://blog.csdn.net/lanyachuanshu/article/details/52172143https://developer.android.com/training/basics/intents/result.html http://45.77.222.97:3000/root/MineUtils/src/master/app/src/main/java/com/jonzhou/mineutils/result/FirstResultActivity.java https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650826252&amp;idx=1&amp;sn=9ec620d630706c9f8de328e87bb8a0f1&amp;chksm=80b7b292b ActivityResultContract新方式https://mp.weixin.qq.com/s/o2_2DeAIcJGYSvm2WlhUxg","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"DevicesScreenSupport","slug":"DevicesScreenSupport","date":"2017-09-23T13:41:20.000Z","updated":"2021-08-19T11:11:43.802Z","comments":true,"path":"2017/09/23/DevicesScreenSupport/","link":"","permalink":"http://noteforme.github.io.com/2017/09/23/DevicesScreenSupport/","excerpt":"","text":"Android屏幕的一些技巧 官网适配方案https://developer.android.com/training/basics/supporting-devices/index.htmlhttps://developer.android.com/training/multiscreen/screensizes.html 资源图片适配Provide alternative bitmaps To provide good graphical qualities on devices with different pixel densities, you should provide multiple versions of each bitmap in your app—one for each density bucket, at a corresponding resolution. Otherwise, Android must scale your bitmap so it occupies the same visible space on each screen, resulting in scaling artifacts such as blurring. Figure 2. Relative sizes for bitmaps at different density sizes There are several density buckets available for use in your apps. Table 1 describes the different configuration qualifiers available and what screen types they apply to. Table 1. Configuration qualifiers for different pixel densities. Density qualifier Description ldpi Resources for low-density (ldpi) screens (~120dpi). mdpi Resources for medium-density (mdpi) screens (~160dpi). (This is the baseline density.) hdpi Resources for high-density (hdpi) screens (~240dpi). xhdpi Resources for extra-high-density (xhdpi) screens (~320dpi). xxhdpi Resources for extra-extra-high-density (xxhdpi) screens (~480dpi). xxxhdpi Resources for extra-extra-extra-high-density (xxxhdpi) uses (~640dpi). nodpi Resources for all densities. These are density-independent resources. The system does not scale resources tagged with this qualifier, regardless of the current screen’s density. tvdpi Resources for screens somewhere between mdpi and hdpi; approximately 213dpi. This is not considered a “primary” density group. It is mostly intended for televisions and most apps shouldn’t need it—providing mdpi and hdpi resources is sufficient for most apps and the system will scale them as appropriate. If you find it necessary to provide tvdpi resources, you should size them at a factor of 1.33*mdpi. For example, a 100px x 100px image for mdpi screens should be 133px x 133px for tvdpi. To create alternative bitmap drawables for different densities, you should follow the 3:4:6:8:12:16 scaling ratio between the six primary densities. For example, if you have a bitmap drawable that’s 48x48 pixels for medium-density screens, all the different sizes should be: 36x36 (0.75x) for low-density (ldpi) 48x48 (1.0x baseline) for medium-density (mdpi) 72x72 (1.5x) for high-density (hdpi) 96x96 (2.0x) for extra-high-density (xhdpi) 144x144 (3.0x) for extra-extra-high-density (xxhdpi) 192x192 (4.0x) for extra-extra-extra-high-density (xxxhdpi) Then, place the generated image files in the appropriate subdirectory under res/ and the system will pick the correct one automatically based on the pixel density of the device your app is running on: 1234567891011res/ drawable-xxxhdpi/ awesome-image.png drawable-xxhdpi/ awesome-image.png drawable-xhdpi/ awesome-image.png drawable-hdpi/ awesome-image.png drawable-mdpi/ awesome-image.png Then, any time you reference @drawable/awesomeimage, the system selects the appropriate bitmap based on the screen’s dpi. If you don’t provide a density-specific resource for that density, the system picks the next best match and scales it to fit the screen. This means that if you generate a 200x200 image for xhdpi devices, you should generate the same resource in 150x150 for hdpi, 100x100 for mdpi, and 75x75 for ldpi devices.而UI问我们需要多少大小的图，如果效果图根据750*1334的话，可以告诉他，不过PS有个叫cutterman的工具可以自动生成不同分辨率的图片 PX转 dp 以5X 为例: 5X的dpi =420, PPI = 420/160 = 2.625设置view的宽度我们用 match_parent,那么在5X上，他是多少dp呢？ 5X : width = 1080 pxdp = 1080 / PPI = 411.428571429,所以411dp就是5X的match_parent http://blog.csdn.net/u010983881/article/details/51993157 实际应用 开发中的实际转化 生成主流屏幕的values，安宽分成320份,高400份 假设ＵＩ根据 iphone6(750×1334)设计的效果图 根据下图公式计算 Dpi iphone6是4.7寸的 分辨率 750 * 1334, 它的dpi 就是 √(750²+1334²)/4.7 = 325 ​ 和drawable-xhdpi 320接近 drawable-xhdpi 480上做的图就是大概是1.5倍的样子 ,分辨率在1920 *1080上的也是一样的 ​ 然而pixel 2的模拟器是420 真机是441，这是什么原因呢!!! http://blog.csdn.net/zengd0/article/details/52464627 所以说 给的1334 * 750 图就是 10px 我们写5dp ​ 参考: http://www.jianshu.com/p/ec5a1a30694b http://blog.csdn.net/lmj623565791/article/details/45460089 DPI参考 自己计算按照上面的公式很简单，最棘手的还是手机尺寸给出一个手机dpi网站 get what you wanthttp://dpi.lv/ https://mp.weixin.qq.com/s/v_aauFjx-f91WrpCAaNMVQ) https://developer.android.com/guide/practices/screens_support 今日头条适配 https://www.jianshu.com/p/55e0fca23b4f https://github.com/JessYanCoding/AndroidAutoSize 为什么原来长度 ic_launcher.png 192*192 到了nexus5 中显示是216 * 216 而不是原来的尺寸","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"Retrofit","slug":"Retrofit","date":"2017-09-23T01:20:09.000Z","updated":"2021-08-19T11:11:44.217Z","comments":true,"path":"2017/09/23/Retrofit/","link":"","permalink":"http://noteforme.github.io.com/2017/09/23/Retrofit/","excerpt":"","text":"Okhttp缺陷 Retofit调用 Retrofit Rxjava Retorift使用过程 动态生成了实现了接口类型的， 类的对象。 调用方法,通过反射解析接口，拿到方法参数 生成代理类 Retrofit.java 123456789101112131415161718192021222324public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; validateServiceInterface(service); return (T) Proxy.newProxyInstance( service.getClassLoader(), new Class&lt;?&gt;[] &#123;service&#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); private final Object[] emptyArgs = new Object[0]; @Override public @Nullable Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable &#123; // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); //传入的是this &#125; args = args != null ? args : emptyArgs; return platform.isDefaultMethod(method) ? platform.invokeDefaultMethod(method, service, proxy, args) : loadServiceMethod(method).invoke(args); //这个动态代理的形式，为什么没传对象？ &#125; &#125;);&#125; 12IApiStores iApiStores = RetrofitFactory.create(IApiStores.class);retrofit2.Call&lt;List&lt;SharedListBean&gt;&gt; sharedListCall = iApiStores.getSharedList(2, 1); ServiceMethod 一个方法对应一个serviceMethod,使用hashmap缓存,构建okhttp的网络请求。 Retrofit包装类Retrofit组装完数据，使用Okhttp进行网络请求的类 OkHttpCall.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Overridepublic void enqueue(final Callback&lt;T&gt; callback) &#123; Objects.requireNonNull(callback, &quot;callback == null&quot;); okhttp3.Call call; Throwable failure; synchronized (this) &#123; call = rawCall = createRawCall(); // 创建OkhttpCall &#125; call.enqueue( new okhttp3.Callback() &#123; @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) &#123; Response&lt;T&gt; response; try &#123; response = parseResponse(rawResponse); &#125; catch (Throwable e) &#123; throwIfFatal(e); callFailure(e); return; &#125; try &#123; callback.onResponse(OkHttpCall.this, response); &#125; catch (Throwable t) &#123; throwIfFatal(t); t.printStackTrace(); // TODO this is not great &#125; &#125; @Override public void onFailure(okhttp3.Call call, IOException e) &#123; callFailure(e); &#125; private void callFailure(Throwable e) &#123; try &#123; callback.onFailure(OkHttpCall.this, e); &#125; catch (Throwable t) &#123; throwIfFatal(t); t.printStackTrace(); // TODO this is not great &#125; &#125; &#125;);&#125; https://www.bilibili.com/video/BV1mU4y1p71g?p=10&amp;spm_id_from=pageDriver https://www.bilibili.com/video/BV12Q4y1d7uD?p=7&amp;spm_id_from=pageDriver http://www.jianshu.com/p/308f3c54abdd这篇文章不错，深入浅出我还加了了提交Map参数的Demo Demo http://www.10tiao.com/html/227/201701/2650238307/1.html http://blog.csdn.net/itjianghuxiaoxiong/article/details/52135748 https://juejin.im/post/5afc1706518825426f30f6ec 要实现类似这样的请求,用post方式怎么也不行https://newsapi.org/v2/top-headlines?sources=financial-times&amp;apiKey=e4f505f73a9f4ee99119ab33a19ab05ehttp://wuxiaolong.me/2016/06/18/retrofits/","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"Package-signature","slug":"Package-signature","date":"2017-09-21T02:56:13.000Z","updated":"2021-08-19T11:11:44.199Z","comments":true,"path":"2017/09/21/Package-signature/","link":"","permalink":"http://noteforme.github.io.com/2017/09/21/Package-signature/","excerpt":"","text":"Apk打包流程 相同签名 不同包名问题现在把项目重新生成签名，然后安装，安装后会安装失败，因为和以前的app冲突 应用安装后会在data/data 目录生成和包名一样的文件夹 虽然生成了了新的签名但是会覆盖 打包android studio更新了新版本 打包的时候v1和v2都需要勾选才能安装 http://blog.h5min.cn/daihuimaozideren/article/details/77842549 walle打包生成渠道包 生成渠道包 ./gradlew clean assembleReleaseChannels 支持 productFlavors ./gradlew clean assembleMeituanReleaseChannels https://github.com/Meituan-Dianping/walle","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"ubuntu_guide","slug":"ubuntu_guide","date":"2017-09-20T13:42:17.000Z","updated":"2021-08-19T11:11:44.318Z","comments":true,"path":"2017/09/20/ubuntu_guide/","link":"","permalink":"http://noteforme.github.io.com/2017/09/20/ubuntu_guide/","excerpt":"","text":"解决Ubuntu 16.04 系统的一些错误 Unable to mount root fs on unknown-block 看到Ubuntu系统有更新就点了下，早上打开电脑 Ubuntu直接进不去最下面弹出这这样的 错误 Unable to mount root fs on unknown-block 而且只能强制关机，心想完了我的 资料，还有辛苦编译的源码，不过好在晚上回来倒腾了一把 终于好了。 步骤1、 Advanced options for Ubuntu２、ubuntu Linux 4.4.0-96… (recovery mdoe) 这里我选择的是第二个，第一个点击后还是 会报错3、Menu界面 ，把能清的先清了，然后点击grub,执行后续操作 4、登录进入命令行界面 12345sudo mount -o rw //这一行和参考资料不同sudo dpkg --configure -a //在这里等了很久 Device ....Start的字样,接着就按了 Ctrl + Alt + Delete , 重启就好了sudo apt-get install -f # to finish upgrades 最好加这个吧type reboot https://askubuntu.com/questions/875862/kernel-panic-unable-to-mount-root-in-ubuntu-16-04/875868 解压乱码在windows上压缩的文件，是以系统默认编码中文来压缩文件。由于zip文件中没有声明其编码，所以linux上的unzip一般以默认编码解压，中文文件名会出现乱码。可以使用终端zip文件进行解压并指定解压的编码 unzip -O GBK xxx.zip解压后的文件的路径为当前终端所在的路径 参考： Eric Chan ** 17.10的问题 ** Android studio3.1无法输入中文 使用 fcitx 选择sunpingying 也可以选择 google pinyin 然后输入这两行命令 pidof fcitx | xargs kill #找到原有的fcitx端口并kill掉 fcitx #开启fcitx 参考： https://blog.csdn.net/he729164860/article/details/78484713 安装Gnome shell12sudo apt-get install gnome-tweak-toolsudo apt-get install chrome-gnome-shell 打开tweak可以看到按钮 浏览点击 ||| off按钮系统就会安装 开源chromium加载有问题，使用firefox 很有用的插件 https://extensions.gnome.org/extension/545/hide-top-bar/ 参考:https://www.mobibrw.com/2017/9342 ctrl + alt + left （Intellij idea shortcut conflict） install Dconf Editor in ubuntu software launch Dconf Editor, go to /org/gnome/desktop/wm/keybindings/switch-to-workspace-left double click like below use default value(click Off) -&gt; Custom value(like me or else) you could use it in intellij idea now . genymotion安装 下载Virtualbox 下载genymotion 下载Android stuido genymotion插件 12chmod +x genymotion-2.6.0-linux_x64.bin ./genymotion-2.6.0-linux_x64.bin -d /home/qiu/Work/genymotion //注意： chmod +x 有空格 输入法设置ubuntu 18.04 intellij 输入法选择有问题，可以用命令行安装 ibus-pinyin，然后input souce选择拼音输入法","categories":[{"name":"LINUX","slug":"LINUX","permalink":"http://noteforme.github.io.com/categories/LINUX/"}],"tags":[],"keywords":[{"name":"LINUX","slug":"LINUX","permalink":"http://noteforme.github.io.com/categories/LINUX/"}]},{"title":"SDK_Integration","slug":"SDK_Integration","date":"2017-09-19T06:44:01.000Z","updated":"2021-08-19T11:11:44.237Z","comments":true,"path":"2017/09/19/SDK_Integration/","link":"","permalink":"http://noteforme.github.io.com/2017/09/19/SDK_Integration/","excerpt":"","text":"平常集成SDK虽然简单，但是过了半年就全忘了，又得重新来过 友盟分享微信开发者平台创建应用需要 应用签名 需要签名工具,可以从 微信资源中心 获取 注意要打包才能运行 商汤认证文档 身份证认证 在common-idcard包中的assets目录下添加 SenseID_OCR.lic文件就可以了 在androidmanifest.xml注册activity 活体认证 最终调用onDetectOver 1public void onDetectOver(ResultCode code, String id, List imageData) 会返回id,然后把id,身份证number,name传给商汤对比 极光推送 集成过程 按照文档，主要是要注意这个广播接收器就可以了 1234567891011121314151617&lt;receiver android:name=&quot;.jpush.MyReceiver&quot; android:enabled=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;!--Required 用户注册SDK的intent--&gt; &lt;action android:name=&quot;cn.jpush.android.intent.REGISTRATION&quot; /&gt; &lt;!--Required 用户接收SDK消息的intent--&gt; &lt;action android:name=&quot;cn.jpush.android.intent.MESSAGE_RECEIVED&quot; /&gt; &lt;!--Required 用户接收SDK通知栏信息的intent--&gt; &lt;action android:name=&quot;cn.jpush.android.intent.NOTIFICATION_RECEIVED&quot; /&gt; &lt;!--Required 用户打开自定义通知栏的intent--&gt; &lt;action android:name=&quot;cn.jpush.android.intent.NOTIFICATION_OPENED&quot; /&gt; &lt;!-- 接收网络变化 连接/断开 since 1.6.3 --&gt; &lt;action android:name=&quot;cn.jpush.android.intent.CONNECTION&quot; /&gt; &lt;category android:name=&quot;com.zhujia.land&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 有点疑惑的是推送给特定的APP 目前获取RegistrationID，登陆接口把 RegistrationID传给服务端, 然后Server推送过来就可以了 http://blog.jiguang.cn/push_audience_tech-2/ 暂时别试用Jcenter集成,会出现各种问题 微信登陆App登录https://developers.weixin.qq.com/doc/oplatform/Mobile_App/Resource_Center_Homepage.html 问题1 E/MtaSDK: [pool-4-thread-1(320): null:705] - Server response error code:404, error:&#123;&quot;ret&quot;:-1, &quot;msg&quot;:&quot;invalid appkey&quot;&#125; Demo里的wechat-sdk-android-with-mta 换成 api ‘com.tencent.mm.opensdk:wechat-sdk-android-without-mta:+’ 这个弄了一上午 问题2 No value for openid. WXEntryActivity {“errcode”:40029,”errmsg”:”invalid code”} WXEntryActivity appid secret错误 1234567if (resp.getType() == ConstantsAPI.COMMAND_SENDAUTH) &#123; SendAuth.Resp authResp = (SendAuth.Resp)resp; final String code = authResp.code; NetworkUtil.sendWxAPI(handler, String.format(&quot;https://api.weixin.qq.com/sns/oauth2/access_token?&quot; + &quot;appid=%s&amp;secret=%s&amp;code=%s&amp;grant_type=authorization_code&quot;, &quot;wx930ea5d5a258f4f&quot;, &quot;1d6d1d57a3dd06336d917bc0b44d964&quot;, code), NetworkUtil.GET_TOKEN);&#125; 1GET https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code demo中 appid wxd930ea5d5a2584f要换成自己的 secret 1d6d1d57a3dd063b36d91bc0b44d964也要换成自己的 问题3 需要注册，否则WXEntryActivity不能收到回调 1234567891011121314151617181920212223private static final String APP_ID = &quot;wx88888888&quot;;// IWXAPI 是第三方app和微信通信的openApi接口private IWXAPI api;private regToWx() &#123; // 通过WXAPIFactory工厂，获取IWXAPI的实例 api = WXAPIFactory.createWXAPI(this, APP_ID, true); // 将应用的appId注册到微信 api.registerApp(APP_ID); //建议动态监听微信启动广播进行注册到微信 registerReceiver(new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; // 将该app注册到微信 api.registerApp(Constants.APP_ID); &#125; &#125;, new IntentFilter(ConstantsAPI.ACTION_REFRESH_WXAPP));&#125; 二维码扫码登录https://developers.weixin.qq.com/doc/oplatform/Mobile_App/WeChat_Login/Login_via_Scan.html 登录公众平台 https://mp.weixin.qq.com/cgi-bin/home?t=home ,点击配置进入IP白名单 点击配置进入IP白名单设置页 https://mp.weixin.qq.com/cgi-bin/announce?action=getannouncement&amp;key=1495617578&amp;version=1&amp;lang=zh_CN&amp;platform=2&amp;token=38764305 二维码扫码登录的appid secret key用开放平台的 https://open.weixin.qq.com/cgi-bin/index?t=home/index&amp;lang=zh_CN 注意两个不同的平台配置 二维码失效: 首先普及一下二维码是有失效时间以及失效状态的，一旦你扫过一次二维码或者在某段时间内没有扫描页面上的二维码，该二维码就失效了 app分享拉新规则 https://mp.weixin.qq.com/s/3bsmiv78yJ4XKwd8iu-0Ig Wechat Payhttps://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=8_5 Alipayhttps://opendocs.alipay.com/open/204/105296 orderInfo订单信息 由接口拼接就可以了 https://mp.weixin.qq.com/s/wWB5ENo3eQJH03OXvoup8w https://mp.weixin.qq.com/s?__biz=MzUxODg0MzU2OQ==&amp;mid=2247485318&amp;idx=1&amp;sn=174338566ad8c0426c95815c4f4aee5a&amp;scene=21#wechat_redirect 推送相关 https://juejin.im/post/6881414546859229192","categories":[{"name":"TOOL","slug":"TOOL","permalink":"http://noteforme.github.io.com/categories/TOOL/"}],"tags":[],"keywords":[{"name":"TOOL","slug":"TOOL","permalink":"http://noteforme.github.io.com/categories/TOOL/"}]},{"title":"JavaIo","slug":"JavaIo","date":"2017-09-12T02:14:41.000Z","updated":"2021-08-19T11:11:44.087Z","comments":true,"path":"2017/09/12/JavaIo/","link":"","permalink":"http://noteforme.github.io.com/2017/09/12/JavaIo/","excerpt":"","text":"![Screen Shot 2020-09-12 at 5.20.14 PM](JavaIo/Screen Shot 2020-09-12 at 5.20.14 PM.png) ![Screen Shot 2020-09-12 at 5.22.29 PM](JavaIo/Screen Shot 2020-09-12 at 5.22.29 PM.png) Byte Stream : 对于二进制文件或处理 数字字母之类的数据 https://www.javazhiyin.com/17362.html FileInputStream单个字节读 123456789101112FileInputStream fis = null;try &#123; fis = new FileInputStream(&quot;/Users/john/Documents/jywork/THINKJAVA/src/main/resource/a.txt&quot;); int data; while ((data = fis.read()) != -1) &#123; System.out.print((char) data+&quot; &quot;); &#125;&#125; catch (FileNotFoundException e) &#123; e.printStackTrace();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 读到bytes数组里面 12345678910111213FileInputStream fis = null;try &#123; byte[] bytes = new byte[14]; fis = new FileInputStream(&quot;/Users/john/Documents/jywork/THINKJAVA/src/main/resource/a.txt&quot;); int read = fis.read(bytes); String s = new String(bytes); System.out.println(s); System.out.println(read);&#125; catch (FileNotFoundException e) &#123; e.printStackTrace();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 读到bytes里面 ,限定读的字节个数 12345678910111213FileInputStream fis = null;try &#123; byte[] bytes = new byte[14]; fis = new FileInputStream(&quot;/Users/john/Documents/jywork/THINKJAVA/src/main/resource/a.txt&quot;); int read = fis.read(bytes,0,4); String s = new String(bytes); System.out.println(s); System.out.println(read);&#125; catch (FileNotFoundException e) &#123; e.printStackTrace();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 对于为什么必须继承装饰器父类 FilterInputStream的思考 实际上，如果去查看 JDK 的源码，你会发现，BufferedInputStream、DataInputStream 并非继承自 InputStream，而是另外一个叫 FilterInputStream 的类。那这又是出于什么样的设计意图，才引入这样一个类呢？我们再重新来看一下 BufferedInputStream 类的代码。InputStream 是一个抽象类而非接口，而且它的大部分函数（比如 read()、available()）都有默认实现，按理来说，我们只需要在 BufferedInputStream 类中重新实现那些需要增加缓存功能的函数就可以了，其他函数继承 InputStream 的默认实现。但实际上，这样做是行不通的。对于即便是不需要增加缓存功能的函数来说，BufferedInputStream 还是必须把它重新实现一遍，简单包裹对 InputStream 对象的函数调用。具体的代码示例如下所示。如果不重新实现，那 BufferedInputStream 类就无法将最终读取数据的任务，委托给传递进来的 InputStream 对象来完成。这一部分稍微有点不好理解，你自己多思考一下。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}],"tags":[],"keywords":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}]},{"title":"WebView","slug":"WebView","date":"2017-09-01T08:07:15.000Z","updated":"2021-08-19T11:11:44.292Z","comments":true,"path":"2017/09/01/WebView/","link":"","permalink":"http://noteforme.github.io.com/2017/09/01/WebView/","excerpt":"","text":"使用加载apk包中的html页面 webView.loadUrl(&quot;file:///android_asset/java.html&quot;); Enabling JavaScript12345678910111213141516171819202122WebView myWebView = (WebView) findViewById(R.id.webview);WebSettings webSettings = myWebView.getSettings(); //支持JavaScript// webSettings.setJavaScriptEnabled(true); // 在 onStop 和 onResume 里分别把 setJavaScriptEnabled() 给设置成 false 和 true 即可 /** * 设置自适应屏幕,两者合用 */ webSettings.setUseWideViewPort(true); //将图片调整到适合webview的大小 webSettings.setLoadWithOverviewMode(true); //缩放至屏幕的大小 /** * 缩放操作 */ webSettings.setSupportZoom(true); //支持缩放，默认为true。是下面那个的前提。 webSettings.setBuiltInZoomControls(true); //设置内置的缩放控件。若为false，则该WebView不可缩放 webSettings.setDisplayZoomControls(false);//隐藏原生的缩放控件// myWebView.setWebChromeClient(new MyWebViewClient()); myWebView.setWebViewClient(new MyViewClient()); 上面是一些常用的操作 Binding JavaScript code to Android code(JS交互)When developing a web application that’s designed specifically for the WebView in your Android application, you can create interfaces between your JavaScript code and client-side Android code. For example, your JavaScript code can call a method in your Android code to display a Dialog, instead of using JavaScript’s alert() function. To bind a new interface between your JavaScript and Android code, call addJavascriptInterface(), passing it a class instance to bind to your JavaScript and an interface name that your JavaScript can call to access the class. office Demo 12345678910111213inner class WebLoginInterface(context: Context?) &#123; @JavascriptInterface fun appLogin() &#123; Timber.i(&quot;appLogin&quot;) mWebView?.post &#123; val mSessionId = SharedPreferencesUtils.getParam(AppCtxUtil.getApp(), GsonUtil.SHARE_TOKEN_KEY, &quot;&quot;) as String Timber.i(&quot;mSessionId $&#123;mSessionId&#125;&quot;) val jsMethodName = &quot;javascript:appLoginCallBack(&#x27;$mSessionId&#x27;,&#x27;4&#x27;)&quot;; //需要参数的JS函数名 Timber.i(&quot;jsMethodName $jsMethodName&quot;) mWebView?.loadUrl(jsMethodName) &#125; &#125; &#125; 注意 Caution: If you’ve set your targetSdkVersion to 17 or higher, you must add the @JavascriptInterface annotation to any method that you want available to your JavaScript (the method must also be public). If you do not provide the annotation, the method is not accessible by your web page when running on Android 4.2 or higher. html小例子 1234567&lt;input type=&quot;button&quot; value=&quot;Say hello&quot; onClick=&quot;showAndroidToast(&#x27;Hello Android!&#x27;)&quot; /&gt;&lt;script type=&quot;text/javascript&quot;&gt; function showAndroidToast(toast) &#123; Android.showToast(toast); &#125;&lt;/script&gt; 接着加载JS 12WebView webView = (WebView) findViewById(R.id.webview);webView.addJavascriptInterface(new WebAppInterface(this), &quot;Android&quot;); https://developer.android.com/guide/webapps/webview.htmlhttp://www.jianshu.com/p/3c94ae673e2a http://www.jianshu.com/p/c20513cad758 缓存方案office (原生缓存)1234567891011121314 WebSettings webSettings = wbNews.getSettings(); webSettings.setJavaScriptEnabled(true);// 启用支持javascript webSettings.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK);//缓存模式 webSettings.setDomStorageEnabled(true); // 开启DOM storage API 功能 // 开启database storage API功能 webSettings.setDatabaseEnabled(true); webSettings.setAllowFileAccess(true);//可以访问文件 webSettings.setBuiltInZoomControls(true);//支持缩放 // 设置数据库缓存路径 String cacheDirPath = getFilesDir().getAbsolutePath() + APP_CACHE_DIRNAME; webSettings.setAppCachePath(cacheDirPath); webSettings.setAppCacheEnabled(true); http://blog.csdn.net/coder_pig/article/details/48468969 图片替换方式https://github.com/GcsSloop/diycode/blob/master/blog/journal-02.md 其他常用方式美团点评腾讯 https://juejin.im/post/5a94f9d15188257a63113a74 页面白屏1webSettings.setDomStorageEnabled(true); // 开启DOM storage API 功能 ​ https://blog.csdn.net/ONLYMETAGAIN/article/details/78390643 https://iluhcm.com/2017/12/10/design-an-elegant-and-powerful-android-webview-part-one/ 不显示图片的问题 1234webSettings.setBlockNetworkImage(false);if (Build.VERSION.SDK_INT&gt;=Build.VERSION_CODES.LOLLIPOP)&#123; webSettings.setMixedContentMode(WebSettings.MIXED_CONTENT_ALWAYS_ALLOW);&#125; 但是我的还是不显示 1android:hardwareAccelerated=&quot;false&quot; WebView缓存功能 https://github.com/yale8848/CacheWebView http://blog.leanote.com/post/zbyzhlsp/%E6%BC%AB%E8%B0%88Android-Webview%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%9C%BA%E6%99%AF%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95 https://www.zybuluo.com/zyl06/note/737188 https://juejin.im/post/5b94ca52e51d450e7d097f38 2、缓存模式(5种) LOAD_CACHE_ONLY: 不使用网络，只读取本地缓存数据 LOAD_DEFAULT: 根据cache-control决定是否从网络上取数据。 LOAD_CACHE_NORMAL: API level 17中已经废弃, 从API level 11开始作用同LOAD_DEFAULT模式 LOAD_NO_CACHE: 不使用缓存，只从网络获取数据. LOAD_CACHE_ELSE_NETWORK，只要本地有，无论是否过期，或者no-cache，都使用缓存中的数据。如：www.taobao.com的cache-control为no-cache，在模式LOAD_DEFAULT下，无论如何都会从网络上取数据，如果没有网络，就会出现错误页面；在LOAD_CACHE_ELSE_NETWORK模式下，无论是否有网络，只要本地有缓存，都使用缓存。本地没有缓存时才从网络上获取。www.360.com.cn的cache-control为max-age=60，在两种模式下都使用本地缓存数据。 https://juejin.im/entry/5ad70987f265da239148a614 zip离线缓存 https://mp.weixin.qq.com/s/AV2SwFfwwJH7xyrIBJemgw 安全问题WebView漏洞的根源在于强制其访问攻击者控制的网页。网页中含有攻击者可以控制的JS,因此可能钓鱼，窃取私有文件，甚至是 RCE,带来比较大的危害。 下面主要是4.4系统以上的机型 Webview密码明文存储漏洞WebView默认开启密码保存功能mWebView.setSavePassword(true),如果未关闭，用户输入密码时，会弹出提示框，询问用户是否保存密码，如果选是，密码会明文保存到 /data/data/com.package.name/databases/webview.db WebView域控制不严格漏洞setAllowFileAccess(true) : 窃取APP任意目录下的私有文件 setAllowUniversalAccessFromFileURLs : 允许通过file域url中的 javascript访问其他的源。 方案 通过以下设置，防止越权访问，跨域等安全问题 12345setAllowFileAccess(false)setAllowFileAccessFromFileURLs(false)setAllowUniversalAccessFromFileURLs(false) WebSettings.setSavePassword(false) 关闭密码保存提醒功能 建议开发者通过以下方式移除该JavaScript接口 12345removeJavascriptInterface(&quot;searchBoxJavaBridge_&quot;)removeJavascriptInterface(&quot;accessibility&quot;)；removeJavascriptInterface(&quot;accessibilityTraversal&quot;) https://zhuanlan.zhihu.com/p/21787366 https://zhuanlan.kanxue.com/article-14155.htm","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"Camera","slug":"Camera","date":"2017-08-28T14:16:43.000Z","updated":"2021-08-19T11:11:43.750Z","comments":true,"path":"2017/08/28/Camera/","link":"","permalink":"http://noteforme.github.io.com/2017/08/28/Camera/","excerpt":"","text":"https://developer.android.com/training/camera/photobasics.html#TaskPath Get the thumbnail(缩略图)12345678public static final int REQUEST_IMAGE_CAPTURE = 1;private void btAlbum() &#123; Intent takePictureIntent = new Intent( Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI); startActivityForResult(takePictureIntent, REQUEST_IMAGE_CAPTURE);&#125; 123456789@Override public void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if (requestCode == REQUEST_IMAGE_CAPTURE &amp;&amp; resultCode == Activity.RESULT_OK) &#123; data?.extras?.let &#123; val imageBitmap = it.get(&quot;data&quot;) as Bitmap img_show.setImageBitmap(imageBitmap) &#125; &#125; Save the full-size photo provider_camera.xml 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;paths xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;external-path name=&quot;my_images&quot; path=&quot;Android/data/com.zhujia.land/files/Pictures&quot; /&gt;&lt;/paths&gt; 跳转拍照 : 还得注意申请权限 1234567891011121314151617181920212223private void dispatchTakePictureIntent(int num) &#123; Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); if (takePictureIntent.resolveActivity(this.getPackageManager()) != null) &#123; try &#123; photoFile = createImageFile(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; if (photoFile == null) &#123; return; &#125; Uri imgUri; if (Build.VERSION.SDK_INT &lt; 24) &#123; imgUri = Uri.fromFile(photoFile); &#125; else &#123; //Android 7.0系统开始 使用本地真实的Uri路径不安全,使用FileProvider封装共享Uri //参数二:fileprovider绝对路径 com.dyb.testcamerademo：项目包名 imgUri = FileProvider.getUriForFile(this, &quot;com.zhujia.land.fileprovider&quot;, photoFile); &#125; takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, imgUri); &#125; startActivityForResult(takePictureIntent, num); &#125; 12345678910111213override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) &#123; super.onActivityResult(requestCode, resultCode, data) if (requestCode == REQUEST_IMAGE_CAPTURE &amp;&amp; resultCode == Activity.RESULT_OK) &#123; //如果拍照成功，将Uri用BitmapFactory的decodeStream方法转为Bitmap val imageBitmap = BitmapFactory.decodeStream(photoURI?.let &#123; contentResolver.openInputStream( it ) &#125;) galleryAddPic(mImageUriFromFile) //将拍的照片添加到相册 img_show.setImageBitmap(imageBitmap) &#125; &#125; 照片添加到相册 123456789/** * 将拍的照片添加到相册 * * @param uri 拍的照片的Uri */private fun galleryAddPic(uri: Uri?) &#123; val mediaScanIntent = Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE,uri) sendBroadcast(mediaScanIntent)&#125; But it has a question 12345678910111213141516 fun createImageFile(context: Context): File? &#123; // Create an image file name val timeStamp: String = SimpleDateFormat(yyyyMMDD_HHmmss).format(Date())// val storageDir: File? = context.getExternalFilesDir(Environment.DIRECTORY_PICTURES) val storageDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES) return File.createTempFile( &quot;JPEG_$&#123;timeStamp&#125;_&quot;, /* prefix */ &quot;.jpg&quot;, /* suffix */ storageDir /* directory */ ).apply &#123; // Save a file: path for use with ACTION_VIEW intents var currentPhotoPath = absolutePath Timber.i(&quot;createImageFile $currentPhotoPath&quot;) &#125; &#125; ACTION_MEDIA_SCANNER_SCAN_FILE 还有一个限制条件，那就是传递进去的文件绝对路径，必须是以 Environment.getExternalStorageDirectory() 方法的返回值开头。 这样 ‘context.getExternalFilesDir(Environment.DIRECTORY_PICTURES)’ 这个暂时没弄好 https://juejin.im/post/5ae0541df265da0b9d77e45a https://www.jianshu.com/p/f269bcda335f# https://www.jianshu.com/p/26d29e187f89 servlethttps://my.oschina.net/u/2008084/blog/524937 7.0https://blog.csdn.net/u011418943/article/details/77712662 Android 10 https://mp.weixin.qq.com/s/31esIqMudRRDBY8JDs8D4A https://juejin.im/post/5a33a5106fb9a04525782db5","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"ConcurrencyThreadPool","slug":"ConcurrencyThreadPool","date":"2017-08-27T02:40:55.000Z","updated":"2021-08-19T14:06:15.145Z","comments":true,"path":"2017/08/27/ConcurrencyThreadPool/","link":"","permalink":"http://noteforme.github.io.com/2017/08/27/ConcurrencyThreadPool/","excerpt":"","text":"线程池状态切换 1、RUNNING (1) 状态说明：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。 (02) 状态切换：线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0！ 1 2、 SHUTDOWN (1) 状态说明：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。 (2) 状态切换：调用线程池的shutdown()接口时，线程池由RUNNING -&gt; SHUTDOWN。 3、STOP (1) 状态说明：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。 (2) 状态切换：调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -&gt; STOP。 4、TIDYING (1) 状态说明：当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。 (2) 状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -&gt; TIDYING。 当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -&gt; TIDYING。 5、 TERMINATED (1) 状态说明：线程池彻底终止，就变成TERMINATED状态。 (2) 状态切换：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -&gt; TERMINATED。 https://blog.csdn.net/nmjhehe/article/details/115901549 https://www.cnblogs.com/east7/p/14417977.html 线程池工作原理 各参数含义corePoolSize线程池初始化时线程数默认为 0，当有新的任务提交后，会创建新线程执行任务，如果不做特殊设置，此后线程数通常不会再小于 corePoolSize ，因为它们是核心线程，即便未来可能没有可执行的任务也不会被销毁。 maximumPoolSize​ maximumPoolSize 最大线程数，线程池会在 corePoolSize 核心线程数的基础上继续创建线程来执行任务，假设任务被不断提交，线程池会持续创建线程直到线程数达到 maximumPoolSize 最大线程数，如果依然有任务被提交，这就超过了线程池的最大处理能力，这个时候线程池就会拒绝这些任务，我们可以看到实际上任务进来之后，线程池会逐一判断 corePoolSize、workQueue、maximumPoolSize，如果依然不能满足需求，则会拒绝任务。 keepAliveTime+时间单位​ 当线程池中线程数量多于核心线程数时，而此时又没有任务可做，线程池就会检测线程的 keepAliveTime，如果超过规定的时间，无事可做的线程就会被销毁，以便减少内存的占用和资源消耗。但是要注意到了核心线程数就不会销毁了。 如上图所示，当提交任务后，线程池首先会检查当前线程数，如果此时线程数小于核心线程数，比如最开始线程数量为 0，则新建线程并执行任务，随着任务的不断增加，线程数会逐渐增加并达到核心线程数，此时如果仍有任务被不断提交，就会被放入 workQueue 任务队列中，等待核心线程执行完当前任务后重新从 workQueue 中提取正在等待被执行的任务。 此时，假设我们的任务特别的多，已经达到了 workQueue 的容量上限，这时线程池就会启动后备力量，也就是 maximumPoolSize 最大线程数，线程池会在 corePoolSize 核心线程数的基础上继续创建线程来执行任务，假设任务被不断提交，线程池会持续创建线程直到线程数达到 maximumPoolSize 最大线程数，如果依然有任务被提交，这就超过了线程池的最大处理能力，这个时候线程池就会拒绝这些任务，我们可以看到实际上任务进来之后，线程池会逐一判断 corePoolSize、workQueue、maximumPoolSize，如果依然不能满足需求，则会拒绝任务。 6 种线程池 FixedThreadPool 它的核心线程数和最大线程数是一样的 CachedThreadPool 它的特点在于线程数是几乎可以无限增加的（实际最大可以达到 Integer.MAX_VALUE，为 2^31-1),当我们提交一个任务后，线程池会判断已创建的线程中是否有空闲线程，如果有空闲线程则将任务直接指派给空闲线程，如果没有空闲线程，则新建线程去执行任务，这样就做到了动态地新增线程。 12345ExecutorService service = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 1000; i++) &#123; service.execute(new Task() &#123; &#125;); &#125; 使用 for 循环提交 1000 个任务给 CachedThreadPool，假设这些任务处理的时间非常长，会发生什么情况呢？因为 for 循环提交任务的操作是非常快的，但执行任务却比较耗时，就可能导致 1000 个任务都提交完了但第一个任务还没有被执行完，所以此时 CachedThreadPool 就可以动态的伸缩线程数量，随着任务的提交，不停地创建 1000 个线程来执行任务，而当任务执行完之后，假设没有新的任务了，那么大量的闲置线程又会造成内存资源的浪费，这时线程池就会检测线程在 60 秒内有没有可执行任务，如果没有就会被销毁，最终线程数量会减为 0。 ScheduledThreadPool 周期性的执行任务 SingleThreadExecutor 它会使用唯一的线程去执行任务，原理和 FixedThreadPool 是一样的，只不过这里线程只有一个，如果线程在执行任务的过程中发生异常，线程池也会重新创建一个线程来执行后续的任务 SingleThreadScheduledExecutor 它实际和第三种 ScheduledThreadPool 线程池非常相似，它只是 ScheduledThreadPool 的一个特例，内部只有一个线程. ForkJoinPool 我们有一个 Task，这个 Task 可以产生三个子任务，三个子任务并行执行完毕后将结果汇总给 Result。 拒绝策略 第一种拒绝策略是 AbortPolicy，这种拒绝策略在拒绝任务时，会直接抛出一个类型为 RejectedExecutionException 的 RuntimeException，让你感知到任务被拒绝了，于是你便可以根据业务逻辑选择重试或者放弃提交等策略。 第二种拒绝策略是 DiscardPolicy，这种拒绝策略正如它的名字所描述的一样，当新任务被提交后直接被丢弃掉，也不会给你任何的通知，相对而言存在一定的风险，因为我们提交的时候根本不知道这个任务会被丢弃，可能造成数据丢失。 第三种拒绝策略是 DiscardOldestPolicy，如果线程池没被关闭且没有能力执行，则会丢弃任务队列中的头结点，通常是存活时间最长的任务，这种策略与第二种不同之处在于它丢弃的不是最新提交的，而是队列中存活时间最长的，这样就可以腾出空间给新提交的任务，但同理它也存在一定的数据丢失风险。 第四种拒绝策略是 CallerRunsPolicy，相对而言它就比较完善了，当有新任务提交后，如果线程池没被关闭且没有能力执行，则把这个任务交于提交任务的线程执行，也就是谁提交任务，谁就负责执行任务。这样做主要有两点好处。第一点新提交的任务不会被丢弃，这样也就不会造成业务损失。第二点好处是，由于谁提交任务谁就要负责执行任务，这样提交任务的线程就得负责执行任务，而执行任务又是比较耗时的，在这段期间，提交任务的线程被占用，也就不会再提交新的任务，减缓了任务提交的速度，相当于是一个负反馈。在此期间，线程池中的线程也可以充分利用这段时间来执行掉一部分任务，腾出一定的空间，相当于是给了线程池一定的缓冲期。 提交任务的线程是不固定的，取决于具体是哪个线程执行submit等方法的 https://kaiwu.lagou.com/course/courseInfo.htm?courseId=16#/detail/pc?id=248 线程数量和CPU核数关系线程数 = CPU 核心数 *（1+平均等待时间/平均工作时间） 线程平均等待时间所占比例越高，就需要越多的线程 耗时 IO 型任务 , 比如数据库、文件的读写，网络通信等任务，这种任务的特点是并不会特别消耗 CPU 资源，但是 IO 操作很耗时，总体会占用比较多的时间 , 因为 IO 读写速度相比于 CPU 的速度而言是比较慢的，如果我们设置过少的线程数，就可能导致 CPU 资源的浪费,而如果我们设置更多的线程数，那么当一部分线程正在等待 IO 的时候，它们此时并不需要 CPU 来计算，那么另外的线程便可以利用 CPU 去执行其他的任务，互不影响，这样的话在任务队列中等待的任务就会减少，可以更好地利用资源。 线程的平均工作时间所占比例越高，就需要越少的线程 平均工作时间长 : CPU密集型任务，加密、解密、压缩、计算等一系列需要大量耗费 CPU 资源的任务。因为计算任务非常重，会占用大量的 CPU 资源，所以这时 CPU 的每个核心工作基本都是满负荷的，而我们又设置了过多的线程，每个线程都想去利用 CPU 资源来执行自己的任务，这就会造成不必要的上下文切换，此时线程数的增多并没有让性能提升，反而由于线程数量过多会导致性能下降。 可以通过写代码等办法统计到各部分语句的运行时长 如果我们执行的任务类型不是固定的，比如可能一段时间是 CPU 密集型，另一段时间是 IO 密集型，或是同时有两种任务相互混搭。那么在这种情况下，我们可以把最大线程数设置成核心线程数的几倍，以便应对任务突发情况。当然更好的办法是用不同的线程池执行不同类型的任务，让任务按照类型区分开，而不是混杂在一起，这样就可以按照上一课时估算的线程数或经过压测得到的结果来设置合理的线程数了，达到更好的性能。 https://kaiwu.lagou.com/course/courseInfo.htm?courseId=16#/detail/pc?id=254 阻塞队列5种常见的线程池 12345ExecutorService fixedThreadPool = Executors.newFixedThreadPool(1); //LinkedBlockingQueueExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor(); // LinkedBlockingQueueExecutorService cachedThreadPool = Executors.newCachedThreadPool(); // SynchronousQueueScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(1); //DelayedWorkQueueScheduledExecutorService singleThreadScheduledExecutor = Executors.newSingleThreadScheduledExecutor(); //DelayedWorkQueue 上图 前面是线程池，后面是使用的阻塞队列 LinkedBlockingQueue (FixedThreadPool,SingleThreadExector) 使用的有 FixedThreadPool ,SingleThreadExector,它们使用的阻塞队列是容量为 Integer.MAX_VALUE 的 LinkedBlockingQueue,可以认为是无界队列。由于 FixedThreadPool 线程池的线程数是固定的，所以没有办法增加特别多的线程来处理任务，这时就需要 LinkedBlockingQueue 这样一个没有容量限制的阻塞队列来存放任务。 缺点: 最终大量堆积的任务会占用大量内存，并发生 OOM ，也就是OutOfMemoryError. SynchronousQueue (CachedThreadPool) 对应的线程池是 CachedThreadPool,线程池 CachedThreadPool 的最大线程数是 Integer 的最大值，可以理解为线程数是可以无限扩展的。和LinkedBlockingQueue阻塞队列重复相反， 缺点: 当任务数量特别多的时候，就可能会导致创建非常多的线程，最终超过了操作系统的上限而无法创建新线程，或者导致内存不足。 DelayedWorkQueue (DelayedWorkQueue) 顾名思义，特点就是可以延迟执行任务 缺点: 它采用的任务队列是 DelayedWorkQueue，这是一个延迟队列，同时也是一个无界队列，所以和 LinkedBlockingQueue 一样，如果队列中存放过多的任务，就可能导致 OOM OkHttp线程池12ThreadPoolExecutor executor = new ThreadPoolExecutor( 0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); 可以看到 corePoolSize 0 , MaxPoolSize Integer.MAX_VALUE 根据线程池执行流程： 首先核心线程，corePoolSize 为0 。 把任务加入SynchronousQueue，但是这个队列加入就会失败。 创建非核心线程，数量为Integer.MAX_VALUE，可以创建。 当任务执行完后，3创建的非核心线程 根据keepAliveTime时间，逐步销毁。 问题OkHttpThreadPool.java 12345678910111213141516171819ThreadPoolExecutor executor = new ThreadPoolExecutor( 0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;());executor.execute(() -&gt; &#123; System.out.println(&quot;任务1&quot;); System.out.println(Thread.currentThread()); while (true) &#123; &#125;&#125;);executor.execute(() -&gt; &#123; System.out.println(&quot;任务1&quot;); System.out.println(Thread.currentThread());&#125;);executor.execute(() -&gt; &#123; System.out.println(&quot;任务1&quot;); System.out.println(Thread.currentThread());&#125;); 运行结果: 任务1Thread[pool-1-thread-1,5,main] 如果 new LinkedBlockingDeque&lt;&gt;(1)能正常执行，因为LinkedBlockingDeque加入 任务1 就满了，后面的任务创建非核心线程 但是有点疑惑，我这里核心线程是0，任务都加入到LinkedBlockingDeque, 按照线程池流程，非核心就不应该创建呀？怎么任务1就执行了呢 https://www.bilibili.com/video/BV15y4y1B7Rw?p=5 https://mp.weixin.qq.com/s/BHDrSgwUVXkzvswK1khidQ https://github.com/Snailclimb/programmer-advancement https://juejin.im/post/6855586076132655118 https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485441&amp;idx=1&amp;sn=303a25ab02fa9f14a319923e6b0d9759&amp;chksm=cea247caf9d5cedc3a5e1d31f26c08d8ae4c11c349fbdc91ac1d90d8b35807517accb5f5d527&amp;token=2128752750&amp;lang=zh_CN#rd","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}],"tags":[{"name":"concurrency","slug":"concurrency","permalink":"http://noteforme.github.io.com/tags/concurrency/"}],"keywords":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}]},{"title":"Handler","slug":"Handler","date":"2017-08-21T09:06:35.000Z","updated":"2021-08-19T11:11:43.906Z","comments":true,"path":"2017/08/21/Handler/","link":"","permalink":"http://noteforme.github.io.com/2017/08/21/Handler/","excerpt":"","text":"原理图 各组件作用 Handler：事件的发送及处理者，在构造方法中可以设置其 async，默认为 false。若 async 为 true 则该 Handler 发送的 Message 均为异步消息，有同步屏障的情况下会被优先处理。 Looper：一个用于遍历 MessageQueue 的类，每个线程有一个独有的 Looper，它会在所处的线程开启一个死循环，不断从 MessageQueue 中拿出消息，并将其发送给 target 进行处理 MessageQueue：在主线程,用于存储 Message，内部维护了 Message 的链表，每次拿取 Message 时，若该 Message 离真正执行还需要一段时间，会通过 nativePollOnce 进入阻塞状态，避免资源的浪费。若存在消息屏障，则会忽略同步消息优先拿取异步消息，从而实现异步消息的优先消费。 消息入队算法https://www.jianshu.com/p/9efe3b48b730 https://juejin.cn/post/6844904113470177293 https://www.bilibili.com/video/BV1VE411Z7Ay?p=4 ThreadLocal存取算法 ThreadLocal是一个线程内部的数据存储类，它可以指定线程的存储数据，数据存储后只有在指定的线程种裁可以获取到存储的数据, 其他线程无法获取。 验证: private ThreadLocal&lt;String&gt; mStringThreadLocal = new ThreadLocal&lt;&gt;(); mStringThreadLocal.set(&quot;我是主线程&quot;); Log.d(TAG, &quot;mStringThreadLocal 主线程 : &quot; + mStringThreadLocal.get()); exec.submit(new Runnable() &#123; @Override public void run() &#123; mStringThreadLocal.set(&quot;我是线程１&quot;); Log.d(TAG, &quot;mStringThreadLocal 线程１: &quot; + mStringThreadLocal.get()); &#125; &#125;); exec.submit(new Runnable() &#123; @Override public void run() &#123; Log.d(TAG, &quot;mStringThreadLocal 线程2: &quot; + mStringThreadLocal.get()); &#125; &#125;); 运行结果: D/MainActivity: mStringThreadLocal 主线程 : 我是主线程 D/MainActivity: mStringThreadLocal 线程１: 我是线程１ D/MainActivity: mStringThreadLocal 线程2: null 从日志可以看到，虽然在不同线程访问的同一个ThreadLocal对象，但是他们通过ThreadLocal获取到的值确不一样 结论： 对ThreadLocal所做的 读写操作仅限于各自线程的内部，ThreadLocal可以在多个线程互不干扰的存储和修改数据。 !!!任务： 分析ThreadLocal存取算法 [^参考：Android开发艺术探索 p377] 消息同步消息 来个简单的例子 12345678new Thread(new Runnable() &#123; @Override public void run() &#123; Looper.prepare(); handler = new Handler(); Looper.loop(); &#125; &#125;).start();把 Looper.prepare();注释，报错日志 : java.lang.RuntimeException: Can&#39;t create handler inside thread that has not called Looper.prepare() 从报错信息入手看原因，初始化Handler (API = 25) 12345678910111213141516171819public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( &quot;Can&#x27;t create handler inside thread that has not called Looper.prepare()&quot;); //报错信息 &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; &#125; mLooper为空,所以报错，看下Looper.myLooper(); 1234567/** * Return the Looper object associated with the current thread. Returns * null if the calling thread is not associated with a Looper. */ public static @Nullable Looper myLooper() &#123; return sThreadLocal.get(); &#125; 注释可以看到，当前线程没有Looper对象, 那么Looper对象是怎么创建的呢，很显然就是上面例子里的 Looper.prepare(); 12345678910111213141516/** Initialize the current thread as a looper. * This gives you a chance to create handlers that then reference * this looper, before actually starting the loop. Be sure to call * &#123;@link #loop()&#125; after calling this method, and end it by calling * &#123;@link #quit()&#125;. */ public static void prepare() &#123; prepare(true); &#125; private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper(quitAllowed)); &#125; 如果没有Looper 则new 一个，由此也看到每个线程最多一个Looper对象,接着看初始化的Looper 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); &#125; MesageQueue也是通过Looper创建的，看到private 构造方法,一个Looper管理一个 ＭesageQueue,但是我们通常在UI线程初始化Handler不需要调用 Looper.prepare();,这是因为应用启动后,主线程ActivityThread main方法为我们做了工作。 12345678910111213141516171819202122232425262728293031323334353637383940public static void main(String[] args) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;); SamplingProfilerIntegration.start(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); // Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;); Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;)); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;); &#125; 这样初始化Handler操作分析好了，接着就开始发消息了 handler.sendMessage(message);,经过层层调用来到这个方法 12345678910 public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125; 第二个参数时间是可以添加延时的参数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException(&quot;Message must have a target.&quot;); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + &quot; This message is already in use.&quot;); &#125; synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + &quot; sending message to a Handler on a dead thread&quot;); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don&#x27;t have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true; &#125; 这要Mesage消息就添加到 MesageQueue中了，按事件顺序添加，然后就是取消息了，通过调用Looper.loop(); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. */ public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; + msg.callback + &quot;: &quot; + msg.what); &#125; final long traceTag = me.mTraceTag; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; try &#123; msg.target.dispatchMessage(msg); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (logging != null) &#123; logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn&#x27;t corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, &quot;Thread identity changed from 0x&quot; + Long.toHexString(ident) + &quot; to 0x&quot; + Long.toHexString(newIdent) + &quot; while dispatching to &quot; + msg.target.getClass().getName() + &quot; &quot; + msg.callback + &quot; what=&quot; + msg.what); &#125; msg.recycleUnchecked(); &#125; &#125; 通过 Message msg = queue.next(); 获取消息，然后用 msg.target.dispatchMessage(msg);把消息往哪发呢 ? 123456789101112131415/** * Handle system messages here. */ public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125; &#125; 点开 handleMesage(msg),msg.target 就是Handler 12345/** * Subclasses must implement this to receive messages. */ public void handleMessage(Message msg) &#123; &#125; 这里就清楚了，消息就传到了 Hanlder里面handleMessage的实现方法从上面分析handler消息传递基本了解了，借张图看下整片森林 异步消息Android系统16ms会刷新一次屏幕，如果主线程的消息过多，在16ms之内没有执行完，必然会造成卡顿或者掉帧。那怎么才能不排队，没有延时的处理呢？这个时候就需要异步消息，在处理异步消息的时候，我们就需要同步屏障，让异步消息不用排队等候处理。可以理解为同步屏障是一堵墙，把同步消息队列拦住，先处理异步消息，等异步消息处理完了，这堵墙就会取消，然后继续处理同步消息。 https://blog.csdn.net/ly502541243/article/details/109091386 查找异步消息方法 MessageQueue.java 12345678910111213141516171819202122Message next() &#123; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); //循环查找 直到找到异步消息为止. &#125; &#125; &#125; https://blog.csdn.net/ly502541243/article/details/109091386 发送延时消息看下面问题:handler如何实现延时发消息postdelay() https://zhuanlan.zhihu.com/p/260661053 https://blog.csdn.net/thh159/article/details/103644489 IdleHandler使用当消息队列空闲时会执行IdleHandler的queueIdle()方法，该方法返回一个boolean值，如果为false则执行完毕之后移除这条消息，如果为true则保留，等到下次空闲时会再次执行，下面看下MessageQueue的next()方法可以发现确实是这样 12345Message next() &#123; // Run the idle handlers. // We only ever reach this code block during the first iteration. keep = idler.queueIdle();&#125; Activity启动优化：onCreate，onStart，onResume中耗时较短但非必要的代码可以放到IdleHandler中执行，减少启动时间 想要在一个View绘制完成之后添加其他依赖于这个View的View，当然这个用View#post()也能实现，区别就是前者会在消息队列空闲时执行 一些第三方库中有使用，比如LeakCanary，Glide中有使用到，具体可以自行去查看 以前我们在Activity中获取某个控件的宽高的时候总是得到的是0，那是因为view的测量还未完成。通常的做法是监听ViewTreeObserver，它是在ViewRootImpl测量完成之后调用ViewTreeObserver.dispatchOnGlobalLayout()方法，这时候在onGlobalLayout回调中获取的控件宽高都是正确的数据。 1234Looper.myQueue().addIdleHandler &#123; Log.i(&quot;HandlerActivity&quot;, &quot;width $&#123;btFive.width&#125; height $&#123;btFive.height&#125;&quot;) false&#125; https://blog.csdn.net/ZYJWR/article/details/103086664 https://www.wanandroid.com/wenda/show/8723 问题handler的是怎样实现的？新线程中执行了一个耗时操作，然后把该结果塞给message，handler将发送这个messageQueue，Loop不停的从消息队列中取出消息。Handler 分发给Ui. Handler是怎么切换线程的我们在不同的线程发送消息，线程之间的资源是共享的 Handler机制了解吗？一个线程有几个Looper？为什么？只能有一个，不然调用Looper.prepare()会抛出运行时异常，提示“Only one Looper may be created per thread” handler如何实现延时发消息postdelay(),可以看到这里也是一个for循环遍历队列，核心变量就是nextPollTimeoutMillis。可以看到，计算出nextPollTimeoutMillis后就调用nativiePollOnce这个native方法。这里的话大概可以猜到他的运行机制，因为他是根据执行时间进行排序的，那传入的这个nextPollTimeoutMillis应该就是休眠时间，类似于java的sleep(time)。休眠到下一次message的时候就执行。那如果我在这段时间又插入了一个新的message怎么办，所以handler每次插入message都会唤醒线程，重新计算插入后，再走一次这个休眠流程。 值得注意的是这个方法没有开启子线程，只是调用了run(), 在 msg.target.dispatchMessage(msg)可以看到，接着调用了handleCallback(). https://www.jianshu.com/p/68083d432b3f 如果移除一个延时消息会解除休眠吗主线程死循环不会卡死吗从前面的主线程、子线程的分析可以看出，Looper会在线程中不断的检索消息，如果是子线程的Looper死循环，一旦任务完成，用户应该手动退出，而不是让其一直休眠等待。（引用自Gityuan）线程其实就是一段可执行的代码，当可执行的代码执行完成后，线程的生命周期便该终止了，线程退出。而对于主线程，我们是绝不希望会被运行一段时间，自己就退出，那么如何保证能一直存活呢？简单做法就是可执行代码是能一直执行下去的，死循环便能保证不会被退出，例如，binder 线程也是采用死循环的方法，通过循环方式不同与 Binder 驱动进行读写操作，当然并非简单地死循环，无消息时会休眠。Android是基于消息处理机制的，用户的行为都在这个Looper循环中，我们在休眠时点击屏幕，便唤醒主线程继续进行工作。 主线程的死循环一直运行是不是特别消耗 CPU 资源呢？ 其实不然，这里就涉及到 Linux pipe/epoll机制，简单说就是在主线程的 MessageQueue 没有消息时，便阻塞在 loop 的 queue.next() 中的 nativePollOnce() 方法里，此时主线程会释放 CPU 资源进入休眠状态，直到下个消息到达或者有事务发生，通过往 pipe 管道写端写入数据来唤醒主线程工作。这里采用的 epoll 机制，是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步I/O，即读写是阻塞的。 所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源。 https://www.jianshu.com/p/a7969d73c120 handler内存泄露问题说说你对Handler机制的了解，同步消息，异步消息等IdleHandler用过吗,IdleHandler应用场景？ 见上面IdleHandler使用 handler如何实现延时发消息postdelay()。callback，runnable，msg的执行优先级。阻塞是怎么实现的？为什么不会阻塞主线程？ Handler休眠是怎样的？epoll的原理是什么？如何实现延时消息，如果移除一个延时消息会解除休眠吗？Handler内存泄漏的GCRoot是什么？ epoll的时候算是卡顿吗 怎么样算是卡顿了 怎么利用消息机制检测卡顿 除了这种方式还有别的监测卡顿的方式吗 Android中为什么主线程不会因为Looper.loop()里的死循环卡死？对于线程即是一段可执行的代码，当可执行代码执行完成后，线程生命周期便该终止了，线程退出。而对于主线程，我们是绝不希望会被运行一段时间，自己就退出，那么如何保证能一直存活呢？简单做法就是可执行代码是能一直执行下去的，死循环便能保证不会被退出，例如，binder线程也是采用死循环的方法，通过循环方式不同与Binder驱动进行读写操作，当然并非简单地死循环，无消息时会休眠。但这里可能又引发了另一个问题，既然是死循环又如何去处理其他事务呢？通过创建新线程的方式。真正会卡死主线程的操作是在回调方法onCreate/onStart/onResume等操作时间过长，会导致掉帧，甚至发生ANR，looper.loop本身不会导致应用卡死。 主线程的死循环一直运行是不是特别消耗CPU资源呢？ 其实不然，这里就涉及到Linux pipe/epoll机制，简单说就是在主线程的MessageQueue没有消息时，便阻塞在loop的queue.next()中的nativePollOnce()方法里，此时主线程会释放CPU资源进入休眠状态，直到下个消息到达或者有事务发生，通过往pipe管道写端写入数据来唤醒主线程工作。这里采用的epoll机制，是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步I/O，即读写是阻塞的。 所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源。 Gityuan–Handler(Native层) Handler通信，Binder通信 Handler同步屏障Handler发送的消息分为普通消息、屏障消息、异步消息，一旦Looper在处理消息时遇到屏障消息，那么就不再处理普通的消息，而仅仅处理异步的消息。不再使用屏障后，需要撤销屏障，不然就再也执行不到普通消息了。 为什么需要这样？它是设计来为了让某些特殊的消息得以更快被执行的机制。比如绘制界面，这种消息可能会明显的被用户感知到，稍有不慎就会引起卡顿、掉帧之类的，所以需要及时处理（可能消息队列中有大量的消息，如果像平时一样挨个进行处理，那绘制界面这个消息就得等很久，这是不想看到的）。 屏障消息仅仅是起一个屏障的作用，本身一般不附带其他东西，它需要配合其他Handler组件才能发挥作用。 1、Handler问题三连：是什么？有什么用？为什么要用，不用行不行？ 2、Android UI更新机制(GUI) 为何设计成了单线程的？ 3、真的只能在主(UI)线程中更新UI吗？ 4、真的不能在主(UI)线程中执行网络操作吗？ 6、为什么建议使用Message.obtain()来创建Message实例？ 7、为什么子线程中不可以直接new Handler()而主线程中可以？ 8、主线程给子线程的Handler发送消息怎么写？ 9、HandlerThread实现的核心原理？ 10、当你用Handler发送一个Message，发生了什么？ 11、Looper是怎么拣队列里的消息的？ 12、分发给Handler的消息是怎么处理的？ 14、Looper在主线程中死循环，为啥不会ANR？ 15、Handler泄露的原因及正确写法 16、Handler中的同步屏障机制 17、Android 11 Handler相关变更 https://juejin.cn/post/6844904150140977165 handler post和handleMesage区别 ​ post的runnable会直接在callback中调用run方法执行，而sendMessage方法要用户主动重写mCallback或者handleMessage方法来处理 https://www.bilibili.com/video/BV1A7411M7zQ?from=search&amp;seid=14693797999095810218 https://juejin.im/post/6844904150140977165 http://blog.csdn.net/guolin_blog/article/details/9991569 https://xiaozhuanlan.com/topic/0843791256 glide handler https://www.bilibili.com/video/BV1FU4y1V7HE https://segmentfault.com/a/1190000039809784","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"AnimationResource","slug":"AnimationResource","date":"2017-08-16T03:22:57.000Z","updated":"2021-08-19T11:11:43.675Z","comments":true,"path":"2017/08/16/AnimationResource/","link":"","permalink":"http://noteforme.github.io.com/2017/08/16/AnimationResource/","excerpt":"","text":"https://developer.android.com/guide/topics/resources/animation-resource.html Android动画简介,直接copy了 The Android framework provides two animation systems: property animation and view animation. Both animation systems are viable options, but the property animation system, in general, is the preferred method to use, because it is more flexible and offers more features. In addition to these two systems, you can utilize Drawable animation, which allows you to load drawable resources and display them one frame after another. 可以看出官方更推崇 Property Animiation,更灵活而且提供更多的功能,看下３种动画方式 Drawable Animation (Frame动画，帧动画) Drawable animation involves displaying Drawable resources one after another, like a roll of film. This method of animation is useful if you want to animate things that are easier to represent with Drawable resources, such as a progression of bitmaps. 通过人视觉的延迟，把图片一张连接一张，类似放电影 View Animation(Tween动画) View Animation is the older system and can only be used for Views. It is relatively easy to setup and offers enough capabilities to meet many application’s needs. Property Animation Introduced in Android 3.0 (API level 11), the property animation system lets you animate properties of any object, including ones that are not rendered to the screen. The system is extensible and lets you animate properties of custom types as well. view动画示例: 文件位置放哪呢？ 在官网确认了了位置 The animation XML file belongs in the res/anim/ directory of your Android project. The file must have a single root element: this will be either a single , , , , interpolator element, or element that holds groups of these elements (which may include another ). By default, all animation instructions are applied simultaneously. To make them occur sequentially, you must specify the startOffset attribute, as shown in the example below. 123456789101112131415161718192021222324252627282930&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;1000&quot; android:fillAfter=&quot;true&quot; android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot; android:shareInterpolator=&quot;true&quot;&gt; &lt;!-- 位置移动--&gt; &lt;translate android:fromXDelta=&quot;0.0&quot; android:fromYDelta=&quot;0.0&quot; android:toXDelta=&quot;500.0&quot; android:toYDelta=&quot;500.0&quot; /&gt; &lt;!-- 放大或缩小 --&gt; &lt;scale android:fromXScale=&quot;0.0&quot; android:fromYScale=&quot;0.0&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:toXScale=&quot;1.0&quot; android:toYScale=&quot;1.0&quot; /&gt; &lt;rotate android:fromDegrees=&quot;0.0&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:toDegrees=&quot;30.0&quot; /&gt; &lt;alpha android:fromAlpha=&quot;0.0&quot; android:toAlpha=&quot;0.5&quot; /&gt;&lt;/set&gt; 演示代码:参考：http://www.jianshu.com/p/b7aa2a4a9787http://blog.csdn.net/yanbober/article/details/46481171 跑完代码后，点击动画结束后的图片，没反应，实际上按钮还是停留在屏幕左上角，只不过view动画把图片绘制到了新的位置。所以说 View动画是对View的影像做操作，它并不能改变View的位置参数 Property Animation 属性动画就是对 对象的属性进行实质的改变了，而不只是投影了，比如刚才的图片修改后是可以点击的 ValueAnimator: 通过不断的对值进行操作来实现的，初始值盒结束值之间的动画过渡就是由ValueAnimator来负责计算的，除此之外，还负责管理动画的播放次数，播放模式，以及监听等。 /** * 300 ms内,value值从0 平滑的过渡到了1 */ // ValueAnimator anim = ValueAnimator.ofFloat(0f, 1f);// anim.setDuration(300); /** * value值从0过渡到５，再到３最后到10的过程 */ // ValueAnimator anim = ValueAnimator.ofFloat(0f, 5f, 3f, 10f); //整形数从 0到 100 ValueAnimator anim = ValueAnimator.ofInt(0, 100); anim.setDuration(5000); anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator valueAnimator) &#123; Object currentValue = valueAnimator.getAnimatedValue(); Log.d(TAG, &quot; current value is &quot; + currentValue); &#125; &#125;); anim.start(); ObjectAnimatorObjectAnimator继承ValueAnimator，它可以直接对任意对象的任意属性进行动画操作演示示例 /** * 透明: ５秒内从常规变换成全 透明,再从透明变成常规 */ // ObjectAnimator animator = ObjectAnimator.ofFloat(v, “alpha”, 1f, 0f, 1f); /** * 旋转 : 对按钮进行旋转 360 */ // ObjectAnimator animator = ObjectAnimator.ofFloat(v, “rotation”, 0f, 360f); /** * 位置移动: Button向左移动再回来 */ // float curTranslationX = v.getTranslationX(); //获取当前Button的translationX位置// ObjectAnimator animator = ObjectAnimator.ofFloat(v, “translationX”,// curTranslationX, -500f, curTranslationX); //传入translationX，后面３个参数告诉它怎么移动 /** * 缩放： 参数改为 scaleY,表示再垂直方向上放大３倍再还原 */ ObjectAnimator animator = ObjectAnimator.ofFloat(v, &quot;scaleY&quot;, 1f, 3f, 1f); animator.setDuration(5000); animator.start(); ObjectAnimator传入参数是根据Ｖiew的属性进行操作的，如setRotation()、getRotation()、setTranslationX()、getTranslationX()、setScaleY()、getScaleY() ＃ 组合动画 : 就是属性动画组合起来,借助AnimatorSet 微风吹着，飘来周传雄的音乐… 敲着键盘 人生不过如此～～ after(Animator anim) : 现有动画放在传入动画之后执行 after(long delay) : 將现有动画延迟 “delay” 后执行 before(Animator anim) :参考楼上 with(Animator anim) : 现有动画盒传入动画同时执行 示例 ObjectAnimator moveIn = ObjectAnimator.ofFloat(v, “translationX”, -500f, 0f); ObjectAnimator rotation = ObjectAnimator.ofFloat(v, “rotation”, 0f, 360f); ObjectAnimator fadeInOut = ObjectAnimator.ofFloat(v, “alpha”, 1f, 0f, 1f); AnimatorSet animSet = new AnimatorSet(); animSet.play(rotation).with(fadeInOut).after(moveIn); animSet.setDuration(5000); animSet.addListener(new Animator.AnimatorListener() { @Override public void onAnimationStart(Animator animation) { Log.d(TAG, “ onAnimationStart “); } @Override public void onAnimationEnd(Animator animation) &#123; Log.d(TAG, &quot; onAnimationEnd &quot;); &#125; @Override public void onAnimationCancel(Animator animation) &#123; Log.d(TAG, &quot; onAnimationCancel &quot;); &#125; @Override public void onAnimationRepeat(Animator animation) &#123; Log.d(TAG, &quot; onAnimationRepeat &quot;); &#125; &#125;); animSet.start(); 下面是监听器，也可以用AnimatorListenerAdapter 选择想要重写的方法 XML支持的Property Animation tags 对应代码中的ValueAnimator - ObjectAnimator - AnimatorSet - 这里也需要建个文件夹存放 The property animation system lets you declare property animations with XML instead of doing it programmatically. By defining your animations in XML, you can easily reuse your animations in multiple activities and more easily edit the animation sequence. To distinguish animation files that use the new property animation APIs from those that use the legacy view animation framework, starting with Android 3.1, you should save the XML files for property animations in the **res/animator/ **directory. 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;animator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:valueFrom=&quot;0&quot; android:valueTo=&quot;100&quot; android:valueType=&quot;intType&quot; /&gt;加载Animator anim = AnimatorInflater.loadAnimator(this, R.animator.propery_first); anim.setTarget(v); anim.start(); 根据官方例子,也可以强转ValueAnimator，添加监听器,其他形式的xml文件也类似 设置动画参数 12345678910111213141516// ValueAnimator采用&lt;animator&gt; 标签&lt;animator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:valueFrom=&quot;0&quot; // 初始值 android:valueTo=&quot;100&quot; // 结束值 android:valueType=&quot;intType&quot; // 变化值类型 ：floatType &amp; intType android:duration=&quot;3000&quot; // 动画持续时间（ms），必须设置，动画才有效果 android:startOffset =&quot;1000&quot; // 动画延迟开始时间（ms） android:fillBefore = “true” // 动画播放完后，视图是否会停留在动画开始的状态，默认为true android:fillAfter = “false” // 动画播放完后，视图是否会停留在动画结束的状态，优先于fillBefore值，默认为false android:fillEnabled= “true” // 是否应用fillBefore值，对fillAfter值无影响，默认为true android:repeatMode= “restart” // 选择重复播放动画模式，restart代表正序重放，reverse代表倒序回放，默认为restart| android:repeatCount = “0” // 重放次数（所以动画的播放次数=重放次数+1），为infinite时无限重复 android:interpolator = @[package:]anim/interpolator_resource // 插值器，即影响动画的播放速度,下面会详细讲/&gt; https://blog.csdn.net/carson_ho/article/details/72909894 参考：http://blog.csdn.net/guolin_blog/article/details/43536355","categories":[{"name":"anim","slug":"anim","permalink":"http://noteforme.github.io.com/categories/anim/"}],"tags":[],"keywords":[{"name":"anim","slug":"anim","permalink":"http://noteforme.github.io.com/categories/anim/"}]},{"title":"PerformancePatterns","slug":"PerformancePatterns","date":"2017-08-16T01:56:08.000Z","updated":"2021-08-19T11:11:44.203Z","comments":true,"path":"2017/08/16/PerformancePatterns/","link":"","permalink":"http://noteforme.github.io.com/2017/08/16/PerformancePatterns/","excerpt":"","text":"性能优化 布局优化https://www.jianshu.com/p/ee9e4b8cb95f ANR 全称 Application Nor Responding,在debug的时候经常会出现的一个框框，询问关闭或等待，在正常环境下出现的情况 * 主线程IO 操作 * 主线程耗时任务 * 主线程错误的操作 Thread.wait或Thread.sleep Android系统监控程序的响应状况，出现下面两种情况弹出ANR对话框 *应用在5秒内未响应用户的输入事件(按键或者触摸) *BroadcastReceiver未在 10秒内完成相关的处理 AndroidStudio Profiler工具这个视频 讲解了找出内存泄漏的步骤 还有AndroidStudio3.0的图文方法 leakcanaryhttps://github.com/square/leakcanary 图片处理 https://developer.android.com/topic/performance/graphics/index.htmlhttps://developer.android.com/topic/performance/graphics/load-bitmap.html#read-bitmap apk size https://mp.weixin.qq.com/s/jnZpgaRFQT5ULk9tHWMAGg https://www.jianshu.com/p/fba7b43bdc9c 性能优化 https://mp.weixin.qq.com/s/ceXsH06fUFa7y4lzi4uXzw https://mp.weixin.qq.com/s/xqrGukIqA2zpGsGzah2EzA 包体积优化 https://juejin.im/post/6854573210408189960","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"TouchEvent2","slug":"TouchEvent2","date":"2017-08-13T14:01:04.000Z","updated":"2021-08-19T11:11:44.255Z","comments":true,"path":"2017/08/13/TouchEvent2/","link":"","permalink":"http://noteforme.github.io.com/2017/08/13/TouchEvent2/","excerpt":"","text":"Android touch Event 事件分发其实就是对MotionEvent事件得分发过程,当MotionEvet产生后，系统需要把这个事件传递给一个具体得View,而这个传递得过程就是分发过程 概述 为什么会有事件分发机制? Android得View是树形结构，绘制得时候遍历子View,他们必定是会重合分布，那么当我们点击得时候，是应该谁来响应这个事件呢? 然后才有事件分发 Activity －&gt; PhoneWindow －&gt; DecorView －&gt; ViewGroup －&gt; … －&gt; View 整个分发的宏观过程,Android群英传 这本书描述的很清晰,然后配合 Android开发艺术探索，的源码分析，简直天作之合． 主要方法 method事件分发机制事由 Activity -&gt; ViewGroup -&gt; View 方向上得传递通过三个很重要得方法共同完成 dispatchTouchEvent、onInterceptTouchEvent、onTouchEvent dispatchTouchEvent() 属性 介绍 使用对象 Activity、ViewGroup、View 作用 事件分发 onInterceptTouchEvent() 属性 介绍 作用 拦截事件 调用时刻 在ViewGroup的dispatchTouchEvent()内部调用 onTouchEvent() 属性 介绍 使用对象 Activity、ViewGroup、View 作用 事件消费 调用时刻 在dispatchTouchEvent()内部调用 三个方法的关系 可以用 singwhatiwanna 写的伪代码表示: 123456789public boolean dispatchTouchEvent(MotionEvent ev)&#123; boolean consume = false; if(onInterceptTouchEvent(ev))&#123; consume = onTouchEvent(ev); &#125;else&#123; consume = child.dispatchTouchEvent(ev); &#125; return consume;&#125; dispatchTouchEvent ：对于ViewGroup，点击事件产生后首先会传递给它， onInterceptTouchEvent(ev）: 如果方法返回true,则拦截事件,事件就交给当前ViewGroup处理,接着调用当前 ViewGroup的onTouchEvent.如果返回flase,就交给它的子元素,子元素的dispatchTouchEvent就会调用 onTouchEvent : 如果返回false，那么父容器的onTouchEvent将会被调用. Activity ViewGroup Viewsource code Activity 123456789public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); &#125; if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; return onTouchEvent(ev);&#125; ViewGroup 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215@Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(ev, 1); &#125; // If the event targets the accessibility focused view and this is it, start // normal event dispatch. Maybe a descendant is what will handle the click. if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123; ev.setTargetAccessibilityFocus(false); &#125; boolean handled = false; if (onFilterTouchEventForSecurity(ev)) &#123; final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; // Handle an initial down. if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState(); &#125; // Check for interception. final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125; &#125; else &#123; // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; &#125; // If intercepted, start normal event dispatch. Also if there is already // a view that is handling the gesture, do normal event dispatch. if (intercepted || mFirstTouchTarget != null) &#123; ev.setTargetAccessibilityFocus(false); &#125; // Check for cancelation. final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; // Update list of touch targets for pointer down, if needed. final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0; TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; if (!canceled &amp;&amp; !intercepted) &#123; // If the event is targeting accessibility focus we give it to the // view that has accessibility focus and if it does not handle it // we clear the flag and dispatch the event to all children as usual. // We are looking up the accessibility focused host to avoid keeping // state since these events are very rare. View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; final int actionIndex = ev.getActionIndex(); // always 0 for down final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; // Clean up earlier touch targets for this pointer id in case they // have become out of sync. removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123; final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // Find a child that can receive the event. // Scan children from front to back. final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); // If there is a view that has accessibility focus we want it // to get the event first and if not handled we will perform a // normal dispatch. We may do a double iteration but this is // safer given the timeframe. if (childWithAccessibilityFocus != null) &#123; if (childWithAccessibilityFocus != child) &#123; continue; &#125; childWithAccessibilityFocus = null; i = childrenCount - 1; &#125; if (!child.canReceivePointerEvents() || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; resetCancelNextUpFlag(child); if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) &#123; // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) &#123; if (children[childIndex] == mChildren[j]) &#123; mLastTouchDownIndex = j; break; &#125; &#125; &#125; else &#123; mLastTouchDownIndex = childIndex; &#125; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; // The accessibility focus didn&#x27;t handle the event, so clear // the flag and do a normal dispatch to all children. ev.setTargetAccessibilityFocus(false); &#125; if (preorderedList != null) preorderedList.clear(); &#125; if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123; // Did not find a child to receive the event. // Assign the pointer to the least recently added target. newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) &#123; newTouchTarget = newTouchTarget.next; &#125; newTouchTarget.pointerIdBits |= idBitsToAssign; &#125; &#125; &#125; // Dispatch to touch targets. if (mFirstTouchTarget == null) &#123; // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); &#125; else &#123; // Dispatch to touch targets, excluding the new touch target if we already // dispatched to it. Cancel touch targets if necessary. TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) &#123; final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123; handled = true; &#125; else &#123; final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123; handled = true; &#125; if (cancelChild) &#123; if (predecessor == null) &#123; mFirstTouchTarget = next; &#125; else &#123; predecessor.next = next; &#125; target.recycle(); target = next; continue; &#125; &#125; predecessor = target; target = next; &#125; &#125; // Update list of touch targets for pointer up or cancel, if needed. if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; resetTouchState(); &#125; else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123; final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); &#125; &#125; if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); &#125; return handled; &#125; View 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public boolean dispatchTouchEvent(MotionEvent event) &#123; // If the event should be handled by accessibility focus first. if (event.isTargetAccessibilityFocus()) &#123; // We don&#x27;t have focus or no virtual descendant has it, do not handle the event. if (!isAccessibilityFocusedViewOrHost()) &#123; return false; &#125; // We have focus and got the event, then use normal event dispatch. event.setTargetAccessibilityFocus(false); &#125; boolean result = false; if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(event, 0); &#125; final int actionMasked = event.getActionMasked(); if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Defensive cleanup for new gesture stopNestedScroll(); &#125; if (onFilterTouchEventForSecurity(event)) &#123; if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123; result = true; &#125; //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; &#125; if (!result &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(event, 0); &#125; // Clean up after nested scrolls if this is the end of a gesture; // also cancel it if we tried an ACTION_DOWN but we didn&#x27;t want the rest // of the gesture. if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123; stopNestedScroll(); &#125; return result;&#125; 图ACTION_DOWN分析1.MotionEvent.ACTION_DOWN 都不拦截 Activity dispatchTouchEvent() 1 =&gt; 5 RootView dispatchTouchEvent() 29 =&gt; (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT)==0 ​ =&gt; 33 =&gt; 58 =&gt; 68 =&gt; 122 =&gt; dispatchTransformedTouchEvent有子view重复上面流程 =&gt; dispatchTransformedTouchEvent没有子View =&gt; View1 dispatchTouchEvent() 36 =&gt; 54 result=false =&gt;事件开始往回传=&gt; ViewGroupA 122=&gt;163=&gt; 164 dispatchTransformedTouchEvent child传null =&gt;开始调用View dispatchTouchEvent()=false =&gt; 事件继续回传=&gt; RootView =&gt;重复上面ViewGroupA的流程 =&gt; 164 handled=false =&gt; Activity =&gt;5 getWindow().superDispatchTouchEvent(ev) =&gt; onTouchEvent(ev); 图ACTION_MOVE UP分析 RootView onInterceptTouchEvent =true Activity dispatchTouchEvent() 1 =&gt; 5 RootView dispatchTouchEvent() 29 =&gt; (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT)==0 =&gt; 164 &gt;handler = false =&gt; Activity =&gt;5 getWindow().superDispatchTouchEvent(ev) =&gt; onTouchEvent(ev); 图ACTION_MOVE UP分析 View touchevent = true Activity dispatchTouchEvent() 1 =&gt; 5 RootView dispatchTouchEvent() 29 =&gt; 41 =&gt; 170 =&gt; 183 遍历查找消费event的View =&gt; handled = true Activity =&gt;5 getWindow().superDispatchTouchEvent(ev) =&gt; onTouchEvent(ev); View点击事件处理(不是ViewGroup) onTouch返回false 1234567891011121314button2.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; Log.d(TAG, &quot;执行 button2 onTouch() 动作&quot; + event.getAction()); return false; &#125; &#125;); button2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.d(TAG, &quot;you clicked button2&quot;); &#125; &#125;); 打印结果: D/DispatchActivity: 执行 button2 onTouch() 动作0 D/DispatchActivity: 执行 button2 onTouch() 动作1 D/DispatchActivity: you clicked button2 onTouch返回trueLog打印结果: D/DispatchActivity: 执行 button2 onTouch() 动作0D/DispatchActivity: 执行 button2 onTouch() 动作1 不同得返回值,得到不同得结果 看下为什么看下 View的dispatchTouchEvent（） API 23 源码的事件分发流程点击 Button寻找dispatchTouchEvent() Button -&gt; dispatchTouchEvent() -&gt; TextView-&gt;View (点击Button后就会找 dispatchTouchEvent()，Button没有，然后就去父类TextView还是没找到，最后在View找到了) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * Pass the touch screen motion event down to the target view, or this * view if it is the target. * * @param event The motion event to be dispatched. * @return True if the event was handled by the view, false otherwise. */ public boolean dispatchTouchEvent(MotionEvent event) &#123; // If the event should be handled by accessibility focus first. if (event.isTargetAccessibilityFocus()) &#123; // We don&#x27;t have focus or no virtual descendant has it, do not handle the event. if (!isAccessibilityFocusedViewOrHost()) &#123; return false; &#125; // We have focus and got the event, then use normal event dispatch. event.setTargetAccessibilityFocus(false); &#125; boolean result = false; if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(event, 0); &#125; final int actionMasked = event.getActionMasked(); if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Defensive cleanup for new gesture stopNestedScroll(); &#125; if (onFilterTouchEventForSecurity(event)) &#123; //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; &#125; if (!result &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(event, 0); &#125; // Clean up after nested scrolls if this is the end of a gesture; // also cancel it if we tried an ACTION_DOWN but we didn&#x27;t want the rest // of the gesture. if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123; stopNestedScroll(); &#125; return result; &#125; 分析第34行,result默认为false,li.mOnTouchListener.onTouch(this, event))默认也是false,接着第40行,onTouchEvent(event)) 方法也会得到执行 -&gt; performClick()会给点击事件 一个回调; 以下内容参考: gcssloopViewGroup的 dispatchTouchEvent()解析http://blog.csdn.net/guolin_blog/article/details/9097463 https://mp.weixin.qq.com/s/KU32XpwDFBOl8ueXIaA8Tw","categories":[{"name":"VIEW","slug":"VIEW","permalink":"http://noteforme.github.io.com/categories/VIEW/"}],"tags":[{"name":"TouchEvent","slug":"TouchEvent","permalink":"http://noteforme.github.io.com/tags/TouchEvent/"}],"keywords":[{"name":"VIEW","slug":"VIEW","permalink":"http://noteforme.github.io.com/categories/VIEW/"}]},{"title":"AndroidStudioTool","slug":"AndroidStudioTool","date":"2017-08-13T10:20:17.000Z","updated":"2021-09-13T08:22:15.858Z","comments":true,"path":"2017/08/13/AndroidStudioTool/","link":"","permalink":"http://noteforme.github.io.com/2017/08/13/AndroidStudioTool/","excerpt":"","text":"降低 compileSdkVersion 版本 有时候需要看低版本的源码，就要修改compileSdkVersion版本 修改编译版本 targetSdkVersion版本修改成 21 然后 compile ‘com.android.support:appcompat-v7:21.+’ 继承的AppCompatActivity改成Activity 编译后报错 Error:(11) No resource identifier found for attribute ‘roundIcon’ in package ‘android’ 根据错误删除 android:roundIcon ,然后编译 参考：http://blog.csdn.net/hyr83960944/article/details/39941683 android stuido代理普通代理修改Gradle配置文件后就一直卡在那，在 build.gradle值修改下面如果用了ss代理，在ubuntu设置http没用，可以在 工程根目录下 gradle.properties 添加 org.gradle.jvmargs=-DsocksProxyHost=127.0.0.1 -DsocksProxyPort=1080 参考: https://www.zhihu.com/question/37810416 平常github下载项目导入AndroidStudio直接卡死，心里真不是…., 目前实验一种方式应该会快点修改 gradle\\wrapper\\gradle-wrapper.properties下的 distributionUrl=https://services.gradle.org/distributions/gradle-3.3-all.zip， 我的AndroidStudio默认是这个 所以就修改成这样的. jcenter库代理 (这几句话花了关键得一天时间)前天升级了系统，之前下得Demo一直跑不起来，’https://jitpack.io&#39;得文件一直下载不下来 ＞错误： jcenter.bintray.com:443 failed to respond 折腾了一天终于弄好了,需要设置proxy代理,把socket流量转为http 然后在 Ｍanual proxy configuration下面选择HTTP 填上 127.0.0.1 8118 就可以下载jitpack里面得文件了 阿里云镜像 /Users/john/.gradle/init.gradle 下载gradle 有时候想用新的的gradle，但是新的更新几十M的文件，一天都不一定能下下来 直接去官网下载 https://gradle.org/releases/ ，对应版本的zip文件，放到相应目录 比如我的就是 C:\\Users\\Administrator.gradle\\wrapper\\dists\\gradle-3.3-all\\55gk2rcmfc6p2dg9u9ohc3hw9\\ 还一个是在${home}/.gradle目录下得gradle.properties文件配置应该也是可以的 快捷键 Ctrl＋F12，可以显示当前文件的结构Ctrl＋Shift＋F7 可以高亮当前元素在当前文件中的使用Ctrl＋E，可以显示最近编辑的文件列表 Alt＋Up 和 Alt＋Down可在方法间快速移动 Shift＋Click可以关闭文件 Ctrl+ H 查看类的继承关系 Ctrl＋Alt＋B可以跳转到抽象方法的实现 Ctrl＋Q可以看JavaDoc 参考：https://github.com/1sters/Android-Studio-Guide/blob/master/tips-shortcuts.md 常用快捷键:https://mp.weixin.qq.com/s/lYBHtg342-t3NkPPY9E-YQ debug问题 15:40 Error running ‘app’ Cannot debug application from module app on device huawei-pra_al00-HMKNW17A12007001. This application does not have the debuggable attribute enabled in its manifest. If you have manually set it in the manifest, then remove it and let the IDE automatically assign it. If you are using Gradle, make sure that your current variant is debuggable. Build Variants 设置成debug 12345debug &#123; debuggable false minifyEnabled false signingConfig signingConfigs.debug &#125; debuggable设置成 true SVN分支合并 主干,主干新增文件被删除弄了两个多小时，说多了都是泪 https://www.jianshu.com/p/e50af339259f android命名规范https://juejin.im/entry/5b6a4ca9f265da0f4c6fe566 无线调试https://juejin.im/entry/5a6a7e69518825733b0f1635 设置侦听断开 : 123adb tcpip 8888adb connect 192.168.31.76:8888 安装包安装 adb -s acac34d7 install /e/JYWORK/ win10 jdk环境变量设置在系统变量中设置 ,注意要点开编辑文本是不是之前输入的有 “” Android stuido发布项目Jcenter12gradlew clean build bintrayUpload -PbintrayUser=blogforme -PbintrayKey=4c7511bba437157d77baeb5c17d339ce92c2bee7 -PdryRun=false https://github.com/novoda/bintray-release https://www.jianshu.com/p/9f81d5b5a451 https://blog.csdn.net/qq_32452623/article/details/79282605 Apk瘦身 https://blog.csdn.net/qq_32175491/article/details/80071987 也有不建议删SO库的说法 http://kaedea.com/2016/06/04/android-dynamical-loading-04-so-problems/ 依赖其他moudlehttps://mp.weixin.qq.com/s/trAxRzz573TFyJk2klKdag android stuido 日志过滤不需要的日志123^(?!.*(eglMakeCurrent|OpenGLRenderer)).*$eglMakeCurrent OpenGLRenderer两个包含需要过滤的字段 留下需要的日志 https://www.jianshu.com/p/11e56991ff28","categories":[{"name":"TOOL","slug":"TOOL","permalink":"http://noteforme.github.io.com/categories/TOOL/"}],"tags":[],"keywords":[{"name":"TOOL","slug":"TOOL","permalink":"http://noteforme.github.io.com/categories/TOOL/"}]},{"title":"BroadcastReceiver","slug":"BroadcastReceiver","date":"2017-08-12T07:44:53.000Z","updated":"2021-08-19T11:11:43.750Z","comments":true,"path":"2017/08/12/BroadcastReceiver/","link":"","permalink":"http://noteforme.github.io.com/2017/08/12/BroadcastReceiver/","excerpt":"","text":"BroadcastReceiver https://developer.android.com/guide/components/broadcasts.html 广播使应用程序间传输传输信息的机制，主要用来监听系统或者应用发出的广播信息。 BroadcastReceiver使用注意 当系统或应用发出广播时，扫描系统所有广播接收者(无论时静态注册还是动态注册方式)，通过action匹配將广播发给相应接收者，接收者收到 广播后会产生一个广播实例，执行onReceiver()，这个实例生命周期只有10秒,10秒内没执行结束onReceiver，系统会报错,所以不能再onReceiver()执行耗时操作,onReceiver结束后，实例被销毁. BroadcastReceiver注册方式Context-registered receivers (动态注册)注册 12345678910private UpdateBroadcastReceiver updateBr;@Overrideprotected void onStart() &#123; super.onStart(); updateBr = new UpdateBroadcastReceiver(); IntentFilter intentFilter = new IntentFilter(); intentFilter.addAction(ACTION_UPDATE); registerReceiver(updateBr, intentFilter);&#125; 发送注销广播 123456789101112131415//点击发送广播public void btBroadcast(View v) &#123; Intent intentBroad = new Intent(); intentBroad.setAction(ACTION_UPDATE); sendBroadcast(intentBroad);&#125;@Overrideprotected void onDestroy() &#123; super.onDestroy(); if (updateBr != null) &#123; unregisterReceiver(updateBr); &#125;&#125; 注意:这种注册方式 AndroidManifest.xml不用做任何操作 静态注册Android 8.0之后，静态注册是无法接收隐式广播的，而默认情况下，我们发出的广播都是隐式广播，因此一定要调用setPackage()方法，指定这条广播是发送给哪个应用程序的，从而让它变成一条显示广播。（第一行代码） AndroidManifest.xml添加 12345&lt;receiver android:name=&quot;.broadcastservice.UpdateBroadcastReceiver&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.UpdateBroadcastReceiver&quot;/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 注意 为了杜绝APP滥用资源,官方对有的广播做了限制 Note: If your app targets API level 26 or higher, you cannot use the manifest to declare a receiver for implicit broadcasts (broadcasts that do not target your app specifically), except for a few implicit broadcasts that are exempted from that restriction. In most cases, you can use scheduled jobs instead. 1intent.setPackage(&quot;com.comm.util&quot;) Sending broadcasts方式普通广播有序广播FirstOrderBroadCast 12345678910class FirstOrderBroadCast : BroadcastReceiver() &#123; override fun onReceive(context: Context?, intent: Intent?) &#123; Log.e(&quot;receive&quot;, &quot;Low&quot;); val code = 1 val data = &quot;hello I am FirstOrderBroadCast&quot; val bundle: Bundle? = Bundle() bundle?.putString(&quot;first&quot;,&quot;from FirstOrderBroadCast&quot;) setResult(code, data, bundle) &#125;&#125; SecondOrderBroadCast 1234567891011class SecondOrderBroadCast : BroadcastReceiver() &#123; override fun onReceive(context: Context?, intent: Intent?) &#123; Log.e(&quot;receive&quot;, &quot;Mid&quot;) //获取上一个广播接收器结果 val code = resultCode val data = resultData var bundleResult = getResultExtras(true).get(&quot;first&quot;); Log.e(&quot;receive&quot;, &quot;获取到上一个广播接收器结果：code= $code data= $data bundleResult $bundleResult&quot;) &#125;&#125; ThirdOrderBroadCast 12345678910class ThirdOrderBroadCast : BroadcastReceiver() &#123; override fun onReceive(context: Context?, intent: Intent?) &#123; Log.e(&quot;receive&quot;, &quot;High&quot;) //传递结果到下一个广播接收器 val code = 3 val data = &quot;hello&quot; val bundle: Bundle? = null setResult(code, data, bundle) &#125;&#125; AndroidMnifest.xml 123456789101112131415&lt;receiver android:name=&quot;.component.broadcastservice.FirstOrderBroadCast&quot;&gt; &lt;intent-filter android:priority=&quot;3000&quot;&gt; &lt;action android:name=&quot;com.broadcast.android&quot; /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt;&lt;receiver android:name=&quot;.component.broadcastservice.SecondOrderBroadCast&quot;&gt; &lt;intent-filter android:priority=&quot;2000&quot;&gt; &lt;action android:name=&quot;com.broadcast.android&quot; /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt;&lt;receiver android:name=&quot;.component.broadcastservice.ThirdOrderBroadCast&quot;&gt; &lt;intent-filter android:priority=&quot;1000&quot;&gt; &lt;action android:name=&quot;com.broadcast.android&quot; /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; or 1234updateBr = UpdateBroadcastReceiver()val intentFilter = IntentFilter()intentFilter.addAction(UpdateBroadcastReceiver.ACTION_UPDATE)registerReceiver(updateBr, intentFilter) 使用 BroadcastReceiverActivity 123456val intent = Intent()intent.action = &quot;com.broadcast.android&quot;bt_order_broadcast.setOnClickListener &#123; sendOrderedBroadcast(intent,null)&#125; 运行结果 1234E/receive: LowE/receive: MidE/receive: 获取到上一个广播接收器结果：code= 1 data= hello I am FirstOrderBroadCast bundleResult from FirstOrderBroadCastE/receive: High LocalBroadcastManager.sendBroadcastmethod sends broadcasts to receivers that are in the same app as the sender. If you don’t need to send broadcasts across apps, use local broadcasts.he implementation is much more efficient (no interprocess communication needed) and you don’t need to worry about any security issues related to other apps being able to receive or send your broadcasts.(应用内发送广播) 发送 123val intentBroad = Intent()intentBroad.action = UpdateBroadcastReceiver.ACTION_UPDATELocalBroadcastManager.getInstance(this).sendBroadcast(intentBroad) 注册 1234567updateBr = UpdateBroadcastReceiver()val intentFilter = IntentFilter()intentFilter.addAction(UpdateBroadcastReceiver.ACTION_UPDATE)registerReceiver(updateBr, intentFilter)updateBr?.let &#123; LocalBroadcastManager.getInstance(this).registerReceiver(it,intentFilter)&#125; https://blog.csdn.net/qq_30379689/article/details/53341313","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"SERVICE","slug":"SERVICE","date":"2017-08-11T10:21:06.000Z","updated":"2021-08-19T11:11:44.237Z","comments":true,"path":"2017/08/11/SERVICE/","link":"","permalink":"http://noteforme.github.io.com/2017/08/11/SERVICE/","excerpt":"","text":"https://developer.android.com/guide/components/services https://developer.android.com/reference/android/app/Service Service启动服务两种方式 startService bindService startService一个Service被startService多次启动,那么onCreate只会调用一次,onstart()会被调用多次, StartServcie:一旦启动，服务即可在后台无限期运行，即使启动服务的Ａctivity已被销毁也不受影响,直到调用stipService，或自身的stopSelf方法。内存不足系统也会结束服务。 bindService客户端通过IBinder接口于服务进行通信,客户端可以调用unbindServie关闭连接,当所有客户端关闭连接后系统会销毁服务.启动Log日志I/LearnService: – onCreate() –I/LearnService: – onBind() – 一个Service被某个Activity调用Context.bindService绑定启动，不管bindService调用几次，onCreate方法只会调用一次,onStart不会调用. service 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class BluetoothService extends Service &#123; @Override public void onCreate() &#123; super.onCreate(); Timber.i(&quot; onCreate()&quot;); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Timber.i(&quot; onStartCommand()&quot;); String param = intent.getStringExtra(PARRAM); Timber.i(&quot;接受 &quot; + param); return super.onStartCommand(intent, flags, startId); &#125; @Override public void onDestroy() &#123; super.onDestroy(); Timber.i(&quot; onDestroy()&quot;); &#125; @Override public void onLowMemory() &#123; super.onLowMemory(); Timber.i(&quot;onLowMemory()&quot;); &#125; @Override public boolean onUnbind(Intent intent) &#123; Timber.i(&quot;onUnbind(intent)()&quot;); return super.onUnbind(intent); &#125; @Override public void onRebind(Intent intent) &#123; super.onRebind(intent); Timber.i(&quot;onRebind(intent)()&quot;); &#125; public class LocalBinder extends Binder &#123; public BluetoothService getService() &#123; return BluetoothService.this; &#125; &#125; private final IBinder mBinder = new LocalBinder(); @Nullable @Override public IBinder onBind(Intent intent) &#123; Timber.i(&quot;onBind(intent)()&quot;); return mBinder; &#125;&#125; 启动 bindService(intent,mServiceConnection,BIND_AUTO_CREATE); 回调 123456789101112ServiceConnection mServiceConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; mBlueService = ((BluetoothService.LocalBinder)service).getService(); Timber.i(&quot;onServiceConnected(ComponentName name, IBinder service)&quot;); &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; Timber.i(&quot;onServiceDisconnected(ComponentName name)&quot;); &#125; &#125;; 先startService创建服务，然后bindService绑定，这时候调用stopService或stopSelf(),不会停止，只能使unbindService()停止服务 IntentService 通过HandlerThread单独开启一个线程一次处理所有的任务 不需要调用stopSelft()关闭服务，任务结束后自动关闭 1234567808-12 13:38:26.601 30532-30532/com.hyhy.lern I/MyIntentService: -- onCreate() --08-12 13:38:26.601 30532-30532/com.hyhy.lern I/MyIntentService: -- onStartCommand() --08-12 13:38:26.601 30532-30532/com.hyhy.lern I/MyIntentService: -- onStartCommand() --08-12 13:38:26.601 30532-30532/com.hyhy.lern I/MyIntentService: -- onStartCommand() --08-12 13:38:26.601 30532-30655/com.hyhy.lern I/MyIntentService: do task108-12 13:38:26.601 30532-30655/com.hyhy.lern I/MyIntentService: do task208-12 13:38:26.601 30532-30655/com.hyhy.lern I/MyIntentService: do task108-12 13:38:26.617 30532-30532/com.hyhy.lern I/MyIntentService: -- onDestroy() -- https://developer.android.com/training/run-background-service/create-service.html onStartCommand()1. onStartCommand方式中，返回START_STICKY 首先我们来看看onStartCommand都可以返回哪些值： 调用Context.startService方式启动Service时，如果Android面临内存匮乏，可能会销毁当前运行的Service，待内存充足时可以重建Service。而Service被Android系统强制销毁并再次重建的行为依赖于Service的onStartCommand()方法的返回值。 START_NOT_STICKY 如果返回START_NOT_STICKY，表示当Service运行的进程被Android系统强制杀掉之后，不会重新创建该Service。当然如果在其被杀掉之后一段时间又调用了startService，那么该Service又将被实例化。那什么情境下返回该值比较恰当呢？ 如果我们某个Service执行的工作被中断几次无关紧要或者对Android内存紧张的情况下需要被杀掉且不会立即重新创建这种行为也可接受，那么我们便可将 onStartCommand的返回值设置为START_NOT_STICKY。 举个例子，某个Service需要定时从服务器获取最新数据：通过一个定时器每隔指定的N分钟让定时器启动Service去获取服务端的最新数据。当执行到Service的onStartCommand时，在该方法内再规划一个N分钟后的定时器用于再次启动该Service并开辟一个新的线程去执行网络操作。假设Service在从服务器获取最新数据的过程中被Android系统强制杀掉，Service不会再重新创建，这也没关系，因为再过N分钟定时器就会再次启动该Service并重新获取数据 START_STICKY 如果返回START_STICKY，表示Service运行的进程被Android系统强制杀掉之后，Android系统会将该Service依然设置为started状态（即运行状态），但是不再保存onStartCommand方法传入的intent对象，然后Android系统会尝试再次重新创建该Service，并执行onStartCommand回调方法，但是onStartCommand回调方法的Intent参数为null，也就是onStartCommand方法虽然会执行但是获取不到intent信息。如果你的Service可以在任意时刻运行或结束都没什么问题，而且不需要intent信息，那么就可以在onStartCommand方法中返回START_STICKY，比如一个用来播放背景音乐功能的Service就适合返回该值。 START_REDELIVER_INTENT 如果返回START_REDELIVER_INTENT，表示Service运行的进程被Android系统强制杀掉之后，与返回START_STICKY的情况类似，Android系统会将再次重新创建该Service，并执行onStartCommand回调方法，但是不同的是，Android系统会再次将Service在被杀掉之前最后一次传入onStartCommand方法中的Intent再次保留下来并再次传入到重新创建后的Service的onStartCommand方法中，这样我们就能读取到intent参数。只要返回START_REDELIVER_INTENT，那么onStartCommand重的intent一定不是null。如果我们的Service需要依赖具体的Intent才能运行（需要从Intent中读取相关数据信息等），并且在强制销毁后有必要重新创建运行，那么这样的Service就适合返回START_REDELIVER_INTENT。 https://juejin.im/post/5b1747e5e51d45069a39ef45 https://developer.android.com/guide/components/bound-services#kotlin bindService callback 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class BindingActivity : Activity() &#123; private lateinit var mService: LocalService private var mBound: Boolean = false /** Defines callbacks for service binding, passed to bindService() */ private val connection = object : ServiceConnection &#123; override fun onServiceConnected(className: ComponentName, service: IBinder) &#123; // We&#x27;ve bound to LocalService, cast the IBinder and get LocalService instance val binder = service as LocalService.LocalBinder mService = binder.getService() mBound = true &#125; override fun onServiceDisconnected(arg0: ComponentName) &#123; mBound = false &#125; &#125; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.main) &#125; override fun onStart() &#123; super.onStart() // Bind to LocalService Intent(this, LocalService::class.java).also &#123; intent -&gt; bindService(intent, connection, Context.BIND_AUTO_CREATE) &#125; &#125; override fun onStop() &#123; super.onStop() unbindService(connection) mBound = false &#125; /** Called when a button is clicked (the button in the layout file attaches to * this method with the android:onClick attribute) */ fun onButtonClick(v: View) &#123; if (mBound) &#123; // Call a method from the LocalService. // However, if this call were something that might hang, then this request should // occur in a separate thread to avoid slowing down the activity performance. val num: Int = mService.randomNumber Toast.makeText(this, &quot;number: $num&quot;, Toast.LENGTH_SHORT).show() &#125; &#125;&#125; get Service object in this place 12val binder = service as LocalService.LocalBindermService = binder.getService() Using a Messenger If you need your service to communicate with remote processes, then you can use a Messenger to provide the interface for your service. stopself()​ 目前测试只有在onStartCommand()有效，多次点击startService(intent),startId持续递增. foreground service（前台服务） 被用户所知道，系统内存不足时候不允许被系统杀死的服务，前台服务必须给通知了一个通知，放在正在运行的标题之下，一般用于应用保活。 https://www.jianshu.com/p/5505390503fa onRebind()什么情况下执行 验证方法: startService(intent) 启动Service - bindService() 绑定Service - unBindService()解绑- bindService() 继续绑定 就会执行onRebind() 多个acitivty与service通信https://www.jianshu.com/p/9885acf65405 https://blog.csdn.net/pihailailou/article/details/78588496","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"DesignPatterns-Adatper","slug":"DesignPatterns_Adatper","date":"2017-08-10T07:41:04.000Z","updated":"2021-08-19T11:11:43.801Z","comments":true,"path":"2017/08/10/DesignPatterns_Adatper/","link":"","permalink":"http://noteforme.github.io.com/2017/08/10/DesignPatterns_Adatper/","excerpt":"","text":"适配器模式 //需要适配的类 public class Adaptee &#123; public void specificRequest()&#123; System.out.println(&quot;需要适配的类&quot;); &#125; &#125; //目标接口 public interface Target &#123; void request(); &#125; 对象适配器（采用对象组合方式实现）public class Adapter implements Target &#123; //直接关联被适配类 private Adaptee adaptee; //可以通过构造函数传入具体需要适配的被适配类对象 public Adapter(Adaptee adaptee) &#123; this.adaptee = adaptee; &#125; @Override public void request() &#123; this.adaptee.specificRequest(); &#125; public static void main(String[] args) &#123; Target adapter = new Adapter(new Adaptee()); adapter.request(); &#125; &#125; 类适配器模式(采用继承实现)public class CAdapter extends Adaptee implements Target &#123; @Override public void request() &#123; super.specificRequest(); &#125; public static void main(String[] args) &#123; Target adapter = new CAdapter(); adapter.request(); &#125; &#125; Builder模式参考 ：https://github.com/helen-x/AndroidInterview/blob/master/android/Android%20%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%A8%E5%9C%A8%E8%BF%99%E9%87%8C).md","categories":[{"name":"DesignPatterns","slug":"DesignPatterns","permalink":"http://noteforme.github.io.com/categories/DesignPatterns/"}],"tags":[],"keywords":[{"name":"DesignPatterns","slug":"DesignPatterns","permalink":"http://noteforme.github.io.com/categories/DesignPatterns/"}]},{"title":"DesignPatterns  Factory","slug":"DesignPatterns_Factory","date":"2017-08-10T00:36:29.000Z","updated":"2021-09-12T11:12:09.191Z","comments":true,"path":"2017/08/10/DesignPatterns_Factory/","link":"","permalink":"http://noteforme.github.io.com/2017/08/10/DesignPatterns_Factory/","excerpt":"","text":"工厂方法模式 工厂方法和抽象工厂方法 都是通过工厂生产产品，由于产品都实现了相同的接口，根据获取到的产品作相应的处理 工厂方法 :返回一个产品实例 , 继承了工厂Dialog Base类,Base类抽象方法由sub类实现 抽象工厂方法:可以返回一组相关的产品实例,实现了创建不同产品的抽象工厂接口 Simple factory1234567891011121314151617public class PizzaStore &#123; SimplePizzaFactory factory; public PizzaStore(SimplePizzaFactory factory) &#123; this.factory = factory; &#125; public Pizza orderPizza(String type) &#123; Pizza pizza = factory.createPizza(type); pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza; &#125;&#125; 1234567891011121314public class SimplePizzaFactory &#123; public Pizza createPizza(String type) &#123; Pizza pizza = null; if (&quot;cheese&quot;.equals(type)) &#123; pizza = new CheesePizza(); &#125; else if (&quot;pepperoni&quot;.equals(type)) &#123; pizza = new PepperoniPizza(); &#125; else if (&quot;calm&quot;.equals(type)) &#123; pizza = new GreekPizza(); &#125; return pizza; &#125;&#125; 123456789101112131415161718public class PizzaStore &#123; SimplePizzaFactory factory; public PizzaStore(SimplePizzaFactory factory) &#123; this.factory = factory; &#125; public Pizza orderPizza(String type) &#123; Pizza pizza = factory.createPizza(type); pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637public class Pizza &#123; String name; String dough; String sauce; ArrayList topping = new ArrayList(); public void prepare() &#123; printOperation(&quot;preparing &quot; + name); System.out.println(&quot;Tossing dough...&quot;); System.out.println(&quot;Adding sauce&quot;); System.out.println(&quot;Adding topping: &quot;); for (int i=0;i&lt;topping.size();i++)&#123; System.out.println(&quot; &quot;+topping.get(i)); &#125; &#125; public void bake() &#123; printOperation(&quot;bake for 25 minutes at 350&quot;); &#125; public void cut() &#123; printOperation(&quot;Cutting the pizza into diagonal slices&quot;); &#125; public void box() &#123; printOperation(&quot;Place pizza in official pizzaStore bx&quot;); &#125; public void printOperation(String op) &#123; System.out.println(/*getClass().getSimpleName() + &quot; &quot; +*/ op); &#125; public String getName()&#123; return name; &#125;&#125; 123SimplePizzaFactory calmFactory = new SimplePizzaFactory();PizzaStore calmPizza = new PizzaStore(calmFactory);calmPizza.orderPizza(&quot;calm&quot;); Static Factory（静态工厂模式）123public interface Animal &#123; void move();&#125; 12345public class Cat implements Animal&#123; public void move() &#123; System.out.println(&quot;Cat move&quot;); &#125;&#125; 工厂类 对实例类进行管理和创建 public class Factory &#123; //静态工厂方法 public static Cat produceCat() &#123; return new Cat(); &#125; public static Dog produceDog() &#123; return new Dog(); &#125; public static void main(String[] args) &#123; Animal cat = Factory.produceCat(); cat.move(); Dog dog = Factory.produceDog(); dog.move(); dog.eatBone(); &#125; &#125;` 假如我要实例化一个pig对象,那么肯定是要在Factory做添加的，接下来看看可以不修改其他类实现需求 Abstract Factory(抽象工厂 elementary ) public interface Provider &#123; Animal produce(); &#125; public class DogFactory implements Provider &#123; @Override public Animal produce() &#123; return new Dog(); &#125; &#125; public class CatFactory implements Provider &#123; @Override public Animal produce() &#123; return new Cat(); &#125; &#125; ​ Provider provider = new CatFactory();​ Animal cat = provider.produce();​ cat.move(); 如果要实例化Pig，添加一个PigFactory 就可以了 abstact guru123456789/** * // 抽象工厂接口声明了一组能返回不同抽象产品的方法。这些产品属于同一个系列 * // 且在高层主题或概念上具有相关性。同系列的产品通常能相互搭配使用。系列产 * // 品可有多个变体，但不同变体的产品不能搭配使用。 */public interface GUIFactory &#123; Button createButton(); CheckBox createCheckBox();&#125; 1234567891011121314// Concrete factories produce a family of products that belong// to a single variant. The factory guarantees that the// resulting products are compatible. Signatures of the concrete// factory&#x27;s methods return an abstract product, while inside// the method a concrete product is instantiated.public class WinFactory implements GUIFactory &#123; public Button createButton() &#123; return new WinButton(); &#125; public CheckBox createCheckBox() &#123; return new WinCheckbox(); &#125;&#125; 123456789public class MacFactory implements GUIFactory &#123; public Button createButton() &#123; return new MacButton(); &#125; public CheckBox createCheckBox() &#123; return new MacCheckbox(); &#125;&#125; 123456/** * // 系列产品中的特定产品必须有一个基础接口。所有产品变体都必须实现这个接口。 */public interface Button &#123; void paint();&#125; 1234567// Concrete products are created by corresponding concrete// factories.public class WinButton implements Button&#123; public void paint() &#123; System.out.println(&quot;根据 Windows 样式渲染按钮 WinButton&quot;); &#125;&#125; 12345public class MacButton implements Button&#123; public void paint() &#123; System.out.println(&quot;根据 macOs 样式渲染按钮 MacButton&quot;); &#125;&#125; 12345// 这是另一个产品的基础接口。所有产品都可以互动，但是只有相同具体变体的产// 品之间才能够正确地进行交互。public interface CheckBox &#123; void paint();&#125; 12345public class WinCheckbox implements CheckBox &#123; public void paint() &#123; System.out.println(&quot;根据 Win 样式渲染复选框。 WinCheckbox&quot;); &#125;&#125; 12345public class MacCheckbox implements CheckBox &#123; public void paint() &#123; System.out.println(&quot;根据 macOS 样式渲染复选框。 MacCheckbox&quot;); &#125;&#125; 123456789101112131415161718public class Application &#123; private GUIFactory factory; private Button button; private CheckBox checkBox; public Application(GUIFactory factory) &#123; this.factory = factory; &#125; public void createUi() &#123; this.button = factory.createButton(); this.checkBox = factory.createCheckBox(); &#125; public void paint()&#123; button.paint(); checkBox.paint(); &#125;&#125; https://refactoring.guru/design-patterns/abstract-factory https://www.zhihu.com/question/20367734 factory guru1234567891011121314151617181920public abstract class Dialog &#123; // The creator may also provide some default implementation // of the factory method. abstract Button createButton(); // Note that, despite its name, the creator&#x27;s primary // responsibility isn&#x27;t creating products. It usually // contains some core business logic that relies on product // objects returned by the factory method. Subclasses can // indirectly change that business logic by overriding the // factory method and returning a different type of product // from it. void render() &#123; // Call the factory method to create a product object. Button okButton = createButton(); // Now use the product. okButton.onClick(&quot;closeDialog&quot;); okButton.render(); &#125;&#125; 12345public class WindowsDialogFac extends Dialog &#123; Button createButton() &#123; return new WindowsButton(); &#125;&#125; 12345public class WebDialogFac extends Dialog &#123; Button createButton() &#123; return new HTMLButton(); &#125;&#125; 1234public interface Button &#123; void render(); void onClick(String cls);&#125; 123456789public class WindowsButton implements Button &#123; public void render() &#123; System.out.println(&quot;WindowsButton render()&quot;); &#125; public void onClick(String cls) &#123; System.out.println(&quot;WindowsButton onClick &quot;+cls); &#125;&#125; 123456789public class HTMLButton implements Button &#123; public void render() &#123; System.out.println(&quot;HTMLButton render()&quot;); &#125; public void onClick(String cls) &#123; System.out.println(&quot;HTMLButton onClick &quot;+cls); &#125;&#125; 12345678910111213141516171819202122232425public class Application &#123; Dialog dialog; String configOs = &quot;Windows&quot;; void initialize() throws Exception &#123; if (configOs.equals(&quot;Windows&quot;)) &#123; dialog = new WindowsDialogFac(); &#125; else if (configOs.equals(&quot;HTML&quot;)) &#123; dialog = new WebDialogFac(); &#125; else throw new Exception(&quot;Error! Unknown operating system.&quot;); &#125; // The client code works with an instance of a concrete // creator, albeit through its base interface. As long as // the client keeps working with the creator via the base // interface, you can pass it any creator&#x27;s subclass. public void main() throws Exception &#123; initialize(); dialog.render(); &#125;&#125;","categories":[{"name":"DesignPatterns","slug":"DesignPatterns","permalink":"http://noteforme.github.io.com/categories/DesignPatterns/"}],"tags":[],"keywords":[{"name":"DesignPatterns","slug":"DesignPatterns","permalink":"http://noteforme.github.io.com/categories/DesignPatterns/"}]},{"title":"Accessibility","slug":"Accessibility","date":"2017-08-09T13:27:05.000Z","updated":"2021-08-19T11:11:43.524Z","comments":true,"path":"2017/08/09/Accessibility/","link":"","permalink":"http://noteforme.github.io.com/2017/08/09/Accessibility/","excerpt":"","text":"先上官网地址 https://developer.android.com/guide/topics/ui/accessibility/services.html下面的是例子 https://developer.android.com/training/accessibility/index.html 然后是codelab 看看 https://codelabs.developers.google.com/codelabs/developing-android-a11y-service/index.html?index=..%2F..%2Findex#0 这是codelab github上的地址 https://github.com/googlecodelabs/android-accessibility一、简单实现1、创建一个 MyAccessibilityService类 继承 AccessibilityService … public class MyAccessibilityService extends AccessibilityService &#123; @Override public void onAccessibilityEvent(AccessibilityEvent event) &#123; &#125; @Override public void onInterrupt() &#123; &#125; }… 2、创建一个values下创建XML文件夹 3、 实现 onServiceConnected() @Override public void onServiceConnected() &#123; // Set the type of events that this service wants to listen to. Others // won&#39;t be passed to this service. info.eventTypes = AccessibilityEvent.TYPE_VIEW_CLICKED | AccessibilityEvent.TYPE_VIEW_FOCUSED; // If you only want this service to work with specific applications, set their // package names here. Otherwise, when the service is activated, it will listen // to events from all applications. info.packageNames = new String[] &#123;&quot;com.example.android.myFirstApp&quot;, &quot;com.example.android.mySecondApp&quot;&#125;; // Set the type of feedback your service will provide. info.feedbackType = AccessibilityServiceInfo.FEEDBACK_SPOKEN; // Default services are invoked only if no package-specific ones are present // for the type of AccessibilityEvent generated. This service *is* // application-specific, so the flag isn&#39;t necessary. If this was a // general-purpose service, it would be worth considering setting the // DEFAULT flag. // info.flags = AccessibilityServiceInfo.DEFAULT; info.notificationTimeout = 100; this.setServiceInfo(info); Log.i(&quot;test&quot;,&quot;测试&quot;); &#125; 4、实现 onAccessibilityEvent方法 @Override public void onAccessibilityEvent(AccessibilityEvent event) &#123; final int eventType = event.getEventType(); String eventText = null; switch(eventType) &#123; case AccessibilityEvent.TYPE_VIEW_CLICKED: eventText = &quot;Focused: &quot;; break; case AccessibilityEvent.TYPE_VIEW_FOCUSED: eventText = &quot;Focused: &quot;; break; &#125; eventText = eventText + event.getContentDescription(); // Do something nifty with this text, like speak the composed string // back to the user. speakToUser(eventText); &#125; ... 然后就可以开启辅助功能，看下log","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"OKHTTP","slug":"OKHTTP","date":"2017-08-07T02:04:29.000Z","updated":"2021-08-19T11:11:44.179Z","comments":true,"path":"2017/08/07/OKHTTP/","link":"","permalink":"http://noteforme.github.io.com/2017/08/07/OKHTTP/","excerpt":"","text":"Okhttp使用线程池无 核心级线程，不应该先把阻塞队列塞满，再执行非核心级线程吗，这样任何不应该会立即执行呀？？？ 阻塞队列用了synchrnized 会添加失败。所以直接创建非核心线程。 如何阅读开源项目https://time.geekbang.org/column/article/186778 https://www.imooc.com/article/301778 https://baixin.ink/2019/05/10/how-to-learn-opensorce-project/ https://www.jianshu.com/p/656dbb97a40f https://www.codedump.info/post/20200605-how-to-read-code-v2020/ 不管写的怎么样，先把东西弄出来，然后参考别人的写法，做对比 Okhttp优势https://square.github.io/okhttp/ OkHttp is an HTTP client that’s efficient by default: HTTP/2 support allows all requests to the same host to share a socket. Connection pooling reduces request latency (if HTTP/2 isn’t available). Transparent GZIP shrinks download sizes. Response caching avoids the network completely for repeat requests. 任务运行图 分析一开始看了网上视频，就说Okhttp是自驱动循环调用，相对于AsyncTask的优势就是 并发执行，但是这两条不就矛盾了吗，既然环形链式调用，怎么能并发呢。就从源码中找答案。 Dispatcher.java 12345678910private int maxRequests = 64;private int maxRequestsPerHost = 5;synchronized void enqueue(AsyncCall call) &#123; if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123; runningAsyncCalls.add(call); executorService().execute(call); &#125; else &#123; readyAsyncCalls.add(call); &#125;&#125; 可以看到提交任务 &gt;5时，才会被添加到readyAsyncCalls队列中。&lt;5的任务直接提交。 1234567891011121314151617private void promoteCalls() &#123; if (runningAsyncCalls.size() &gt;= maxRequests) return; // Already running max capacity. if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote. for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123; AsyncCall call = i.next(); if (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123; i.remove(); runningAsyncCalls.add(call); Log.i(&quot;Dispatcher&quot;, &quot;promoteCalls: 准备队列 &quot;+call.request().tag+&quot; 执行&quot;); executorService().execute(call); &#125; if (runningAsyncCalls.size() &gt;= maxRequests) return; // Reached max capacity. &#125;&#125; readyAsyncCalls不为空，然后取出一条，再执行，可以看到，默认情况下会有5条环形任务链。 拦截器 OkHttp的拦截器有： RetryAndFollowUpInterceptor：失败和重定向拦截器； BridgeInterceptor：负责将http协议必备的请求头加入其中(host),并添加一些默认的行为(gzip),获得结果后，调用cookie接口并解析GZIP数据。 CacheInterceptor：缓存处理相关的拦截器； ConnectInterceptor： 负责找到或者新建一个连接，并获取对应的socket流；在获得结果后不进行额外的处理。 CallServerInterceptor：进行真正的与服务器的通信，向服务器请求和读响应的拦截器； 面试题okhttp 是如何支持 Http2 的？ Handshake则会把服务端支持的Tls版本，加密方式等都带回来，然后会把这个没有验证过的HandShake用X509Certificate去验证证书的有效性。然后会通过Platform去从SSLSocket去获取ALPN的协议支持信息，当后端支持的协议内包含Http2.0时，则就会把请求升级到Http2.0阶段。 Okhttp连接池是咋实现的? 在连接池中找连接的时候会对比连接池中相同host的连接。 如果在连接池中找不到连接的话，会创建连接，创建完后会存储到连接池中。 在把连接放入连接池中时，会把清除操作的任务放入到线程池中执行，删除任务中会判断当前连接有没有在使用中，有没有正在使用通过RealConnection的transmitters集合的size是否为0来判断，如果不在使用中，找出空闲时间最长的连接，如果空闲时间最长的连接超过了keep-alive默认的5分钟或者空闲的连接数超过了最大的keep-alive连接数5个的话，会把存活时间最长的连接从连接池中删除。保证keep-alive的最大空闲时间和最大的连接数 雨露均沾的OkHttp—WebSocket长连接（使用篇） OKHTTP之缓存配置详解 OkHttp对于网络请求都有哪些优化 OkHttp框架中都用到了哪些设计模式 https://www.codetd.com/article/4354895 https://www.jianshu.com/p/d85e556b8da6 解析Okhttp缓存 1、添加cache 路径 2、初始化OkhttpClient 12345678910111213141516public class NewCacheInterceptor implements Interceptor &#123; @Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); Response response = chain.proceed(request); Response response1 = response.newBuilder() .removeHeader(&quot;Pragma&quot;) .removeHeader(&quot;Cache-Control&quot;) .header(&quot;Cache-Control&quot;, &quot;max-age=&quot; + 3600 * 24 * 30) .build(); return response1; &#125; &#125; https://juejin.cn/post/6873476209737629709/ http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0106/2275.html http://blog.csdn.net/briblue/article/details/52920531http://mushuichuan.com/2016/03/01/okhttpcache/ https://www.mocklab.io/blog/which-java-http-client-should-i-use-in-2020/ https://www.bilibili.com/video/BV12Q4y1d7uD?p=7&amp;spm_id_from=pageDriver","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"Network","slug":"Network","date":"2017-08-03T01:27:38.000Z","updated":"2021-08-19T11:11:44.128Z","comments":true,"path":"2017/08/03/Network/","link":"","permalink":"http://noteforme.github.io.com/2017/08/03/Network/","excerpt":"","text":"https://www.bilibili.com/video/BV1F54y1t7Dx?from=search&amp;seid=12798261982184143495 Open System InterconnectionOSI 7层模型 TCP/IP 5层模型 应用层protocolURI ftp://ftp.is.co.za/rfc/rfc1808.txt http://www.ietf.org/rfc/rfc2396.txt ldap://[2001:db8::7]/c=GB?objectClass?one mailto:&#x4a;&#x6f;&#104;&#110;&#46;&#68;&#x6f;&#x65;&#x40;&#101;&#x78;&#x61;&#x6d;&#112;&#108;&#x65;&#x2e;&#x63;&#x6f;&#x6d; news:comp.infosystems.www.servers.unix tel:+1-816-555-1212 telnet://192.0.2.16:80/ urn:oasis:names:specification:docbook:dtd:xml:4.1.2 Http1.1https://tools.ietf.org/html/rfc7230#section-6 HyperText Transfer Protocol 可靠的数据传输协议，基于TCP 报文格式 Http2.0https://tools.ietf.org/html/rfc7540 可以看到http2.0改造了协议， head 改成了 HEADERS frame ,Body 改成了 DATA frame。 Length : 整个frame 开始到结束 Type : frame的类型 Stream ID用作流控制 Payload 请求正文 https://www.bilibili.com/video/BV1SJ411q7ei?from=search&amp;seid=10178848750670062838 https://www.bilibili.com/video/BV1Sw411d7oE?from=search&amp;seid=10178848750670062838 端口作用进程id是会变化的，进程通过绑定固定不变的端口，来实现通信。 http版本区别 https://juejin.cn/post/6844903489596833800 Socket对TCP/IP的封装， 提供可供程序员做网络开发的接口-Socket编程接口。 SocketHttpTest.java http get请求 按照get请求拼接字符串 123456789101112131415161718192021222324252627282930313233343536373839404142StringBuffer protocol = new StringBuffer(); //请求行 protocol.append(&quot;GET &quot;); protocol.append(url.getPath()); protocol.append(&quot;?&quot;); protocol.append(url.getQuery()); protocol.append(&quot; &quot;); protocol.append(&quot;HTTP/1.1&quot;); protocol.append(&quot;\\r\\n&quot;); // http请求头 protocol.append(&quot;Host:&quot;); protocol.append(url.getHost()); protocol.append(&quot;\\r\\n&quot;); //空行 protocol.append(&quot;\\r\\n&quot;); //post请求体 get没有 System.out.println(&quot;发送的http报文: \\n&quot; + protocol.toString()); Socket socket = new Socket(); socket.connect(new InetSocketAddress(url.getHost(), 80)); //获得输入输出流 BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream())); bufferedWriter.write(protocol.toString()); bufferedWriter.flush(); StringBuilder stringBuilder = new StringBuilder(); String line = &quot;&quot;; while ((line = bufferedReader.readLine()) != null) &#123; stringBuilder.append(line) .append(&quot;\\r\\n&quot;); &#125; System.out.println(stringBuilder.toString()); Http Post请求 参数放入请求体中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 URL url = new URL(cUrl); StringBuffer protocol = new StringBuffer(); //请求行 protocol.append(&quot;POST &quot;); protocol.append(url.getPath()); protocol.append(&quot; &quot;); protocol.append(&quot;HTTP/1.1&quot;); protocol.append(&quot;\\r\\n&quot;); // http请求头 protocol.append(&quot;Host:&quot;); protocol.append(url.getHost()); protocol.append(&quot;\\r\\n&quot;); protocol.append(&quot;Content-Length: 60\\r\\n&quot;); protocol.append(&quot;Content-Type: application/x-www-form-urlencoded\\r\\n&quot;); //空行 protocol.append(&quot;\\r\\n&quot;); // 必须用空行分隔请求体 //post请求体 get没有// protocol.append(&quot;city=&quot;+ URLEncoder.encode(&quot;长沙&quot;,&quot;UTF-8&quot;) +&quot;&amp;key=13cb58f5884f9749287abbead9c658f2&quot;); protocol.append(url.getQuery()); System.out.println(&quot;发送的http报文: \\n&quot; + protocol.toString()); Socket socket = new Socket(); socket.connect(new InetSocketAddress(url.getHost(), 80)); //获得输入输出流 BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream())); bufferedWriter.write(protocol.toString()); bufferedWriter.flush(); StringBuilder stringBuilder = new StringBuilder(); String line = &quot;&quot;; while ((line = bufferedReader.readLine()) != null) &#123; stringBuilder.append(line) .append(&quot;\\r\\n&quot;); &#125; System.out.println(stringBuilder.toString()); 分块编码 数据量很大！分块编码 上面的5就是 下面的字符长度 HTTPShttps://www.bilibili.com/video/BV1F54y1t7Dx?p=5 https://www.bilibili.com/video/BV1j7411H7vV?from=search&amp;seid=12798261982184143495 传输层 (TCP UDP)代码运行在用户机器上，为了对 网络层进行更好的控制 UDP(User Datagram Protocol) 面向报文传输 没有拥塞控制,无法保证数据在网络中是否丢失 UDP首部开销小 ​ TCP (Transmission Control Protocol) 面向连接的协议 提供可靠传输 全双工通信 面向字节流协议: 可能对用户数据合并或分拆进行传输 TCP首部 序号 tcp标记 如何保证TCP可靠传输? 停止等待协议 连续ARQ协议(Automatic Repeat request) : ​ 滑动窗口: 以字节为单位，实现流量控制 累计确认 ​ 选择重传: 重传边界和范围 定时器 超时定时器 坚持定时器: 解决死锁局面,当收到窗口为0的消息，则启动坚持定时器,每隔一段时间发送一个窗口探测报文 TCP协议的拥塞控制 报文超时即认为拥塞 慢启动算法 由小到大逐渐增加发送数据量,直到到达 “慢启动阈值”=&gt;开始 拥塞避免算法 拥塞避免算法 只要网络不拥塞，就试探拥塞窗口调大 TCP三次握手 TCP标记 三次握手 为何3次握手1客户端角度 : 1 ，2，说明客户端的发送和接收没问题 服务端角度： 1，2，说明服务端的接收没问题，但是不确定自己的发送收否有问题，所以需要3确认 为何3次握手2第一次握手客户端发出: Server觉得 : 客户端的发送能力没问题 第二次握手服务端发出: Client觉得 : 服务端的接收能力没问题， 以及服务端的发送能力没问题。 第三次握手客户端发出: Server觉得: 客户端的接收能力没问题。 为什么要第三次握手? 只有两次握手的话，一旦第二次握手接收超时，重新发送后就会重新发送，会导致建立2个连接 TCP连接的4次挥手 由客户端向服务端发起 : 服务端收到信息后,就能确定客户端已经停止发送数据。 由服务端向客户端发起 : 客户端收到消息后,就能确定服务端已经知道客户端不会再发送数据。这一次是为了TCP可靠传输，确认收到了数据包。 由服务端向客户端发起 : 客户端收到消息后,就能确定服务端已经停止发送数据。此时 服务端数据发送完了。 由客户端向服务端发起 : 服务端收到信息后,就能确定客户端已经知道服务端不会再发送数据。 Client: 分手 Server : what Server : 好吧 分吧 Client : 我已经删微信了； 等待计时器 : 2MSL(Max Segment liftime), **为什么需要等待计时器?**： 如果第4个挥手报文接收方没收到，那么接收方会重新发送第3次的挥手报文 为什么第3次挥手是接收方发出的? : 我的理解是，第2次挥手是确认收到的回复，第三次是挥手是确认数据发送完毕，告诉发送方可以断开了,然而我又有了疑问? 为什么需要第4次挥手? 小扎和小美通信 https://www.zhihu.com/question/63264012 网络层 通过ISP、路由 找到 ,运行在路由器上 rip协议:不太理解 网络配置 主机计算IPADDR : 192.168.139.10 NETMASK子网掩码 : 255.255.255.0 网络号: 就是上面的IPADDR ,NETMASK进行 与运算, 192.168.139.0,10就是网络中的第10号主机。 路由表 第一条意思 我这台计算机通过 eth0,不需要任何中间的网关Geteway,久可以访问这个网络(192.168.150.)中的任何计算机， 怎么找到目标主机面试题:路由器是怎么找目标服务器 https://www.bilibili.com/video/BV1PU4y1s7Bs?p=18&amp;spm_id_from=pageDriver https://www.bilibili.com/video/BV1PU4y1s7Bs?p=24&amp;spm_id_from=pageDriver www.baidu.com通过 DNS解析得到目标ip地址 61.135.169.121 61.135.169.121和第一条255.255.255.0进行 按位与运算的到的61.135.169.0和192.168.150.0结果不一样，所以该条目被淘汰。 第二条目不用管（好像这个条目有问题），来到第三条，按照步骤2按位与运算，得到结果0.0.0.0，和Destination结果一样。则此时的Gateway起作用。 数据给到下一跳网关，也就是192.168.150.2，如果获得的下一跳网关Gateway是 0.0.0.0的话，那么说明在同一个局域网直接发数据就好了，不用跳了。 数据链路层封装成帧透明传输差错检测ARP协议 网卡的IP 192.168.150.1 和at后面对应的 网卡mac地址。 网卡pc1到pc5的过程网络数据里层存放目标IP地址，外层有下一跳的mac地址。 但是mac地址是怎么来的呢? 就是通过 arp协议, pc1发到pc2路由器,带的数据是1，mac先定义成FFFFFF pc2接受到后，回传给pc1自己的mac地址，接着上面的传输层步骤4就有了下一跳的mac地址了。 物理层: 铜线介质类 数据链路层 ： 相邻两台机器间的连接，把数据报以帧的形式发送, 以太网协议 https://www.bilibili.com/video/BV1pA411M7Ai?p=137&amp;spm_id_from=pageDriver https://www.bilibili.com/video/BV1PU4y1s7Bs?from=search&amp;seid=16016904944562540448 https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html https://hpbn.co/brief-history-of-http/ https://www.w3.org/Protocols/History.html https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}],"tags":[],"keywords":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}]},{"title":"HexoConfigure","slug":"HexoConfigure","date":"2017-08-01T06:03:52.000Z","updated":"2021-08-20T02:51:32.455Z","comments":true,"path":"2017/08/01/HexoConfigure/","link":"","permalink":"http://noteforme.github.io.com/2017/08/01/HexoConfigure/","excerpt":"","text":"基本配置​ 官方文档:https://hexo.io/zh-cn/docs/index.html 下载 Node.js ) Git 下载的是 node-v6.11.3-x64.msi ，一路安装下去自动配置好了环境变量 输入 node -v 测试 npm npm install -g hexo-cli 注意： 安装Node.js最佳方式使用nvm，使用master分支不起作用,需要github推荐的分支 接着安装node.js 搭建好hexo后，由于他是本地生成的，那么就要考虑同步的问题了，目前解决在github建一个分支 hexo，然后把本地资源用git分支管理 安装 npm install hexo 安装出问题 更换镜像源 https://www.lemonneko.cn/win10%E6%90%AD%E5%BB%BAhexo%E5%8F%8A%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/ 上传文件到分支 // git初始化 git init // 添加仓库地址 git remote add origin https://github.com/用户名/仓库名.git // 新建分支并切换到新建的分支 git checkout -b 分支名 // 添加所有本地文件到git git add . // git提交 git commit -m &quot;&quot; // 文件推送到hexo分支 git push origin hexo 其他设备安装好环境(支持跨平台)，先clone hexo分支到本地 git clone -b hexo git@github.com:noteforme/noteforme.github.io.git // 安装hexo , 下不下来就用privoxy npm install hexo // 注意这里不需要hexo初始化：hexo init；否则之前的hexo配置参数会重置 // 安装依赖库 npm install // 安装部署相关配置 npm install hexo-deployer-git //如果出错执行下面的 npm install -g hexo-cli 这要就完成同步了(上面的流程还不是很规范，不过执行上面几个命令基本都能解决) 如果有这些不用管了 npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@^1.0.0 (node_modules\\chokidar\\node_modules\\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for &#x66;&#115;&#101;&#x76;&#x65;&#110;&#x74;&#115;&#64;&#49;&#x2e;&#49;&#46;&#x32;: wanted {“os”:”darwin”,”arch”:”any”} (current: {“os”:”win32”,”arch”:”x64” 问题:在ubuntu上，执行hexo d部署后每次都要输入github用户名和密码，在这里也找到了答案，就是根目录下的 _config.yml文件没有配置成ssh,之前是这样的 repository:https://github.com/noteforme/noteforme.github.io.git Deployment Docs: https://hexo.io/docs/deployment.html deploy: type: git repository: &#103;&#x69;&#116;&#x40;&#103;&#x69;&#116;&#104;&#x75;&#98;&#x2e;&#99;&#x6f;&#109;:noteforme/noteforme.github.io.git branch: master 参考：http://www.jianshu.com/p/6fb0b287f950 博客嵌入图片我们生成的路径是以public目录的路径为相对路径，所以要看public下面有没有生成图片 所以我的写法是 “ ” 别忘了2017前面的 “/”，否则文章页面不显示图片 参考： http://www.jianshu.com/p/950f8f13a36c 之前用上面的方式比较麻烦，有时候还有问题 ![描述](BLOG_SYNC_HTTPS/img_generate20170717152203.png) 竟然也是可以的，可以看下效果 奇怪了 这里又不显示了,明明 AndroidStudioTool这篇博客可以显示的,看来还得摸索 https认证:Cloudflare免费的ssl创建账户注册 https://www.cloudflare.com/a/sign-up 登录后输入域名,点击扫描 如图 一直continue，到了Selet a Cloudflare Plan 选择Free Website 解析域名的地方，修改域名服务器,我这里是在godaddy修改，然后continue 点击Preview on your site instantly－&gt; 点击Overview(显示Ａctive即可)－&gt;点击Crypto(选择Ｆlexible) 参考：http://www.jianshu.com/p/92b6d4a6ecd5 mac install hero1sudo npm install -g hero-cli theme didn’t commit to GitHub ,so you could clone theme hexo next主题添加分类修改主题 git clone git@github.com:ppoffice/hexo-theme-icarus.git themes/icarus里面都有介绍，主要石npm安装不了插件就需要这篇文章 的polipo工具，最有名的Privoxy反而不起作用 分类只要在 博客头部加 categories: “BLOG” 就会自动展示分类了，如果觉得每次添加麻烦的话，修改scaffolds/post.md 模板 title: HexoConfigure date: 1501567432000 tags: categories: comments: true 然后hexo n “yourblog”,就会有这些了，接下里就是在首页分类进行关联了 生成 分类（默认已有分类） 1hexo new page &quot;categories&quot; 新建page: $ hexo new page “categories” ，在 hexo &gt; source 文件夹中会出现一个categories文件夹 打开categories文件夹中的index.md页面，在头部添加 – type: “categories” （为了点击的时候链接生效） 在hexo &gt; theme &gt; next &gt; _config.yml 中修改menu下的categorues,去掉前面井号注释。 然后就可以看到分类页面了 参考：https://lannly.github.io/2016/11/16/Hexo-Next-%E6%B7%BB%E5%8A%A0%E8%8F%9C%E5%8D%95%E5%88%86%E7%B1%BB/ next 添加头像新建uploads文件夹，放入图片 找到themes/next 下的 -config.yml,修改如下图所示 1234# Sidebar Avatar# in theme directory(source/images): /images/avatar.jpg# in site directory(source/uploads): /uploads/avatar.jpg avatar: /uploads/author.png https://github.com/iissnan/hexo-theme-next/wiki/%E8%AE%BE%E7%BD%AE%E4%BE%A7%E8%BE%B9%E6%A0%8F%E5%A4%B4%E5%83%8F Mac Hexo安装后 command not found: hexo的解决方法$ npm root -g获取node_modules地址/Users/guo/.npm-global/lib/node_modules 1$export PATH=$PATH:/Users/m/.npm-global/lib/node_modules/hexo-cli/bin 也可以去修改/.zshrc 或者/.bashrc，在里面添加上述命令，然后 source ~/.zshrc","categories":[],"tags":[{"name":"BLOG","slug":"BLOG","permalink":"http://noteforme.github.io.com/tags/BLOG/"}],"keywords":[]},{"title":"ContentProvider","slug":"ContentProvider","date":"2017-07-31T01:35:40.000Z","updated":"2021-08-19T11:11:43.768Z","comments":true,"path":"2017/07/31/ContentProvider/","link":"","permalink":"http://noteforme.github.io.com/2017/07/31/ContentProvider/","excerpt":"","text":"https://developer.android.com/guide/topics/providers/content-provider-basics.html?hl=zh-cn 还需要完善单条记录 查询 修改等一、新建数据库 https://github.com/BlogForMe/AndroidProject/blob/master/ContentProvider/mylibrary/src/main/java/com/hyhy/mylibrary/ArticleDbHelper.java二、创建ContentProvider public class ArticlesProvider extends ContentProvider &#123; public static final String AUTHORITY = &quot;com.hyhy.contenttest.db.ArticlesProvider&quot;; //标识特定ContentProvider,使用包名使他唯一 private static final Uri NOTIFY_URI = Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/&quot; + TABLE_NAME); private static final UriMatcher uriMatcher; /** * Match Code */ public static final int ARTICLE_ALL = 0; public static final int ARTICLE_SINGLE = 1; /** * MIME */ public static final String CONTENT_TYPE = &quot;vnd.android.cursor.dir/vnd.com.hyhy.article&quot;; private static final String CONTENT_ITEM_TYPE = &quot;vnd.android.cursor.item/vnd.com.hyhy.article&quot;; static &#123; uriMatcher = new UriMatcher(UriMatcher.NO_MATCH); uriMatcher.addURI(AUTHORITY, TABLE_NAME, ARTICLE_ALL); //匹配记录集合 uriMatcher.addURI(AUTHORITY, TABLE_NAME + &quot;/#&quot;, ARTICLE_SINGLE); //匹配单条记录 &#125; private ArticleDbHelper helper; private SQLiteDatabase db; private ContentResolver resolver; @Override public boolean onCreate() &#123; resolver = getContext().getContentResolver(); helper = new ArticleDbHelper(getContext()); return false; &#125; @Nullable @Override public String getType(@NonNull Uri uri) &#123; int match = uriMatcher.match(uri); switch (match) &#123; case ARTICLE_ALL: return CONTENT_TYPE; case ARTICLE_SINGLE: return CONTENT_ITEM_TYPE; default: throw new IllegalArgumentException(&quot;Unknown URI: &quot; + uri); &#125; &#125; @Override public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder) &#123; db = helper.getReadableDatabase(); int match = uriMatcher.match(uri); switch (match) &#123; case ARTICLE_ALL: //doesn&#39;t need any code in my provider. break; case ARTICLE_SINGLE: // long _id = ContentUris.parseId() break; default: throw new IllegalArgumentException(&quot;Unknown URI: &quot; + uri); &#125; return db.query(TABLE_NAME, projection, selection, selectionArgs, null, null, sortOrder); &#125; @Nullable @Override public Uri insert(@NonNull Uri uri, @Nullable ContentValues values) &#123; int match = uriMatcher.match(uri); if (match != ARTICLE_ALL) &#123; throw new IllegalArgumentException(&quot;Wrong URI:&quot; + uri); &#125; db = helper.getWritableDatabase(); long rowId = db.insert(TABLE_NAME, null, values); if (rowId &gt; 0) &#123; notifyDataChanged(); return ContentUris.withAppendedId(uri, rowId); &#125; return null; &#125; @Override public int delete(@NonNull Uri uri, @Nullable String selection, @Nullable String[] selectionArgs) &#123; return 0; &#125; @Override public int update(@NonNull Uri uri, @Nullable ContentValues values, @Nullable String selection, @Nullable String[] selectionArgs) &#123; return 0; &#125; private void notifyDataChanged() &#123; getContext().getContentResolver().notifyChange(NOTIFY_URI, null); &#125; &#125; 配置Androidmanifest.xml &lt;provider android:name=&quot;.db.ArticlesProvider&quot; android:authorities=&quot;com.hyhy.contenttest.db.ArticlesProvider&quot; android:exported=&quot;true&quot; /&gt; 三、操作ContentProvider public class MainActivity extends AppCompatActivity &#123; private static final String AUTHORITY = &quot;com.hyhy.contenttest.db.ArticlesProvider&quot;; private static final Uri ARTICLE_ALL_URI = Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/&quot; + TABLE_NAME); private ContentResolver resolver; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); resolver = getContentResolver(); &#125; public void addDb(View v) &#123; ContentValues values; for (int i = 1; i &lt; 5; i++) &#123; values = new ContentValues(); values.put(ArticleReaderContract.Articles.COLUMN_NAME_ENTRY_ID, i); values.put(ArticleReaderContract.Articles.COLUMN_NAME_TITLE, &quot;heh &quot; + i); values.put(ArticleReaderContract.Articles.COLUMN_NAME_SUBTITLE, &quot;describe &quot; + i); resolver.insert(ARTICLE_ALL_URI, values); &#125; Toast.makeText(MainActivity.this, &quot;插入成功&quot;, Toast.LENGTH_SHORT).show(); &#125; public void btQueryAll(View v) &#123; Cursor c = resolver.query(ARTICLE_ALL_URI, null, null, null, null); while (c.moveToNext()) &#123; System.out.println(c.getString(c.getColumnIndex(COLUMN_NAME_TITLE))); &#125; &#125; &#125; 参考 ： http://blog.csdn.net/liuhe688/article/details/7050868 这一块还不熟悉","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"EclipseIdeaWeb","slug":"EclipseIdeaWeb","date":"2017-07-23T11:16:39.000Z","updated":"2021-08-19T11:11:43.802Z","comments":true,"path":"2017/07/23/EclipseIdeaWeb/","link":"","permalink":"http://noteforme.github.io.com/2017/07/23/EclipseIdeaWeb/","excerpt":"","text":"Eclipse导入web项目1、src并入包导入项目后可以看这种情况 ​ 处理方法：VideoServer右键－&gt;Build Path-&gt;Configure Build Path-&gt;Source-&gt;Brower-&gt;src-&gt;Apply;接着就可以看到 ,点击Yes后，项目目录正常了，但是发现这是一个Ｊava项目,没有javax.相关的包 ２、Java项目转Ｗeb项目VideoServer右键－&gt;Properties-&gt;Project Facets 在这里勾选 Dynamic Web Module:下面会有个提示 Ｄynamic Web Module 3.0 Requires Java 1.6 or newer. 勾选 Ｊava 勾选 ＪavaScript点击Apply Idea安装http://justcode.ikeepstudying.com/2017/12/%E6%9B%B4%E6%96%B0-intellij-idea-2017-3-1-%E6%B3%A8%E5%86%8C%E7%A0%81-%EF%BC%88%E4%BA%B2%E6%B5%8B%E5%8F%AF%E7%94%A8%EF%BC%89/ http://idea.lanyus.com/ https://www.jetbrains.com/help/idea/developing-a-java-ee-application.html","categories":[{"name":"TOOL","slug":"TOOL","permalink":"http://noteforme.github.io.com/categories/TOOL/"}],"tags":[],"keywords":[{"name":"TOOL","slug":"TOOL","permalink":"http://noteforme.github.io.com/categories/TOOL/"}]},{"title":"String","slug":"String","date":"2017-07-21T06:54:53.000Z","updated":"2021-08-19T11:11:44.238Z","comments":true,"path":"2017/07/21/String/","link":"","permalink":"http://noteforme.github.io.com/2017/07/21/String/","excerpt":"","text":"字符串连接有两种方式，一种时 “ + “,另一种是 StringBuilder方式 命令行运行java 平常用开发工具习惯了，都忘了怎么用命令行运行，特此记录下 新建 Concatenation.java文件，cmd到该目录下，写入代码 public class Concatenation&#123; public static void main(String[] args)&#123; String mango = &quot;mango&quot;; String s = &quot;abc&quot; + mango + &quot;def&quot; + 47; System.out.print(s); &#125; &#125; 生成 Concatenation.calss 文件 D:\\DemoExo&gt;javac Concatenation.java 运行Concatenation.class文件,后面是运行结果 D:\\DemoExo&gt;java Concatenation abcmangodef47 String字符串连接方式回到主题 查看JDK文档（不知道在哪），String 类中每一个看起来会修改String值的方法，实际上都是创建了一个全新的String对象,以包含修改后的字符串内容. public class Immutable&#123; public static String upcase(String s)&#123; return s.toUpperCase(); &#125; public static void println(String q)&#123; System.out.println(q); &#125; public static void main(String[] args)&#123; String q = &quot;howdy&quot;; print(q); // howdy String qq= upcase(q); print(qq); //HOWDY print(q); //howdy &#125; &#125; 运行结果：howdyHOWDYhowdy当把q传给upcase()时，实际传递的是引用的拷贝 编译器运行过程反编译Concatenation,生成JVM字节码 javap -c Concatenation.class 字节码是这样的 C:\\DemoExo&gt;javap -c Concatenation.class Compiled from &quot;Concatenation.java&quot; public class Concatenation &#123; public Concatenation(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: ldc #2 // String mango 2: astore_1 3: new #3 // class java/lang/StringBuilder 6: dup 7: invokespecial #4 // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V 10: ldc #5 // String abc 12: invokevirtual #6 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 15: aload_1 16: invokevirtual #6 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 19: ldc #7 // String def 21: invokevirtual #6 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 24: bipush 47 26: invokevirtual #8 // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder; 29: invokevirtual #9 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 32: astore_2 33: getstatic #10 // Field java/lang/System.out:Ljava/io/PrintStream; 36: aload_2 37: invokevirtual #11 // Method java/io/PrintStream.print:(Ljava/lang/String;)V 40: return &#125; 可以看到，编译器创建了一个StringBuilder对象,用以构造最终的String，并四次调用了append(),最后使用命令astore_2生成 s对象。这样来看，使用 “+” 连接符，是不会影响性能的咯，接着往下 “+”连接符 和 StringBuilder对比运行javap -c WhitherStringBuilder.class 看到两个方法对象的字节码，先看前半部分implicit() public class WhitherStringBuilder &#123; public WhitherStringBuilder(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return public java.lang.String implicit(java.lang.String[]); Code: 0: ldc #2 // String 2: astore_2 3: iconst_0 4: istore_3 5: iload_3 6: aload_1 7: arraylength 8: if_icmpge 38 11: new #3 // class java/lang/StringBuilder 14: dup 15: invokespecial #4 // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V 18: aload_2 19: invokevirtual #5 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 22: aload_1 23: iload_3 24: aaload 25: invokevirtual #5 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 28: invokevirtual #6 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 31: astore_2 32: iinc 3, 1 35: goto 5 38: aload_2 39: areturn 第8到35行，在for循环体内，每一次循环就创建了一个StringBuilder对象，接着看看explicit() public java.lang.String explicit(java.lang.String[]); Code: 0: new #3 // class java/lang/StringBuilder 3: dup 4: invokespecial #4 // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V 7: astore_2 8: iconst_0 9: istore_3 10: iload_3 11: aload_1 12: arraylength 13: if_icmpge 30 16: aload_2 17: aload_1 18: iload_3 19: aaload 20: invokevirtual #5 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 23: pop 24: iinc 3, 1 27: goto 10 30: aload_2 31: invokevirtual #6 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 第13到27行在for循环体内，StringBuilder只会生成一个对象 总结： 由此来看，如果字符串操作比较简单，就可以用“+”连接让编译器处理字符串如果在循环中，那么自己创建一个StringBuilder对象 参考：摘自ThinkInJava4 P286 避免创建不必要的对象创建 String对象 最好能重用对象而不是每次需要的时候就创建一个功能相同的新对象，重用方式即快速又流行。如果对象是不可变的，它始终可以被重用。 极端的反面例子 ｀Ｓtring s = new String(“stringette”); //DON’T DO THIS ! ｀该语句每次被执行的时候都创建一个新的String实例，传递给String构造器的参数”stringette’本身就是一个String实例，如果这种用法在一个循环中，或者在一个频繁调用的方法中，就会创建出成千上万不必要的String 实例。 改进后的版本如下所示 1String s = &quot;stringette&#x27;; 这个版本只用了一个String实例，而且它可以保证，对于所有的同一台虚拟机中运行的代码，只要包含相同的字符串字面常量，该对象就会被重用. 返回数据处理对于同时提供静态工厂方法和构造器的不可变类，通常可以使用静态工厂方法，而不是构造器以避免创建不必要的对象，例如，静态工厂方法Boolean.valueof(String)由于构造器Boolean(String),构造器每次调用的时候都会创建一个新的对象，而静态工厂方法则不会 我们平常解析回来后非String类型的数据，需要转换成String对象 看到这里后就需要使用String.valueof(String) 123456789101112/** * Returns the string representation of the &#123;@code Object&#125; argument. * * @param obj an &#123;@code Object&#125;. * @return if the argument is &#123;@code null&#125;, then a string equal to * &#123;@code &quot;null&quot;&#125;; otherwise, the value of * &#123;@code obj.toString()&#125; is returned. * @see java.lang.Object#toString() */ public static String valueOf(Object obj) &#123; return (obj == null) ? &quot;null&quot; : obj.toString(); &#125; 从源码中看到对形参 做了 null判断，所以用这种方式页不用担心闪退的情况了参考 Effective Java page17 java 8 获取对象数据 12345678910111213private WchatMobile decodeMobile(String encryptedData, String iv, String unionid) &#123; WchatMiniAppSession miniAppSession = getWchatMiniAppSession(unionid); String sessionKey = Optional.ofNullable(miniAppSession) .orElseThrow(() -&gt; new ServiceExecutionException(&quot;用户小程序登录信息为空&quot;)) .getSessionKey(); return Optional.ofNullable(wchatMiniAppService) .map(as -&gt; as.getWxMaService()) .map(s -&gt; s.getUserService()) .map(se -&gt; se.getPhoneNoInfo(sessionKey, encryptedData, iv)) .map(num -&gt; WchatMobile.from(num)) .orElse(null); &#125; https://time.geekbang.org/column/article/209343 亨元模式Integer a = 1; Integer b = 2; Integer c = 3; Integer d = 3; Integer e = 321; Integer f = 321; Long g = 3L; System.out.println(c==d); System.out.println(e==f); System.out.println(c==(a+b)); System.out.println(c.equals(a+b)); System.out.println(g ==(a+b)); System.out.println(g.equals(a+b));","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}],"tags":[],"keywords":[{"name":"JAVA","slug":"JAVA","permalink":"http://noteforme.github.io.com/categories/JAVA/"}]},{"title":"Glide","slug":"Glide","date":"2017-07-21T06:03:20.000Z","updated":"2021-08-19T11:11:43.897Z","comments":true,"path":"2017/07/21/Glide/","link":"","permalink":"http://noteforme.github.io.com/2017/07/21/Glide/","excerpt":"","text":"Glide加载流程\\ LruCache LinkedHashMap参数含义initialCapacity : 最大容量 loadFactor : 负载因子 accessOrder : 排序方式, true 按照访问顺序排序， false 按照插入顺序排序 访问顺序排序accessOrder : true 1234567891011121314LinkedHashMap&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;(0, 0.75f, true);map.put(&quot;a&quot;, &quot;A&quot;);map.put(&quot;b&quot;, &quot;B&quot;);map.put(&quot;c&quot;, &quot;C&quot;);map.put(&quot;d&quot;, &quot;D&quot;);map.put(&quot;e&quot;, &quot;E&quot;);map.put(&quot;f&quot;, &quot;F&quot;);map.get(&quot;a&quot;);map.put(&quot;n&quot;,&quot;N&quot;);for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123; Log.d(&quot;LruCacheTest&quot;, &quot;testLinkedHashMap : &quot;+ entry.getKey()+&quot; : &quot; + entry.getValue());&#125; 结果 D LruCacheTest: testLinkedHashMap : b : B D LruCacheTest: testLinkedHashMap : c : C D LruCacheTest: testLinkedHashMap : d : D D LruCacheTest: testLinkedHashMap : e : E D LruCacheTest: testLinkedHashMap : f : F D LruCacheTest: testLinkedHashMap : a : A D LruCacheTest: testLinkedHashMap : n : N 可以看到 先访问a ,在插入n,把最新最近使用和访问的 A N,放到链表后面 1LinkedHashMap&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;(100, 0.75f, true); D LruCacheTest: testLinkedHashMap : a : AD LruCacheTest: testLinkedHashMap : b : BD LruCacheTest: testLinkedHashMap : c : CD LruCacheTest: testLinkedHashMap : d : DD LruCacheTest: testLinkedHashMap : e : ED LruCacheTest: testLinkedHashMap : f : FD LruCacheTest: testLinkedHashMap : n : N 感知生命周期 https://www.bilibili.com/video/BV1Qy4y1s7Gh?p=15&amp;spm_id_from=pageDriver https://github.com/bumptech/glide https://muyangmin.github.io/glide-docs-cn/doc/generatedapi.html https://juejin.im/post/6844904136266219534 https://www.jianshu.com/p/48d9e4d5d75d","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"Gson","slug":"Gson","date":"2017-07-21T01:12:15.000Z","updated":"2021-08-19T11:11:43.906Z","comments":true,"path":"2017/07/21/Gson/","link":"","permalink":"http://noteforme.github.io.com/2017/07/21/Gson/","excerpt":"","text":"$Gson$Types理解 官方教程 https://github.com/google/gson/blob/master/UserGuide.md 源码分析http://www.jianshu.com/p/89c314ae8c0b Gson转map Gson可以直接把json转为map,但是在转成map时，默认將int long型的数字,转换成doublel类型 12String sms = &quot;&#123;\\&quot;Code\\&quot;:200,\\&quot;Data\\&quot;:&#123;\\&quot;Code\\&quot;:\\&quot;\\&quot;&#125;,\\&quot;Message\\&quot;:\\&quot;发送成功\\&quot;&#125;&quot;;Map&lt;String, Object&gt; map = new Gson().fromJson(sms, HashMap.class); 这里装成map后，Code值尾 200.0 ,解析方法 123456789101112131415Gson gson = new GsonBuilder() .registerTypeAdapter(new TypeToken&lt;TreeMap&lt;String, Object&gt;&gt;() &#123; &#125;.getType(), new JsonDeserializer&lt;TreeMap&lt;String, Object&gt;&gt;() &#123; @Override public TreeMap&lt;String, Object&gt; deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException &#123; TreeMap&lt;String, Object&gt; treeMap = new TreeMap&lt;&gt;(); JsonObject jsonObject = json.getAsJsonObject(); Set&lt;Map.Entry&lt;String, JsonElement&gt;&gt; entrySet = jsonObject.entrySet(); for (Map.Entry&lt;String, JsonElement&gt; entry : entrySet) &#123; treeMap.put(entry.getKey(), entry.getValue()); &#125; return treeMap; &#125; &#125;).create(); 参考 map to json(生成json数据) HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;key&quot;, &quot;real_name&quot;); map.put(&quot;value&quot;, userName); list.add(map); map = new HashMap&lt;&gt;(); map.put(&quot;key&quot;, &quot;mobile_phone&quot;); map.put(&quot;value&quot;, userPhone); map.put(&quot;hidden&quot;, false); list.add(map); userInfo.data = new Gson().toJson(list); kotlin json to object 12val type = object : TypeToken&lt;BaseCount&lt;List&lt;Site&gt;&gt;&gt;() &#123;&#125;.typevar response = gson.fromJson&lt;BaseCount&lt;List&lt;Site&gt;&gt;&gt;(json, type) https://ask.helplib.com/java/post_498433 java parse1234567891011121314151617181920212223242526272829303132333435 public static List&lt;RecipeBean&gt; analysisChild(String receps) throws JSONException &#123; List&lt;RecipeBean&gt; list = new ArrayList&lt;&gt;();// JSONObject jsonObject = new JSONObject(); JSONArray jsonArray = new JSONArray(receps); for (int i = 0; i &lt; jsonArray.length(); i++) &#123; JSONObject object = jsonArray.getJSONObject(i); RecipeBean mPatient = new RecipeBean(TYPE_ITEM); if (object.has(&quot;drug_name&quot;))&#123; mPatient.setDrug_name(object.getString(&quot;drug_name&quot;)); &#125; if (object.has(&quot;drug_num&quot;))&#123; mPatient.setDrug_num(object.getString(&quot;drug_num&quot;)); &#125; if (object.has(&quot;frequency&quot;))&#123; mPatient.setFrequency(object.getString(&quot;frequency&quot;)); &#125; if (object.has(&quot;num&quot;))&#123; mPatient.setNum(object.getString(&quot;num&quot;)); &#125; if (object.has(&quot;drug_num&quot;))&#123; mPatient.setDrug_num(object.getString(&quot;drug_num&quot;)); &#125; if (object.has(&quot;pharmacy_type&quot;))&#123; mPatient.setPharmacy_type(object.getString(&quot;pharmacy_type&quot;)); &#125; if (object.has(&quot;medicine_num&quot;))&#123; mPatient.setMedicine_num(object.getString(&quot;medicine_num&quot;)); &#125; if (object.has(&quot;medicine_unit&quot;))&#123; mPatient.setMedicine_unit(object.getString(&quot;medicine_unit&quot;)); &#125; list.add(mPatient); &#125; return list; &#125;","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"linux","slug":"linux","date":"2017-07-19T07:03:07.000Z","updated":"2021-09-11T03:19:46.594Z","comments":true,"path":"2017/07/19/linux/","link":"","permalink":"http://noteforme.github.io.com/2017/07/19/linux/","excerpt":"","text":"Linux使用 find ： $ find . -name ‘my*’ 搜索当前目录（含子目录，以下同）中，所有文件名以my开头的文件。 http://www.ruanyifeng.com/blog/2009/10/5_ways_to_search_for_files_using_the_terminal.html ubuntu wifi热点http://blog.csdn.net/sunmc1204953974/article/details/45740853 删除build文件find . -name &quot;build&quot; | xargs rm -rf","categories":[{"name":"LINUX","slug":"LINUX","permalink":"http://noteforme.github.io.com/categories/LINUX/"}],"tags":[],"keywords":[{"name":"LINUX","slug":"LINUX","permalink":"http://noteforme.github.io.com/categories/LINUX/"}]},{"title":"ubuntu-mariaDb","slug":"ubuntu-mariaDb","date":"2017-07-18T07:31:21.000Z","updated":"2021-08-19T11:11:44.318Z","comments":true,"path":"2017/07/18/ubuntu-mariaDb/","link":"","permalink":"http://noteforme.github.io.com/2017/07/18/ubuntu-mariaDb/","excerpt":"","text":"数据库常用用法W3C教程 : https://www.w3cschool.cn/mariadb/1、创建/删除 数据库：CREATE DATABASE 数据库名 / drop database 数据库名;2、建表/删除表 ： h_id为主键 /DROP TABLE table_name ; MariaDB [person]&gt; CREATE TABLE home_recycler( h_id INT NOT NULL AUTO_INCREMENT, h_title VARCHAR(100) NOT NULL, h_describe VARCHAR(100) NOT NULL, h_imgurl VARCHAR(40) NOT NULL, PRIMARY KEY(h_id) ); Query OK, 0 rows affected (0.29 sec) 3、 插入数据 MariaDB [person]&gt; INSERT INTO home_recycler(h_title,h_describable,h_imgurl) VALUES(&#39;1&#39;,&#39;D&#39;,&#39;m&#39;); 删除数据,删除全部表的数据就不需要条件了 DELETE FROM home_recycler WHERE product_id=133; 注意：插入数据乱码： 在命令行也是插入数据也是中文乱码，解决方法 https://my.oschina.net/u/1011130/blog/864540 重启数据库：http://www.cnblogs.com/anseey/archive/2013/04/28/3049785.html 、 Ubuntu数据库安装 更新系统 $ sudo apt update $ sudo apt upgrade 安装MariaDB： $ sudo apt install mariadb-server 登陆MariaDB命令行 $ sudo mysql -u root -p 参考：http://blog.topspeedsnail.com/archives/6323 https://linux.cn/article-6210-1.html 、 数据库操作 登录 ：mysql -u root -p 数据库导出 导入在网上查了下，导出命令 千遍一律 都是这样的 mysqldump -u username -p dbname &gt; filename.sql ，按照这个操作，语法错误， 在我的惯性思维中，觉得是命令行登录数据库后再导出，其实是不需要登录的，首先Win + r 输入cmd,进入命令行 输入 mysqldump，如果看到下面这个 C:\\Users\\Administrator&gt;mysqldump&#39; mysqldump&#39; 不是内部或外部命令，也不是可运行的程序或批处理文件。 说明需要配置环境变量了，类似我的就需要 D:\\install\\Mariadb\\bin；加入path路径后面 然后输入mysqldump ， C:\\Users\\Administrator&gt;mysqldump Usage: mysqldump [OPTIONS] database [tables] OR mysqldump [OPTIONS] --databases [OPTIONS] DB1 [DB2 DB3...] OR mysqldump [OPTIONS] --all-databases [OPTIONS] For more options, use mysqldump --help 然后主题来了 mysqldump -u root -p person &gt; &quot;C:\\mysql.sql&quot; root是用户名 ， person是数据库，&gt;后面是存放位置 ，标准格式是这样的 mysqldump -u username -p dbname &gt; filename.sql 然后导入：mysql -u username -p dbname &lt; filename.sql 但是我在vps导入后数据库为空 参考： https://www.youtube.com/watch?v=2hsOk0XcYC4 https://john-dugan.com/dump-and-restore-mysql-databases-in-windows/ http://wqss.2008.blog.163.com/blog/static/912428082010102092548409/ MariaDB 配置远程访问 有时候在家也要整整这些玩意儿，代码可以用github同步，每次数据库数据还倒腾来倒腾去的 ，如果在vps直接访问就最好了 找到默认配置文件 : 目的是要找到 my.cnf ， 可以先 “ cd /“ ，到根目录下 ，输入下面命令 root@TrustingDevoted-VM:/# find -name &quot;my.cnf&quot; ./etc/mysql/my.cnf 2.修改my.cnf， 找到【mysqld】 ” bind-address = 127.0.0.1“ ，前面加个” # “就可以了， 教程说 “skip-networking”前面也需要修改，但是我这里没有就作罢了 3 授予权限 ，这里授予的是183.129.133.0/24段的ip GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;183.129.133.%&#39; IDENTIFIED BY &#39;123456&#39; WITH GRANT OPTION; 4 给远程主机给予连接用户，查询已经存在的远程用户 SELECT User, Host FROM mysql.user WHERE Host &lt;&gt; &#39;localhost&#39;; | User | Host | +-----------+--------------------+ | user_name | % | | root | 127.0.0.1 | | root | 183.129.133.% | | root | ::1 | | root | trustingdevoted-vm | +-----------+--------------------+ “user_name” 是给的所有用户授予的 ,”root 暂时不知道怎么删除， | 183.129.133.%”是刚才添加的，然后 sudo reboot 重启下 5 本地远程登录 mysql -h66.168.1.11 -uroot -p123456 注意中间没有空格, -h 后面yourVpsIp ,-u后面 用户名， -p 后面密码 参考：https://mariadb.com/kb/zh-cn/configuring-mariadb-for-remote-client-access/ http://blog.csdn.net/ithomer/article/details/6976148 http://www.jianshu.com/p/9c175e9293e2 安装Navicathttps://www.jianshu.com/p/42a33b0dda9c","categories":[{"name":"LINUX","slug":"LINUX","permalink":"http://noteforme.github.io.com/categories/LINUX/"}],"tags":[],"keywords":[{"name":"LINUX","slug":"LINUX","permalink":"http://noteforme.github.io.com/categories/LINUX/"}]},{"title":"ubuntu_vr","slug":"ubuntu_vr","date":"2017-07-18T06:34:53.000Z","updated":"2021-08-19T11:11:44.319Z","comments":true,"path":"2017/07/18/ubuntu_vr/","link":"","permalink":"http://noteforme.github.io.com/2017/07/18/ubuntu_vr/","excerpt":"","text":"自从shadowsocks出来，我们的上网问题算是解决了，通过google查资料确实更便利 shadowsocks安装 对于新手 作者建议安装在ubuntu上，那就用他开始吧 安装软件 sudo apt-get install python-pip pip install shadowsocks 然而我遇到了这样的问题 Command “python setup.py egg_info” failed with error code 1 in /tmp/pip-build-Mlx8an/shadowsocks/You are using pip version 8.1.1, however version 9.0.1 is available.You should consider upgrading via the ‘pip install –upgrade pip’ command.接着按照他的指示来 pip install --upgrade pip 然而又出问题了，这次是这个 Could not import setuptools which is required to install from a source distribution.Please install setuptools. 这时候Google派上用场了，解决方案是 sudo pip install -U setuptools 参考：https://github.com/fredley/play-pi/issues/22 然后执行 pip install shadowsocks ，终于OK，Collecting shadowsocks Using cached shadowsocks-2.8.2.tar.gzInstalling collected packages: shadowsocks Running setup.py install for shadowsocks … doneSuccessfully installed shadowsocks-2.8.2 前台运行 软件安装好了，现在可以配置了，先在前台跑下 ssserver -p 8388 -k 123456 -m aes-256-cfb 然后手机或电脑同样配置看下代理是否有用，Ok的话，新建一个文件替代命令 vi /etc/shadowsocks.json &#123; &quot;server&quot;:&quot;my_server_ip&quot;, &quot;server_port&quot;:8388, &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;123456&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;: false &#125; 前台执行 : ssserver -c /etc/shadowsocks.json 后台执行:​​ ssserver -c /etc/shadowsocks.json -d start​ ssserver -c /etc/shadowsocks.json -d stop 接着就可以愉快的玩耍了 卸载shadowsocks 先停掉服务 sudo ssserver -d stop 然后 pip uninstall shadowsocks shadowsocks-libev安装ubuntu 17 12sudo apt updatesudo apt install shadowsocks-libev 如果是其他版本可以看下面 参考from :https://github.com/shadowsocks/shadowsocks-libev#install-from-repository 启动测试连接 和shadowsocks启动类似 ssserver 换成了 ss-server 启动测试 : ss-server -s 0.0.0.0 -p 8388 -k 123456 -m aes-256-cfb 没有 -d start可能会占用端口 配置文件启动To run in the foreground: ss-server -c /etc/shadowsocks-libev/config.json To run in the background: ｀nohup ss-server -c /etc/shadowsocks-libev/config.json｀ 停止运行: sudo ss-server -d stop simple-obfs(混淆工具)安装 BuildFor Unix-like systems, especially Debian-based systems, e.g. Ubuntu, Debian or Linux Mint, you can build the binary like this: Debian / Ubuntu 环境配置sudo apt-get install --no-install-recommends build-essential autoconf libtool libssl-dev libpcre3-dev libc-ares-dev libev-dev asciidoc xmlto automake 下载simple-obfs //Debian / Ubuntu ​ sudo apt-get install –no-install-recommends build-essential autoconf libtool libssl-dev libpcre3-dev libev-dev asciidoc xmlto automake ​ //CentOS / Fedora / RHEL ​ sudo yum install gcc autoconf libtool automake make zlib-devel openssl-devel asciidoc xmlto ​ // Arch ​ sudo pacman -Syu gcc autoconf libtool automake make zlib openssl asciidoc xmlto ​ //Alpine ​ apk add gcc autoconf make libtool automake zlib-devel openssl asciidoc xmlto libpcre32 libev-dev g++ linux-headers git clone https://github.com/shadowsocks/simple-obfs.git cd simple-obfs git submodule update --init --recursive ./autogen.sh ./configure &amp;&amp; make sudo make install ​ 注意: Question 问题1autoconf --version需要安装 sudo apt install autoconf 问题2 123456configure.ac:19: error: possibly undefined macro: AC_DISABLE_STATIC If this token and others are legitimate, please use m4_pattern_allow. See the Autoconf documentation.configure.ac:20: error: possibly undefined macro: AC_DISABLE_SHAREDconfigure.ac:44: error: possibly undefined macro: AC_PROG_LIBTOOLautoreconf: /usr/bin/autoconf failed with exit status: 1 sudo apt-get install libtool 问题3sudo apt-get install automakehttp://ask.xmodulo.com/fix-failed-to-run-aclocal.html 混淆 server端: ss-server -c /etc/shadowsocks-libev/config.json --plugin obfs-server --plugin-opts &quot;obfs=http&quot; clinet 端:ss-local -c config.json --plugin obfs-local --plugin-opts &quot;obfs=http;obfs-host=www.baidu.com&quot; 也可以都放在配置文件中 12345678910&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;server_port&quot;:your_server_port, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;your_password&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;your_encryption_method&quot;, &quot;plugin&quot;:&quot;/usr/local/bin/obfs-server --obfs http&quot;&#125; 那么服务端直接运行``ss-server -c /etc/shadowsocks-libev/config.json `就可以了 后台运行就是前面的测试连接 nohup命令 from:https://teddysun.com/511.html 参数: 12插件：obfs-local插件选项：obfs=http;obfs-host=www.baidu.com 客户端连接 client也按照 simple-obfs 服务端安装方式安装 连接命令 ss-local -c /etc/shadowsocks-libev/config.json --plugin obfs-local --plugin-opts &quot;obfs=http;obfs-host=www.biadu.com&quot; 参考:https://github.com/shadowsocks/simple-obfshttps://blog.phpgao.com/shadowsocks_on_linux.htmlhttps://softwaredownload.gitbooks.io/openwrt-fanqiang/content/ebook/03.2.html 配置ubuntu开机启动 home下 新建 run_server.sh输入 123#!/bin/bashcd /home/jon/shadowsocksr/shadowsockspython local.py -c /etc/shadowsocks.json 修改脚本权限一定要让脚本具备可执行权限，可以执行如下指令：$ sudo chmod 755 run_server.sh 将脚本放置在启动路径下将run_server.sh移动到/etc/init.d路径下，可以直接拷贝，也可以链接过去$ sudo cp run_server.sh /etc/init.d/ 将脚本添加到启动脚本。执行如下指令，在这里90表明一个优先级，越高表示执行的越晚 12$ cd /etc/init.d/$ sudo update-rc.d run_server.sh defaults 90 如何移除该脚本很简单，执行如下指令： sudo update-rc.d -f run_server.sh remove http://jackqdyulei.github.io/2016/03/06/linux-auto-script/ 设置系统全局代理 https://blog.csdn.net/u012810317/article/details/52139361 terminal代理 12export http_proxy=http://127.0.0.1:8118export https_proxy=http://127.0.0.1:8118 或者 git config –global http.proxy “localhost:1080” git config –global http.proxy “localhost:1080” git clone –recurse-submodules &#x67;&#x69;&#x74;&#64;&#103;&#x69;&#x74;&#x68;&#x75;&#x62;&#x2e;&#x63;&#111;&#109;:shadowsocks/shadowsocks-android.git 修改包名 把apk改成 shadowsocks.apk 1234567![SS_20190DD](E:\\noteforme.github.io\\source\\_posts\\ubuntu_ssr\\SS_20190DD.png)java -jar apktool.jar d shadowsocks.apk //解包 //中间做修改java -jar apktool.jar b shadowsocks //打成apk再dist目录下jarsigner -verbose -keystore androidTest.jks -signedjar signed.apk AndroidTest.apk test //生成签名jarsigner -verbose -keystore androidTest.jks -signedjar signed.apk shadowsockstt.apk test https://blog.csdn.net/huaiyiheyuan/article/details/53114490 windows全局代理https://www.flyzy2005.com/fan-qiang/shadowsocks/proxifier-with-shadowsocks/ win7下使用 首先下载 Microsoft .NET Framework 4.6.2，但是win7系统不支持安装 下载 需要升级为Windows 7 SP1 需要去官网下载 Windows 7 SP1 VR INSTALL 安装 https://toutyrater.github.io/prep/install.html Install ```wget https://install.direct/go.sh sudo bash go.sh 1234567892. checkcat /etc/v2ray/config.json you will see the config,I won&#x27;t be change it3. ff $ sudo systemctl start v2ray 12345678910111213141516171819 sudo: unable to resolve host vm8l4. $ cat /etc/hostname vm8lcxg8.hostflyte.com or you could use this[vr使用](https://github.com/233boy/v2ray/wiki/V2Ray%E6%90%AD%E5%BB%BA%E8%AF%A6%E7%BB%86%E5%9B%BE%E6%96%87%E6%95%99%E7%A8%8B)* macOS useproxyGithub slowly git config –global http.proxy socks5://127.0.0.1:1081 git config –global https.proxy socks5://127.0.0.1:1081 123 git config –global –unset http.proxygit config –global –unset https.proxy 1234567891011https://www.jianshu.com/p/5e74b1042b70GitHub 镜像 https://github.com/Zenquan/quickgitclonegit clone https://github.com.cnpmjs.org/android/media-samples.git sudo dscacheutil -flushcache 12345678Terminal```cppexport http_proxy=&quot;http://127.0.0.1:1081&quot;export https_proxy=&quot;http://127.0.0.1:1081&quot; google 搭建vr 查看网络详情 -》防火墙 按照这个教程 https://zelikk.blogspot.com/2019/01/gcp-v2ray-firewall.html 网络标记就选了全部实例 注意复制的端口号 带上了逗号 ​ root身份运行 -bash: sudo: command not found 123dpkg -l|grep sudoapt-get install sudosudo apt-get install wget root运行 1sudo -i 安装 123wget https://install.direct/go.shsudo bash go.shsudo systemctl start v2ray 设置mac终端走ssr或者是v2ray代理 http://www.xiaosuiyin.com/2020/02/15/%E8%AE%BE%E7%BD%AEmac%E7%BB%88%E7%AB%AF%E8%B5%B0ssr%E6%88%96%E8%80%85%E6%98%AFv2ray%E4%BB%A3%E7%90%86/ https://github.com/233boy/v2ray/wiki/V2Ray%E6%90%AD%E5%BB%BA%E8%AF%A6%E7%BB%86%E5%9B%BE%E6%96%87%E6%95%99%E7%A8%8B https://github.com/v2fly/fhs-install-v2ray/blob/master/README.zh-Hans-CN.md 注意配置 tcp端口 https://justmysocks3.net","categories":[{"name":"LINUX","slug":"LINUX","permalink":"http://noteforme.github.io.com/categories/LINUX/"}],"tags":[],"keywords":[{"name":"LINUX","slug":"LINUX","permalink":"http://noteforme.github.io.com/categories/LINUX/"}]},{"title":"RecyclerViewUse","slug":"RecyclerView","date":"2017-07-17T03:30:18.000Z","updated":"2021-08-19T11:11:44.215Z","comments":true,"path":"2017/07/17/RecyclerView/","link":"","permalink":"http://noteforme.github.io.com/2017/07/17/RecyclerView/","excerpt":"","text":"Question https://www.bilibili.com/video/BV1Fi4y1x7p5?from=search&amp;seid=3244755609076396172 RecycleView复用机制 无 问题3 适配不同类型的View布局，将用户界面显示与逻辑代码分离 无 滑动坐标第一个左边 - 第二个坐标 所以负值 一定是往下滑 用栈数组保存不同类型回收的view 回收情况ScrollY 第一个可见Item的左上顶点 距离屏幕左上角的距离。 顶部item回收网上滑动 当顶部item滑出屏幕，ScrollY的高度等于第一个item高度时，就被滑出了屏幕。 底部item再添加网上滑动 当 屏幕显示的几个Item 长度 - ScrollY 刚好等于 屏幕高度，底部item之下再开始添加item。 因为ScrollY变大. 顶部item添加向下滑动 ScrollY = 顶部item高度，顶部添加item 底部item回收ScrollY = 底部item高度，底部回收。 基本使用123LinearLayoutManager layoutManager = new LinearLayoutManager(getActivity());layoutManager.setOrientation(LinearLayoutManager.VERTICAL); //默认竖直布局mRecyclerView.setLayoutManager(layoutManager); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class CustomAdapter extends RecyclerView.Adapter&lt;CustomAdapter.ViewHolder&gt; &#123; private static final String TAG = &quot;CustomAdapter&quot;; private String[] mDataSet; // BEGIN_INCLUDE(recyclerViewSampleViewHolder) /** * Provide a reference to the type of views that you are using (custom ViewHolder) */ public static class ViewHolder extends RecyclerView.ViewHolder &#123; private final TextView textView; public ViewHolder(View v) &#123; super(v); // Define click listener for the ViewHolder&#x27;s View. v.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.d(TAG, &quot;Element &quot; + getAdapterPosition() + &quot; clicked.&quot;); &#125; &#125;); textView = (TextView) v.findViewById(R.id.textView); &#125; public TextView getTextView() &#123; return textView; &#125; &#125; // END_INCLUDE(recyclerViewSampleViewHolder) /** * Initialize the dataset of the Adapter. * * @param dataSet String[] containing the data to populate views to be used by RecyclerView. */ public CustomAdapter(String[] dataSet) &#123; mDataSet = dataSet; &#125; // BEGIN_INCLUDE(recyclerViewOnCreateViewHolder) // Create new views (invoked by the layout manager) @Override public ViewHolder onCreateViewHolder(ViewGroup viewGroup, int viewType) &#123; // Create a new view. View v = LayoutInflater.from(viewGroup.getContext()) .inflate(R.layout.text_row_item, viewGroup, false); return new ViewHolder(v); &#125; // END_INCLUDE(recyclerViewOnCreateViewHolder) // BEGIN_INCLUDE(recyclerViewOnBindViewHolder) // Replace the contents of a view (invoked by the layout manager) @Override public void onBindViewHolder(ViewHolder viewHolder, final int position) &#123; Log.d(TAG, &quot;Element &quot; + position + &quot; set.&quot;); // Get element from your dataset at this position and replace the contents of the view // with that element viewHolder.getTextView().setText(mDataSet[position]); &#125; // END_INCLUDE(recyclerViewOnBindViewHolder) // Return the size of your dataset (invoked by the layout manager) @Override public int getItemCount() &#123; return mDataSet.length; &#125;&#125; https://github.com/googlesamples/android-RecyclerView http://blog.csdn.net/lmj623565791/article/details/51854533http://blog.csdn.net/qibin0506/article/details/49716795 Jectpack Paginghttps://developer.android.com/topic/libraries/architecture/paging https://www.youtube.com/watch?v=BE5bsyGGLf4&amp;t=841s https://codelabs.developers.google.com/codelabs/android-paging/index.html?index=..%2F..%2Findex#1 ItemKeyedDataSource的子类需要实现loadInitial、loadAfter、loadBefore和getKey方法。它们分别的作用如下： loadInitial：此方法之后在用DataSource构建PageList的时候才会调用一次。用于进行加载初始化。 loadAfter：在每次RecyclerView滑动到底部没有数据的时候就会调用此方法进行数据的加载。 loadBefore：在每次RecyclerView滑动到顶部没有数据的时候就会调用此方法进行数据的加载。 getKey: 这返回下一个loadAfter调用所需要用到的key。就相当于链表的指针。 https://anriku.top/2018/09/25/Android%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD-Paging%E7%9A%84%E4%BD%BF%E7%94%A8/ https://github.com/fmtjava/Jetpack_GitHub https://github.com/Hankkin/JetPack_Note 解释 paging diff http://www.jeepxie.net/article/25492.html https://www.jianshu.com/p/bbb96fc62bcd https://www.jianshu.com/p/10bf4bf59122 https://juejin.im/post/5db06bb6518825646d79070b Item分类前面添加header, footer就用到了item分类reclverview也有很多分类方式 使用adapter 组合设计模式，进行组装，代码简洁，比较好操作多adapter分类 https://github.com/luizgrp/SectionedRecyclerViewAdapterhttp://blog.csdn.net/wzlyd1/article/details/52292548https://github.com/luizgrp/SectionedRecyclerViewAdapter https://github.com/donkingliang/GroupedRecyclerViewAdapter https://mp.weixin.qq.com/s/oCl4BQ8uB9ZDSOEKESM7hA 复杂布局: https://github.com/385841539/RecycleviewStaggered 竖直嵌套水平:https://github.com/drakeet/MultiType/issues/67 分割线 https://www.jianshu.com/p/4eff036360da https://www.jianshu.com/p/b2ef4f8e859f https://github.com/YoKeyword/IndexableRecyclerView https://juejin.im/post/5eae33a26fb9a043586c7f19 Reycleview previewhttps://medium.com/aubergine-solutions/creating-recyclerview-layout-in-android-no-pain-only-gain-404280471003 12tools:itemCount=&quot;5&quot;tools:listitem=&quot;@layout/adapter_red_pack&quot; 1tools:src=&quot;@sample/RedPack.json/dataList/redEnvelopeMoney&quot; 问题使用recycleView中会遇到一些问题,总结一下 问题1下拉刷新 滑动列表 crash 使用下拉刷新的时候 往上滑动item会出现这样的错误 123456789101112131415161718E/CrashReport: sys default last handle start!FATAL EXCEPTION: main Process: com.huifu, PID: 22865 java.lang.IndexOutOfBoundsException: Inconsistency detected. Invalid item position 4(offset:4).state:10 at android.support.v7.widget.RecyclerView$Recycler.tryGetViewHolderForPositionByDeadline(RecyclerView.java:5504) at android.support.v7.widget.GapWorker.prefetchPositionWithDeadline(GapWorker.java:282) at android.support.v7.widget.GapWorker.flushTaskWithDeadline(GapWorker.java:336) at android.support.v7.widget.GapWorker.flushTasksWithDeadline(GapWorker.java:349) at android.support.v7.widget.GapWorker.prefetch(GapWorker.java:356) at android.support.v7.widget.GapWorker.run(GapWorker.java:387) at android.os.Handler.handleCallback(Handler.java:739) at android.os.Handler.dispatchMessage(Handler.java:95) at android.os.Looper.loop(Looper.java:148) at android.app.ActivityThread.main(ActivityThread.java:5417) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:726) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616) 刷新之后数据清空，再滑动数据和item不一致, 情况数据应该在拿到数据之后, 使用下面这种方式解决问题， 12345678910111213141516 @Override public void onRefresh() &#123;// if (!mProjectList.isEmpty()) &#123;// mProjectList.clear();// &#125; start = 0; loadData(); &#125;//拿到数据后 public void onSuccess(List&lt;Project&gt; projects) &#123; swipeInvest.setRefreshing(false); isloading = false; if (start == 0) mProjectList.clear(); &#125; http://blog.csdn.net/weixiao_812/article/details/78138075 下拉刷新时快速滑动崩溃的问题解决 问题2 界面不能展示 ,和ListView 不同的是RecyclerView不同,没设置下面的参数是不显示的 12mLayoutManager = new LinearLayoutManager(getActivity());rcvRrecord.setLayoutManager(mLayoutManager); 如果还是没有就看看 recycleview布局是否显示 https://blog.csdn.net/mjb00000/article/details/106014544 不用等数据来了后再显示 https://github.com/leobert-lan/Pandora","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"VideoAudio","slug":"VideoAudio","date":"2017-07-14T08:50:09.000Z","updated":"2021-08-19T11:11:44.259Z","comments":true,"path":"2017/07/14/VideoAudio/","link":"","permalink":"http://noteforme.github.io.com/2017/07/14/VideoAudio/","excerpt":"","text":"先安装codelabs把整个流程走一便，对库的使用有了整体的认识，https://codelabs.developers.google.com/codelabs/exoplayer-intro/#1 接着了解基本概念 语音转化 AudioApplication /Applications/VLC.app/Contents/MacOS/VLC –demux=rawaud –rawaud-channels 1 –rawaud-samplerate 44100 /Users/john/Desktop/audio/recording.pcm 声音声音三要素音调 : 音频的快慢 男生 &lt; 女生 &lt; 儿童 音量: 振动的幅度 音色: 谐波 PCM采样大小 ： 一个采样用多少bit存放。常用16bit 采样率 : 采样频率 8k , 16k , 32k, 44.1k 48k 声道数 ： 单声道 ， 双声道 ， 多声道 WAV![](/Users/john/Documents/noteforme.github.io/source/_posts/VideoAudio/Screen Shot 2021-03-07 at 5.21.18 PM.png) ![](/Users/john/Documents/noteforme.github.io/source/_posts/VideoAudio/Screen Shot 2021-03-07 at 5.23.23 PM.png) 采集命令采集12ffmpeg -f avfoundation -i :0 out.wav //采集ffplay out.wav //播放","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]},{"title":"MarkdownStnddard","slug":"Markdown-Standard","date":"2017-07-11T02:46:11.000Z","updated":"2021-08-19T11:11:44.127Z","comments":true,"path":"2017/07/11/Markdown-Standard/","link":"","permalink":"http://noteforme.github.io.com/2017/07/11/Markdown-Standard/","excerpt":"","text":"第一篇还没写 在CSDN写了一年多的博客也算是自己历程的简单记录，竟然莫名奇妙的就被封了，客服说被系统误封了，接着帮我解封，然而自己建博客就提前排上了日常，接着就是Google了，好在几天就建好了，开始吧 骚年！！！ ** Markdown规范** 12a b . DogsAnatomy of the dogCatsAnatomy of the cat参考: http://einverne.github.io/markdown-style-guide/zh.html","categories":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}],"tags":[],"keywords":[{"name":"ANDROID","slug":"ANDROID","permalink":"http://noteforme.github.io.com/categories/ANDROID/"}]}]}