<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Jon&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Jon&#39;s Blog">
<meta property="og:url" content="https://noteforme.github.io/page/2/index.html">
<meta property="og:site_name" content="Jon&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jon">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Jon's Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Jon&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Cease to struggle and you cease to live. - Thomas Carlyle</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://noteforme.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-LC-Tree-Search-22" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/10/05/LC-Tree-Search-22/" class="article-date">
  <time class="dt-published" datetime="2022-10-05T14:00:07.000Z" itemprop="datePublished">2022-10-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/DataStructure/">DataStructure</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/10/05/LC-Tree-Search-22/">LC-Tree-Search-22</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="二叉树搜索-BST"><a href="#二叉树搜索-BST" class="headerlink" title="二叉树搜索 BST"></a>二叉树搜索 BST</h3><p><strong>根节点比左子树所有节点的数值都大，比右子树所有节点的数值都小.</strong> </p>
<h4 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700. 二叉搜索树中的搜索"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></h4><p>My idea</p>
<h5 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h5><ol>
<li><p>先序遍历搜索，如果找到了直接返回当前节点。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">searchBST</span><span class="params">(root: <span class="type">TreeNode</span>?, `<span class="keyword">val</span>`: <span class="type">Int</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (root.`<span class="keyword">val</span>` == `<span class="keyword">val</span>`) &#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> nodeLeft = searchBST(root.left, `<span class="keyword">val</span>`)</span><br><span class="line">    <span class="keyword">if</span> (nodeLeft != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nodeLeft</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> nodeRight = searchBST(root.right, `<span class="keyword">val</span>`)</span><br><span class="line">    <span class="keyword">if</span> (nodeRight != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nodeRight</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>看了官方解法,利用二叉搜索树的特性 </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">searchBST1</span><span class="params">(root: <span class="type">TreeNode</span>?, `<span class="keyword">val</span>`: <span class="type">Int</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> node: TreeNode? = root.left</span><br><span class="line">    <span class="keyword">if</span> (root.`<span class="keyword">val</span>` == `<span class="keyword">val</span>`) &#123; <span class="comment">//一开始没有做出来，这个条件没写,导致一直往下递归</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.`<span class="keyword">val</span>` &lt; `<span class="keyword">val</span>`) &#123;</span><br><span class="line">        node = root.right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> searchBST1(node, `<span class="keyword">val</span>`)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h5><p>二叉搜索树的迭代法相对简单，暂时先不看了</p>
<h4 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h4><p>二叉搜索树是一个有序树：</p>
<ul>
<li>若它的左子树不空，则左子树上<strong>所有结点</strong>的值均小于它的根结点的值；  注意==都不行</li>
<li>若它的右子树不空，则右子树上<strong>所有结点</strong>的值均大于它的根结点的值；</li>
<li>它的左、右子树也分别为二叉搜索树</li>
</ul>
<p>这就决定了，二叉搜索树，递归遍历和迭代遍历和普通二叉树都不一样。</p>
<p>一开始理解错了，只比较根节点和左右子树，导致下面这个testcase没通过，应该是根节点和所有的左右子树的节点数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5, 4, 6, null, null, 3, 7</span><br></pre></td></tr></table></figure>



<h5 id="转数组"><a href="#转数组" class="headerlink" title="转数组"></a>转数组</h5><p>把中序遍历转成数组很好理解</p>
<ol>
<li><p> 中序遍历递归 得到list数组</p>
</li>
<li><p>比较数组的前后节点大大小,</p>
</li>
<li><p>如果前面节点值更大，那么直接返回false, ==也不行</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isValidBST3</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    dfsTraversal(root) <span class="comment">// 中序遍历递归 得到list数组</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until list.size - <span class="number">1</span>) &#123; <span class="comment">// 比较数组的前后节点大大小</span></span><br><span class="line">        <span class="keyword">if</span> (list[i] &gt;= list[i + <span class="number">1</span>]) &#123; <span class="comment">// 如果前面节点值更大，那么直接返回false, ==也不行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dfsTraversal</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">    dfsTraversal(root.left)</span><br><span class="line">    list.add(root.`<span class="keyword">val</span>`)</span><br><span class="line">    dfsTraversal(root.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h5><p>随想录的递归解法，一开始怎么也理解不了，其实和上面 中序转数组的类似，就是把根据中序遍历遍历的节点，后一个节点一定比前一个节点的数值高。</p>
<ol>
<li>中序遍历 后一个节点比前一个节点的值大，就可以了，所以存储前一个节点。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> preNode: TreeNode? = <span class="literal">null</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isValidBST4</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (!isValidBST4(root.left)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (preNode != <span class="literal">null</span> &amp;&amp; preNode!!.`<span class="keyword">val</span>` &gt;= root.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    preNode = root</span><br><span class="line">    <span class="keyword">if</span> (!isValidBST4(root.right)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>之前的题主要用到 后序和先序，二叉搜索这里开始用到了 中序遍历。</p>
<h4 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530. 二叉搜索树的最小绝对差"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差</a></h4><p>My idea </p>
<p>这一题和上一题 98 思路差不多，</p>
<p>中序遍历的节点之间的数组相差最小，所以找出节点间的间隔最小值就可以了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> preNode: TreeNode? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">var</span> miniNum = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getMinimumDifference</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line">    getMinimumDifference(root.left)</span><br><span class="line">    <span class="keyword">if</span> (preNode != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> gapNum = root.`<span class="keyword">val</span>` - preNode!!.`<span class="keyword">val</span>`<span class="comment">//这一步可以简化 Math.min()</span></span><br><span class="line">        <span class="keyword">if</span> (gapNum &lt; miniNum) &#123;</span><br><span class="line">            miniNum = gapNum</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    preNode = root</span><br><span class="line">    getMinimumDifference(root.right)</span><br><span class="line">    <span class="keyword">return</span> miniNum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>也可以先中序遍历转成数组，然后求数组元素间的差值就可以了。</p>
<h4 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501. 二叉搜索树中的众数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数</a></h4><p>My idea</p>
<p>我的想法和上面的类似。</p>
<ol>
<li>中序遍历相邻节点用map存下value和值的个数。</li>
<li>遍历map求得最大个事的数组。把map按照value个数进行数组排序</li>
<li> 然后取排序后的前面的元素</li>
</ol>
<p>。了。/其实上面这种方式，用先序 后序都可以，都不需要二叉搜索树。</p>
<p>其实上面我的想法也是 打算用二叉搜索树的特性，放到map中，然后把map排序,就不知道怎么处理更好。看了随想录的处理方式,理了下思路.</p>
<ol>
<li>根据中序遍历的前后节点，他们的值相同的是一起的，进行遍历。</li>
<li>对value值进行count计数，如果count == 最大个数，加入集合。</li>
<li>如果count&gt;最大个数，清空集合.</li>
</ol>
<p>一开始不知道放哪里, maxCount=count ，以为在前面if (preNode != null &amp;&amp; preNode!!.<code>val</code> == node.<code>val</code>) 前面的比较里面,还想着Math.max,但是都不合适。然后看了一半随想录是放在更新节点的位置，更好.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> array = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findMode</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: IntArray &#123;</span><br><span class="line">    inDFS(root)</span><br><span class="line">    <span class="keyword">return</span> array.toIntArray()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> preNode: TreeNode? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">var</span> maxCount = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">inDFS</span><span class="params">(node: <span class="type">TreeNode</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> printNode = node?.`<span class="keyword">val</span>`</span><br><span class="line">    println(<span class="string">&quot;printNode <span class="variable">$printNode</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    inDFS(node.left)</span><br><span class="line">    <span class="keyword">if</span> (preNode != <span class="literal">null</span> &amp;&amp; preNode!!.`<span class="keyword">val</span>` == node.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        count++</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count == maxCount) &#123;</span><br><span class="line">        array.add(node.`<span class="keyword">val</span>`)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; maxCount) &#123;</span><br><span class="line">        maxCount = count<span class="comment">//这一步一开始不知道放哪里,看了一眼随想录答案</span></span><br><span class="line">        array.clear() <span class="comment">// 有更大的值，清空之前的集合</span></span><br><span class="line">        array.add(node.`<span class="keyword">val</span>`)</span><br><span class="line">    &#125;</span><br><span class="line">    preNode = node</span><br><span class="line">    inDFS(node.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>官方还有 o(1)的处理，while循环</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/solution/er-cha-sou-suo-shu-zhong-de-zhong-shu-by-leetcode-/">https://leetcode.cn/problems/find-mode-in-binary-search-tree/solution/er-cha-sou-suo-shu-zhong-de-zhong-shu-by-leetcode-/</a></p>
<h4 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h4><p>这一题有两种想法</p>
<ol>
<li>之前做的环形链表 走对方的路</li>
<li>先序遍历每一个节点，只要下面的节点都走过，只要下一个节点没有走到，就返回上一个节点，但是先序遍历DFS 两个节点都走了不知道怎么返回。</li>
</ol>
<p>看了随想录视频思路后 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1jd4y1B7E2">https://www.bilibili.com/video/BV1jd4y1B7E2</a></p>
<ol>
<li>后序遍历如果碰到p或q,就返回他们的节点.</li>
<li>如果一个节点的左右子树都不为空说明当前节点是他们的最近公共祖先.</li>
<li>还一种情况，有一个节点p就是祖先节点</li>
</ol>
<p>debug调试，拼凑把代码写出来了</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">lowestCommonAncestor</span><span class="params">(root: <span class="type">TreeNode</span>?, p: <span class="type">TreeNode</span>?, q: <span class="type">TreeNode</span>?)</span></span>: TreeNode? &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">// 随想录这里改成 碰到节点判断，直接在这里返回</span></span><br><span class="line"><span class="comment">//        val printData = root.`val`</span></span><br><span class="line"><span class="comment">//        println(printData)</span></span><br><span class="line">        <span class="keyword">val</span> leftNode = lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        <span class="keyword">val</span> rightNode = lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> (leftNode != <span class="literal">null</span> &amp;&amp; rightNode != <span class="literal">null</span>) &#123; <span class="comment">// 如果左右子树都不为空，那么当前节点就是最近公共祖先节点</span></span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; root.`<span class="keyword">val</span>` == p.`<span class="keyword">val</span>`) &#123;   <span class="comment">//碰到了其中一个节点返回</span></span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (q != <span class="literal">null</span> &amp;&amp; root.`<span class="keyword">val</span>` == q.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">            <span class="keyword">return</span> root                             <span class="comment">//碰到了其中一个节点返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftNode != <span class="literal">null</span>) <span class="keyword">return</span> leftNode       <span class="comment">//回溯之前碰到的节点</span></span><br><span class="line">        <span class="keyword">if</span> (rightNode != <span class="literal">null</span>) <span class="keyword">return</span> rightNode</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h5 id="终止条件写法"><a href="#终止条件写法" class="headerlink" title="终止条件写法"></a>终止条件写法</h5><p> 随想录这里改成 碰到节点判断，直接在这里返回，下次可以改成在终止条件这里，更简单</p>
<h4 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></h4><p>My idea</p>
<p>可以根据二叉搜索树的特性， 祖先节点的值大小有两种情况</p>
<ol>
<li>在p和q之前,</li>
<li>如果p&lt;q, 祖先节点的值 等于p , 大于q</li>
<li>只要满足上述条件，用先序遍历或者后序遍历都可以，把节点返回</li>
</ol>
<p>官方和随想录解法都是给出了相反的条件 ，当前节点&lt;p , &gt;q,在外面的情况（其实这里没想清楚,不存在这样的&lt;2 &gt;4的节点）, 但是我这里ide testcase也没问题。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/solution/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-26/">https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/solution/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-26/</a></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 很奇怪，IDE可以跑这个testcase没问题</span></span><br><span class="line"><span class="comment"> *[2,1]</span></span><br><span class="line"><span class="comment"> * 2</span></span><br><span class="line"><span class="comment"> * 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lowestCommonAncestor</span><span class="params">(root: <span class="type">TreeNode</span>?, p: <span class="type">TreeNode</span>?, q: <span class="type">TreeNode</span>?)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (p!!.`<span class="keyword">val</span>` &gt; q!!.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        swap(p, q)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.`<span class="keyword">val</span>` &gt; p.`<span class="keyword">val</span>` &amp;&amp; root.`<span class="keyword">val</span>` &lt; q.`<span class="keyword">val</span>`) &#123; </span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.`<span class="keyword">val</span>` == p.`<span class="keyword">val</span>` &amp;&amp; root.`<span class="keyword">val</span>` &lt; q.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.`<span class="keyword">val</span>` == q.`<span class="keyword">val</span>` &amp;&amp; root.`<span class="keyword">val</span>` &gt; p.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> leftNode = lowestCommonAncestor(root.left, p, q)</span><br><span class="line">    <span class="keyword">if</span> (leftNode != <span class="literal">null</span>) <span class="keyword">return</span> leftNode</span><br><span class="line">    <span class="keyword">val</span> rightNode = lowestCommonAncestor(root.right, p, q)</span><br><span class="line">    <span class="keyword">if</span> (rightNode != <span class="literal">null</span>) <span class="keyword">return</span> rightNode</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">swap</span><span class="params">(p: <span class="type">TreeNode</span>, q: <span class="type">TreeNode</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> temp = p.`<span class="keyword">val</span>`</span><br><span class="line">    p.`<span class="keyword">val</span>` = q!!.`<span class="keyword">val</span>`</span><br><span class="line">    q.`<span class="keyword">val</span>` = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0235.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html">https://programmercarl.com/0235.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Zt4y1F7ww">https://www.bilibili.com/video/BV1Zt4y1F7ww</a></p>
<p>看了随想录视频，其实相反的就两种情况</p>
<ol>
<li>当前节点 &lt;p , &lt;q， 那么p,q一定在右子树上，就去右子树去找</li>
<li>当前节点 &gt; p , &gt;q ,那么p,q一定在左子树上，就去左子树去找</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lowestCommonAncestor</span><span class="params">(root: <span class="type">TreeNode</span>?, p: <span class="type">TreeNode</span>?, q: <span class="type">TreeNode</span>?)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (root.`<span class="keyword">val</span>` &lt; p!!.`<span class="keyword">val</span>` &amp;&amp; root.`<span class="keyword">val</span>` &lt; q!!.`<span class="keyword">val</span>`) &#123; <span class="comment">// 当前节点比p和q的值都小，那么一定p,q一定在右子树上，就往右边遍历</span></span><br><span class="line">        <span class="keyword">val</span> rightNode = lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> (rightNode != <span class="literal">null</span>) <span class="keyword">return</span> rightNode</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root.`<span class="keyword">val</span>` &gt; p.`<span class="keyword">val</span>` &amp;&amp; root.`<span class="keyword">val</span>` &gt; q!!.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        <span class="keyword">val</span> leftNode = lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        <span class="keyword">if</span> (leftNode != <span class="literal">null</span>) <span class="keyword">return</span> leftNode</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a></h4><h5 id="DFS-1"><a href="#DFS-1" class="headerlink" title="DFS"></a>DFS</h5><p>My idea</p>
<p>可以用后序遍历，按照二叉树的特性，走到叶子节点后，连接到叶子节点，然后回溯到根节点并返回</p>
<ol>
<li>后序遍历根据待插入值和当前节点比较，找到需要插入的位置。</li>
<li>如果需要插入的位置左或右节点刚好为空，就插入。</li>
</ol>
<p>随想录其中一个解法和我的这个类似，不过感觉比我这个更复杂点</p>
<p>自己的做的解法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">insertIntoBST</span><span class="params">(root: <span class="type">TreeNode</span>?, `<span class="keyword">val</span>`: <span class="type">Int</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> TreeNode(`<span class="keyword">val</span>`) <span class="comment">//有一个这个test case  [] 5 ,空树的话返回 [5]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (`<span class="keyword">val</span>` &lt; root.`<span class="keyword">val</span>`) &#123; <span class="comment">// 插入点小于当前节点，往左子树中插入</span></span><br><span class="line">        insertIntoBST(root.left, `<span class="keyword">val</span>`)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (`<span class="keyword">val</span>` &gt; root.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        insertIntoBST(root.right, `<span class="keyword">val</span>`)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一开始这个放前面导致添加了两个5的左节点，因为 insertIntoBST(root.left, `val`)又走了一次</span></span><br><span class="line">    <span class="keyword">val</span> treeNode = TreeNode(`<span class="keyword">val</span>`) <span class="comment">// 只有一次机会走这个</span></span><br><span class="line">    <span class="keyword">if</span> (root.right == <span class="literal">null</span> &amp;&amp; `<span class="keyword">val</span>` &gt; root.`<span class="keyword">val</span>`) &#123; <span class="comment">//  待插入点大于当前节点，所以要插入右子树中，此时右子树为空，那么直接插入</span></span><br><span class="line">        root.right = treeNode</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; `<span class="keyword">val</span>` &lt; root.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        root.left = treeNode</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>看了随想录的解法，其实还可以每一个都被父节点接住更简单,也是后序遍历的精髓 </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">insertIntoBST</span><span class="params">(root: <span class="type">TreeNode</span>?, `<span class="keyword">val</span>`: <span class="type">Int</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> TreeNode(`<span class="keyword">val</span>`)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (`<span class="keyword">val</span>` &lt; root.`<span class="keyword">val</span>`) &#123; <span class="comment">// 插入点小于当前节点，往左子树中插入</span></span><br><span class="line">        root.left = insertIntoBST1(root.left, `<span class="keyword">val</span>`)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (`<span class="keyword">val</span>` &gt; root.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        root.right = insertIntoBST1(root.right, `<span class="keyword">val</span>`)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="迭代法-1"><a href="#迭代法-1" class="headerlink" title="迭代法"></a>迭代法</h5><p>官方用迭代法 ,看起来也不难</p>
<p> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/solution/er-cha-sou-suo-shu-zhong-de-cha-ru-cao-zuo-by-le-3/">https://leetcode.cn/problems/insert-into-a-binary-search-tree/solution/er-cha-sou-suo-shu-zhong-de-cha-ru-cao-zuo-by-le-3/</a></p>
<h4 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></h4><p>My idea</p>
<p>和上面思路类似，用后序遍历的 父节点接住，当前要删除节点的左或者右节点，那么当前节点就删除了，然后左右节点再改变指向。</p>
<ol>
<li><p>后序遍历到要删除的节点.</p>
</li>
<li><p>当前节点的右节点指向它的左节点。被上一个节点回溯的父节点接住。</p>
</li>
<li><p>返回当前节点的左节点，</p>
</li>
</ol>
<p>[5,3,6,2,4,null,7]<br>5<br>优先还是需要右节点上去，否则就很麻烦，需要4上去</p>
<p>删除节点主要有这5种情况</p>
<ul>
<li>第一种情况：没找到删除的节点，遍历到空节点直接返回了</li>
<li>找到删除的节点<ul>
<li>第二种情况：删除的左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</li>
<li>第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点</li>
<li>第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</li>
<li>第五种情况：删除节点的左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。</li>
</ul>
</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbj3k596mg30dq0aigyz.gif" alt="450.删除二叉搜索树中的节点"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">deleteNode</span><span class="params">(root: <span class="type">TreeNode</span>?, key: <span class="type">Int</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">//情况一</span></span><br><span class="line">    <span class="keyword">if</span> (key &lt; root.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        root.left = deleteNode(root.left, key)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        root.right = deleteNode(root.right, key)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key == root.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.right == <span class="literal">null</span> &amp;&amp; root.left == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">// 情况2  [0] 0 因为这个testcase 会返回[0]和预期不一致</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.left != <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;            <span class="comment">//情况三 如果左节点不为空</span></span><br><span class="line">            <span class="keyword">val</span> node = root.left  <span class="comment">// 左节点 2 推到删除的节点位置</span></span><br><span class="line">            <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;               <span class="comment">//这两句可以去掉 ，直接返回节点</span></span><br><span class="line">                node.right = root.right         <span class="comment">//此时左节点2在在删除节点位置，它的右子树指向之前右节点4</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.right != <span class="literal">null</span> &amp;&amp; root.left == <span class="literal">null</span>) &#123;  <span class="comment">//情况四 如果右节点不为空</span></span><br><span class="line">            <span class="keyword">val</span> node = root.right <span class="comment">//右节点4 推到删除的节点位置</span></span><br><span class="line">            <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;                 <span class="comment">//这两句可以去掉</span></span><br><span class="line">                node.left = root.left           <span class="comment">// 此时左节点4在在删除节点位置，它的左子树指向之前右节点2</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> rightNode = root.right <span class="comment">//情况五</span></span><br><span class="line">            <span class="keyword">var</span> leftNode = rightNode?.left</span><br><span class="line">            <span class="keyword">while</span> (leftNode?.left!= <span class="literal">null</span>) &#123;</span><br><span class="line">                leftNode = leftNode.left</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (leftNode != <span class="literal">null</span>) &#123;</span><br><span class="line">                leftNode.left = root.left</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rightNode.left = root.left</span><br><span class="line">            &#125;</span><br><span class="line">            root.left = <span class="literal">null</span></span><br><span class="line">            <span class="keyword">return</span> rightNode <span class="comment">// 这里返回的节点，可以被上面的左右子树接住</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="普通二叉树的节点删除"><a href="#普通二叉树的节点删除" class="headerlink" title="普通二叉树的节点删除"></a>普通二叉树的节点删除</h5><p>通用二叉树节点删除</p>
<p><img src="/2022/10/05/LC-Tree-Search-22/20221012115615.jpg"></p>
<p>要加if (leftNode != null)，否则删除报错</p>
<p>这个题目的leetcode的测试用例有问题,单独跑报错.</p>
<h4 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h4><p>看了随想录的解答，从中取中间节点的位置就可以了，如果数字是偶数，中间节点的两个中的一个都可以，</p>
<p>但是问题来了，为什么取中间节点构造的二叉树就是高度平衡的二叉搜索树呢?</p>
<p>先按照这个思路，把代码写出来</p>
<ol>
<li>按照先序遍历思路，先找到根节点，构造出中间节点。</li>
<li>根据中间节点划定新的数组的范围，左边和右边，然后递归找到新的数组的中间节点继续划出范围.</li>
</ol>
<p>在这里 左闭右闭更合理</p>
<p>这题主要注意边界值,if (left &gt; right）这个要注意是&gt; 没有=,因为index-1和index+1了，所以最终一定会超过right</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sortedArrayToBST</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">return</span> buildSearchTree(nums, <span class="number">0</span>, nums.size - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">buildSearchTree</span><span class="params">(nums: <span class="type">IntArray</span>, left: <span class="type">Int</span>, right: <span class="type">Int</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> index = <span class="comment">/*(start + end) / 2*/</span> left + (right - left) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">val</span> node = TreeNode(nums[index])</span><br><span class="line">    <span class="comment">// println(&quot;node $&#123;node.`val`&#125; :  start $left end $right&quot;)</span></span><br><span class="line">    node.left = buildSearchTree(nums, left, index - <span class="number">1</span>)</span><br><span class="line">    node.right = buildSearchTree(nums, index + <span class="number">1</span>, right)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538. 把二叉搜索树转换为累加树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></h4><p>累加树: 按照中序遍历的到的 从小到大的数组 [1,2,3,4] ,累加树就是右到左的值相加 [10,9,7,4]</p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0538.%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91.html#%E9%80%92%E5%BD%92">https://programmercarl.com/0538.%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91.html#%E9%80%92%E5%BD%92</a></p>
<p>中序遍历的树 : 左 中 右 2 , 5, 13</p>
<p>反中序遍历的: 右 中 左 13 , 5 , 2</p>
<p>然后按照反中序遍历的到节点累加就可以了。</p>
<img src="https://img-blog.csdnimg.cn/20210204153440666.png" alt="538.把二叉搜索树转换为累加树" style="zoom:50%;">



<p>这一题一开始没想上面的思路，看了随想录的思路后,写出来的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">convertBST</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    convertBST(root.right)</span><br><span class="line">    sum += root.`<span class="keyword">val</span>`</span><br><span class="line">    root.`<span class="keyword">val</span>` = sum</span><br><span class="line">    convertBST(root.left)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>根据中序遍历的规则，写出反中序 右中左遍历节点。</li>
<li>拿到每次中序的到的节点累加，然后赋值给当前节点。</li>
</ol>
<pre><code>sum += root.`val`
root.`val` = sum
</code></pre>
<p>这一段可以改进，可以保存前一个节点值，然后加上当前节点就可以了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pre = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">convertBST1</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    convertBST(root.right)</span><br><span class="line">    root.`<span class="keyword">val</span>` += pre</span><br><span class="line">    pre = root.`<span class="keyword">val</span>`</span><br><span class="line">    convertBST(root.left)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://noteforme.github.io/2022/10/05/LC-Tree-Search-22/" data-id="clce8xxrw0011k79k4affh421" data-title="LC-Tree-Search-22" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LEETCODE/" rel="tag">LEETCODE</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Fragment-StateLoss" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/09/15/Fragment-StateLoss/" class="article-date">
  <time class="dt-published" datetime="2022-09-15T02:25:12.000Z" itemprop="datePublished">2022-09-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/ANDROID/">ANDROID</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/09/15/Fragment-StateLoss/">Fragment_StateLoss</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>问题 ，Activity恢复后 mStateSaved,是怎么恢复的？</p>
<p>就是onSavedInstanceState 的官方API文档2</p>
<p>这里问题的场景是Activity已经关闭了,rpc请求很久再回来,导致了这个问题,所以我觉得判断livedate激活状态就可以了</p>
<p>可是这个改动应该只能在resume吧？</p>
<p>LiveData started 和 resumed 都可以</p>
<p>Livedata 会感知activity生命周期</p>
<p>这个有可能 activity 也在 started / resumed 状态下发出吧？ 这样的话，showDialog 应该也还会崩溃，因为onSavedInstanceState 是在 paused 时候发生的，这个时候应该还是 started 状态。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">* 后续考虑做个技改把它加到[BaseDialogFragment]里面</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">showWithLifecycle</span><span class="hljs-params">(fragmentActivity: <span class="hljs-type">FragmentActivity</span>, tag: <span class="hljs-type">String</span>? = <span class="hljs-literal">null</span>)</span></span> &#123;<br><br>  <span class="hljs-keyword">val</span> liveData = showWithLifecycleLiveData ?: MutableLiveData&lt;<span class="hljs-built_in">Boolean</span>&gt;().also &#123;<br><br>    it.observe(fragmentActivity) &#123; <span class="hljs-keyword">this</span>.show(fragmentActivity.supportFragmentManager, tag) &#125;<br><br>    showWithLifecycleLiveData = it<br><br>  &#125;<br><br>  liveData.value = <span class="hljs-literal">true</span><br><br>&#125;<br></code></pre></td></tr></table></figure>







<p>onSaveInstanceState保存分析</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6995791487426363405">https://juejin.cn/post/6995791487426363405</a></p>
<p>状态恢复</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/58579627f70a">https://www.jianshu.com/p/58579627f70a</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7057564670567120903">https://juejin.cn/post/7057564670567120903</a></p>
<p> <strong>can not perform this action after onsaveinstancestate dialogfragment show</strong> </p>
<p>developer  -&gt; 不保留活动 </p>
<p>onSaveInstanceState以下5种情况被调用：</p>
<p>1、当用户按下手机home键的时候。</p>
<p>2、长按手机home键或者按下菜单键时。</p>
<p>3、手机息屏时。</p>
<p>4、FirstActivity启动SecondActivity，FirstActivity就会调用，也就是说打开新Activity时，原Activity就会调用。</p>
<p>5、默认情况下横竖屏切换时。</p>
<p>打开Activity -&gt; Home  -&gt; 再从后台拿出来</p>
<p><img src="/2022/09/15/Fragment-StateLoss//20220919212018.jpg" alt="20220919212018"></p>
<p>既然状态的保存与恢复都必须要把Fragment带上，那么一旦当Fragment的状态已保存过了，那么就不应该再改变Fragment的状态。因此FragmentManager的每一个操作前，都会调用一个方法来检查状态是否保存过了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkStateLoss</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (mStateSaved) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<br>                    <span class="hljs-string">&quot;Can not perform this action after onSaveInstanceState&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (mNoTransactionsBecause != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<br>                    <span class="hljs-string">&quot;Can not perform this action inside of &quot;</span> + mNoTransactionsBecause);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * This is the same as &#123;<span class="hljs-doctag">@link</span> #onSaveInstanceState&#125; but is called for activities</span><br><span class="hljs-comment"> * created with the attribute &#123;<span class="hljs-doctag">@link</span> android.R.attr#persistableMode&#125; set to</span><br><span class="hljs-comment"> * &lt;code&gt;persistAcrossReboots&lt;/code&gt;. The &#123;<span class="hljs-doctag">@link</span> android.os.PersistableBundle&#125; passed</span><br><span class="hljs-comment"> * in will be saved and presented in &#123;<span class="hljs-doctag">@link</span> #onCreate(Bundle, PersistableBundle)&#125;</span><br><span class="hljs-comment"> * the first time that this activity is restarted following the next device reboot.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> outState Bundle in which to place your saved state.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> outPersistentState State which will be saved across reboots.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #onSaveInstanceState(Bundle)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #onCreate</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #onRestoreInstanceState(Bundle, PersistableBundle)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #onPause</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSaveInstanceState</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Bundle outState,</span><br><span class="hljs-params">        <span class="hljs-meta">@NonNull</span> PersistableBundle outPersistentState)</span> &#123;<br>    onSaveInstanceState(outState);<br>&#125;<br></code></pre></td></tr></table></figure>



<p>为什么会有这个异常</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lzf_acraftsman/article/details/108831949">https://blog.csdn.net/lzf_acraftsman/article/details/108831949</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903458605105160">https://juejin.cn/post/6844903458605105160</a></p>
<p>fragment重叠原因</p>
<h4 id="Fragment懒加载"><a href="#Fragment懒加载" class="headerlink" title="Fragment懒加载"></a>Fragment懒加载</h4><p>Fragment和ViewPager一起使用会有个预加载机制，会把旁白的Fragment的生命周期方法<br>前半段先执行，然后执行自身的生命周期方法</p>
<p>在项目终从其他页面回到MainAcitivty的时候，三个页面的生命周期方法都跑了一遍</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs isbl">　  <span class="hljs-variable">D</span>/<span class="hljs-variable">FinanceFragment</span>         <span class="hljs-variable">Test</span>: <span class="hljs-function"><span class="hljs-title">onStart</span>()</span><br><span class="hljs-variable">D</span>/<span class="hljs-variable">WealthFragment</span>         <span class="hljs-variable">Test</span>: <span class="hljs-function"><span class="hljs-title">onStart</span>()</span><br><span class="hljs-variable">D</span>/<span class="hljs-variable">MineFragment</span>         <span class="hljs-variable">Test</span>: <span class="hljs-function"><span class="hljs-title">onStart</span>()</span><br><span class="hljs-variable">D</span>/<span class="hljs-variable">FinanceFragment</span>         <span class="hljs-variable">Test</span>: <span class="hljs-function"><span class="hljs-title">onResume</span>()</span><br><span class="hljs-variable">D</span>/<span class="hljs-variable">WealthFragment</span>         <span class="hljs-variable">Test</span>: <span class="hljs-function"><span class="hljs-title">onResume</span>()</span><br><span class="hljs-variable">D</span>/<span class="hljs-variable">MineFragment</span>         <span class="hljs-variable">Test</span>: <span class="hljs-function"><span class="hljs-title">onResume</span>()</span><br></code></pre></td></tr></table></figure>


<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs typescript">     <br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">boolean</span> isPrepared;  <span class="hljs-comment">//判断view是否加载完成,在视图未初始化的时候，在lazyLoad当中就使用的话，就会有空指针的异常</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">boolean</span> isVisible;  <span class="hljs-comment">//判断当前Fragment是否可见状态,标志已经初始化完成，因为setUserVisibleHint是在onCreateView之前调用的</span><br>	  <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onViewCreated</span>(<span class="hljs-params">View view, <span class="hljs-meta">@Nullable</span> Bundle savedInstanceState</span>) &#123;<br>        <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">onViewCreated</span>(view, savedInstanceState);<br>        isPrepared = <span class="hljs-literal">true</span>;<br>        <span class="hljs-title function_">lazyLoad</span>();<br>    &#125;<br><br><br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">View</span> <span class="hljs-title function_">onCreateView</span>(<span class="hljs-params">LayoutInflater inflater, <span class="hljs-meta">@Nullable</span> ViewGroup container, Bundle savedInstanceState</span>) &#123;<br><span class="hljs-comment">//        Log.d(TAG + &quot;         Test&quot;, &quot; onCreateView()&quot;);</span><br><br>        <span class="hljs-keyword">if</span> (rootView == <span class="hljs-literal">null</span>) &#123;<br>            int view = <span class="hljs-title function_">setLayoutId</span>();<br>            <span class="hljs-keyword">if</span> (view != <span class="hljs-number">0</span>) &#123;<br>                rootView = inflater.<span class="hljs-title function_">inflate</span>(view, container, <span class="hljs-literal">false</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-title class_">ViewGroup</span> parent = (<span class="hljs-title class_">ViewGroup</span>) rootView.<span class="hljs-title function_">getParent</span>();<br>            <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;<br>                parent.<span class="hljs-title function_">removeView</span>(rootView);<br>            &#125;<br>        &#125;<br>        <span class="hljs-title function_">initView</span>(rootView);<br>        <span class="hljs-keyword">return</span> rootView;<br>    &#125;<br><br>    <span class="hljs-comment">//  http://www.10tiao.com/html/565/201702/2247483988/1.html</span><br>    <span class="hljs-comment">// 标志位，标志已经初始化完成，因为setUserVisibleHint是在onCreateView之前调用的，</span><br>    <span class="hljs-comment">// 在视图未初始化的时候，在lazyLoad当中就使用的话，就会有空指针的异常</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">boolean</span> isPrepared;<br>    <span class="hljs-comment">//标志当前页面是否可见</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">boolean</span> isVisible;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setUserVisibleHint</span>(<span class="hljs-params"><span class="hljs-built_in">boolean</span> isVisibleToUser</span>) &#123;<br>        <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">setUserVisibleHint</span>(isVisibleToUser);<br><span class="hljs-comment">//        Log.d(TAG + &quot;         Test&quot;, &quot; setUserVisibleHint() is Visible : ?  &quot; + isVisibleToUser);</span><br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">getUserVisibleHint</span>()) &#123;<br>            isVisible = <span class="hljs-literal">true</span>;<br>            <span class="hljs-title function_">onVisible</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            isVisible = <span class="hljs-literal">false</span>;<br>            <span class="hljs-title function_">onInvisible</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onInvisible</span>(<span class="hljs-params"></span>) &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onVisible</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">lazyLoad</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">lazyLoad</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (!isVisible || !isPrepared) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-title function_">requestData</span>();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 请求数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">requestData</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">Log</span>.<span class="hljs-title function_">d</span>(<span class="hljs-variable constant_">TAG</span> + <span class="hljs-string">&quot;         Test&quot;</span>, <span class="hljs-string">&quot; requestData &quot;</span>);<br>    &#125;<br><br><br></code></pre></td></tr></table></figure>

<p> <a target="_blank" rel="noopener" href="http://www.10tiao.com/html/565/201702/2247483988/1.html">http://www.10tiao.com/html/565/201702/2247483988/1.html</a></p>
<h4 id="Activity-dialogFragment-的事件回调"><a href="#Activity-dialogFragment-的事件回调" class="headerlink" title="Activity  dialogFragment 的事件回调"></a>Activity  dialogFragment 的事件回调</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ISelectListener</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getItemPosition</span><span class="hljs-params">(position: <span class="hljs-type">Int</span>)</span></span><br>&#125;<br><br><span class="hljs-keyword">var</span> mListener: ISelectListener? = <span class="hljs-literal">null</span><br><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onAttach</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>)</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onAttach(context)<br>    <span class="hljs-keyword">if</span> (parentFragment <span class="hljs-keyword">is</span> ISelectListener)&#123;<br>        mListener = parentFragment  <span class="hljs-keyword">as</span> ISelectListener<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (context <span class="hljs-keyword">is</span> ISelectListener) &#123;<br>        mListener = context<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> RuntimeException(context!!.toString() + <span class="hljs-string">&quot; must implement ISelectListener&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://developer.android.com/guide/components/fragments.html">https://developer.android.com/guide/components/fragments.html</a></p>
<p>onHiddenChanged切换刷新</p>
<p>使用hide()/show()发现生命周期基本不执行，不过可以用到这个onHiddenChanged();</p>
<p>看下执行的生命周期;   从 SecondFragment 页面开始到 -&gt;FirstFragment </p>
<blockquote>
<p>07-18 15:53:25.128 7758-7758/com.mineutils D/SecondFragment: onAttach(Context context)<br>07-18 15:53:25.129 7758-7758/com.mineutils D/SecondFragment: onCreate()<br>07-18 15:53:25.142 7758-7758/com.mineutils D/SecondFragment: onCreateView()<br>07-18 15:53:25.148 7758-7758/com.mineutils D/SecondFragment:  onViewCreated<br>                                                              onActivityCreated()<br>                                                              onStart()<br>​                                                                  onResume()</p>
<p>07-18 15:53:34.200 7758-7758/com.mineutils D/SecondFragment: onHiddenChanged hidden   true<br>07-18 15:53:34.207 7758-7758/com.mineutils D/FirstFragment:    onCreateView()<br>07-18 15:53:34.208 7758-7758/com.mineutils D/FirstFragment:    onViewCreated<br>                                                            onActivityCreated()<br>​                                                           onStart()</p>
<p>07-18 15:53:53.968 7758-7758/com.mineutils D/FirstFragment: onHiddenChanged hidden   true<br>07-18 15:53:53.968 7758-7758/com.mineutils D/SecondFragment: onHiddenChanged hidden   false</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/cml_blog/article/details/41411451">https://blog.csdn.net/cml_blog/article/details/41411451</a></p>
<h4 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h4><p><a target="_blank" rel="noopener" href="https://wizardforcel.gitbooks.io/w3school-android/content/77.html">https://wizardforcel.gitbooks.io/w3school-android/content/77.html</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5901b564570c35005804424b">https://juejin.im/post/5901b564570c35005804424b</a></p>
<h4 id="Fragment-not-attached-to-a-context"><a href="#Fragment-not-attached-to-a-context" class="headerlink" title="Fragment not attached to a context"></a>Fragment not attached to a context</h4><p><a target="_blank" rel="noopener" href="https://weidianhuang.medium.com/android-fragment-not-attached-to-a-context-24d00fac4f3d">https://weidianhuang.medium.com/android-fragment-not-attached-to-a-context-24d00fac4f3d</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://noteforme.github.io/2022/09/15/Fragment-StateLoss/" data-id="clce8xxqg0003k79k7ry73nwc" data-title="Fragment_StateLoss" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Fragment/" rel="tag">Fragment</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-LC-TREE08" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/09/11/LC-TREE08/" class="article-date">
  <time class="dt-published" datetime="2022-09-11T07:39:49.000Z" itemprop="datePublished">2022-09-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/DataStructure/">DataStructure</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/09/11/LC-TREE08/">LC_TREE08</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></h4><h5 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h5><p>层序遍历是没法实现的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isSymmetric3</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.offer(root)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">            <span class="keyword">val</span> layerSize = queue.size</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until layerSize) &#123;</span><br><span class="line"><span class="comment">//                val lastIndex = layerSize - 1 - i // 这样不可以,poll取出元素后，就少了元素越界了</span></span><br><span class="line">                <span class="keyword">val</span> headNode = queue.poll()</span><br><span class="line"></span><br><span class="line">                <span class="keyword">val</span> lastNode = queue.lastOrNull()</span><br><span class="line">                <span class="keyword">if</span> (headNode.`<span class="keyword">val</span>` != lastNode?.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">                headNode.left?.let &#123; queue.offer(it) &#125;</span><br><span class="line">                headNode.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><p>// 不能判断true,判断true直接返回了，判断false返回没问题，true返回就不会往下走了</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">leftRightSymmetric</span><span class="params">(nodeLeft: <span class="type">TreeNode</span>?, nodeRight: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nodeLeft?.`<span class="keyword">val</span>` == nodeRight?.`<span class="keyword">val</span>`) &#123; <span class="comment">// 不能判断true,判断true直接返回了，判断false返回没问题，true返回就不会往下走了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeLeft == nodeRight) &#123; <span class="comment">// = null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    leftRightSymmetric(nodeLeft?.left, nodeRight?.right)</span><br><span class="line">    leftRightSymmetric(nodeLeft?.right, nodeRight?.left)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E9%80%92%E5%BD%92%E6%B3%95">https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E9%80%92%E5%BD%92%E6%B3%95</a></p>
<p>从根节点的左右子树开始，深度遍历比较</p>
<p><img src="https://img-blog.csdnimg.cn/20210203144624414.png"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isSymmetric</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> leftRightSymmetric(root?.left, root?.right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">leftRightSymmetric</span><span class="params">(nodeLeft: <span class="type">TreeNode</span>?, nodeRight: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nodeLeft == <span class="literal">null</span> &amp;&amp; nodeRight != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeLeft != <span class="literal">null</span> &amp;&amp; nodeRight == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeLeft?.`<span class="keyword">val</span>` != nodeRight?.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeLeft == <span class="literal">null</span> &amp;&amp; nodeRight == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">//这里需要，否则就递归 溢出了,如果根节点的左右节点为null,退出也是没问题的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> leftFlag = leftRightSymmetric(nodeLeft?.left, nodeRight?.right)</span><br><span class="line">    <span class="keyword">val</span> rightFlag = leftRightSymmetric(nodeLeft?.right, nodeRight?.left)</span><br><span class="line">    <span class="keyword">return</span> leftFlag &amp;&amp; rightFlag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnwcimlj8lg30hm0bqnpd.gif"></p>
<p>队列，一直向下按照对称的条件添加</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isSymmetric1</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123; </span><br><span class="line">        root.left?.let &#123; queue.offer(it) &#125; <span class="comment">// 官方解法中，根节点入队2次也可以</span></span><br><span class="line">        root.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> node1 = queue.poll()</span><br><span class="line">        <span class="keyword">val</span> node2 = queue.poll()</span><br><span class="line">        <span class="keyword">if</span>(node1==<span class="literal">null</span>&amp;&amp;node2==<span class="literal">null</span>)&#123; <span class="comment">// 一开始没写这个条件，提示超出时间限制</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node1?.`<span class="keyword">val</span>` != node2?.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        queue.offer(node1?.left) <span class="comment">// 两边的节点比较</span></span><br><span class="line">        queue.offer(node2?.right)</span><br><span class="line">        queue.offer(node1?.right) <span class="comment">//中间的节点比较</span></span><br><span class="line">        queue.offer(node2?.left)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>栈也是可以的，只要保证位置靠近</p>
<h4 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/same-tree/">100. 相同的树</a></h4><h5 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isSameTree</span><span class="params">(p: <span class="type">TreeNode</span>?, q: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span> &amp;&amp; q != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p?.`<span class="keyword">val</span>` == q?.`<span class="keyword">val</span>` &amp;&amp; isSameTree(p?.left, q?.left) &amp;&amp; isSameTree(p?.right, q?.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="队列-1"><a href="#队列-1" class="headerlink" title="队列"></a>队列</h5><img src="/2022/09/11/LC-TREE08/20220912130345.jpg" alt="20220912130345" style="zoom: 67%;">

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isSameTree1</span><span class="params">(p: <span class="type">TreeNode</span>?, q: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span> &amp;&amp; q != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    queue.offer(p)</span><br><span class="line">    queue.offer(q)</span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> node1 = queue.poll()</span><br><span class="line">        <span class="keyword">val</span> node2 = queue.poll()</span><br><span class="line">        <span class="keyword">if</span> (node1 == <span class="literal">null</span> &amp;&amp; node2 == <span class="literal">null</span>) &#123; <span class="comment">// continue后，因为null,就不会加入新的节点</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node1?.`<span class="keyword">val</span>` != node2?.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        queue.offer(node1?.left)</span><br><span class="line">        queue.offer(node2?.left)</span><br><span class="line">        queue.offer(node1?.right)</span><br><span class="line">        queue.offer(node2?.right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="572-另一棵树的子树"><a href="#572-另一棵树的子树" class="headerlink" title="572. 另一棵树的子树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subtree-of-another-tree/">572. 另一棵树的子树</a></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isSubtree</span><span class="params">(root: <span class="type">TreeNode</span>?, subRoot: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span> &amp;&amp; subRoot == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root == <span class="literal">null</span> &amp;&amp; subRoot != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root != <span class="literal">null</span> &amp;&amp; subRoot == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isSameTree(root, subRoot) || isSubtree(root?.left, subRoot) || isSubtree(root?.right, subRoot) <span class="comment">//subRoot和root相同,subRoot和root左子树相同，subRoot和右子树相同</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isSameTree</span><span class="params">(node1: <span class="type">TreeNode</span>?, node2: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node1 == <span class="literal">null</span> &amp;&amp; node2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node1 == <span class="literal">null</span> &amp;&amp; node2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node1 != <span class="literal">null</span> &amp;&amp; node2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node1?.`<span class="keyword">val</span>` == node2?.`<span class="keyword">val</span>` &amp;&amp; isSameTree(node1?.left, node2?.left) &amp;&amp; isSameTree(</span><br><span class="line">        node1?.right,</span><br><span class="line">        node2?.right</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h4><h5 id="DFS-普通二叉树解法"><a href="#DFS-普通二叉树解法" class="headerlink" title="DFS 普通二叉树解法"></a>DFS 普通二叉树解法</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countNodes</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> leftCount = countNodes(root.left)</span><br><span class="line">    <span class="keyword">val</span> rightCount = countNodes(root.right)</span><br><span class="line">    <span class="keyword">return</span> leftCount + rightCount + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countNodes1</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.offer(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> size = queue.size</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until size) &#123;</span><br><span class="line">            <span class="keyword">val</span> treeNode = queue.poll()</span><br><span class="line">            count++</span><br><span class="line">            treeNode.left?.let &#123; queue.offer(it) &#125;</span><br><span class="line">            treeNode.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="DFS-完全二叉树特性"><a href="#DFS-完全二叉树特性" class="headerlink" title="DFS 完全二叉树特性"></a>DFS 完全二叉树特性</h5><p>一开始打算用先序遍历，但是这样不行,</p>
<p>如果一颗树 是平衡的，永远是得到 1,  想了一下，这种也不属于 先序遍历</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countNodes</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> depth = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> postTraversal(root, depth)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">postTraversal</span><span class="params">(root: <span class="type">TreeNode</span>?, depth: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isBalanced(root)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> shl (depth - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> leftNums = postTraversal(root?.left, depth + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> rightNums = postTraversal(root?.right, depth + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> leftNums + rightNums + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countNodes</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> leftNode = root.left</span><br><span class="line">    <span class="keyword">var</span> depthLeft = <span class="number">0</span> <span class="comment">//左子树深度</span></span><br><span class="line">    <span class="keyword">while</span> (leftNode != <span class="literal">null</span>) &#123;</span><br><span class="line">        leftNode = leftNode.left</span><br><span class="line">        depthLeft++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> rightNode = root.right</span><br><span class="line">    <span class="keyword">var</span> depthRight = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (rightNode != <span class="literal">null</span>) &#123;</span><br><span class="line">        rightNode = rightNode.right</span><br><span class="line">        depthRight++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (depthLeft == depthRight) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">2</span> shl depthLeft) - <span class="number">1</span> <span class="comment">// 节点数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> leftNums = countNodes(root.left)</span><br><span class="line">    <span class="keyword">val</span> rightNums = countNodes(root.right)</span><br><span class="line">    <span class="keyword">return</span> leftNums + rightNums + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countNodes3</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> leftNode = root.left</span><br><span class="line">    <span class="keyword">var</span> depthLeft = <span class="number">0</span> <span class="comment">//左子树深度</span></span><br><span class="line">    <span class="keyword">while</span> (leftNode != <span class="literal">null</span>) &#123;</span><br><span class="line">        leftNode = leftNode.left</span><br><span class="line">        depthLeft++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> rightNode = root.right</span><br><span class="line">    <span class="keyword">var</span> depthRight = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (rightNode != <span class="literal">null</span>) &#123;</span><br><span class="line">        rightNode = rightNode.right</span><br><span class="line">        depthRight++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> leftNums = countNodes(root.left)</span><br><span class="line">    <span class="keyword">val</span> rightNums = countNodes(root.right)</span><br><span class="line">    <span class="keyword">if</span> (depthLeft == depthRight) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">2</span> shl depthLeft) - <span class="number">1</span> <span class="comment">// 节点数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> leftNums + rightNums + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树</a></h4><p>一开始错误的解答是这样的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isBalanced</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> postTraversal(root) != -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">postTraversal</span><span class="params">(node: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> leftDepth = postTraversal(node.left)</span><br><span class="line">        <span class="keyword">val</span> rightDepth = postTraversal(node.right)</span><br><span class="line">        <span class="keyword">val</span> isBalance = Math.abs(leftDepth - rightDepth) &lt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (isBalance) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(leftDepth, rightDepth) + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里问题是   return -1，作为父节点的深度返回给了 depth，然后继续计算 Math.abs(leftDepth - rightDepth) &lt;= 1，出现了问题</p>
<p>改进解法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isBalanced</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> postTraversal(root) != -<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">postTraversal</span><span class="params">(node: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> leftDepth = postTraversal(node.left)</span><br><span class="line">    <span class="keyword">val</span> rightDepth = postTraversal(node.right)</span><br><span class="line">    <span class="keyword">if</span> (leftDepth == -<span class="number">1</span> || rightDepth == -<span class="number">1</span>) &#123; <span class="comment">// 子节点已经有不是平衡的节点 直接返回，来判断</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> isBalance = Math.abs(leftDepth - rightDepth) &lt;= <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (isBalance) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftDepth, rightDepth) + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>随想录迭代遍历，看起来很复杂，看起来是统一解法.</p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E9%A2%98%E5%A4%96%E8%AF%9D">https://programmercarl.com/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E9%A2%98%E5%A4%96%E8%AF%9D</a></p>
<h4 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-paths/">257. 二叉树的所有路径</a></h4><h5 id="隐藏回溯过程"><a href="#隐藏回溯过程" class="headerlink" title="隐藏回溯过程"></a>隐藏回溯过程</h5><p>这一题 没理解透字符串怎么形成的和回溯的, 用到了先序遍历，</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ZG411G7Dh">https://www.bilibili.com/video/BV1ZG411G7Dh</a> 视频包含了回溯过程</p>
<p> 可以看下随想录回溯过程</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">binaryTreePaths</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: List&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> result = LinkedList&lt;String&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    dfs(root, result, root.`<span class="keyword">val</span>`.toString())</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://www.youtube.com/watch?v=swG70SQBJ-A</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. String不能用 StringBuilder,存在引用传递问题，会输出</span></span><br><span class="line"><span class="comment"> *    [&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;2-&gt;5-&gt;3&quot;]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. 在先序位置 val存到path也有问题,头节点会存在重复的情况 [&quot;1-&gt;1-&gt;2-&gt;5&quot;,&quot;1-&gt;1-&gt;2-&gt;5-&gt;3&quot;]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(node: <span class="type">TreeNode</span>?, result: <span class="type">LinkedList</span>&lt;<span class="type">String</span>&gt;, path: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        result.add(path)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        dfs(node.left, result, <span class="string">&quot;<span class="variable">$path</span>-&gt;<span class="subst">$&#123;node.left.`val`&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        dfs(node.right, result, <span class="string">&quot;<span class="variable">$path</span>-&gt;<span class="subst">$&#123;node.right.`val`&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面2的情况演示</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(node: <span class="type">TreeNode</span>?, result: <span class="type">LinkedList</span>&lt;<span class="type">String</span>&gt;, path: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">val</span> mPath = <span class="string">&quot;<span class="variable">$path</span>-&gt; <span class="subst">$&#123;node.`val`&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        result.add(mPath)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        dfs(node.left, result, mPath)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        dfs(node.right, result, mPath)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面两种写法，回溯隐藏在参数里面.</p>
<h5 id="显示回溯"><a href="#显示回溯" class="headerlink" title="显示回溯"></a>显示回溯</h5><p>这是随想录的代码，二刷可以自己写, </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">binaryTreePaths</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: List&lt;String&gt;? &#123;</span><br><span class="line">    <span class="keyword">val</span> res: MutableList&lt;String&gt; = ArrayList()</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> paths: MutableList&lt;<span class="built_in">Int</span>&gt; = ArrayList()</span><br><span class="line">    traversal(root, paths, res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">traversal</span><span class="params">(root: <span class="type">TreeNode</span>, paths: <span class="type">MutableList</span>&lt;<span class="type">Int</span>&gt;, res: <span class="type">MutableList</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    paths.add(root.`<span class="keyword">val</span>`)</span><br><span class="line">    <span class="comment">// 叶子结点</span></span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123; <span class="comment">// 碰到叶子节点，开始把path遍历放进string中 </span></span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        <span class="keyword">val</span> sb = StringBuilder()</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until paths.size - <span class="number">1</span>) &#123;</span><br><span class="line">            sb.append(paths[i]).append(<span class="string">&quot;-&gt;&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(paths[paths.size - <span class="number">1</span>]) <span class="comment">//也可以放到上面一起再把&quot;-&gt;&quot; 删除</span></span><br><span class="line">        res.add(sb.toString()) </span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        traversal(root.left, paths, res)</span><br><span class="line">        paths.removeAt(paths.size - <span class="number">1</span>) <span class="comment">// 回溯  </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        traversal(root.right, paths, res)</span><br><span class="line">        paths.removeAt(paths.size - <span class="number">1</span>) <span class="comment">// 回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paths.removeAt(paths.size - 1) 最初这里没理解，都删除了，为什么,上面还能遍历所有节点，其实递归是一致先走的，碰到叶子节点的时候，遍历path, 最后才开始 paths.removeAt(paths.size - 1) 回溯 到上面. </span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html">https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ZG411G7Dh">https://www.bilibili.com/video/BV1ZG411G7Dh</a></p>
<p>迭代法 后面再说吧</p>
<h4 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404. 左叶子之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-left-leaves/">404. 左叶子之和</a></h4><p>这一题和【 222 完全二叉树的节点个数】很像，这里是普通的二叉树，所以我的想法就前两种做法</p>
<ol>
<li>后序遍历</li>
<li>层序遍历</li>
</ol>
<p>把根节点换成左子树的节点</p>
<p>看错了题目，其实是左子树叶子值的和</p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C.html#%E6%80%9D%E8%B7%AF">https://programmercarl.com/0404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C.html#%E6%80%9D%E8%B7%AF</a></p>
<p>只看了随想录题解，自己这样写的代码</p>
<h5 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sumOfLeftLeaves</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> dfsLeaves(root, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> direction 0 右子树， 1：左子树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dfsLeaves</span><span class="params">(node: <span class="type">TreeNode</span>?, direction: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span> &amp;&amp; direction == <span class="number">1</span>) &#123; <span class="comment">// 左右子树为空，根据父亲节点的传入，判断它是左子树</span></span><br><span class="line">        <span class="keyword">return</span> node.`<span class="keyword">val</span>` <span class="comment">//这种情况返回值，根据后序规则，上层节点叠加</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> leftCount = dfsLeaves(node.left, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> rightCount = dfsLeaves(node.right, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> leftCount + rightCount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>看了随想录解法，可以直接看更下一层节点，就不用再传入方向了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">          leftValue = root-&gt;left-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>迭代法</p>
<p>随想录统一迭代法</p>
<h4 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513. 找树左下角的值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513. 找树左下角的值</a></h4><p>想了下</p>
<ol>
<li>层序遍历可以解决</li>
<li>递归法还没想道，到了最底层，没想到如何判断 哪个是最左边的。</li>
</ol>
<h5 id="BFS-1"><a href="#BFS-1" class="headerlink" title="BFS"></a>BFS</h5><p>先存下来每一层的第一个节点，知道queue为空，那么最后一层的头节点就是要返回的.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findBottomLeftValue1</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.offer(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> leftNodeVal = root?.`<span class="keyword">val</span>`</span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> size = queue.size</span><br><span class="line">        leftNodeVal = queue.peek().`<span class="keyword">val</span>` <span class="comment">//每一层的第一个节点</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until size) &#123;</span><br><span class="line">            <span class="keyword">val</span> node = queue.poll()</span><br><span class="line">            node?.left?.let &#123; queue.offer(it) &#125;</span><br><span class="line">            node?.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> leftNodeVal!! <span class="comment">// queue为empty的时候退出，此时上一层存的节点就是最左边的节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h5><p>My idea</p>
<ol>
<li><p>一开始以为树的层级里，树的左边的值小于右边，来得出结果，但是这是二叉树，不是平衡形的，即使平衡这种思路也不一定对.</p>
</li>
<li><p>然后又看了树结构,想了下可以用 inorder traversal ,中序遍历, 层数最深，然后最先得到的数据就是要拿到的结果. </p>
<p>想下面8肯定是后面遍历到的</p>
</li>
</ol>
<p><img src="/2022/09/11/LC-TREE08/20220924155016.jpg" alt="20220924155016"></p>
<ol>
<li>一开始不知道leetcode可以用全局变量，用对象返回还很麻烦，删掉了</li>
<li>判断层级，如果大于之前的深度，那么就更新深度和值</li>
<li>中序和后序肯定没问题，但是先序不确定（随想录说是可以的）而且随想录 depth + 1 展开了用回溯</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mDepth = <span class="number">0</span> <span class="comment">//一开始不知道leetcode可以用全局变量，用对象返回还很麻烦，删掉了</span></span><br><span class="line"><span class="keyword">var</span> result = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findBottomLeftValue</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    inOrderTraversal(root, mDepth)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最左边的节点最先访问到</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">inOrderTraversal</span><span class="params">(node: <span class="type">TreeNode</span>?, depth: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">    inOrderTraversal(node.left, depth + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> (depth + <span class="number">1</span> &gt; mDepth) &#123; <span class="comment">// 判断层级，如果大于之前的深度，那么就更新深度和值</span></span><br><span class="line">        mDepth = depth + <span class="number">1</span></span><br><span class="line">        result = node.`<span class="keyword">val</span>`</span><br><span class="line">    &#125;</span><br><span class="line">    inOrderTraversal(node.right, depth + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum/">112. 路径总和</a></h4><p>解决所有二叉树路径的问题文章</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-ii/solution/yi-pian-wen-zhang-jie-jue-suo-you-er-cha-oo63/">https://leetcode.cn/problems/path-sum-ii/solution/yi-pian-wen-zhang-jie-jue-suo-you-er-cha-oo63/</a></p>
<p>这一题和  [112. 路径总和]  类似</p>
<p>使用回溯写法，因为添加和删除，回溯的规则，那么感觉用栈比较合适.</p>
<ol>
<li>终止条件就是 到达了叶子节点，此时开始计算当前路径和 是否满足条件</li>
<li>手写判断是否有左子树，有的话继续判断，又继续preOrderTraversal, 这里用的是先序遍历,方法查看条件</li>
<li>遍历完叶子节点后判断，此时这条路径完成，开始回溯，回退上一层preOrderTraversal，继续判断右子树</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">hasPathSum</span><span class="params">(root: <span class="type">TreeNode</span>?, targetSum: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> pathStack = Stack&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        pathStack.push(root.`<span class="keyword">val</span>`) <span class="comment">// root需要放在遍历外面，否则会push多次</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">//按照前面的规则 root==null ,0 应该是对的,但是题目说false,就单独加一句</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> preOrderTraversal(root, targetSum, pathStack) <span class="comment">// pathstack必须传进去，否则每次都new</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">preOrderTraversal</span><span class="params">(root: <span class="type">TreeNode</span>?, targetSum: <span class="type">Int</span>, pathStack: <span class="type">Stack</span>&lt;<span class="type">Int</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root?.left == <span class="literal">null</span> &amp;&amp; root?.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> pathSum = <span class="number">0</span></span><br><span class="line">        pathStack.forEach &#123;</span><br><span class="line">            pathSum += it</span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;pathSum <span class="variable">$pathSum</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (pathSum == targetSum) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root?.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        pathStack.push(root.left.`<span class="keyword">val</span>`) <span class="comment">// 有左节点，加入当前路径</span></span><br><span class="line">        <span class="keyword">if</span> (preOrderTraversal(root.left, targetSum, pathStack)) &#123; <span class="comment">//有路径是和 == targetSum 直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        pathStack.pop()  <span class="comment">// 不会直接把上面的回退了，需要上一句遍历执行完回退后，才把自己回退了，此时已经到了叶子判断了 root?.left == null &amp;&amp; root?.right == null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root?.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        pathStack.push(root.right.`<span class="keyword">val</span>`)</span><br><span class="line">        <span class="keyword">if</span> (preOrderTraversal(root.right, targetSum, pathStack)) &#123; <span class="comment">//有路径是和 == targetSum 直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        pathStack.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">hasPathSum1</span><span class="params">(root: <span class="type">TreeNode</span>?, targetSum: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">//按照前面的规则 root==null ,0 应该是对的,但是题目说false,就单独加一句</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> pathSum = root.`<span class="keyword">val</span>`</span><br><span class="line">    <span class="keyword">return</span> preOrderDFS(root, pathSum, targetSum) <span class="comment">// pathstack必须传进去，否则每次都new</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">preOrderDFS</span><span class="params">(node: <span class="type">TreeNode</span>, pathSum: <span class="type">Int</span>, targetSum: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> nodeValue = node.`<span class="keyword">val</span>`</span><br><span class="line">    println(<span class="string">&quot;nodeValue <span class="variable">$nodeValue</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span> &amp;&amp; targetSum == pathSum) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">if</span> (preOrderDFS(node.left, pathSum + node.left.`<span class="keyword">val</span>`, targetSum)) &#123; <span class="comment">// 这个直接放回，容易忘了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">if</span> (preOrderDFS(node.right, pathSum + node.right.`<span class="keyword">val</span>`, targetSum)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II</a></h4><p>如果是找路径和等于给定target的路径的，那么可以不用新增一个临时变量cursum来判断当前路径和，<br>只需要用给定和target减去节点值，最终结束条件判断target==0即可</p>
<h5 id="DFS-1"><a href="#DFS-1" class="headerlink" title="DFS"></a>DFS</h5><p>这一题的思路和前面的差不多，就是他要求返回所有符合条件的集合，所以直接添加值觉得不合适，除非多加一个参数，不加一个参数就不好弄。</p>
<p>//这种解法要注意 值引用问题，即使最初加入到resultList的pathList是正确的，后序的回退也会把值给修改了.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> resultList = LinkedList&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">pathSum</span><span class="params">(root: <span class="type">TreeNode</span>?, targetSum: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> resultList</span><br><span class="line">    <span class="keyword">val</span> stackList = Stack&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    stackList.add(root.`<span class="keyword">val</span>`)</span><br><span class="line">    preDFS(root, stackList, targetSum)</span><br><span class="line">    <span class="keyword">return</span> resultList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">preDFS</span><span class="params">(node: <span class="type">TreeNode</span>, pathList: <span class="type">Stack</span>&lt;<span class="type">Int</span>&gt;, targetSum: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = node.`<span class="keyword">val</span>`</span><br><span class="line">    println(<span class="keyword">data</span>)</span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span> &amp;&amp; pathSum(pathList) == targetSum) &#123;</span><br><span class="line">        resultList.add(pathList.toMutableList().toList()) <span class="comment">// 注意引用传递</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        pathList.push(node.left.`<span class="keyword">val</span>`)</span><br><span class="line">        preDFS(node.left, pathList, targetSum)</span><br><span class="line">        pathList.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        pathList.push(node.right.`<span class="keyword">val</span>`)</span><br><span class="line">        preDFS(node.right, pathList, targetSum)</span><br><span class="line">        pathList.pop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">pathSum</span><span class="params">(pathList: <span class="type">Stack</span>&lt;<span class="type">Int</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    pathList.forEach &#123;</span><br><span class="line">        sum += it</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这一题的官方DFS解法没看懂，感觉不好理解.</p>
<p>这是看完官方写法自己写的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> pathList = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">pathSum1</span><span class="params">(root: <span class="type">TreeNode</span>?, targetSum: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> resultList</span><br><span class="line">    <span class="keyword">val</span> stackList = Stack&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    stackList.add(root.`<span class="keyword">val</span>`)</span><br><span class="line">    preTraversal(root, targetSum - root.`<span class="keyword">val</span>`)</span><br><span class="line">    <span class="keyword">return</span> resultList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">preTraversal</span><span class="params">(node: <span class="type">TreeNode</span>?, targetSum: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = node.`<span class="keyword">val</span>`</span><br><span class="line">    println(<span class="keyword">data</span>)</span><br><span class="line">    pathList.offer(node.`<span class="keyword">val</span>`)</span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span> &amp;&amp; targetSum == <span class="number">0</span>) &#123;</span><br><span class="line">        resultList.add(pathList.toMutableList())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="literal">null</span>)</span><br><span class="line">        preTraversal(node.left, targetSum - node.left.`<span class="keyword">val</span>`)</span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="literal">null</span>)</span><br><span class="line">        preTraversal(node.right, targetSum - node.right.`<span class="keyword">val</span>`)</span><br><span class="line">    pathList.pop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这是官方解法，也很棒</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">pathSum2</span><span class="params">(root: <span class="type">TreeNode</span>?, targetSum: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> resultList</span><br><span class="line">    <span class="keyword">val</span> stackList = Stack&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    stackList.add(root.`<span class="keyword">val</span>`)</span><br><span class="line">    preDFSTraversal(root, targetSum)</span><br><span class="line">    <span class="keyword">return</span> resultList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">preDFSTraversal</span><span class="params">(node: <span class="type">TreeNode</span>?, targetSum: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = node.`<span class="keyword">val</span>`</span><br><span class="line">    println(<span class="keyword">data</span>)</span><br><span class="line">    <span class="keyword">val</span> targetSum = targetSum - node.`<span class="keyword">val</span>`</span><br><span class="line">    pathList.offer(node.`<span class="keyword">val</span>`)</span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span> &amp;&amp; targetSum == <span class="number">0</span>) &#123;</span><br><span class="line">        resultList.add(pathList.toMutableList())</span><br><span class="line">    &#125;</span><br><span class="line">    preDFSTraversal(node.left, targetSum)</span><br><span class="line">    preDFSTraversal(node.right, targetSum)</span><br><span class="line">    pathList.pop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>官方BFS 就很不好理解</p>
<h3 id="构建树"><a href="#构建树" class="headerlink" title="构建树"></a>构建树</h3><p>先序，中序</p>
<p>后序，中序</p>
<p>inOrder         [L, 3 ,R ]</p>
<p>PostOrder     [L, R, 3] </p>
<p>PreOrder       [3,L ,R]<br>可以看到 只有PostOrder ,PreOrder左右是分不清的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> 			1    					1 </span><br><span class="line"> 		2									2</span><br><span class="line">  3											3</span><br><span class="line">  </span><br><span class="line">PreOrder  1,2,3				PreOrder  1,2,3</span><br><span class="line">PostOrder 3,2,1 			PostOrder 3,2,1</span><br></pre></td></tr></table></figure>



<h4 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h4><p>效率低，但是好理解的方法</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1pp4y1k75Q/">https://www.bilibili.com/video/BV1pp4y1k75Q/</a></p>
<p>为什么post右子树是从 , [i , n-1],因为他是后序遍历，所以从 i开始</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inorder &#x3D; 	[9,3,15,20,7]</span><br><span class="line">postorder &#x3D; [9,15,7,20,3]</span><br></pre></td></tr></table></figure>

<ol>
<li><p>根据后序postorder 得到root 3, 然后根据中序知道 left branch [9] , right branch [15 , 20 , 7]</p>
</li>
<li><p>根据 left branch 的9,可以把 postorder后序分成[9], [15 , 20 , 7]两部分</p>
</li>
<li><p>然后 inorder= [15 , 20 , 7] , postorder=[15 , 20 , 7] 继续进行遍历</p>
</li>
</ol>
<p>总的来说，就是这样</p>
<ol>
<li>确定终止条件</li>
<li>构造节点</li>
<li>构造左子树， 构造右子树</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">buildTree</span><span class="params">(inorder: <span class="type">IntArray</span>, postorder: <span class="type">IntArray</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (inorder.isEmpty() &amp;&amp; postorder.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> node = TreeNode(postorder[postorder.size - <span class="number">1</span>]) <span class="comment">//postorder.size用的地方多，可以提取出来</span></span><br><span class="line">    <span class="keyword">val</span> index = getIndex(node, inorder)</span><br><span class="line">    node.left = buildTree(inorder.copyOfRange(<span class="number">0</span>, index), postorder.copyOfRange(<span class="number">0</span>, index)) <span class="comment">// copyOfRange数组效率低</span></span><br><span class="line">    node.right = buildTree(</span><br><span class="line">        inorder.copyOfRange(index + <span class="number">1</span>, inorder.size), postorder.copyOfRange(index, postorder.size - <span class="number">1</span>)</span><br><span class="line">    ) <span class="comment">// 注意copyOfRange(0,2)获取的是index 0,1两个元素</span></span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getIndex</span><span class="params">(node: <span class="type">TreeNode</span>, inorder: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> inorder.indices) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.`<span class="keyword">val</span>` == inorder[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h5><p>写出来还有问题,先pass这题耗时太久了,边界不好掌握可以考虑用日志调试</p>
<p>还可以再看下随想录的视频讲解</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1vW4y1i7dn">https://www.bilibili.com/video/BV1vW4y1i7dn</a></p>
<p>随想录代码优化前的写法，和上面代码写法是一样的，只是用了C++语言</p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html">https://programmercarl.com/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html</a></p>
<p>最初错误的解法,上面的解法数组有变化所以 end位置就是数组的大小，但是这里不同，数组是没变化，就不能这样做</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 数组不变，只改变下标</span><br><span class="line">private fun buildDFSTree(</span><br><span class="line">    inorder: IntArray,</span><br><span class="line">    postorder: IntArray,</span><br><span class="line">    inStart: Int,</span><br><span class="line">    inEnd: Int,</span><br><span class="line">    postStart: Int,</span><br><span class="line">    postEnd: Int</span><br><span class="line">): TreeNode? &#123;</span><br><span class="line">    if (inStart &gt; inEnd || postStart &gt; postEnd || inEnd &lt; 0 || postEnd &lt; 0) &#123;</span><br><span class="line">        return null</span><br><span class="line">    &#125;</span><br><span class="line">    val node &#x3D; TreeNode(postorder[postEnd]) &#x2F;&#x2F;postorder.size用的地方多，可以提取出来</span><br><span class="line">    val index &#x3D; getIndex(node, inorder)</span><br><span class="line"></span><br><span class="line">    node.left &#x3D; buildDFSTree(inorder, postorder, inStart, index - 1, 0, index - 1)   &#x2F;&#x2F;[0,index) 左闭右开</span><br><span class="line">    node.right &#x3D; buildDFSTree(inorder, postorder, index + 1, inEnd, index + 1, postEnd)</span><br><span class="line">    return node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这一题花了不少时间，思路不难，主要是 切割后序的数组的时候，左右子树的边界值不好处理,</p>
<ol>
<li>map用来存储，中序value值和position的对应关系，这里value应该是唯一的.</li>
<li>采用的是左闭右闭的方案，所以inStart &gt; inEnd 不能用 &gt;=, 否则return了，叶子节点无法构造出来.</li>
<li>根据后序root节点，分割中序数组，拿到左子树后，再用左子树树的分割后序数组,因为左子树的长度是一样的。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> map = HashMap&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">buildTree1</span><span class="params">(inorder: <span class="type">IntArray</span>, postorder: <span class="type">IntArray</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (inorder.isEmpty() &amp;&amp; postorder.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> inStart = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> inEnd = inorder.size - <span class="number">1</span></span><br><span class="line">    <span class="keyword">val</span> postStart = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> postEnd = postorder.size - <span class="number">1</span></span><br><span class="line">    inorder.forEachIndexed &#123; position, item -&gt;</span><br><span class="line">        map[item] = position</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buildDFSTree(inStart, inEnd, postStart, postEnd, inorder, postorder)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组不变，只改变下标</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">buildDFSTree</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    inStart: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    inEnd: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    postStart: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    postEnd: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    inorderArr: <span class="type">IntArray</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    postorderArr: <span class="type">IntArray</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: TreeNode? &#123;</span><br><span class="line">    println(<span class="string">&quot; inStart <span class="variable">$inStart</span> inEnd <span class="variable">$inEnd</span>  postStart <span class="variable">$postStart</span> postEnd <span class="variable">$postEnd</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> (inStart &gt; inEnd || postStart &gt; postEnd) &#123; <span class="comment">// 因为是左闭右闭的方案，所以这里不能用 &gt;= ,否则叶子节点无法构造出来</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> node = TreeNode(postorderArr[postEnd]) <span class="comment">//postorder.size用的地方多，可以提取出来</span></span><br><span class="line">    <span class="keyword">val</span> index = map[postorderArr[postEnd]] ?: <span class="number">0</span> <span class="comment">// 这里要改</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切割左子树,这种坐标定义好更清晰</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> leftInBegin = inStart</span><br><span class="line">    <span class="keyword">val</span> leftInEnd = index - <span class="number">1</span> <span class="comment">// 左闭右闭</span></span><br><span class="line">    <span class="keyword">val</span> leftPostBegin = postStart</span><br><span class="line">    <span class="keyword">val</span> leftPostEnd = postStart + (index - inStart - <span class="number">1</span>) <span class="comment">//(index - inStart) 左子树的长度, 因为选择是左闭右闭的方案，所以自身也-1</span></span><br><span class="line"></span><br><span class="line">    node.left = buildDFSTree(</span><br><span class="line">        leftInBegin, leftInEnd, leftPostBegin, leftPostEnd,</span><br><span class="line">        inorderArr,</span><br><span class="line">        postorderArr</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切割右子树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> rightInBegin = index + <span class="number">1</span></span><br><span class="line">    <span class="keyword">val</span> rightInEnd = inEnd</span><br><span class="line">    <span class="keyword">val</span> rightPostBegin = postStart + index - inStart <span class="comment">//(index - inStart) 这里不用-1,因为左子树的右边就是右子树，所以右子树就是从这个位置开始的</span></span><br><span class="line">    <span class="keyword">val</span> rightPostEnd = postEnd - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    node.right = buildDFSTree(</span><br><span class="line">        rightInBegin, rightInEnd, rightPostBegin, rightPostEnd,</span><br><span class="line">        inorderArr,</span><br><span class="line">        postorderArr</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>官方</p>
<p>先构建右子树的想法好巧妙，要是先构建的是左子树还有个确定后序区间的步骤。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution/cong-zhong-xu-yu-hou-xu-bian-li-xu-lie-gou-zao-14/">https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution/cong-zhong-xu-yu-hou-xu-bian-li-xu-lie-gou-zao-14/</a></p>
<p>官方解法很妙，根据后序数组pop，post_idx–;先开始右子树,然后左子树,构造方法也很简单，这样不用找后序数组的 开始和结束位置在哪. 做了上面的解法，也就是这个后序的边界值最难搞. 这种方式直接给省去了。</p>
<p>不得不说太妙了</p>
<p><img src="https://assets.leetcode-cn.com/solution-static/106/6.png"></p>
<p>官方迭代法后面再看吧 。</p>
<h4 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654. 最大二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-binary-tree/">654. 最大二叉树</a></h4><p>输入：nums = [3,2,1,6,0,5]<br>输出：[6,3,5,null,2,0,null,null,1]<br>解释：递归调用如下所示：</p>
<p>[3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。</p>
<ul>
<li>[3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。 ,3的左边是[]没有节点, 右边是[0,5],所以树也是这样构造的.<ul>
<li>空数组，无子节点。</li>
<li>[2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。<ul>
<li>空数组，无子节点。</li>
<li>只有一个元素，所以子节点是一个值为 1 的节点。</li>
</ul>
</li>
</ul>
</li>
<li>[0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。<ul>
<li>只有一个元素，所以子节点是一个值为 0 的节点。</li>
<li>空数组，无子节点。</li>
</ul>
</li>
</ul>
<h5 id="preTraversal"><a href="#preTraversal" class="headerlink" title="preTraversal"></a>preTraversal</h5><p>思路 : </p>
<ol>
<li>因为需要构造中间节点，所以用先序遍历</li>
<li>先找到数组中最大值，然后切割成左右子树。</li>
<li>在切割后的左右子树中继续切割，直至无法切割为止</li>
</ol>
<p>自己写的，做法和随想录类似 </p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0654.%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html#java">https://programmercarl.com/0654.%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html#java</a></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">constructMaximumBinaryTree</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">return</span> buildTree(nums, <span class="number">0</span>, nums.size - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">buildTree</span><span class="params">(nums: <span class="type">IntArray</span>, start: <span class="type">Int</span>, end: <span class="type">Int</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    println(<span class="string">&quot;buildTree start <span class="variable">$start</span> end <span class="variable">$end</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="literal">null</span>            <span class="comment">//分割的左右下标越界就退出 ,不能加==，否则叶子节点构造不到.</span></span><br><span class="line">    <span class="keyword">val</span> maxIndex = getMaxIndex(nums, start, end)</span><br><span class="line">    <span class="keyword">val</span> node = TreeNode(nums[maxIndex])     <span class="comment">// 构造先序的父节点</span></span><br><span class="line">    node.left = buildTree(nums, start, maxIndex - <span class="number">1</span>) <span class="comment">// 构造左节点</span></span><br><span class="line">    node.right = buildTree(nums, maxIndex + <span class="number">1</span>, end)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getMaxIndex</span><span class="params">(nums: <span class="type">IntArray</span>, start: <span class="type">Int</span>, end: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> maxIndex = start</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> start..end) &#123;  <span class="comment">// 在对应的数组范围内，找到最大值</span></span><br><span class="line">        <span class="keyword">if</span> (nums[maxIndex] &lt; nums[i]) &#123;</span><br><span class="line">            maxIndex = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxIndex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h5><p>官方还有一种单调栈的写法，后面再看吧</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-binary-tree/solution/zui-da-er-cha-shu-by-leetcode-solution-lbeo/">https://leetcode.cn/problems/maximum-binary-tree/solution/zui-da-er-cha-shu-by-leetcode-solution-lbeo/</a></p>
<h4 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h4><p>Idea</p>
<h5 id="只分割中序数组"><a href="#只分割中序数组" class="headerlink" title="只分割中序数组"></a>只分割中序数组</h5><p>按照上面106官方很妙的思路，下面解法</p>
<ol>
<li>根据中序遍历。value和index构造hash map,方便后面获取中序位置</li>
<li>根据先序遍历数组从 左子树到右子树构造节点, 这样就不用分割先序数组，也是很麻烦的</li>
<li>根据先序数组的节点的位置，分割中序遍历数组，拿到左右子树</li>
<li>然后是递归分割.</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> map = HashMap&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="keyword">var</span> preNodeIndex = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">buildTree</span><span class="params">(preorder: <span class="type">IntArray</span>, inorder: <span class="type">IntArray</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    inorder.forEachIndexed &#123; position, item -&gt; <span class="comment">//</span></span><br><span class="line">        map[item] = position</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buildDFS(preorder, inorder, <span class="number">0</span>, inorder.size - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">buildDFS</span><span class="params">(preorder: <span class="type">IntArray</span>, inorder: <span class="type">IntArray</span>, inBegin: <span class="type">Int</span>, inEnd: <span class="type">Int</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (inBegin &gt; inEnd) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> node = TreeNode(preorder[preNodeIndex])  <span class="comment">// 根据先序遍历数组从 左子树到右子树构造节点</span></span><br><span class="line">    <span class="keyword">val</span> inIndex = map[preorder[preNodeIndex]]!! <span class="comment">// 根据先序数组的节点的位置，分割中序遍历数组，拿到左右子树</span></span><br><span class="line">    println(<span class="string">&quot;<span class="subst">$&#123;preorder[preNodeIndex]&#125;</span> inBegin <span class="variable">$inBegin</span> inEnd <span class="variable">$inEnd</span>&quot;</span>)</span><br><span class="line">    preNodeIndex++</span><br><span class="line">    node.left = buildDFS(preorder, inorder, inBegin, inIndex - <span class="number">1</span>)</span><br><span class="line">    node.right = buildDFS(preorder, inorder, inIndex + <span class="number">1</span>, inEnd)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="分割先序-中序数组"><a href="#分割先序-中序数组" class="headerlink" title="分割先序 中序数组"></a>分割先序 中序数组</h5><ol>
<li>根据中序数组构造，位置和值的hashmap 。</li>
<li>根据先序数组的中节点位置，分割中序数组，得到左右子树。</li>
<li>根据中序数组得到的左子树的长度，分割 先序数组的左右子树.</li>
<li>构造左右子树.</li>
</ol>
<p>左闭右闭的情况</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> map = HashMap&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="keyword">var</span> preNodeIndex = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">buildTree1</span><span class="params">(preorder: <span class="type">IntArray</span>, inorder: <span class="type">IntArray</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    inorder.forEachIndexed &#123; position, item -&gt;</span><br><span class="line">        map[item] = position  <span class="comment">// 获得 中序 value和index hash</span></span><br><span class="line">        map.put(item,position)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> splitPreInOrder(preorder, <span class="number">0</span>, preorder.size - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.size - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">splitPreInOrder</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    preorderArr: <span class="type">IntArray</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    preStart: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    preEnd: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    inorderArr: <span class="type">IntArray</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    inStart: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    inEnd: <span class="type">Int</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: TreeNode? &#123;</span><br><span class="line">    println(<span class="string">&quot; preStart <span class="variable">$preStart</span> preEnd <span class="variable">$preEnd</span> inStart <span class="variable">$inStart</span> inEnd <span class="variable">$inEnd</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (preStart &gt; preEnd || inStart &gt; inEnd) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">val</span> inIndex = map[preorderArr[preStart]]!!  <span class="comment">// 分割中序数组</span></span><br><span class="line">    <span class="keyword">val</span> node = TreeNode(preorderArr[preStart])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> leftInBegin = inStart <span class="comment">//左闭</span></span><br><span class="line">    <span class="keyword">val</span> leftInEnd = inIndex-<span class="number">1</span>    <span class="comment">// 右闭</span></span><br><span class="line">    <span class="keyword">val</span> leftPreBegin = preStart + <span class="number">1</span> <span class="comment">// 先序中节点的后一个位置，就是左子树的开始位置</span></span><br><span class="line">    <span class="keyword">val</span> leftPreEnd = preStart + (inIndex - inStart) <span class="comment">// 其实位置 + 中序中左子树的长度</span></span><br><span class="line"></span><br><span class="line">    node.left = splitPreInOrder(preorderArr, leftPreBegin, leftPreEnd, inorderArr, leftInBegin, leftInEnd)</span><br><span class="line">    <span class="keyword">val</span> rightInBegin = inIndex + <span class="number">1</span> <span class="comment">// 分割点的后一个位置</span></span><br><span class="line">    <span class="keyword">val</span> rightInEnd = inEnd</span><br><span class="line">    <span class="keyword">val</span> rightPreBegin = preStart + (inIndex - inStart) + <span class="number">1</span> <span class="comment">// 先序数组 左子树位置+1 后一个位置</span></span><br><span class="line">    <span class="keyword">val</span> rightPreEnd = preEnd</span><br><span class="line">    node.right = splitPreInOrder(preorderArr, rightPreBegin, rightPreEnd, inorderArr, rightInBegin, rightInEnd)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>感觉还是左闭右闭好点，右开的情况容易越界.</p>
<h4 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-binary-trees/">617. 合并二叉树</a></h4><h5 id="DFS-2"><a href="#DFS-2" class="headerlink" title="DFS"></a>DFS</h5><ol>
<li>合并二叉树，通过先序遍历，先构造根节点</li>
<li>然后再分别构造左右子树</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">mergeTrees</span><span class="params">(root1: <span class="type">TreeNode</span>?, root2: <span class="type">TreeNode</span>?)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="literal">null</span> &amp;&amp; root2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">//这里还可以优化, 看官方解法和随想录的优化一样的</span></span><br><span class="line">    <span class="keyword">val</span> node = TreeNode((root1?.`<span class="keyword">val</span>` ?: <span class="number">0</span>) + (root2?.`<span class="keyword">val</span>` ?: <span class="number">0</span>))</span><br><span class="line">    node.left = mergeTrees(root1?.left, root2?.left)</span><br><span class="line">    node.right = mergeTrees(root1?.right, root2?.right)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>BFS</p>
<p>这题官方有一种BFS的解法,感觉有点麻烦，后面继续</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-binary-trees/solution/he-bing-er-cha-shu-by-leetcode-solution/">https://leetcode.cn/problems/merge-two-binary-trees/solution/he-bing-er-cha-shu-by-leetcode-solution/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://noteforme.github.io/2022/09/11/LC-TREE08/" data-id="clce8xxse001jk79kfx0cdkx6" data-title="LC_TREE08" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LEETCODE/" rel="tag">LEETCODE</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-view_custom_attr" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/08/27/view_custom_attr/" class="article-date">
  <time class="dt-published" datetime="2022-08-27T13:53:08.000Z" itemprop="datePublished">2022-08-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/VIEW/">VIEW</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/08/27/view_custom_attr/">view_custom_attr</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h5 id="自定义属性类别"><a href="#自定义属性类别" class="headerlink" title="自定义属性类别"></a>自定义属性类别</h5><blockquote>
<p>boolean     表示attr取值为true或者false<br>color         表示attr取值是颜色类型，例如#ff3344,或者是一个指向color的资源id，例如R.color.colorAccent.<br>dimension 表示 attr 取值是尺寸类型，例如例如取值16sp、16dp，也可以是一个指向dimen的资源id，例          如R.dimen.dp_16<br>float      表示attr取值是整形或者浮点型<br>fraction     表示 attr取值是百分数类型，只能以%结尾，例如30%<br>integer      表示attr取值是整型<br>string        表示attr取值是String类型，或者一个指向String的资源id，例如R.string.testString<br>reference   表示attr取值只能是一个指向资源的id。<br>enum     表示attr取值只能是枚举类型。</p>
</blockquote>
<p>CustomView.kt</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">declare-styleable</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;CustomView&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;attr_boolean&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;boolean&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;attr_color&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;color&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;attr_dimension&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;dimension&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;attr_float&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;float&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;attr_fraction&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;fraction&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;attr_string&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;string&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;attr_reference&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;reference&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;attr_enum&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;enum&quot;</span> &gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">enum</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;left&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">enum</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;right&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">attr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">declare-styleable</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> a = context.obtainStyledAttributes(attrs, R.styleable.CustomView, <span class="hljs-number">0</span>, defStyleAttr)<br><span class="hljs-keyword">val</span> boolean = a.getBoolean(R.styleable.CustomAttribute_customBoolean, <span class="hljs-literal">false</span>)<br><span class="hljs-keyword">val</span> color = a.getColor(R.styleable.CustomAttribute_customColorValue, R.color.colorPrimary)<br><span class="hljs-keyword">val</span> dimension = a.getDimension(R.styleable.CustomAttribute_customDimension, <span class="hljs-number">20F</span>)<br><span class="hljs-keyword">val</span> float = a.getFloat(R.styleable.CustomView_attr_float, <span class="hljs-number">20f</span>)<br><span class="hljs-keyword">val</span> fraction = a.getFraction(R.styleable.CustomView_attr_fraction, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0f</span>)<br><span class="hljs-keyword">val</span> integer = a.getInteger(R.styleable.CustomAttribute_customIntegerValue, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">val</span> string = a.getString(R.styleable.CustomView_attr_string)<br>resourceId =<br>    a.getResourceId(R.styleable.CustomAttribute_customReference, R.drawable.meitu13333)<br><span class="hljs-keyword">var</span> textPos = a.getInteger(R.styleable.CustomView_attr_enum, <span class="hljs-number">0</span>)<br>a.recycle()<br></code></pre></td></tr></table></figure>

<p><strong>refrence , 表示attr取值只能是一个指向资源的id。</strong></p>
<p> <a target="_blank" rel="noopener" href="https://github.com/GcsSloop/AndroidNote/tree/master/CustomView">https://github.com/GcsSloop/AndroidNote/tree/master/CustomView</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000012253911">https://segmentfault.com/a/1190000012253911</a></p>
<h5 id="onDraw-dispatchDraw"><a href="#onDraw-dispatchDraw" class="headerlink" title="onDraw  dispatchDraw"></a>onDraw  dispatchDraw</h5><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/89efaf8bd3dd">https://www.jianshu.com/p/89efaf8bd3dd</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903997917102093">https://juejin.cn/post/6844903997917102093</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://noteforme.github.io/2022/08/27/view_custom_attr/" data-id="clq9i92wc0000gqgqgokm6v1k" data-title="view_custom_attr" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-ADB" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/08/18/ADB/" class="article-date">
  <time class="dt-published" datetime="2022-08-18T10:07:29.000Z" itemprop="datePublished">2022-08-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/08/18/ADB/">ADB</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys window | grep mCurrentFocus		&#x2F;&#x2F;当前Activity</span><br><span class="line"></span><br><span class="line">adb shell dumpsys activity | grep com.john.kot</span><br><span class="line"></span><br><span class="line">adb shell dumpsys activity | grep com.comm.util</span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="https://noteforme.github.io/2022/08/18/ADB/" data-id="clce8xxq90000k79kb9k98rte" data-title="ADB" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TOOL/" rel="tag">TOOL</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-view-round-image" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/08/14/view-round-image/" class="article-date">
  <time class="dt-published" datetime="2022-08-14T02:55:00.000Z" itemprop="datePublished">2022-08-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/VIEW/">VIEW</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/08/14/view-round-image/">view_round_image</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaohanluo/article/details/52945791">https://blog.csdn.net/xiaohanluo/article/details/52945791</a></p>
<p><a target="_blank" rel="noopener" href="https://guides.codepath.com/android/Working-with-the-ImageView">https://guides.codepath.com/android/Working-with-the-ImageView</a></p>
<p><img src="https://images.thoughtbot.com/blog-vellum-image-uploads/wDbiaqGSQyyErtXGSh6w_scaletype.png"></p>
<p><a target="_blank" rel="noopener" href="https://guides.codepath.com/android/Working-with-the-ImageView">https://guides.codepath.com/android/Working-with-the-ImageView</a></p>
<h3 id="全圆角"><a href="#全圆角" class="headerlink" title="全圆角"></a>全圆角</h3><h4 id="OutLine"><a href="#OutLine" class="headerlink" title="OutLine"></a>OutLine</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/img_test&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:src</span>=<span class="hljs-string">&quot;@drawable/music&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">mImg = findViewById(R.id.img_test);<br><span class="hljs-type">ViewOutlineProvider</span> <span class="hljs-variable">viewOutlineProvider</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ViewOutlineProvider</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getOutline</span><span class="hljs-params">(View view, Outline outline)</span> &#123;<br>       outline.setOval(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,mImg.getWidth(), mImg.getHeight());<br>    &#125;<br>&#125;;<br>mImg.setOutlineProvider(viewOutlineProvider);<br>mImg.setClipToOutline(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43499030/article/details/92799689">https://blog.csdn.net/weixin_43499030/article/details/92799689</a></p>
<h4 id="CardView"><a href="#CardView" class="headerlink" title="CardView"></a>CardView</h4><h3 id="部分圆角"><a href="#部分圆角" class="headerlink" title="部分圆角"></a>部分圆角</h3><h4 id="ShapeableImageView"><a href="#ShapeableImageView" class="headerlink" title="ShapeableImageView"></a>ShapeableImageView</h4><p>这种方式官方的无风险</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- layout.xml 就是在布局中定义--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">com.google.android.material.imageview.ShapeableImageView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;200dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:scaleType</span>=<span class="hljs-string">&quot;fitXY&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:strokeWidth</span>=<span class="hljs-string">&quot;10dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:strokeColor</span>=<span class="hljs-string">&quot;@color/purple&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:src</span>=<span class="hljs-string">&quot;@drawable/ic_launcher_background&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:shapeAppearance</span>=<span class="hljs-string">&quot;@style/RoundAndCutImageStyle&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>

<p>需要通过设置 app:shapeAppearance 才有用</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--  style.xml  可以单独给每个角设置属性--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;RoundAndCutImageStyle&quot;</span>&gt;</span><span class="language-xml"></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cornerFamilyTopLeft&quot;</span>&gt;</span>rounded<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cornerFamilyBottomLeft&quot;</span>&gt;</span>rounded<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cornerFamilyTopRight&quot;</span>&gt;</span>cut<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cornerFamilyBottomRight&quot;</span>&gt;</span>cut<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cornerSize&quot;</span>&gt;</span>50%<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cornerSizeBottomLeft&quot;</span>&gt;</span>20dp<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cornerSizeTopLeft&quot;</span>&gt;</span>20dp<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>左边是圆角，右边是“切角”</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f808689473d4938bf84d101b5908143~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6913083202387050509">https://juejin.cn/post/6913083202387050509</a></p>
<h4 id="BitmapShader"><a href="#BitmapShader" class="headerlink" title="BitmapShader"></a>BitmapShader</h4><p>setShader</p>
<p>setShader，顾名思义，设置着色器，我们知道在Canvas中，我们调用drawXXX可以绘制出各种各样的图形，如圆形、矩形、扇形等等，而Shader是给Paint设置的属性，决定paint绘制图形的时候如何给图形上色，比如绘制一个矩形，我想要矩形中铺满一张图片，那这些平铺的图片就相当于是给这个矩形上色了。好了，概念先说到这，Shader是一个基类，setShader中设置的都是Shader的子类<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/huxin1875/article/details/89133025">https://blog.csdn.net/huxin1875/article/details/89133025</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">     Call <span class="hljs-built_in">this</span> to create a <span class="hljs-keyword">new</span> <span class="hljs-title class_">shader</span> that will draw with a bitmap.<br>     Params:<br>     bitmap – The bitmap to use inside the shader<br>     tileX – The tiling mode <span class="hljs-keyword">for</span> x to draw the bitmap in.<br>     tileY – The tiling mode <span class="hljs-keyword">for</span> y to draw the bitmap in.<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">BitmapShader</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Bitmap bitmap, <span class="hljs-meta">@NonNull</span> TileMode tileX, <span class="hljs-meta">@NonNull</span> TileMode tileY)</span> &#123;<br>    <span class="hljs-built_in">this</span>(bitmap, tileX.nativeInt, tileY.nativeInt);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BitmapShaderView</span> <span class="hljs-meta">@JvmOverloads</span> <span class="hljs-keyword">constructor</span>(<br>    context: Context?, attrs: AttributeSet?,<br>    defStyleAttr: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span><br>) : View(context, attrs, defStyleAttr) &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mWidth <span class="hljs-keyword">by</span> Delegates.notNull&lt;<span class="hljs-built_in">Int</span>&gt;()<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mHeight <span class="hljs-keyword">by</span> Delegates.notNull&lt;<span class="hljs-built_in">Int</span>&gt;()<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> bmpShader: BitmapShader<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> mPaint: Paint<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> bmpRect: RectF<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSizeChanged</span><span class="hljs-params">(w: <span class="hljs-type">Int</span>, h: <span class="hljs-type">Int</span>, oldw: <span class="hljs-type">Int</span>, oldh: <span class="hljs-type">Int</span>)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onSizeChanged(w, h, oldw, oldh)<br>        mWidth = w  <span class="hljs-comment">//屏幕宽</span><br>        mHeight = h <span class="hljs-comment">//屏幕高</span><br>        bmpRect = RectF(<span class="hljs-number">0f</span>, <span class="hljs-number">0f</span>, mWidth.toFloat(), mHeight.toFloat())<br>        <span class="hljs-keyword">val</span> bitmap = BitmapFactory.decodeResource(resources, R.drawable.meitu122822234759011)<br>        <span class="hljs-comment">//Shader.TileMode里有三种模式：CLAMP（拉伸）、MIRROR（镜像）、REPETA（重复）</span><br>        bmpShader = BitmapShader(bitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP)<br>        mPaint = Paint(Paint.ANTI_ALIAS_FLAG)<br>        mPaint.shader = bmpShader<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(canvas: <span class="hljs-type">Canvas</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onDraw(canvas)<br>        canvas?.drawRect(bmpRect, mPaint)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> 先来看看BitmapShader属性的作用</p>
<p> bitmap 指的是要作为纹理的图片，</p>
<p> tileX 指的是在ｘ方向纹理的绘制模式</p>
<p> tileY 指的是Ｙ方向上的绘制模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">TileMode</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Replicate the edge color if the shader draws outside of its</span><br><span class="hljs-comment">     * original bounds.</span><br><span class="hljs-comment">     */</span><br>    CLAMP   (<span class="hljs-number">0</span>),<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Repeat the shader&#x27;s image horizontally and vertically.</span><br><span class="hljs-comment">     */</span><br>    REPEAT  (<span class="hljs-number">1</span>),<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Repeat the shader&#x27;s image horizontally and vertically, alternating</span><br><span class="hljs-comment">     * mirror images so that adjacent images always seam.</span><br><span class="hljs-comment">     */</span><br>    MIRROR(<span class="hljs-number">2</span>),<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Render the shader&#x27;s image pixels only within its original bounds. If the shader</span><br><span class="hljs-comment">     * draws outside of its original bounds, transparent black is drawn instead.</span><br><span class="hljs-comment">     */</span><br>    DECAL(<span class="hljs-number">3</span>);<br><br>    TileMode(<span class="hljs-type">int</span> nativeInt) &#123;<br>        <span class="hljs-built_in">this</span>.nativeInt = nativeInt;<br>    &#125;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> nativeInt;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>*<strong>CLAMP 拉伸*</strong>:设置x , 横向的最后一个横行像素，不断的重复，设置y，那么纵项的那一列像素，不断的重复；<br>*<strong>REPEAT 重复*</strong>:就是横向、纵向不断重复这个bitmap<br>*<strong>MIRROR 镜像*</strong>:横向不断翻转重复，纵向不断翻转重复；</p>
<h5 id="CLAMP"><a href="#CLAMP" class="headerlink" title="CLAMP"></a>CLAMP</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">BitmapShader(bitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP)<br></code></pre></td></tr></table></figure>

<img src="/2022/08/14/view-round-image//Screenshot_1660468780.png" alt="Screenshot_1660468780" style="zoom:20%;">

<p>REPEAT</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">BitmapShader(bitmap, Shader.TileMode.REPEAT, Shader.TileMode.REPEAT)<br></code></pre></td></tr></table></figure>

<img src="/2022/08/14/view-round-image//Screenshot_1660469449.png" alt="Screenshot_1660469449" style="zoom:20%;">

<h5 id="MIRROR"><a href="#MIRROR" class="headerlink" title="MIRROR"></a>MIRROR</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">BitmapShader(bitmap, Shader.TileMode.MIRROR, Shader.TileMode.MIRROR)<br></code></pre></td></tr></table></figure>

<img src="/2022/08/14/view-round-image//Screenshot_1660469253.png" alt="Screenshot_1660469253" style="zoom:20%;">

<p>可以看到， x y 镜像映射</p>
<h5 id="DECAL"><a href="#DECAL" class="headerlink" title="DECAL"></a>DECAL</h5><p>最后这种就是正常显示的了</p>
<img src="/2022/08/14/view-round-image//Screenshot_1660469645.png" alt="Screenshot_1660469645" style="zoom:20%;">

<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903480809766920">https://juejin.cn/post/6844903480809766920</a></p>
<h5 id="全部圆角"><a href="#全部圆角" class="headerlink" title="全部圆角"></a>全部圆角</h5><p>有了scale，就可以设置给我们的matrix；</p>
<p>然后使用mBitmapShader.setLocalMatrix(mMatrix);</p>
<p>最后将bitmapShader设置给paint。</p>
<p>关于drawable转bitmap的代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Math.max(width / bmp.width.toFloat(), height / bmp.height.toFloat())<br></code></pre></td></tr></table></figure>

<p>View宽度 / 图片宽度 , View的高度/图片高度</p>
<p>他们取最大值，进行缩放，图片短的那一部分就会填满View,长的那一部分会被截掉,显示不全</p>
<p>计算scale</p>
<blockquote>
<p>比如：view的宽高为50 * 100；图片的宽高为5*100 ； 最终我们应该按照宽的比例放大，而不是按照高的比例缩小；因为我们需要让缩放后的图片，自定大于我们的view宽高，并保证原图比例。</p>
</blockquote>
<p>那么高度就被放大10倍到1000,值能显示到1/10</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RoundImageShaderView</span> <span class="hljs-meta">@JvmOverloads</span> <span class="hljs-keyword">constructor</span>(<br>    context: Context, attrs: AttributeSet?,<br>    defStyleAttr: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span><br>) : AppCompatImageView(context, attrs, defStyleAttr) &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> TAG = <span class="hljs-string">&quot;RoundImageShaderView&quot;</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> mRoundRect: RectF<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> mBitmapShader: BitmapShader<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mMatrix = Matrix()<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mBitmapPaint = Paint();<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(canvas: <span class="hljs-type">Canvas</span>?)</span></span> &#123;<br>        canvas?.drawRoundRect(mRoundRect, <span class="hljs-number">20f</span>, <span class="hljs-number">20f</span>, mBitmapPaint)<br>    &#125;<br><br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSizeChanged</span><span class="hljs-params">(w: <span class="hljs-type">Int</span>, h: <span class="hljs-type">Int</span>, oldw: <span class="hljs-type">Int</span>, oldh: <span class="hljs-type">Int</span>)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onSizeChanged(w, h, oldw, oldh)<br>        setUpShader()<br>        mRoundRect = RectF(<span class="hljs-number">0f</span>, <span class="hljs-number">0f</span>, width.toFloat(), height.toFloat())<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始化BitmapShader</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setUpShader</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">val</span> drawable: Drawable = drawable ?: <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">val</span> bmp = drawableToBitamp(drawable)<br>        <span class="hljs-comment">// 将bmp作为着色器，就是在指定区域内绘制bmp</span><br>        mBitmapShader = BitmapShader(bmp!!, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP)<br>        <span class="hljs-comment">// 如果图片的宽或者高与view的宽高不匹配，计算出需要缩放的比例；缩放后的图片的宽高，一定要大于我们view的宽高；所以我们这里取大值；</span><br>        <span class="hljs-keyword">val</span> scale = Math.max(width / bmp.width.toFloat(), height / bmp.height.toFloat())<br>        <span class="hljs-comment">// shader的变换矩阵，我们这里主要用于放大或者缩小</span><br>        mMatrix.setScale(scale, scale)<br>        <span class="hljs-comment">// 设置变换矩阵</span><br>        mBitmapShader.setLocalMatrix(mMatrix)<br>        <span class="hljs-comment">// 设置shader</span><br>        mBitmapPaint.shader = mBitmapShader<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * drawable转bitmap</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> drawable</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">drawableToBitamp</span><span class="hljs-params">(drawable: <span class="hljs-type">Drawable</span>)</span></span>: Bitmap? &#123;<br>        <span class="hljs-keyword">if</span> (drawable <span class="hljs-keyword">is</span> BitmapDrawable) &#123;<br>            <span class="hljs-keyword">val</span> bd: BitmapDrawable = drawable<br>            <span class="hljs-keyword">return</span> bd.bitmap<br>        &#125;<br>        <span class="hljs-keyword">val</span> w = drawable.intrinsicWidth<br>        <span class="hljs-keyword">val</span> h = drawable.intrinsicHeight<br>        <span class="hljs-keyword">return</span> Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">com.john.kot.view.RoundImageShaderView</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/iv_girl1&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;200dp&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;200dp&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_marginStart</span>=<span class="hljs-string">&quot;20dp&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">&quot;20dp&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:src</span>=<span class="hljs-string">&quot;@drawable/meitu122822234759011&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">app:layout_constraintStart_toStartOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">app:layout_constraintTop_toTopOf</span>=<span class="hljs-string">&quot;parent&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">com.john.kot.view.RoundImageShaderView</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/iv_girl2&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;200dp&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_marginStart</span>=<span class="hljs-string">&quot;20dp&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">&quot;20dp&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:src</span>=<span class="hljs-string">&quot;@drawable/meitu122822234759011&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">app:layout_constraintStart_toStartOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">app:layout_constraintTop_toBottomOf</span>=<span class="hljs-string">&quot;@+id/iv_girl1&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>

<p><img src="/2022/08/14/view-round-image//20220814224524.jpg" alt="20220814224524"></p>
<p>可以看到，高度部分截取了</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lmj623565791/article/details/41967509">https://blog.csdn.net/lmj623565791/article/details/41967509</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/graphics/PorterDuff.Mode">https://developer.android.com/reference/android/graphics/PorterDuff.Mode</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000012253911">https://segmentfault.com/a/1190000012253911</a></p>
<h5 id="部分圆角-1"><a href="#部分圆角-1" class="headerlink" title="部分圆角"></a>部分圆角</h5><img src="/2022/08/14/view-round-image//20220828111337.jpg" alt="20220828111337" style="zoom: 50%;">

<p>第二张图就可以看到，这样做的原理</p>
<img src="/2022/08/14/view-round-image//20220828120522.jpg" alt="20220828120522" style="zoom:50%;">

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RoundBottomBitmapShaderView</span> <span class="hljs-meta">@JvmOverloads</span> <span class="hljs-keyword">constructor</span>(<br>    context: Context, attrs: AttributeSet?,<br>    defStyleAttr: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span><br>) : AppCompatImageView(context, attrs, defStyleAttr) &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> mBitmapShader: BitmapShader<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mMatrix = Matrix()<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mBitmapPaint = Paint();<br><br>    <span class="hljs-keyword">val</span> radius = resources.getDimension(R.dimen.round_bitmap_radius)<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> outHeight <span class="hljs-keyword">by</span> Delegates.notNull&lt;<span class="hljs-built_in">Int</span>&gt;()<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> outWidth <span class="hljs-keyword">by</span> Delegates.notNull&lt;<span class="hljs-built_in">Int</span>&gt;()<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSizeChanged</span><span class="hljs-params">(w: <span class="hljs-type">Int</span>, h: <span class="hljs-type">Int</span>, oldw: <span class="hljs-type">Int</span>, oldh: <span class="hljs-type">Int</span>)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onSizeChanged(w, h, oldw, oldh)<br>        setUpShader()<br>        outWidth = w<br>        outHeight = h<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(canvas: <span class="hljs-type">Canvas</span>?)</span></span> &#123;<br><span class="hljs-comment">//        super.onDraw(canvas) 要删除 super.onDraw(canvas)：否则Canvas又会在ImageView中重新绘制，将我们之前的操作都覆盖了</span><br>        <span class="hljs-comment">//绘制圆角</span><br>        canvas?.drawRoundRect(<br>            RectF(<br>                <span class="hljs-number">0f</span>,<br>                (outHeight - <span class="hljs-number">2</span> * radius), outWidth.toFloat(), outHeight.toFloat()<br>            ), radius, radius, mBitmapPaint<br>        )<br><span class="hljs-comment">//         利用画笔绘制顶部上面直角部分</span><br>        canvas?.drawRect(<br>            RectF(<br>                <span class="hljs-number">0f</span>, <span class="hljs-number">0f</span>, outWidth.toFloat(),<br>                (outHeight - radius)<br>            ), mBitmapPaint<br>        )<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始化BitmapShader</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setUpShader</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">val</span> drawable: Drawable = drawable ?: <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">val</span> bmp = drawableToBitmap(drawable)<br>        <span class="hljs-comment">// 将bmp作为着色器，就是在指定区域内绘制bmp</span><br>        mBitmapShader = BitmapShader(bmp, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP)<br>        <span class="hljs-comment">// 如果图片的宽或者高与view的宽高不匹配，计算出需要缩放的比例；缩放后的图片的宽高，一定要大于我们view的宽高；所以我们这里取大值；</span><br>        <span class="hljs-keyword">val</span> scale = Math.max(width / bmp.width.toFloat(), height / bmp.height.toFloat())<br>        <span class="hljs-comment">// shader的变换矩阵，我们这里主要用于放大或者缩小</span><br>        mMatrix.setScale(scale, scale)<br>        <span class="hljs-comment">// 设置变换矩阵</span><br>        mBitmapShader.setLocalMatrix(mMatrix)<br>        <span class="hljs-comment">// 设置shader</span><br>        mBitmapPaint.shader = mBitmapShader<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * drawable转bitmap</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> drawable</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">drawableToBitmap</span><span class="hljs-params">(drawable: <span class="hljs-type">Drawable</span>)</span></span>: Bitmap &#123;<br>        <span class="hljs-keyword">if</span> (drawable <span class="hljs-keyword">is</span> BitmapDrawable) &#123;<br>            <span class="hljs-keyword">val</span> bd: BitmapDrawable = drawable<br>            <span class="hljs-keyword">return</span> bd.bitmap<br>        &#125;<br>        <span class="hljs-keyword">val</span> w = drawable.intrinsicWidth<br>        <span class="hljs-keyword">val</span> h = drawable.intrinsicHeight<br>        <span class="hljs-keyword">return</span> Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="一个脚"><a href="#一个脚" class="headerlink" title="一个脚"></a>一个脚</h5><p>前两步绘制的效果</p>
<img src="/2022/08/14/view-round-image//20220828183247.jpg" alt="20220828183247" style="zoom: 50%;">

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RoundSingleBitmapShaderView</span> <span class="hljs-meta">@JvmOverloads</span> <span class="hljs-keyword">constructor</span>(<br>    context: Context, attrs: AttributeSet?,<br>    defStyleAttr: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span><br>) : AppCompatImageView(context, attrs, defStyleAttr) &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> mBitmapShader: BitmapShader<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mMatrix = Matrix()<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mBitmapPaint = Paint();<br><br>    <span class="hljs-keyword">val</span> mRadius = resources.getDimension(R.dimen.round_bitmap_radius)<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> outHeight <span class="hljs-keyword">by</span> Delegates.notNull&lt;<span class="hljs-built_in">Int</span>&gt;()<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> outWidth <span class="hljs-keyword">by</span> Delegates.notNull&lt;<span class="hljs-built_in">Int</span>&gt;()<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSizeChanged</span><span class="hljs-params">(w: <span class="hljs-type">Int</span>, h: <span class="hljs-type">Int</span>, oldw: <span class="hljs-type">Int</span>, oldh: <span class="hljs-type">Int</span>)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onSizeChanged(w, h, oldw, oldh)<br>        setUpShader()<br>        outWidth = w<br>        outHeight = h<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(canvas: <span class="hljs-type">Canvas</span>?)</span></span> &#123;<br><span class="hljs-comment">//        super.onDraw(canvas)  //否则Canvas又会在ImageView中重新绘制，将我们之前的操作都覆盖了</span><br><br>        <span class="hljs-comment">//绘制圆</span><br>        canvas?.drawRoundRect(<br>            RectF(<span class="hljs-number">0f</span>, <span class="hljs-number">0f</span>, <span class="hljs-number">2</span> * mRadius, <span class="hljs-number">2</span> * mRadius),<br>            mRadius,<br>            mRadius,<br>            mBitmapPaint<br>        )<br>        <span class="hljs-comment">//绘制矩形竖线</span><br>        canvas?.drawRect(RectF(<span class="hljs-number">0f</span>, mRadius, mRadius, height.toFloat()), mBitmapPaint)<br><br>          <span class="hljs-comment">//绘制主要的图</span><br>        canvas?.drawRect(<br>            RectF(<br>                mRadius, <span class="hljs-number">0f</span>, width.toFloat(),<br>                height.toFloat()<br>            ), mBitmapPaint<br>        )<br><br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始化BitmapShader</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setUpShader</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">val</span> drawable: Drawable = drawable ?: <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">val</span> bmp = drawableToBitmap(drawable)<br>        <span class="hljs-comment">// 将bmp作为着色器，就是在指定区域内绘制bmp</span><br>        mBitmapShader = BitmapShader(bmp, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP)<br>        <span class="hljs-comment">// 如果图片的宽或者高与view的宽高不匹配，计算出需要缩放的比例；缩放后的图片的宽高，一定要大于我们view的宽高；所以我们这里取大值；</span><br>        <span class="hljs-keyword">val</span> scale = Math.max(width / bmp.width.toFloat(), height / bmp.height.toFloat())<br>        <span class="hljs-comment">// shader的变换矩阵，我们这里主要用于放大或者缩小</span><br>        mMatrix.setScale(scale, scale)<br>        <span class="hljs-comment">// 设置变换矩阵</span><br>        mBitmapShader.setLocalMatrix(mMatrix)<br>        <span class="hljs-comment">// 设置shader</span><br>        mBitmapPaint.shader = mBitmapShader<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * drawable转bitmap</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> drawable</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">drawableToBitmap</span><span class="hljs-params">(drawable: <span class="hljs-type">Drawable</span>)</span></span>: Bitmap &#123;<br>        <span class="hljs-keyword">if</span> (drawable <span class="hljs-keyword">is</span> BitmapDrawable) &#123;<br>            <span class="hljs-keyword">val</span> bd: BitmapDrawable = drawable<br>            <span class="hljs-keyword">return</span> bd.bitmap<br>        &#125;<br>        <span class="hljs-keyword">val</span> w = drawable.intrinsicWidth<br>        <span class="hljs-keyword">val</span> h = drawable.intrinsicHeight<br>        <span class="hljs-keyword">return</span> Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Xfermode绘制圆角"><a href="#Xfermode绘制圆角" class="headerlink" title="Xfermode绘制圆角"></a>Xfermode绘制圆角</h4><h5 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h5><p>先绘制 绘制黄色的圆</p>
<p>然后绘制蓝色正方形</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1930161-1b9736cdad4df3d8?imageMogr2/auto-orient/strip%7CimageView2/2/w/312/format/webp"></p>
<p>模式    说明<br>PorterDuff.Mode.CLEAR    所有绘制不会绘制到画布上<br>PorterDuff.Mode.SRC    显示上层绘制图形<br>PorterDuff.Mode.DST    显示下层绘制图形<br>PorterDuff.Mode.SRC_OVER    图形叠加，上层盖住下层<br>PorterDuff.Mode.DST_OVER    图形叠加，下层盖住上层<br>PorterDuff.Mode.SRC_IN    显示上层交集部分<br>PorterDuff.Mode.DST_IN    显示下层交集部分<br>PorterDuff.Mode.SRC_OUT    显示上层非交集部分<br>PorterDuff.Mode.DST_OUT    显示下层非交集部分<br>PorterDuff.Mode.SRC_ATOP    显示下层非交集部分和上层交集部分<br>PorterDuff.Mode.DST_ATOP    显示下层交集部分与上层非交集部分<br>PorterDuff.Mode.XOR    去除交集部分<br>PorterDuff.Mode.DARKEN    交集部分颜色加深<br>PorterDuff.Mode.LIGHTEN    交集部分颜色变亮<br>PorterDuff.Mode.MULTIPLY    显示交集部分，颜色混合叠加<br>PorterDuff.Mode.SCREEN    取两图层全部区域，交集部分变为透明色</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaohanluo/article/details/52945791">https://blog.csdn.net/xiaohanluo/article/details/52945791</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.android.google.cn/reference/android/graphics/PorterDuff.Mode">https://developer.android.google.cn/reference/android/graphics/PorterDuff.Mode</a></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SampleXfermodeView</span>(context: Context?) : View(context) &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mSrcB: Bitmap<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mDstB: Bitmap<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mBG <span class="hljs-comment">// background checker-board pattern</span><br>                : Shader<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> modeIndex = <span class="hljs-number">1</span> <span class="hljs-comment">// 模式</span><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(canvas: <span class="hljs-type">Canvas</span>)</span></span> &#123;<br>            canvas.drawColor(Color.WHITE)<br>            <span class="hljs-keyword">val</span> labelP = Paint(Paint.ANTI_ALIAS_FLAG)<br>            labelP.textAlign = Paint.Align.CENTER<br>            <span class="hljs-keyword">val</span> paint = Paint()<br>            paint.isFilterBitmap = <span class="hljs-literal">false</span><br>            canvas.translate(<span class="hljs-number">15F</span>, <span class="hljs-number">35F</span>)<br>            <span class="hljs-keyword">var</span> x = <span class="hljs-number">0f</span><br>            <span class="hljs-keyword">var</span> y = <span class="hljs-number">0f</span><br><span class="hljs-comment">//            for (modeIndex in sModes.indices) &#123;</span><br>            <span class="hljs-comment">// draw the border</span><br>            paint.style = Paint.Style.STROKE<br>            paint.shader = <span class="hljs-literal">null</span><br>            canvas.drawRect(<br>                x - <span class="hljs-number">0.5f</span>, y - <span class="hljs-number">0.5f</span>,<br>                x + W + <span class="hljs-number">0.5f</span>, y + H + <span class="hljs-number">0.5f</span>, paint<br>            ) <span class="hljs-comment">// 外层正方形黑色框框</span><br>            <span class="hljs-comment">// draw the checker-board pattern</span><br>            paint.style = Paint.Style.FILL<br>            paint.shader = mBG<br>            canvas.drawRect(x, y, x + W, y + H, paint) <span class="hljs-comment">// 正方形框框里的灰色小格子</span><br>            <span class="hljs-comment">// draw the src/dst example into our offscreen bitmap</span><br>            <span class="hljs-keyword">val</span> sc: <span class="hljs-built_in">Int</span> = canvas.saveLayer(<br>                x, y, x + W, y + H, <span class="hljs-literal">null</span>,<br>            ) <span class="hljs-comment">// 保存 图层</span><br>            canvas.translate(x, y)<br>            canvas.drawBitmap(mDstB, <span class="hljs-number">0f</span>, <span class="hljs-number">0f</span>, paint) <span class="hljs-comment">// 绘制黄色的圆</span><br>            paint.xfermode = sModes[modeIndex]<br>            canvas.drawBitmap(mSrcB, <span class="hljs-number">0f</span>, <span class="hljs-number">0f</span>, paint) <span class="hljs-comment">//绘制蓝色正方形</span><br>            paint.xfermode = <span class="hljs-literal">null</span> <span class="hljs-comment">// 我猜否则下次循环会用到</span><br>            canvas.restoreToCount(sc)<br>            <span class="hljs-comment">// draw the label</span><br>            canvas.drawText(<br>                sLabels[modeIndex],<br>                x + W / <span class="hljs-number">2</span>, y - labelP.textSize / <span class="hljs-number">2</span>, labelP<br>            )<br>            x += W + <span class="hljs-number">10</span><br>            <span class="hljs-comment">// wrap around when we&#x27;ve drawn enough for one row</span><br>            <span class="hljs-keyword">if</span> ((modeIndex % ROW_MAX) == ROW_MAX - <span class="hljs-number">1</span>) &#123;<br>                    x = <span class="hljs-number">0f</span><br>                    y += H + <span class="hljs-number">30</span><br>                &#125;<br><span class="hljs-comment">//            &#125;</span><br>        &#125;<br><br>        <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> W = <span class="hljs-number">200</span><br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> H = <span class="hljs-number">200</span><br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> ROW_MAX = <span class="hljs-number">4</span> <span class="hljs-comment">// number of samples per row</span><br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> sModes: Array&lt;Xfermode&gt; = arrayOf&lt;Xfermode&gt;(<br>                PorterDuffXfermode(PorterDuff.Mode.CLEAR),<br>                PorterDuffXfermode(PorterDuff.Mode.SRC),<br>                PorterDuffXfermode(PorterDuff.Mode.DST),<br>                PorterDuffXfermode(PorterDuff.Mode.SRC_OVER),<br>                PorterDuffXfermode(PorterDuff.Mode.DST_OVER),<br>                PorterDuffXfermode(PorterDuff.Mode.SRC_IN),<br>                PorterDuffXfermode(PorterDuff.Mode.DST_IN),<br>                PorterDuffXfermode(PorterDuff.Mode.SRC_OUT),<br>                PorterDuffXfermode(PorterDuff.Mode.DST_OUT),<br>                PorterDuffXfermode(PorterDuff.Mode.SRC_ATOP),<br>                PorterDuffXfermode(PorterDuff.Mode.DST_ATOP),<br>                PorterDuffXfermode(PorterDuff.Mode.XOR),<br>                PorterDuffXfermode(PorterDuff.Mode.DARKEN),<br>                PorterDuffXfermode(PorterDuff.Mode.LIGHTEN),<br>                PorterDuffXfermode(PorterDuff.Mode.MULTIPLY),<br>                PorterDuffXfermode(PorterDuff.Mode.SCREEN)<br>            )<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> sLabels = arrayOf(<br>                <span class="hljs-string">&quot;Clear&quot;</span>, <span class="hljs-string">&quot;Src&quot;</span>, <span class="hljs-string">&quot;Dst&quot;</span>, <span class="hljs-string">&quot;SrcOver&quot;</span>,<br>                <span class="hljs-string">&quot;DstOver&quot;</span>, <span class="hljs-string">&quot;SrcIn&quot;</span>, <span class="hljs-string">&quot;DstIn&quot;</span>, <span class="hljs-string">&quot;SrcOut&quot;</span>,<br>                <span class="hljs-string">&quot;DstOut&quot;</span>, <span class="hljs-string">&quot;SrcATop&quot;</span>, <span class="hljs-string">&quot;DstATop&quot;</span>, <span class="hljs-string">&quot;Xor&quot;</span>,<br>                <span class="hljs-string">&quot;Darken&quot;</span>, <span class="hljs-string">&quot;Lighten&quot;</span>, <span class="hljs-string">&quot;Multiply&quot;</span>, <span class="hljs-string">&quot;Screen&quot;</span><br>            )<br>        &#125;<br><br>        <span class="hljs-keyword">init</span> &#123;<br>            mSrcB = makeSrc(W, H)<br>            mDstB = makeDst(W, H)<br>            <span class="hljs-comment">// make a ckeckerboard pattern</span><br>            <span class="hljs-keyword">val</span> bm: Bitmap = Bitmap.createBitmap(<br>                intArrayOf(<br>                    -<span class="hljs-number">0x1</span>, -<span class="hljs-number">0x333334</span>,<br>                    -<span class="hljs-number">0x333334</span>, -<span class="hljs-number">0x1</span><br>                ), <span class="hljs-number">2</span>, <span class="hljs-number">2</span>,<br>                Bitmap.Config.RGB_565<br>            )<br>            mBG = BitmapShader(<br>                bm,<br>                Shader.TileMode.REPEAT,<br>                Shader.TileMode.REPEAT<br>            )<br>            <span class="hljs-keyword">val</span> m = Matrix()<br>            m.setScale(<span class="hljs-number">6f</span>, <span class="hljs-number">6f</span>)<br>            mBG.setLocalMatrix(m)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-comment">// create a bitmap with a circle, used for the &quot;dst&quot; image</span><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">makeDst</span><span class="hljs-params">(w: <span class="hljs-type">Int</span>, h: <span class="hljs-type">Int</span>)</span></span>: Bitmap &#123;<br>            <span class="hljs-keyword">val</span> bm: Bitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888)<br>            <span class="hljs-keyword">val</span> c = Canvas(bm)<br>            <span class="hljs-keyword">val</span> p = Paint(Paint.ANTI_ALIAS_FLAG)<br>            p.color = -<span class="hljs-number">0x33bc</span><br>            c.drawOval(RectF(<span class="hljs-number">0f</span>, <span class="hljs-number">0f</span>, w * <span class="hljs-number">3f</span> / <span class="hljs-number">4</span>, h * <span class="hljs-number">3f</span> / <span class="hljs-number">4</span>), p)<br>            <span class="hljs-keyword">return</span> bm<br>        &#125;<br><br>        <span class="hljs-comment">// create a bitmap with a rect, used for the &quot;src&quot; image</span><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">makeSrc</span><span class="hljs-params">(w: <span class="hljs-type">Int</span>, h: <span class="hljs-type">Int</span>)</span></span>: Bitmap &#123;<br>            <span class="hljs-keyword">val</span> bm: Bitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888)<br>            <span class="hljs-keyword">val</span> c = Canvas(bm)<br>            <span class="hljs-keyword">val</span> p = Paint(Paint.ANTI_ALIAS_FLAG)<br>            p.color = -<span class="hljs-number">0x995501</span><br>            c.drawRect(w / <span class="hljs-number">3f</span>, h / <span class="hljs-number">3f</span>, w * <span class="hljs-number">19f</span> / <span class="hljs-number">20</span>, h * <span class="hljs-number">19f</span> / <span class="hljs-number">20</span>, p)<br>            <span class="hljs-keyword">return</span> bm<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="圆角图片"><a href="#圆角图片" class="headerlink" title="圆角图片"></a>圆角图片</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> TYPE_CIRCLE = <span class="hljs-number">0</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> TYPE_ROUND = <span class="hljs-number">1</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">XfermodeView</span> <span class="hljs-meta">@JvmOverloads</span> <span class="hljs-keyword">constructor</span>(<br>    context: Context?,<br>    attrs: AttributeSet? = <span class="hljs-literal">null</span>,<br>    defStyleAttr: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span><br>) : View(context, attrs, defStyleAttr) &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> src: Bitmap? = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> <span class="hljs-keyword">out</span>: Bitmap? = <span class="hljs-literal">null</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mWidth = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mHeight = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> type = TYPE_ROUND  <span class="hljs-comment">//设置类型，是圆角图片还是圆角矩形</span><br><br>    <span class="hljs-keyword">init</span> &#123;<br>        <span class="hljs-comment">// 禁止硬件加速，硬件加速会有一些问题，这里禁用掉</span><br>        setLayerType(LAYER_TYPE_SOFTWARE, <span class="hljs-literal">null</span>)<br>    &#125;<br><br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onMeasure</span><span class="hljs-params">(widthMeasureSpec: <span class="hljs-type">Int</span>, heightMeasureSpec: <span class="hljs-type">Int</span>)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec)<br><br>        <span class="hljs-comment">//自己计算控件的宽高</span><br>        <span class="hljs-keyword">val</span> widthSize = MeasureSpec.getSize(widthMeasureSpec)<br>        <span class="hljs-keyword">val</span> widthMode = MeasureSpec.getMode(widthMeasureSpec)<br>        <span class="hljs-keyword">val</span> heightSize = MeasureSpec.getSize(heightMeasureSpec)<br>        <span class="hljs-keyword">val</span> heightMode = MeasureSpec.getMode(heightMeasureSpec)<br>        mWidth = <span class="hljs-keyword">if</span> (widthMode == MeasureSpec.EXACTLY) &#123;<br>            widthSize<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">val</span> imgWidth = (src!!.width + paddingLeft<br>                    + paddingRight)<br>            <span class="hljs-keyword">if</span> (widthMode == MeasureSpec.AT_MOST) &#123;<br>                Math.min(widthSize, imgWidth)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                imgWidth<br>            &#125;<br>        &#125;<br>        mHeight = <span class="hljs-keyword">if</span> (heightMode == MeasureSpec.EXACTLY) &#123;<br>            heightSize<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">val</span> imgHeight = (src!!.height + paddingTop<br>                    + paddingBottom)<br>            <span class="hljs-keyword">if</span> (heightMode == MeasureSpec.AT_MOST) &#123;<br>                Math.min(heightSize, imgHeight)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                imgHeight<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">when</span> (type) &#123;<br>            TYPE_CIRCLE -&gt; &#123;<br>                <span class="hljs-keyword">val</span> min = Math.min(mWidth, mHeight)<br>                setMeasuredDimension(min, min)<br>            &#125;<br>            TYPE_ROUND -&gt; setMeasuredDimension(mWidth, mHeight)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(canvas: <span class="hljs-type">Canvas</span>)</span></span> &#123;<br>        xmodeImage()<br>        <span class="hljs-comment">//把画好画的画布放到自定义的画板上面</span><br>        canvas.drawBitmap(<span class="hljs-keyword">out</span>!!, <span class="hljs-number">0f</span>, <span class="hljs-number">0f</span>, <span class="hljs-literal">null</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">xmodeImage</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">//根据原始的图片创建一个画布</span><br>        <span class="hljs-keyword">out</span> = Bitmap.createBitmap(mWidth, mHeight, Bitmap.Config.ARGB_8888)<br><br>        <span class="hljs-comment">//创建一个画板，在画布的基础上</span><br>        <span class="hljs-keyword">val</span> canvas = Canvas(<span class="hljs-keyword">out</span>!!)<br>        <span class="hljs-comment">//创建一个画笔</span><br>        <span class="hljs-keyword">val</span> paint = Paint(Paint.ANTI_ALIAS_FLAG)<br>        <span class="hljs-keyword">when</span> (type) &#123;<br>            TYPE_ROUND -&gt;            <span class="hljs-comment">//开始在有画板的画布上用画笔作画了，这里画了一个圆角矩形</span><br>                canvas.drawRoundRect(<br>                    RectF(<span class="hljs-number">0f</span>, <span class="hljs-number">0f</span>, mWidth.toFloat(), mHeight.toFloat()),<br>                    <span class="hljs-number">60f</span>,<br>                    <span class="hljs-number">60f</span>,<br>                    paint<br>                )<br>            TYPE_CIRCLE -&gt; &#123;<br>                <span class="hljs-comment">//画圆，取宽高的最小值作为圆的直径</span><br>                <span class="hljs-keyword">val</span> min = Math.min(mWidth, mHeight)<br>                <span class="hljs-comment">//开始画圆</span><br>                canvas.drawCircle(<br>                    (min / <span class="hljs-number">2</span>).toFloat(),<br>                    (min / <span class="hljs-number">2</span>).toFloat(),<br>                    (min / <span class="hljs-number">2</span>).toFloat(),<br>                    paint<br>                )<br>            &#125;<br>        &#125;<br>        src = BitmapFactory.decodeResource(resources, R.drawable.meitu110468869)<br>        <span class="hljs-comment">//设置Xfermode画笔模式为SRC_IN</span><br>        paint.xfermode = PorterDuffXfermode(PorterDuff.Mode.SRC_IN)<br>        <span class="hljs-comment">//然后有画了一个图片，最终实现两个图像的叠加</span><br><br>        <span class="hljs-keyword">val</span> zoomImg = zoomImg(src!!, mWidth, mHeight)<br>        canvas.drawBitmap(zoomImg!!, <span class="hljs-number">0f</span>, <span class="hljs-number">0f</span>, paint)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">zoomImg</span><span class="hljs-params">(bm: <span class="hljs-type">Bitmap</span>, newWidth: <span class="hljs-type">Int</span>, newHeight: <span class="hljs-type">Int</span>)</span></span>: Bitmap? &#123;<br>        <span class="hljs-comment">// 获得图片的宽高</span><br>        <span class="hljs-keyword">val</span> width = bm.width<br>        <span class="hljs-keyword">val</span> height = bm.height<br>        <span class="hljs-comment">// 计算缩放比例</span><br>        <span class="hljs-keyword">val</span> scaleWidth = newWidth.toFloat() / width<br>        <span class="hljs-keyword">val</span> scaleHeight = newHeight.toFloat() / height<br>        <span class="hljs-comment">// 取得想要缩放的matrix参数</span><br>        <span class="hljs-keyword">val</span> matrix = Matrix()<br>        matrix.postScale(scaleWidth, scaleHeight)<br>        <span class="hljs-comment">// 得到新的图片</span><br>        <span class="hljs-keyword">return</span> Bitmap.createBitmap(bm, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height, matrix, <span class="hljs-literal">true</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://noteforme.github.io/2022/08/14/view-round-image/" data-id="clce8xxs3001ik79kaphibifr" data-title="view_round_image" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Leetcode" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/26/Leetcode/" class="article-date">
  <time class="dt-published" datetime="2022-07-26T06:58:38.000Z" itemprop="datePublished">2022-07-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/07/26/Leetcode/">leetcode</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-parentheses">20. 有效的括号</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//官方 HashMap 解法更好 更清晰</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Stack stack = <span class="keyword">new</span> Stack();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> ((c == <span class="string">&#x27;(&#x27;</span>) || c == <span class="string">&#x27;[&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            stack.push(c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> p1 = (c == <span class="string">&#x27;)&#x27;</span> &amp;&amp; (<span class="keyword">char</span>) stack.peek() == <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> p2 = (c == <span class="string">&#x27;]&#x27;</span> &amp;&amp; (<span class="keyword">char</span>) stack.peek() == <span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">            <span class="keyword">boolean</span> p3 = (c == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; (<span class="keyword">char</span>) stack.peek() == <span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (p1 || p2 || p3) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h4><h5 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;</span><br><span class="line">    ListNode prevHead &#x3D; new ListNode(-1);</span><br><span class="line">    ListNode  prev &#x3D; prevHead;</span><br><span class="line">    while (l1 !&#x3D; null &amp;&amp; l2 !&#x3D; null) &#123;</span><br><span class="line">        if (l1.val &lt; l2.val) &#123;</span><br><span class="line">            prev.next &#x3D; l1;</span><br><span class="line">            l1 &#x3D; l1.next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            prev.next &#x3D; l2;</span><br><span class="line">            l2 &#x3D; l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        prev &#x3D; prev.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (l1 &#x3D;&#x3D; null) &#123;</span><br><span class="line">        prev.next &#x3D; l2;</span><br><span class="line">    &#125;</span><br><span class="line">    if (l2 &#x3D;&#x3D; null) &#123;</span><br><span class="line">        prev.next &#x3D; l1;</span><br><span class="line">    &#125;</span><br><span class="line">    return prevHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="迭代解法"><a href="#迭代解法" class="headerlink" title="迭代解法"></a>迭代解法</h5><p>待学习</p>
<h4 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h4><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p>
<p>图示两个链表在节点 c1 开始相交：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution_160</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode la = headA;</span><br><span class="line">        ListNode lb = headB;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(la!=lb)&#123;</span><br><span class="line">            la = (la==<span class="keyword">null</span>) ? headB : la.next;</span><br><span class="line">            lb = (lb==<span class="keyword">null</span>) ? headA : lb.next ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> la;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>先走自己的路，再走对方的路，最终路程一样</strong></p>
<p>可以这么理解，a，b两个链表，变更为 a+b 和 b+a，长度就相等了，然后等步遍历判断是否相等就行了</p>
<p>原始的数据</p>
<p><img src="https://pic.leetcode-cn.com/1628662967-RLmciV-2.png"></p>
<p>修改后的数据示意图</p>
<p><img src="https://pic.leetcode-cn.com/1628662688-ZdSYRM-1.png" alt="1.png"></p>
<p>!(<img src="https://pic.leetcode-cn.com/e86e947c8b87ac723b9c858cd3834f9a93bcc6c5e884e41117ab803d205ef662-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8.png" alt="相交链表.png">)</p>
<h4 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a></h4><p>迭代法需要再写下 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://noteforme.github.io/2022/07/26/Leetcode/" data-id="cktqmu9vt0000gph4a0yx25je" data-title="leetcode" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Gradle" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/26/Gradle/" class="article-date">
  <time class="dt-published" datetime="2022-07-26T06:58:38.000Z" itemprop="datePublished">2022-07-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/07/26/Gradle/">Gradle</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>可以研究下 Project Api </p>
<h3 id="DEBUG"><a href="#DEBUG" class="headerlink" title="DEBUG"></a>DEBUG</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;gradlew &quot;-Dorg.gradle.daemon&#x3D;false&quot; &quot;-Dorg.gradle.debug&#x3D;true&quot; :tasks</span><br></pre></td></tr></table></figure>



<p>9:37</p>
<h3 id="Gradle-Lifecycle"><a href="#Gradle-Lifecycle" class="headerlink" title="Gradle Lifecycle"></a>Gradle Lifecycle</h3><p><a target="_blank" rel="noopener" href="https://docs.gradle.org/current/userguide/build_lifecycle.html">https://docs.gradle.org/current/userguide/build_lifecycle.html</a></p>
<ul>
<li><p>Initialization</p>
<p>Detects the <a target="_blank" rel="noopener" href="https://docs.gradle.org/current/userguide/organizing_gradle_projects.html#sec:settings_file">settings file</a>.Evaluates the settings file to determine which projects and included builds participate in the build.Creates a <a target="_blank" rel="noopener" href="https://docs.gradle.org/current/dsl/org.gradle.api.Project.html"><code>Project</code></a> instance for every project.</p>
</li>
<li><p>Configuration</p>
<p>Evaluates the build scripts of every project participating in the build.Creates a task graph for requested tasks.</p>
<p>本质上把build.gradle从上到下跑一遍。</p>
</li>
<li><p>Execution</p>
<p>Schedules and executes each of the selected tasks in the order of their dependencies.</p>
</li>
</ul>
<h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1m54y1L7vK/">https://www.bilibili.com/video/BV1m54y1L7vK/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1dK411K7Pg">https://www.bilibili.com/video/BV1dK411K7Pg</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1DE411Z7nt">https://www.bilibili.com/video/BV1DE411Z7nt</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1dp4y1e7W4">https://www.bilibili.com/video/BV1dp4y1e7W4</a></p>
<p>注意Android stuio默认关闭task 按钮</p>
<h5 id="静态任务"><a href="#静态任务" class="headerlink" title="静态任务"></a>静态任务</h5><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">&quot;gradle study&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">task(<span class="string">&quot;helloworld&quot;</span>,&#123;</span><br><span class="line">    println(<span class="string">&#x27;configure&#x27;</span>)</span><br><span class="line">    doLast &#123;&#123;</span><br><span class="line">        println(<span class="string">&quot;Executing task&quot;</span>)</span><br><span class="line">    &#125;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>./gradlew helloworld</p>
<h5 id="动态任务"><a href="#动态任务" class="headerlink" title="动态任务"></a>动态任务</h5><p><img src="/2022/07/26/Gradle/2023-07-16-gradle1.png" alt="2023-07-16-gradle1"></p>
<p>“configure” 在生命周期Configuration 阶段就执行。</p>
<p>dolast dofirst只是加入到任务中，只有指定具体执行的任务，才会执行，就像上面的 ./gradlew helloworld，指明helloworld任务。</p>
<p>闭包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">task testGrdele&#123;</span><br><span class="line">    println(&quot;testGrdele&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;闭包的概念, 像kotlin匿名函数</span><br><span class="line">task closure&#123;</span><br><span class="line">    mEach&#123;</span><br><span class="line">        println it</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mEachWithParams &#123; m, n -&gt;&#x2F;&#x2F;  -&gt; 将闭包的参数和主体分离开</span><br><span class="line">        println &quot;$&#123;m&#125; is $&#123;n&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">def mEach(closure)&#123;</span><br><span class="line">    for (int i in 1..5)&#123;</span><br><span class="line">        closure(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def mEachWithParams(closure)&#123;</span><br><span class="line">    def map &#x3D; [&#39;name&#39;:&#39;groovy&#39;,&#39;age&#39;:10]</span><br><span class="line">    map.each &#123;</span><br><span class="line">        closure(it.key,it.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h3><h4 id="Scrpit-Plugin"><a href="#Scrpit-Plugin" class="headerlink" title="Scrpit Plugin"></a>Scrpit Plugin</h4><h5 id="CustomGradlePlugin"><a href="#CustomGradlePlugin" class="headerlink" title="CustomGradlePlugin"></a>CustomGradlePlugin</h5><p> ./gradlew CustomGradlePlugin</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.脚本插件</span></span><br><span class="line"><span class="comment">//app模块下的build.gradle文件中定义的对象插件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomGradlePlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> apply(Project target) &#123;</span><br><span class="line">        target.task(<span class="string">&quot;showCustomPlugin&quot;</span>) &#123;</span><br><span class="line">            doLast &#123;</span><br><span class="line">                println(<span class="string">&quot;this is CustomGradlePlugin&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>./gradlew scriptPlugin</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply from: &quot;config.gradle&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">project.task(<span class="string">&quot;scriptPlugin&quot;</span>) &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println(<span class="string">&quot;$project.name:this is a scriptPlugin&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>ankotlin:this is a scriptPlugin</p>
<h5 id="MyAwesomePlugin"><a href="#MyAwesomePlugin" class="headerlink" title="MyAwesomePlugin"></a>MyAwesomePlugin</h5><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAwesomePlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt;&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> apply(Project project) &#123;</span><br><span class="line">        task(<span class="string">&quot;helloworld22&quot;</span>,&#123;</span><br><span class="line">            println(<span class="string">&#x27;configure&#x27;</span>)</span><br><span class="line">            doLast &#123;&#123;</span><br><span class="line">                println(<span class="string">&quot;Executing task&quot;</span>)</span><br><span class="line">            &#125;&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply <span class="attr">plugins :</span> MyAwesomePlugin</span><br></pre></td></tr></table></figure>





<p>buildscript 可以把java complile的classpath加入到build.gradle中</p>
<h4 id="Use-Plungin-in-build-gradle"><a href="#Use-Plungin-in-build-gradle" class="headerlink" title="Use Plungin in build.gradle"></a>Use Plungin in build.gradle</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath group: &#39;org.apache.commons&#39;, name: &#39;commons-lang3&#39;, version: &#39;3.5&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: &#39;java&#39;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation group: &#39;org.apache.commons&#39;, name: &#39;commons-lang3&#39;, version: &#39;3.5&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (StringUtils.isNoneEmpty())&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就能使用java的方法在build.gradle中。</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/60550107/gradle-share-repository-configuration-between-settings-gradle-kts-and-buildsrc">https://stackoverflow.com/questions/60550107/gradle-share-repository-configuration-between-settings-gradle-kts-and-buildsrc</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://noteforme.github.io/2022/07/26/Gradle/" data-id="clce8xxqh0004k79k0irq60a3" data-title="Gradle" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-kotlin-inline" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/24/kotlin-inline/" class="article-date">
  <time class="dt-published" datetime="2022-07-24T03:54:53.000Z" itemprop="datePublished">2022-07-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Kotlin/">Kotlin</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/07/24/kotlin-inline/">kotlin-inline</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/2022/07/24/kotlin-inline/20220724115333.jpg" alt="20220724115333"></p>
<h4 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h4><p>4:00分钟 </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    hello &#123;</span><br><span class="line">        println(<span class="string">&quot;Bye&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="不加inline"><a href="#不加inline" class="headerlink" title="不加inline"></a>不加inline</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">(postAction: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line">    postAction()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际编译结果大致</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">val</span> post. = <span class="keyword">object</span>: Function0&lt;<span class="built_in">Unit</span>&gt;&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">nvoke</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> prinltn(<span class="string">&quot;Bye!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在for(i in 1.. 100) 就会创建很对个对象</p>
<h5 id="加-inline"><a href="#加-inline" class="headerlink" title="加 inline"></a>加 inline</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">(postAction: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line">    postAction()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不仅把函数内连过来,也会把它内部的函数的类型的参数 ，lambda表达式也内联过来.</p>
<p>//编译代码 类似</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  println(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">  println(<span class="string">&quot;Bye!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就不存在，对象的创建</p>
<p>noinline</p>
<p>crossinline</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1kz4y1f7sf">https://www.bilibili.com/video/BV1kz4y1f7sf</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://noteforme.github.io/2022/07/24/kotlin-inline/" data-id="clce8xxqv000hk79kcbo909hw" data-title="kotlin-inline" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-LC-Tree" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/17/LC-Tree/" class="article-date">
  <time class="dt-published" datetime="2022-07-17T10:51:21.000Z" itemprop="datePublished">2022-07-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/DataStructure/">DataStructure</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/07/17/LC-Tree/">LC-Tree</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>二叉树算法思维</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1nG411x77H">https://www.bilibili.com/video/BV1nG411x77H</a></p>
<p>TreeOperation.java打印树</p>
<h4 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h4><p><img src="/2022/07/17/LC-Tree/20220723171518.jpg" alt="20220723171518"></p>
<p><img src="/2022/07/17/LC-Tree/20220723171848.jpg" alt="20220723171848"></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1JW411i731">https://www.bilibili.com/video/BV1JW411i731</a></p>
<h5 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h5><p>数组存储方式</p>
<p><img src="/2022/07/17/LC-Tree/20220723173810.jpg" alt="20220723173810"></p>
<p>i 是数组下标</p>
<h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p><img src="/2022/07/17/LC-Tree/20220723183845.jpg" alt="20220723183845"></p>
<p>每个Node都有3次访问机会，谁先出现就代表什么序.</p>
<p>中间节点  在哪,代表的遍历方式</p>
<ul>
<li>先序遍历  preorder traversal ：中左右</li>
<li>中序遍历 inorder traversal：左中右</li>
<li>后序遍历 postorder traversal：左右中</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/azl397985856/leetcode/blob/master/thinkings/tree.md">https://github.com/azl397985856/leetcode/blob/master/thinkings/tree.md</a></p>
<h5 id="preorder-traversal-递归"><a href="#preorder-traversal-递归" class="headerlink" title="preorder traversal 递归"></a>preorder traversal 递归</h5><p><img src="/2022/07/17/LC-Tree/20220724172053.jpg" alt="20220724172053"></p>
<p>二叉树的遍历动画</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1RR4y1j7kh">https://www.bilibili.com/video/BV1RR4y1j7kh</a></p>
<p>B的左边遍历完成后，开始遍历B的右子树</p>
<p>遍历过程</p>
<ol>
<li>访问根节点</li>
<li>先序遍历其左子树</li>
<li>先序遍历其右子树</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraversal</span><span class="params">(BinTree BT)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(BT)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, BT -&gt; Data);</span><br><span class="line">    PreOrderTraversal(BT-&gt;Left)</span><br><span class="line">    PreOrderTraversal(BT-&gt;Right)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1JW411i731?p=34&amp;vd_source=d4c5260002405798a57476b318eccac9">https://www.bilibili.com/video/BV1JW411i731?p=34&amp;vd_source=d4c5260002405798a57476b318eccac9</a></p>
<h5 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h5><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV15f4y1W7i2">https://www.bilibili.com/video/BV15f4y1W7i2</a></p>
<h5 id="构建和打印树"><a href="#构建和打印树" class="headerlink" title="构建和打印树"></a>构建和打印树</h5><p><a target="_blank" rel="noopener" href="https://blog.nowcoder.net/n/f3799d64ed764fd49c63947d617d4cd5">https://blog.nowcoder.net/n/f3799d64ed764fd49c63947d617d4cd5</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/playground/VDCGQ8Ds/">https://leetcode.cn/playground/VDCGQ8Ds/</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/vpcMyM/">https://leetcode.cn/circle/discuss/vpcMyM/</a></p>
<p>中序遍历</p>
<p><img src="/2022/07/17/LC-Tree/20220723183055.jpg" alt="20220723183055"></p>
<h5 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h5><p>也叫 广度优先遍历</p>
<p>用队列实现</p>
<p>while遍历纵向层数</p>
<p>for遍历横向</p>
<p><img src="https://labuladong.gitee.io/algo/images/dijkstra/1.jpeg"></p>
<p><img src="/2022/07/17/LC-Tree/20220723185012.jpg" alt="20220723185012"></p>
<h4 id="确定二叉树"><a href="#确定二叉树" class="headerlink" title="确定二叉树"></a>确定二叉树</h4><p>必须有中序遍历，和先 后 序遍历之一</p>
<p><img src="/2022/07/17/LC-Tree/20220723185911.jpg" alt="20220723185911"></p>
<p>二叉搜索树</p>
<p>BST. Binary Search Tree</p>
<p><img src="/2022/07/17/LC-Tree/20220723190752.jpg" alt="20220723190752"></p>
<h5 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h5><p>递归</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">preorderTraversal</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> linkedList = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    preTraversal(root, linkedList)</span><br><span class="line">    <span class="keyword">return</span> linkedList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">preTraversal</span><span class="params">(node: <span class="type">TreeNode</span>?, linkedList: <span class="type">LinkedList</span>&lt;<span class="type">Int</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="comment">// 这样的递归基更好</span></span><br><span class="line">    linkedList.add(node.`<span class="keyword">val</span>`)</span><br><span class="line">    preTraversal(node.left, linkedList)</span><br><span class="line">    preTraversal(node.right, linkedList)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>迭代</p>
<p>随想录</p>
<p>前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。</p>
<p>为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbmss7603g30eq0d4b2a.gif" alt="二叉树前序遍历（迭代法）"></p>
<p>5 4 1 2 6</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">preorderTraversal1</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> linkedList = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">val</span> stack = Stack&lt;TreeNode&gt;()</span><br><span class="line">    root?.let&#123;</span><br><span class="line">        stack.push(it)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> popNode = stack.pop()</span><br><span class="line">        popNode.`<span class="keyword">val</span>`.let&#123;</span><br><span class="line">            linkedList.add(it)</span><br><span class="line">        &#125;</span><br><span class="line">        popNode.right?.let &#123;</span><br><span class="line">            stack.push(it)</span><br><span class="line">        &#125;</span><br><span class="line">        popNode.left?.let &#123;</span><br><span class="line">            stack.push(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> linkedList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h5><p>递归</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">inorderTraversal</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> linkedList = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    orderRecursive(root, linkedList)</span><br><span class="line">    <span class="keyword">return</span> linkedList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">orderRecursive</span><span class="params">(node: <span class="type">TreeNode</span>?, linkedList: <span class="type">LinkedList</span>&lt;<span class="type">Int</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">    orderRecursive(node.left, linkedList)</span><br><span class="line">    linkedList.add(node.`<span class="keyword">val</span>`)</span><br><span class="line">    orderRecursive(node.right, linkedList)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>迭代法</p>
<p>随想录</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbmuj244bg30eq0d4kjm.gif" alt="二叉树中序遍历（迭代法）"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">inorderTraversal1</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> linkedList = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> linkedList</span><br><span class="line">    <span class="keyword">val</span> stack = Stack&lt;TreeNode&gt;()</span><br><span class="line">    <span class="keyword">var</span> node = root</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span> || !stack.empty()) &#123; <span class="comment">//node != null 第一次可以进来</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(node)</span><br><span class="line">            node = node.left</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> resultNode = stack.pop()</span><br><span class="line">            linkedList.add(resultNode.`<span class="keyword">val</span>`)</span><br><span class="line">            node = resultNode.right</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> linkedList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h5><p>递归</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//recurive</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">postorderTraversal</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> linkedList = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    recursiveTraversal(root, linkedList)</span><br><span class="line">    <span class="keyword">return</span> linkedList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">recursiveTraversal</span><span class="params">(node: <span class="type">TreeNode</span>?, linkedList: <span class="type">LinkedList</span>&lt;<span class="type">Int</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">    recursiveTraversal(node.left, linkedList)</span><br><span class="line">    recursiveTraversal(node.right, linkedList)</span><br><span class="line">    linkedList.add(node.`<span class="keyword">val</span>`)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>迭代法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">postorderTraversal</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">     <span class="keyword">var</span> mRoot = root</span><br><span class="line">     <span class="keyword">val</span> resultList = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">     <span class="keyword">val</span> stack = Stack&lt;TreeNode&gt;()</span><br><span class="line">     <span class="keyword">var</span> preNode: TreeNode? = <span class="literal">null</span></span><br><span class="line">     <span class="keyword">while</span> (mRoot != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">         <span class="keyword">while</span> (mRoot != <span class="literal">null</span>) &#123;</span><br><span class="line">             stack.push(mRoot)</span><br><span class="line">             mRoot = mRoot.left</span><br><span class="line">         &#125;</span><br><span class="line">         mRoot = stack.pop()</span><br><span class="line">         <span class="keyword">if</span> (mRoot?.right == <span class="literal">null</span> || mRoot.right == preNode) &#123; <span class="comment">// 一开始写成这样 mRoot == preNode,导致死循环</span></span><br><span class="line">             resultList.add(mRoot.`<span class="keyword">val</span>`)</span><br><span class="line">             preNode = mRoot</span><br><span class="line">             mRoot = <span class="literal">null</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             stack.push(mRoot)</span><br><span class="line">             mRoot = mRoot.right</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> resultList</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-postorder-traversal/solution/er-cha-shu-de-hou-xu-bian-li-by-leetcode-solution/">https://leetcode.cn/problems/binary-tree-postorder-traversal/solution/er-cha-shu-de-hou-xu-bian-li-by-leetcode-solution/</a> 动图</p>
<p>官方题解</p>
<p>迭代法统一写法</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/dai-ma-sui-xiang-lu-che-di-chi-tou-qian-xjof1/">https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/dai-ma-sui-xiang-lu-che-di-chi-tou-qian-xjof1/</a></p>
<p>这个统一法还没研究，先往后学吧，地铁上看了下，其实也不难</p>
<h4 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h4><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnad5itmk8g30iw0cqe83.gif"></p>
<p>按照顺序，下一层的放在后面.</p>
<h5 id="迭代写法"><a href="#迭代写法" class="headerlink" title="迭代写法"></a>迭代写法</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">levelOrder</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> layerList = LinkedList&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.offer(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> layerSize = queue.size <span class="comment">// queue大小，下面循环在不断变化，所以要先定义出来</span></span><br><span class="line">        <span class="keyword">val</span> linkedList = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until layerSize) &#123;</span><br><span class="line">            <span class="keyword">val</span> headNode = queue.poll()</span><br><span class="line">            linkedList.add(headNode.`<span class="keyword">val</span>`)</span><br><span class="line">            headNode.left?.let &#123; queue.offer(it) &#125;</span><br><span class="line">            headNode.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        layerList.add(linkedList)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> layerList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h5><p>递归解法一开始没理解，再看了下，思路很妙</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">levelOrder1</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> layerList = LinkedList&lt;LinkedList&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> layerList</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> depth = <span class="number">0</span> <span class="comment">// 层级</span></span><br><span class="line">    <span class="keyword">return</span> recursive(layerList, root, depth)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">recursive</span><span class="params">(layerList: <span class="type">LinkedList</span>&lt;<span class="type">LinkedList</span>&lt;<span class="type">Int</span>&gt;&gt;, node: <span class="type">TreeNode</span>?, depth: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (layerList.size &lt;= depth) &#123; <span class="comment">//二维数组长度不超过这个层级,随想录这里是用 ==,不过我觉得&lt;=更好</span></span><br><span class="line">        <span class="keyword">val</span> linkedList = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        layerList.add(linkedList)</span><br><span class="line">    &#125;</span><br><span class="line">    node?.`<span class="keyword">val</span>`?.let &#123; layerList[depth].add(it) &#125; <span class="comment">// 拿到当前层级节点的值</span></span><br><span class="line">    <span class="keyword">val</span> mDepth = depth + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (node?.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        recursive(layerList, node.left, mDepth)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node?.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        recursive(layerList, node.right, mDepth)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> layerList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/solution/er-cha-shu-de-ceng-xu-bian-li-by-leetcode-solution/">https://leetcode.cn/problems/binary-tree-level-order-traversal/solution/er-cha-shu-de-ceng-xu-bian-li-by-leetcode-solution/</a></p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html">https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html</a></p>
<h4 id="107-二叉树的层序遍历-II"><a href="#107-二叉树的层序遍历-II" class="headerlink" title="107. 二叉树的层序遍历 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层序遍历 II</a></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">levelOrderBottom</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> resultList = LinkedList&lt;ArrayList&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.offer(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> layerSize = queue.size <span class="comment">// queue循环中 不断的变化</span></span><br><span class="line">        <span class="keyword">val</span> arrayList = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until layerSize) &#123;</span><br><span class="line">            <span class="keyword">val</span> headNode = queue.poll()</span><br><span class="line">            <span class="keyword">if</span> (headNode != <span class="literal">null</span>) &#123;</span><br><span class="line">                arrayList.add(headNode.`<span class="keyword">val</span>`)</span><br><span class="line">                headNode.left?.let &#123; queue.offer(it) &#125;</span><br><span class="line">                headNode.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        resultList.addFirst(arrayList)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultList</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>



<h4 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h4><h5 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">rightSideView</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> resultList = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.add(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> layoutSize = queue.size</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until layoutSize) &#123;</span><br><span class="line">            <span class="keyword">val</span> headNode = queue.poll()</span><br><span class="line">            <span class="keyword">if</span> (i == layoutSize - <span class="number">1</span>) &#123;</span><br><span class="line">                resultList.add(headNode.`<span class="keyword">val</span>`)</span><br><span class="line">            &#125;</span><br><span class="line">            headNode?.left?.let &#123; queue.offer(it) &#125;</span><br><span class="line">            headNode?.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="DFS-深度优先遍历"><a href="#DFS-深度优先遍历" class="headerlink" title="DFS 深度优先遍历"></a>DFS 深度优先遍历</h5><p>这个DFS很妙，这次只是先理解,二刷的时候可以自己写写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solutions</span></span>&#123;</span><br><span class="line">	  List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">       dfs(root,<span class="number">0</span>)</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function">prvidate <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root ==<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(depth == res.size())&#123; <span class="comment">// 当前层级第一个右节点还没有，添加到结果中</span></span><br><span class="line">      res.add(root.val)</span><br><span class="line">    &#125;</span><br><span class="line">    depth++;</span><br><span class="line">    dfs(root.right,depth)</span><br><span class="line">    dfs(root.left,depth)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理解在官方视频中.</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/solution/er-cha-shu-de-you-shi-tu-by-leetcode-solution/">https://leetcode.cn/problems/binary-tree-right-side-view/solution/er-cha-shu-de-you-shi-tu-by-leetcode-solution/</a></p>
<h4 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637. 二叉树的层平均值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">637. 二叉树的层平均值</a></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">averageOfLevels</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: DoubleArray &#123;</span><br><span class="line">    <span class="keyword">val</span> resultList = ArrayList&lt;<span class="built_in">Double</span>&gt;()</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.offer(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> layoutSize = queue.size</span><br><span class="line">        <span class="keyword">var</span> layerSum = <span class="number">0.</span>toDouble()</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until layoutSize) &#123;</span><br><span class="line">            <span class="keyword">val</span> node = queue.poll()</span><br><span class="line">            layerSum += node.`<span class="keyword">val</span>`</span><br><span class="line">            node?.left?.let &#123; queue.offer(it) &#125;</span><br><span class="line">            node?.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> average = resultList.add(layerSum * <span class="number">1.00000</span> / layoutSize)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultList.toDoubleArray()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="429-N-叉树的层序遍历"><a href="#429-N-叉树的层序遍历" class="headerlink" title="429. N 叉树的层序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">429. N 叉树的层序遍历</a></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">levelOrder</span><span class="params">(root: <span class="type">Node</span>?)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> result = LinkedList&lt;ArrayList&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;Node&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.offer(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> layoutSize = queue.size <span class="comment">// 该层级的节点数</span></span><br><span class="line">        <span class="keyword">val</span> layerResult = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until layoutSize) &#123;</span><br><span class="line">            <span class="keyword">val</span> pollNode = queue.poll()</span><br><span class="line">            layerResult.add(pollNode.`<span class="keyword">val</span>`)</span><br><span class="line">            pollNode.children.forEach &#123; <span class="comment">// 只有这里有点不同</span></span><br><span class="line">                queue.offer(it)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(layerResult)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="515-在每个树行中找最大值"><a href="#515-在每个树行中找最大值" class="headerlink" title="515. 在每个树行中找最大值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">515. 在每个树行中找最大值</a></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largestValues</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> answer = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.offer(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> layerSize = queue.size</span><br><span class="line">        <span class="keyword">var</span> maxValue = <span class="built_in">Int</span>.MIN_VALUE <span class="comment">//最小值 , 每一层级都要初始化，否则拿到上一层级的值，就不是最小值，会有问题</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until layerSize) &#123;</span><br><span class="line">            <span class="keyword">val</span> pollNode = queue.poll()</span><br><span class="line">            maxValue = pollNode.`<span class="keyword">val</span>`.coerceAtLeast(maxValue) <span class="comment">// 比较取最大值</span></span><br><span class="line">            pollNode?.left?.let &#123; queue.offer(it) &#125;</span><br><span class="line">            pollNode?.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        answer.add(maxValue)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></p>
<p>一开始用这种方式，但是会提示 “超出内存限制”</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">connect</span><span class="params">(root: <span class="type">Node</span>?)</span></span>: Node? &#123;</span><br><span class="line"><span class="comment">//        val answerList = ArrayList&lt;String&gt;() //根据题意, 一开始以为要返回这个答案,其实只要连接后 返回root就好了</span></span><br><span class="line">        <span class="keyword">val</span> queue = LinkedList&lt;Node&gt;()</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.offer(root)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> preNode: Node?=<span class="literal">null</span></span><br><span class="line">        <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">            <span class="keyword">val</span> layerSize = queue.size</span><br><span class="line">            preNode = <span class="literal">null</span></span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until layerSize) &#123;</span><br><span class="line">                <span class="keyword">val</span> curNode = queue.poll()</span><br><span class="line">                preNode = curNode </span><br><span class="line">                <span class="keyword">if</span> (preNode != <span class="literal">null</span>) &#123;</span><br><span class="line">                    preNode.next = curNode</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//                answerList.add(curNode.`val`.toString())</span></span><br><span class="line">                <span class="keyword">if</span> (i == layerSize - <span class="number">1</span>) &#123;</span><br><span class="line">                    curNode.next = <span class="literal">null</span>  <span class="comment">// 最后个node 指向null</span></span><br><span class="line">                <span class="comment">//    answerList.add(&quot;#&quot;)</span></span><br><span class="line">                &#125;</span><br><span class="line">                curNode?.left?.let &#123; queue.offer(it) &#125;</span><br><span class="line">                curNode?.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>官方解法 还有另一种解法，二刷时可以研究研究</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">connect</span><span class="params">(root: <span class="type">Node</span>?)</span></span>: Node? &#123;</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;Node&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.offer(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> layerSize = queue.size</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until layerSize) &#123;</span><br><span class="line">            <span class="keyword">val</span> curNode = queue.poll()</span><br><span class="line">            <span class="keyword">if</span> (i &lt; layerSize - <span class="number">1</span>) &#123;</span><br><span class="line">                curNode.next = queue.peek()</span><br><span class="line">            &#125;</span><br><span class="line">            curNode?.left?.let &#123; queue.offer(it) &#125;</span><br><span class="line">            curNode?.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/solution/tian-chong-mei-ge-jie-dian-de-xia-yi-ge-you-ce-2-4/">https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/solution/tian-chong-mei-ge-jie-dian-de-xia-yi-ge-you-ce-2-4/</a></p>
<h4 id="117-填充每个节点的下一个右侧节点指针-II"><a href="#117-填充每个节点的下一个右侧节点指针-II" class="headerlink" title="117. 填充每个节点的下一个右侧节点指针 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">117. 填充每个节点的下一个右侧节点指针 II</a></h4><p>和116题唯一的区别，116是完美二叉树</p>
<h4 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h4><h5 id="广度优先-Breadth-First-Search"><a href="#广度优先-Breadth-First-Search" class="headerlink" title="广度优先 Breadth-First-Search"></a>广度优先 <strong>Breadth-First-Search</strong></h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">maxDepth</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    <span class="keyword">var</span> depth = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.offer(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> layerSize = queue.size</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until layerSize) &#123;</span><br><span class="line">            <span class="keyword">val</span> pollNode = queue.poll()</span><br><span class="line">            pollNode?.left?.let &#123; queue.add(it) &#125; </span><br><span class="line">            pollNode?.right?.let &#123; queue.add(it) &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == layerSize - <span class="number">1</span>) &#123;	</span><br><span class="line">                depth++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="递归-Depth-First-Search"><a href="#递归-Depth-First-Search" class="headerlink" title="递归 Depth First Search"></a>递归 Depth <strong>First Search</strong></h5><p>这题用一个方法就可以了，遍历左右子树取最大值后 再加 1</p>
<p>这个其实也是先序遍历,左右中</p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html#%E9%80%92%E5%BD%92%E6%B3%95">https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html#%E9%80%92%E5%BD%92%E6%B3%95</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> leftdepth = <span class="built_in">getdepth</span>(node-&gt;left);       <span class="comment">// 左</span></span><br><span class="line"><span class="keyword">int</span> rightdepth = <span class="built_in">getdepth</span>(node-&gt;right);     <span class="comment">// 右</span></span><br><span class="line"><span class="keyword">int</span> depth = <span class="number">1</span> + <span class="built_in">max</span>(leftdepth, rightdepth); <span class="comment">// 中</span></span><br><span class="line"><span class="keyword">return</span> depth;</span><br></pre></td></tr></table></figure>



<p><strong>可以看看随想录的解法，里面有回溯的过程，过程更详细</strong></p>
<p>下面解法做了简化</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">maxDepth</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> depth = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> depth</span><br><span class="line">    <span class="keyword">return</span> dfsDepth(root, depth)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dfsDepth</span><span class="params">(node: <span class="type">TreeNode</span>?, depth: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> depth</span><br><span class="line">    <span class="keyword">val</span> maxDepth = Math.max(dfsDepth(node.left, depth + <span class="number">1</span>), dfsDepth(node.right, depth + <span class="number">1</span>)) <span class="comment">// 用max函数更直观</span></span><br><span class="line">    <span class="keyword">return</span> maxDepth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/solution/er-cha-shu-de-zui-da-shen-du-by-leetcode-solution/">https://leetcode.cn/problems/maximum-depth-of-binary-tree/solution/er-cha-shu-de-zui-da-shen-du-by-leetcode-solution/</a></p>
<h4 id="559-N-叉树的最大深度"><a href="#559-N-叉树的最大深度" class="headerlink" title="559. N 叉树的最大深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/">559. N 叉树的最大深度</a></h4><p>DFS</p>
<p> 这个DFS解法 看了官方题解答案，自己再做一次</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/solution/n-cha-shu-de-zui-da-shen-du-by-leetcode-n7qtv/">https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/solution/n-cha-shu-de-zui-da-shen-du-by-leetcode-n7qtv/</a></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">maxDepth</span><span class="params">(root: <span class="type">Node</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> maxDepth = <span class="number">0</span></span><br><span class="line">    root.children.forEach &#123;</span><br><span class="line">        <span class="keyword">val</span> depth = maxDepth(it)</span><br><span class="line">        maxDepth = Math.max(maxDepth, depth)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxDepth +<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>BFS</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">maxDepth1</span><span class="params">(root: <span class="type">Node</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;Node&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.offer(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> maxDepth = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> layerSize = queue.size</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until layerSize) &#123;</span><br><span class="line">            <span class="keyword">val</span> pollNode = queue.poll()</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123; <span class="comment">// 这个条件可以去掉</span></span><br><span class="line">                maxDepth++</span><br><span class="line">            &#125;</span><br><span class="line">            pollNode.children.forEach &#123;</span><br><span class="line">                <span class="keyword">if</span> (it != <span class="literal">null</span>)</span><br><span class="line">                    queue.offer(it)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxDepth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">maxDepth1</span><span class="params">(root: <span class="type">Node</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;Node&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.offer(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> maxDepth = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> layerSize = queue.size</span><br><span class="line">        maxDepth++ <span class="comment">//拿到外面更好，不用判断i==1了,每次layerSize 遍历完就是一层了</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until layerSize) &#123;</span><br><span class="line">            <span class="keyword">val</span> pollNode = queue.poll()</span><br><span class="line">            pollNode.children.forEach &#123;</span><br><span class="line">                <span class="keyword">if</span> (it != <span class="literal">null</span>)</span><br><span class="line">                    queue.offer(it)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxDepth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h4><p>BFS</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">minDepth</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.offer(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> depth = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> layerSize = queue.size</span><br><span class="line">        depth++ <span class="comment">// 不用放下面判断，直接是一层新的</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until layerSize) &#123;</span><br><span class="line">            <span class="keyword">val</span> pollNode = queue.poll()</span><br><span class="line">            <span class="keyword">if</span> (pollNode.left == <span class="literal">null</span> &amp;&amp; pollNode.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> depth</span><br><span class="line">            &#125;</span><br><span class="line">            pollNode?.left?.let &#123; queue.offer(it) &#125;</span><br><span class="line">            pollNode?.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>官方题解看起来，更好</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/solution/er-cha-shu-de-zui-xiao-shen-du-by-leetcode-solutio/">https://leetcode.cn/problems/minimum-depth-of-binary-tree/solution/er-cha-shu-de-zui-xiao-shen-du-by-leetcode-solutio/</a></p>
<p>DFS</p>
<p><img src="https://img-blog.csdnimg.cn/20210203155800503.png"></p>
<p> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/solution/bfshe-dfsliang-chong-fang-shi-jie-jue-by-g4eh/">https://leetcode.cn/problems/minimum-depth-of-binary-tree/solution/bfshe-dfsliang-chong-fang-shi-jie-jue-by-g4eh/</a></p>
<p>用了这个视频的解法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">minDepth</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment">//左子节点和右子节点都不为空，然后取最小值才有意义，否则就是错的</span></span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="literal">null</span> &amp;&amp; root.right != <span class="literal">null</span>) &#123; <span class="comment">// 左右都不为空</span></span><br><span class="line">        <span class="keyword">return</span> Math.min(minDepth(root.left), minDepth(root.right)) + <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.left == <span class="literal">null</span>) &#123; <span class="comment">//左不为空</span></span><br><span class="line">        <span class="keyword">return</span> minDepth(root.right) + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minDepth(root.left) + <span class="number">1</span> <span class="comment">//右不为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>理解了这个解法，再看官方的DFS解法，也简单明了</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/solution/er-cha-shu-de-zui-xiao-shen-du-by-leetcode-solutio/">https://leetcode.cn/problems/minimum-depth-of-binary-tree/solution/er-cha-shu-de-zui-xiao-shen-du-by-leetcode-solutio/</a></p>
<h4 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></h4><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnakm26jtog30e409s4qp.gif"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">invertTree</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    swapNode(root) </span><br><span class="line">    invertTree(root.left)</span><br><span class="line">    invertTree(root.right)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">swapNode</span><span class="params">(node: <span class="type">TreeNode</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> temp = node?.left</span><br><span class="line">    node?.left = node?.right</span><br><span class="line">    node?.right = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    invertTree(root.left);<span class="comment">//注意这里是left</span></span><br><span class="line">    TreeNode temp = root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = temp;</span><br><span class="line">    invertTree(root.left);<span class="comment">//这里还是left</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>————————————————<br>版权声明：本文为CSDN博主「xsybg」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/xsybg/article/details/122687168">https://blog.csdn.net/xsybg/article/details/122687168</a></p>
<p>注意两个递归调用的参数都是root.left, 因为在第二步是交换root的左右孩子，所以在第三步要处理的右孩子其实已经变成了root的左孩子，是不是很有趣？<br>这个题目很简单，但是确实会稀里糊涂地通过，没搞清楚是树的哪一种遍历，看了代码随想录的解析感觉还挺惊喜的。<br>代码随想录的链接贴在这里：<br>————————————————<br>版权声明：本文为CSDN博主「xsybg」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/xsybg/article/details/122687168">https://blog.csdn.net/xsybg/article/details/122687168</a></p>
<p>根据下面打印</p>
<p>4的坐子树中的1,3交换了两次， 6,9一次都没交换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">      4      </span><br><span class="line">    &#x2F;   \    </span><br><span class="line">  2       7  </span><br><span class="line"> &#x2F; \     &#x2F; \ </span><br><span class="line">1   3   6   9</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> node 4</span><br><span class="line">      4      </span><br><span class="line">    &#x2F;   \    </span><br><span class="line">  2       7  </span><br><span class="line"> &#x2F; \     &#x2F; \ </span><br><span class="line">1   3   6   9</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> node 2</span><br><span class="line">      4      </span><br><span class="line">    &#x2F;   \    </span><br><span class="line">  2       7  </span><br><span class="line"> &#x2F; \     &#x2F; \ </span><br><span class="line">1   3   6   9</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> node 1</span><br><span class="line">      4      </span><br><span class="line">    &#x2F;   \    </span><br><span class="line">  2       7  </span><br><span class="line"> &#x2F; \     &#x2F; \ </span><br><span class="line">1   3   6   9</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> node 1</span><br><span class="line">      4      </span><br><span class="line">    &#x2F;   \    </span><br><span class="line">  2       7  </span><br><span class="line"> &#x2F; \     &#x2F; \ </span><br><span class="line">3   1   6   9</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> node 2</span><br><span class="line">      4      </span><br><span class="line">    &#x2F;   \    </span><br><span class="line">  7       2  </span><br><span class="line"> &#x2F; \     &#x2F; \ </span><br><span class="line">6   9   3   1</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> node 3</span><br><span class="line">      4      </span><br><span class="line">    &#x2F;   \    </span><br><span class="line">  7       2  </span><br><span class="line"> &#x2F; \     &#x2F; \ </span><br><span class="line">6   9   3   1</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> node 3</span><br><span class="line">      4      </span><br><span class="line">    &#x2F;   \    </span><br><span class="line">  7       2  </span><br><span class="line"> &#x2F; \     &#x2F; \ </span><br><span class="line">6   9   1   3</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="广度优先遍历-层序遍历"><a href="#广度优先遍历-层序遍历" class="headerlink" title="广度优先遍历(层序遍历)"></a>广度优先遍历(层序遍历)</h5><p>遍历左右节点就可以.然后交换就可以了</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">invertTree1</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.offer(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty())&#123;</span><br><span class="line">        <span class="keyword">val</span> layerSize = queue.size</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until layerSize)&#123;</span><br><span class="line">            <span class="keyword">val</span> pollNode = queue.poll()</span><br><span class="line">            swapNode(pollNode)</span><br><span class="line">            pollNode.left?.let &#123; queue.offer(it) &#125;</span><br><span class="line">            pollNode.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="https://noteforme.github.io/2022/07/17/LC-Tree/" data-id="clce8xxrx0014k79k2mtr742p" data-title="LC-Tree" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LEETCODE/" rel="tag">LEETCODE</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ANDROID/">ANDROID</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/BLE/">BLE</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DataStructure/">DataStructure</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DesignPatterns/">DesignPatterns</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ENGLISH/">ENGLISH</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/">JAVA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Jetpack/">Jetpack</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kotlin/">Kotlin</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LINUX/">LINUX</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mathematics/">Mathematics</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS/">OS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Organization/">Organization</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SOURCE/">SOURCE</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/TEST/">TEST</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/TOOL/">TOOL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/VIEW/">VIEW</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/anim/">anim</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/flutter/">flutter</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ANDROID/" rel="tag">ANDROID</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AOSP/" rel="tag">AOSP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Activity/" rel="tag">Activity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AndroidNewFeatures/" rel="tag">AndroidNewFeatures</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Assembly/" rel="tag">Assembly</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BLOG/" rel="tag">BLOG</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ConstraintLayout/" rel="tag">ConstraintLayout</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DB/" rel="tag">DB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Drawer/" rel="tag">Drawer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fragment/" rel="tag">Fragment</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LEETCODE/" rel="tag">LEETCODE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Operators/" rel="tag">Operators</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Performance/" rel="tag">Performance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RecyclerView/" rel="tag">RecyclerView</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RxJava/" rel="tag">RxJava</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/THINK/" rel="tag">THINK</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TOOL/" rel="tag">TOOL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TabLayout/" rel="tag">TabLayout</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Test/" rel="tag">Test</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TouchEvent/" rel="tag">TouchEvent</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VIEW/" rel="tag">VIEW</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XML/" rel="tag">XML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/anim/" rel="tag">anim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/compose/" rel="tag">compose</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/concurrency/" rel="tag">concurrency</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/coroutie/" rel="tag">coroutie</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/inter/" rel="tag">inter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/keyboard/" rel="tag">keyboard</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/permission/" rel="tag">permission</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/proguard/" rel="tag">proguard</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ANDROID/" style="font-size: 15px;">ANDROID</a> <a href="/tags/AOSP/" style="font-size: 16.67px;">AOSP</a> <a href="/tags/Activity/" style="font-size: 10px;">Activity</a> <a href="/tags/AndroidNewFeatures/" style="font-size: 10px;">AndroidNewFeatures</a> <a href="/tags/Assembly/" style="font-size: 10px;">Assembly</a> <a href="/tags/BLOG/" style="font-size: 10px;">BLOG</a> <a href="/tags/ConstraintLayout/" style="font-size: 10px;">ConstraintLayout</a> <a href="/tags/DB/" style="font-size: 11.67px;">DB</a> <a href="/tags/Drawer/" style="font-size: 10px;">Drawer</a> <a href="/tags/Fragment/" style="font-size: 11.67px;">Fragment</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/JVM/" style="font-size: 18.33px;">JVM</a> <a href="/tags/LEETCODE/" style="font-size: 20px;">LEETCODE</a> <a href="/tags/Operators/" style="font-size: 10px;">Operators</a> <a href="/tags/Performance/" style="font-size: 15px;">Performance</a> <a href="/tags/RecyclerView/" style="font-size: 11.67px;">RecyclerView</a> <a href="/tags/RxJava/" style="font-size: 15px;">RxJava</a> <a href="/tags/THINK/" style="font-size: 10px;">THINK</a> <a href="/tags/TOOL/" style="font-size: 10px;">TOOL</a> <a href="/tags/TabLayout/" style="font-size: 10px;">TabLayout</a> <a href="/tags/Test/" style="font-size: 15px;">Test</a> <a href="/tags/TouchEvent/" style="font-size: 13.33px;">TouchEvent</a> <a href="/tags/VIEW/" style="font-size: 15px;">VIEW</a> <a href="/tags/XML/" style="font-size: 10px;">XML</a> <a href="/tags/anim/" style="font-size: 10px;">anim</a> <a href="/tags/compose/" style="font-size: 10px;">compose</a> <a href="/tags/concurrency/" style="font-size: 15px;">concurrency</a> <a href="/tags/coroutie/" style="font-size: 16.67px;">coroutie</a> <a href="/tags/inter/" style="font-size: 11.67px;">inter</a> <a href="/tags/keyboard/" style="font-size: 10px;">keyboard</a> <a href="/tags/permission/" style="font-size: 10px;">permission</a> <a href="/tags/proguard/" style="font-size: 10px;">proguard</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/11/15/permission-storage/">permission_storage</a>
          </li>
        
          <li>
            <a href="/2023/11/15/notification/">notification</a>
          </li>
        
          <li>
            <a href="/2023/08/20/compose-layout/">compose_layout</a>
          </li>
        
          <li>
            <a href="/2023/08/09/LC-DP-BAG/">LC_DP_BAG</a>
          </li>
        
          <li>
            <a href="/2023/04/02/LC-DP/">LC-DP</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 Jon<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>