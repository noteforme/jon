<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Jon&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
  
  
    <link rel="alternate" href="/atom.xml" title="Jon's Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="/localshare/css/share.css">

  
  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Jon&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Cease to struggle and you cease to live. - Thomas Carlyle</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/."><i class="fa fa-home"></i> Home</a>
        
          <a class="main-nav-link" href="/archives/"><i class="fa fa-archive"></i> Archive</a>
        
          <a class="main-nav-link" href="/about/"><i class="fa fa-user"></i> About</a>
        
          <a class="main-nav-link" href="/atom.xml"><i class="fa fa-rss"></i> RSS</a>
        
      </nav>
    </div>
    <div id="search-form">
      <div id="result-mask" class="hide"></div>
      <label><input id="search-key" type="text" autocomplete="off" placeholder="search"></label>
      <div id="result-wrap" class="hide">
        <div id="search-result"></div>
      </div>
      <div class="hide">
        <template id="search-tpl">
          <div class="item">
            <a href="/{path}" title="{title}">
              <div class="title">{title}</div>
              <div class="time">{date}</div>
              <div class="tags">{tags}</div>
            </a>
          </div>
        </template>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  <article id="post-LC-DP-BAG" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/09/LC-DP-BAG/">LC_DP_BAG</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2023-08-09T14:42:49.000Z" itemprop="datePublished">2023年08月09日</time>
</span>
      
      
      
<a href="/2023/08/09/LC-DP-BAG/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/2023/08/09/LC-DP-BAG//c99835d0b3fe9eb9d3c2470c05afe79b7a917ad4.png" alt="Screenshot 2023-09-23 at 22.11.27.png"></p>
<p>对于01背包，物品i，我觉得也是从0开始更好。</p>
<p>纯01背包:装满这个背包的最大价值。</p>
<p>分割等和子集：能否装满。</p>
<p>本题: 给一个背包容量，有多少种方式装满。</p>
<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>随想录</p>
<p>背包问题理论基础</p>
<p>这个视频讲的很好</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1jT4y1o71J/">https://www.bilibili.com/video/BV1jT4y1o71J/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=cJ21moQpofY&t=575s">0/1 Knapsack problem | Dynamic Programming - YouTube</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1cg411g7Y6/">https://www.bilibili.com/video/BV1cg411g7Y6/</a></p>
<p>The 0/1 Knapsack Problem (Demystifying Dynamic Programming) - YouTube</p>
<p>有N件物品和一个最多能背重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是 value[i] 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] </span><br><span class="line">[0,i]物品任取放容量为j的背包</span><br><span class="line"></span><br><span class="line">不放物品i : dp[i-1][j]</span><br><span class="line">放物品i :  dp[i-1][j-weight[i]] + value[i]， 那么就是前i-1种物品的选择，减去当前i物品的重量 + 当前i物品的价值，其实就转化为 i-1种物品 j-weight[i]的容量下的最大值。</span><br><span class="line"></span><br><span class="line">dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i])</span><br></pre></td></tr></table></figure>

<p>从上面的递推公式可以看出，当前值都是由 左上角的值，其实我觉得是正上角， 来递推出来的。<code>dp[i-1][j]</code></p>
<p><img src="/2023/08/09/LC-DP-BAG//2023-09-10-15-34.png" alt="2023-09-10-15-34"></p>
<p>随想录的解法，物品0是第一个物品，所以X方向初始化是有值的</p>
<p>下面两个视频，x,y都初始化0，感觉更好。</p>
<p>01背包问题，这个视频讲的很好 </p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1pY4y1J7na">https://www.bilibili.com/video/BV1pY4y1J7na</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1K4411X766">https://www.bilibili.com/video/BV1K4411X766</a></p>
<p>对第0行，第0行没有任何物品，在任何背包容量下，前0个物品，能装进背包的最大价值为0.</p>
<p>对第0列，第0列没有任何容量，在任何物品都无法放进背包，因此价值也都为0.</p>
<p>最后一个单元格的数字，就是我们要得到的最终答案。</p>
<p>j<img src="/2023/08/09/LC-DP-BAG//fcecb2979a78a28732b7d44b1b3ab36b80e601dd.png" alt="2023-09-09-21.54.02.png"></p>
<p>sts/LC-DP/2023-09-09-21.54.02.png)</p>
<ol>
<li>[2,1] 放葡萄情况下： 葡萄占用2，并且葡萄无法再次被选择 ， 此时问题从背包容量为2的情况下，对前一种物品取舍选择后获得的容量，变成了背包容量最大为0的情况下，对前0种物品进行取舍选择后获得的最大价值。</li>
</ol>
<p><img src="/2023/08/09/LC-DP-BAG//0fa73053d8180256809d9259f750a51a6e8eb81d.png" alt="2023-09-09-21.56.02.png"></p>
<p>第2行3列的单元格，背包容量最大为3的情况下，对前面2种物品进行选择。</p>
<p>对于i行j列的单元格，背包容量最大为j的情况下，对前面i种物品进行选择，能使得背包价值最大，也就是说每个单元格都是当前条件下的最优解。</p>
<p><img src="/2023/08/09/LC-DP-BAG//6f00c545ed588441ecab7b33ec1afddd19cc12c8.png" alt="2023-09-10-18-21-30.png"></p>
<p>下面这个代码，把x,y 0的点都初始化为0.</p>
<p><img src="/2023/08/09/LC-DP-BAG//6ab176089e4ffef26bcc44d05710170e17c53722.png" alt="2023-09-10-18-18-05.png"></p>
<h3 id="放入的物品"><a href="#放入的物品" class="headerlink" title="放入的物品"></a>放入的物品</h3><p><img src="/2023/08/09/LC-DP-BAG//eb93d18fae9da2e606700effbb8f1d5918a161de.png" alt="Screenshot 2023-09-24 at 16.25.54.png"></p>
<p><img src="/2023/08/09/LC-DP-BAG//28998bfef50922d7b4982839b01667cc347a2d22.png" alt="Screenshot 2023-09-24 at 15.56.52.png"></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1jT4y1o71J/">https://www.bilibili.com/video/BV1jT4y1o71J/</a></p>
<ul>
<li>caculate what goods were added in bag. 33:00</li>
</ul>
<ol>
<li><p>先从dp[5][10] ,17开始，15 !=17 所以 物品5放入了背包, 这个是 dp[4][10-3]=11+6 得出来的，我们可以用10-3 走到了dp[4][7],</p>
</li>
<li><p>dp[4][7] 11 == dp[3][7] 所以物品4没有放入背包。然后走到了dp[3][7],</p>
</li>
<li><p>dp[3][7] 11 != dp[2][7] 9 , 所以物品3放入背包,  dp[2][7-4] + 3 = 9 .  然后走到了 dp[2[3]</p>
</li>
<li><p>dp[2][3] == dp[1][3] ==6,所以物品2没有放入背包, 然后走到了 dp[1][3]</p>
</li>
<li><p>dp[1][3] != dp[0][3] 说明 物品1放入背包，dp[0][3-2] + 6 , 然后就走到了dp[0][1]. </p>
</li>
</ol>
<p>and then will impement above code</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">fun knap01(): Int &#123;</span><br><span class="line"></span><br><span class="line">    val weightArr = arrayOf(1, 3, 4)</span><br><span class="line">    val valueArr = arrayOf(15, 20, 30)</span><br><span class="line"></span><br><span class="line">    val n = 5 // the number of goods</span><br><span class="line">    val w = 8// the max of bag weight</span><br><span class="line">    val dp = Array(n + 1) &#123; IntArray(w + 1) &#125; // 0 is nothing , so need one more</span><br><span class="line"></span><br><span class="line">    //即dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。</span><br><span class="line">    //初始化</span><br><span class="line"></span><br><span class="line">    //j==0 , 背包容量为0，放物品</span><br><span class="line">    for (i in 1 until n) &#123; //number</span><br><span class="line">        dp[i][0] = 0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // i==0 nothing to put in bag</span><br><span class="line">    for (j in 1 until w) &#123; //weights</span><br><span class="line">        dp[0][j] = 0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (i in 0 until n) &#123; //number</span><br><span class="line">        // i==0 , nothing to put in bag</span><br><span class="line">        for (j in 0 until w) &#123; //weights</span><br><span class="line">            if (weightArr[i] &gt; j) &#123; // 物品重量大于 背包容量</span><br><span class="line">                dp[i][j] = dp[i - 1][j]   // if object weight &lt; j , then use top item</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weightArr[i]] + valueArr[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> //这个需要后续的真题验证 </span><br><span class="line">    val addedList = ArrayList&lt;Int&gt;()</span><br><span class="line">    var j = w</span><br><span class="line">    for (i in n downTo 0) &#123;</span><br><span class="line">        if (dp[i - 1][j] &gt;= dp[i][j]) &#123;</span><br><span class="line">            j-=weightArr[j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n][w]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="滑动数组"><a href="#滑动数组" class="headerlink" title="滑动数组"></a>滑动数组</h3><p> <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1jT4y1o71J/">https://www.bilibili.com/video/BV1jT4y1o71J/</a></p>
<p>40:00</p>
<p>the video  clearly  talking about 01 knapstack problem which two ways.</p>
<p><img src="/2023/08/09/LC-DP-BAG//ba58f46e18a492b3083678b2d9f887656f13579e.png" alt="Screenshot 2023-09-23 at 18.51.53.png"></p>
<p><img src="/2023/08/09/LC-DP-BAG//7b91215174baed22460e1d90ff85cebb24811d04.png" alt="Screenshot 2023-09-23 at 18.50.37.png"></p>
<p><img src="/2023/08/09/LC-DP-BAG//1bb5d8b4f1e60677d04e9d871d49ae2099058f10.png" alt="Screenshot 2023-09-23 at 19.04.19.png"></p>
<p>正推的时候，是拿着新值，  去更新,新的值。所以第4个数会放入多次。</p>
<p>完全背包</p>
<p>1 - i 种物品可以取  n 次。</p>
<p>完全背包就是01背包</p>
<p><img src="/2023/08/09/LC-DP-BAG//f14ff7c42ded4ad42e8b5b8637c33ccde3c7681a.png" alt="Screenshot 2023-09-23 at 19.18.50.png"></p>
<p>这个代码需要验证</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fun knapStackarray(N: Int, W: Int) &#123;</span><br><span class="line">    val weightArr = arrayOf(1, 3, 4)</span><br><span class="line">    val valueArr = arrayOf(15, 20, 30)</span><br><span class="line"></span><br><span class="line">    val dp = Array(4) &#123; 0 &#125;</span><br><span class="line">    for (i in 1..N) &#123;</span><br><span class="line">        for (j in W downTo weightArr[i]) &#123; // 只有j容量大于当前物品的容量，才会考虑添加到数组中，更新当前cell的值，否则就直接用上一层的值</span><br><span class="line">            dp[j] = Math.max(dp[j],dp[j-weightArr[i]+valueArr[i]])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a>416. 分割等和子集</h3><p>转化成背包问题的，1,5,11,5，背包容量11，前面题解是装到最大值但是不一定能装满，但是在这里不是拿到最大值，是装到最大值的情况,而且==11两个条件.刚好装满。</p>
<p>一开始打印的时候，发现超出了target,正常情况下是不可能的，加入放入新的物品后，留下的容量去之前的最大值去找，所以不可能超过.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">canPartition</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    nums.forEach &#123;</span><br><span class="line">        sum += it</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>  <span class="comment">// will not fill target exactly </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> target = sum / <span class="number">2</span></span><br><span class="line">    <span class="keyword">val</span> dp = IntArray(target + <span class="number">1</span>)</span><br><span class="line">    println(<span class="string">&quot;target <span class="variable">$target</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until nums.size) &#123;</span><br><span class="line">        println()</span><br><span class="line">        println(<span class="string">&quot;   i <span class="variable">$i</span>    &quot;</span>)</span><br><span class="line">        println()</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> target downTo nums[i]) &#123;</span><br><span class="line">            println(<span class="string">&quot; j = <span class="variable">$j</span>   j - nums[i] = <span class="subst">$&#123;j - nums[i]&#125;</span>      dp[j - nums[i]]  <span class="subst">$&#123;dp[j - nums[i]]&#125;</span> &quot;</span>)</span><br><span class="line">            dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]) <span class="comment">// 一开始 dp[j] 写成了dp[target]排查了很久</span></span><br><span class="line">            print(<span class="string">&quot;  dp[j] <span class="subst">$&#123;dp[j]&#125;</span>  &quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        dp.printIntArray()</span><br><span class="line">        println()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dp[target] == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/last-stone-weight-ii/">1049. 最后一块石头的重量 II</a></p>
<p>两堆石头如果刚好一样大小，结果就是0，所以找出最接近中间重量的石头。</p>
<p>也就是转化成01背包问题了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    fun lastStoneWeightII(stones: IntArray): Int &#123;</span><br><span class="line">        var sum = 0</span><br><span class="line">        stones.forEach &#123;</span><br><span class="line">            sum += it // total sum</span><br><span class="line">        &#125;</span><br><span class="line">        val target = sum / 2</span><br><span class="line"></span><br><span class="line">        val dp = IntArray(target + 1)</span><br><span class="line">        for (i in 0 until stones.size) &#123;</span><br><span class="line">            for (j in target downTo stones[i]) &#123;</span><br><span class="line">//                println(&quot; j = $j   j - nums[i] = $&#123;j - stones[i]&#125;      dp[j - nums[i]]  $&#123;dp[j - stones[i]]&#125; &quot;)</span><br><span class="line">                dp[j] = Math.max(dp[j - stones[i]] + stones[i], dp[j])</span><br><span class="line">//                print(&quot; dp[j] $&#123;dp[j]&#125;  &quot;)</span><br><span class="line">            &#125;</span><br><span class="line">//            dp.printIntArray()</span><br><span class="line">//            println()</span><br><span class="line">        &#125;</span><br><span class="line">        return sum - dp[target]*2 // 这是target,而不是物品的size</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494.目标和"></a>494.目标和</h1><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV16Y411v7Y6/?vd_source=d4c5260002405798a57476b318eccac9">https://www.bilibili.com/video/BV16Y411v7Y6/?vd_source=d4c5260002405798a57476b318eccac9</a></p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=r6Wz4W1TbuI&t=581s&pp=ygUONDk0IFRhcmdldCBTdW0=">花花酱 LeetCode 494. Target Sum 上 - 刷题找工作 EP156 - YouTube</a></p>
<p>12:00</p>
<p>positve 是正数的总和</p>
<p>negative 负数的总和</p>
<h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>positive - negative = target  </p>
<p>positive + negative = sum  </p>
<p>上面公式相加</p>
<p>positive  =  (target + sum)/2</p>
<p>然后就转化成 01背包问题 , 装满容量为positive的背包，有dp[positive]种方法。</p>
<h5 id="确定递推公式"><a href="#确定递推公式" class="headerlink" title="确定递推公式"></a>确定递推公式</h5><p>有哪些来源可以推出dp[j]呢？</p>
<p>只要搞到nums[i]，凑成dp[j]就有dp[j - nums[i]] 种方法。dp[j - nums[i]]， 说明装进nums[i]后,剩下dp[j - nums[i]]的方法数, 一直往前找，初始dp[j]数组的值是0, </p>
<p>例如：dp[j]，j 为5，</p>
<ul>
<li>已经有一个物品1（nums[i]） 的话，有 dp[4]种方法 凑成 容量为5的背包。</li>
<li>已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 容量为5的背包。</li>
<li>已经有一个3（nums[i]） 的话，有 dp[2]中方法 凑成 容量为5的背包</li>
<li>已经有一个4（nums[i]） 的话，有 dp[1]中方法 凑成 容量为5的背包</li>
<li>已经有一个5 （nums[i]）的话，有 dp[0]中方法 凑成 容量为5的背包</li>
</ul>
<p>那么凑整dp[5]有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来。</p>
<p>所以求组合类问题的公式，都是类似这种：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] += dp[j - nums[i]]</span><br></pre></td></tr></table></figure>

<p><strong>这个公式在后面在讲解背包解决排列组合问题的时候还会用到！</strong></p>
<p>//dp[j] += dp[j - nums[i]]对这句组合数的理解： 1、如果不选第i个数（nums[i]）的话，则方法数为dp[j]； 2、如果选第i个数（nums[i]）的话，则方法数为dp[j - nums[i]]；<br>// 所以方法总数为：dp[j] = dp[j] + dp[j - nums[i]]；（感觉这样拆开写比较容易理解） 可以对比其他01背包问题：dp[j] = max(dp[j], dp[j - nums[i]])，这种问题即是从选i与不选i里，选取最大值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">fun findTargetSumWays(nums: IntArray, target: Int): Int &#123;</span><br><span class="line"></span><br><span class="line">      /**</span><br><span class="line">       *  positive - negative = target</span><br><span class="line">       *  positive + negative = sum</span><br><span class="line">       *</span><br><span class="line">       *  positive  =  (target + sum)/2</span><br><span class="line">       *</span><br><span class="line">       */</span><br><span class="line"></span><br><span class="line">      //dp[j] += dp[j - nums[i]]对这句组合数的理解： 1、如果不选第i个数（nums[i]）的话，则方法数为dp[j]； 2、如果选第i个数（nums[i]）的话，则方法数为dp[j - nums[i]]；</span><br><span class="line">      // 所以方法总数为：dp[j] = dp[j] + dp[j - nums[i]]；（感觉这样拆开写比较容易理解） 可以对比其他01背包问题：dp[j] = max(dp[j], dp[j - nums[i]])，这种问题即是从选i与不选i里，选取最大值。</span><br><span class="line"></span><br><span class="line">      var sum = 0</span><br><span class="line">      nums.forEach &#123;</span><br><span class="line">          sum += it</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (Math.abs(target)&gt;sum) return 0 // 如果target 大于 sum是不可能有值的</span><br><span class="line"></span><br><span class="line">      if ((target + sum) % 2 != 0) return 0 // positive 一定是正整数 ,这种情况下没有</span><br><span class="line"></span><br><span class="line">      val positive = (target + sum) / 2</span><br><span class="line">      val dp = IntArray(positive + 1)</span><br><span class="line">      dp[0] = 1</span><br><span class="line">      for (i in nums.indices) &#123;</span><br><span class="line">          for (j in positive downTo nums[i]) &#123; // j表示背包容量</span><br><span class="line">              println(&quot; i = $i  j = $j   j - nums[i] = $&#123;j - nums[i]&#125;  dp[j - nums[i]]  $&#123;dp[j - nums[i]]&#125; &quot;)</span><br><span class="line">              dp[j] += dp[j - nums[i]]</span><br><span class="line">              println(&quot; dp[j] $&#123;dp[j]&#125;  &quot;)</span><br><span class="line">          &#125;</span><br><span class="line">          println()</span><br><span class="line">          dp.printIntArray()</span><br><span class="line">          println()</span><br><span class="line">          println()</span><br><span class="line">      &#125;</span><br><span class="line">      return dp[positive]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这个看了很多视频，还不是特别理解，</p>
<h1 id="474-一和零"><a href="#474-一和零" class="headerlink" title="474.一和零"></a>474.一和零</h1><p>装满m个0,n个1 容器的背包，有哪些物品 ，其实就是01背包，只是装的物品是两个纬度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    fun findMaxForm(strs: Array&lt;String&gt;, m: Int, n: Int): Int &#123;</span><br><span class="line">        val dp = Array(m + 1) &#123; IntArray(n + 1) &#125;</span><br><span class="line"></span><br><span class="line">        strs.forEachIndexed &#123; index, str -&gt;</span><br><span class="line">            var oneNum = 0  // 一开始放，外面，要在里面</span><br><span class="line">            var zeroNum = 0</span><br><span class="line">            str.forEach &#123;</span><br><span class="line">                if (&#x27;1&#x27; == it) &#123;</span><br><span class="line">                    oneNum++</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    zeroNum++</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for (i in m downTo zeroNum) &#123; //</span><br><span class="line">                for (j in n downTo oneNum) &#123;</span><br><span class="line">//                    dp[i][j] = Math.max(dp[i][j], dp[m - i][n - j] + 1) // 错的写法</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j], dp[i-zeroNum][j - oneNum] + 1)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m][n]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

        
        
          <blockquote id="copyright">
              <p>Original link: <a href="https://noteforme.github.io/page/6/index.html">https://noteforme.github.io/page/6/index.html</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LEETCODE/" rel="tag">LEETCODE</a></li></ul>

          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-LC-DP" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/02/LC-DP/">LC-DP</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2023-04-02T09:32:31.000Z" itemprop="datePublished">2023年04月02日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/DataStructure/">DataStructure</a>
  </div>

      
      
<a href="/2023/04/02/LC-DP/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Labuladong</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1XV411Y7oE">https://www.bilibili.com/video/BV1XV411Y7oE</a></p>
<ol>
<li>重叠子问题</li>
<li>状态转移方程 (最关键)</li>
<li>最优子结构</li>
</ol>
<ol>
<li>明确状态</li>
<li>明确 选择</li>
<li>明确dp函数/数组的定义</li>
<li>明确base case</li>
</ol>
<p>随想录</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13Q4y197Wg">https://www.bilibili.com/video/BV13Q4y197Wg</a></p>
<h4 id="动规5部曲"><a href="#动规5部曲" class="headerlink" title="动规5部曲"></a>动规5部曲</h4><p><strong>对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 确定dp数组（dp table）以及下标的含义</span><br><span class="line">2. 确定递推公式</span><br><span class="line">3. dp数组如何初始化</span><br><span class="line">4. 确定遍历顺序</span><br><span class="line">5. 举例推导dp数组</span><br></pre></td></tr></table></figure>





<p>动态规划解法代码框架</p>
<p><img src="/2023/04/02/LC-DP/20230701162055.jpg" alt="20230701162055"></p>
<h4 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fibonacci-number/">509. 斐波那契数</a></h4><h5 id="随想录-迭代递推"><a href="#随想录-迭代递推" class="headerlink" title="随想录 迭代递推"></a>随想录 迭代递推</h5><p>自底向上</p>
<p>通过for循环递推出 dp[n]的值，一开始解的时候写成了  dp[n] = dp[n - 1] + dp[n- 2] </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随想录视频思路解法1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fib1</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line"><span class="comment">//        println(n)</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(n+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line"><span class="comment">//            println(&quot; dp[n - 1]= $&#123; dp[n - 1]&#125;  dp[n - 2]= $&#123;dp[n - 2]&#125;&quot;)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h5 id="随想录-视频思路解法2"><a href="#随想录-视频思路解法2" class="headerlink" title="随想录  视频思路解法2"></a>随想录  视频思路解法2</h5><p>这种解法，dp数组空间复杂度减少了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 随想录视频思路解法2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fib</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">val</span> dp = IntArray(<span class="number">2</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">        sum = dp[<span class="number">0</span>] + dp[<span class="number">1</span>]</span><br><span class="line">        println(<span class="string">&quot;sum <span class="variable">$sum</span>  dp[0]= <span class="subst">$&#123;dp[<span class="number">0</span>]&#125;</span> , dp[1]= <span class="subst">$&#123;dp[<span class="number">1</span>]&#125;</span>&quot;</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>]</span><br><span class="line">        dp[<span class="number">1</span>] = sum</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="labuladong"><a href="#labuladong" class="headerlink" title="labuladong"></a>labuladong</h5><p>把所有计算的值先保存起来，后面需要的话先直接返回，避免重复计算.</p>
<p>为什么申请 n+1 数组大小</p>
<p>因为索引从0开始 ，后面要取memory[n]，所有就申请 n+1 大小.</p>
<p>自顶向下</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fib</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> memory = IntArray(n + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> (memory[n] != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> memory[n]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    memory[n] = fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> memory[n]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fib</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>还有一种lablado解法一开始没想出来,双指针应该怎么操作</p>
<p>这个思路和随想录的思路2是一样的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fib</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> pre1 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> pre2 = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">        sum = pre1 + pre2  <span class="comment">// 得到当前n的num</span></span><br><span class="line">        pre1 = pre2     <span class="comment">//移动指针</span></span><br><span class="line">        pre2 = sum</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70 爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">70 爬楼梯</a></h4><p>根据阶梯</p>
<p>0阶                                 1 //  需要返回1，2 = 1 +1,否则2就不正确了,正常理解应该返回0,不过递归解法，需要返回1</p>
<p>1阶                                  1      </p>
<p>2阶    1+1 , 2                   2</p>
<p>3阶  1+1+1, 1+2, 2+1    3</p>
<p>四阶                                 5</p>
<p>根据上面的推导，这个问题也类似于 斐波那契数    ， 看了随想录的视频，这个推导过程还是没看明白</p>
<p>看了这个视频推导明白了</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1G54y1X72H/">https://www.bilibili.com/video/BV1G54y1X72H/</a>        进度条5分钟.</p>
<p>到达 k 只有 两种方式 , k-2过去和k-1过去，所以到k的所有情况就是  (k-2)  + (k-1) ,我们这里讨论的是多少种不同的方法，而不用管k-2,k-1多少步到达k.</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">k</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">k-1</td>
<td align="center"></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center">k-2</td>
<td align="center"></td>
<td align="center"></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h5 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h5><p>超时</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归解法 ， 会超时</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">climbStairs</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span> <span class="comment">// 需要返回1，2 = 1 +1,否则2就不正确了</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">val</span> dp = IntArray(n + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> climbStairs(n - <span class="number">1</span>) + climbStairs(n - <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="迭代解法"><a href="#迭代解法" class="headerlink" title="迭代解法"></a>迭代解法</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">climbStairs1</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">val</span> dp = IntArray(n + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746 使用最小花费爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-cost-climbing-stairs/">746 使用最小花费爬楼梯</a></h4><p>如果要走到dp[i] 的位置， 有两种选择，dp[i-1] + cost[i-1]    ，dp[i-2] + cost[i-2]， cost就是从当前位置跳出消耗的能量值，dp[i-1] 已经包含dp[0]开始的所有 消费值。     </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] &#x3D; min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2]) </span><br></pre></td></tr></table></figure>





<p>可以用这个推导</p>
<p><img src="/2023/04/02/LC-DP/023-07-09-20-24-53.png" alt="023-07-09-20-24-53"></p>
<p>官方题解</p>
<p>这种方式比较好理解</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">minCostClimbingStairs</span><span class="params">(cost: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> dp = IntArray(cost.size + <span class="number">1</span>) <span class="comment">//要走完数组最后一步的下一步</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.cost.size) &#123;</span><br><span class="line">        dp[i] = min(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[cost.size]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他的后面在看吧</p>
<h4 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></h4><p>这题二叉树解法没看懂，给忘了。</p>
<p>递归公式的推导，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">那么很自然，dp[i][j] &#x3D; dp[i - 1][j] + dp[i][j - 1]，因为dp[i][j]只有这两个方向过来。</span><br></pre></td></tr></table></figure>

<ol>
<li>dp数组的初始化</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如何初始化呢，首先dp[i][0]一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，因为只能向右向下走，那么dp[0][j]也同理。</span><br></pre></td></tr></table></figure>

<p>所以初始化代码为：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; m; i++) dp[i][0] = 1;</span><br><span class="line">for (int j = 0; j &lt; n; j++) dp[0][j] = 1;</span><br></pre></td></tr></table></figure>



<p> <img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201209113631392.png" alt="62.不同路径1"></p>
<p>可以根据上图来推导出  <code> dp[i][j]</code></p>
<p>i =1 时  , j 代入进去进行推导。</p>
<p>j = 1 : <code>  dp[i][j] = dp[i-1][j] + dp[i][j-1]</code></p>
<p>j = 2 : <code>  dp[i][j] = dp[i-1][j] + dp[i][j-1]</code></p>
<p>j = 3 : <code>  dp[i][j] = dp[i-1][j] + dp[i][j-1]</code></p>
<p>然后逐步就能推导出所有的值,注意<code>dp[m][n]</code> 要-1,否则会越界。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">uniquePaths</span><span class="params">(m: <span class="type">Int</span>, n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> dp = Array(m) &#123; IntArray(n) &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until m) dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) dp[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths-ii/">63. 不同路径 II</a></h4><p>原理还是一样，从左到右,<code>array[i][0] :  array[0][0],array[1][0],array[2][0] </code>，从上到下 进行推导。</p>
<p>这一题是上一题的拓展版本</p>
<p>通过62题可以看到 m 是竖线，n是横线。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210104114513928.png" alt="63.不同路径II"></p>
<ol>
<li><p><code>[0][0] [m-1][n-1] </code> 那么不可能有有路径往后走了。</p>
</li>
<li><p>有一点不同的是，如果是有障碍，后面就不用初始化了。</p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg" alt="img"></p>
</li>
<li><p>还有一点不同的是，如果要找的位置没有障碍物，才有求出递推值的意义。</p>
</li>
</ol>
<ol start="3">
<li> 递推公式和前面差不多 ，在处理递推公式的时候，看上图，前一步有障碍物的时候，影响的是 <code>dp[i-1]  dp[j-1]</code> 前一步的一个值。</li>
<li>后续递推的时候，碰到obstacles后，obstacles的点就是0，所以下一个点就是障碍物 0 和另一个点相加。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(obstacleGrid: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> m = obstacleGrid.size <span class="comment">// 表示有多少个数组</span></span><br><span class="line">    <span class="keyword">val</span> n = obstacleGrid[<span class="number">0</span>].size <span class="comment">// 其中一个数组的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> || obstacleGrid[m-<span class="number">1</span>][n-<span class="number">1</span>] == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span> <span class="comment">// if there are obstacle in these two points, will no path.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> dp = Array(m) &#123; IntArray(n) &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until m) &#123; <span class="comment">// 里面再加个条件不好加</span></span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>) <span class="keyword">break</span>      <span class="comment">// when init dats, hit path , following init will 0</span></span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// 前面[i][0] i表述多少个数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>) <span class="keyword">break</span></span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">1</span> <span class="comment">// [0][j] 后面表述一个数组的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until m) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][j] != <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343. 整数拆分"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/integer-break/">343. 整数拆分</a></h4><p>我们按照动规 5 部曲来分析先</p>
<ol>
<li><p>确定dp数组（dp table）以及下标的含义</p>
<p>拆分i，最大乘积是dp[i]  </p>
</li>
<li><p>确定递推公式</p>
<p>这一步是比较难的， 对 i 进行拆分，看了随想录的视频，有3种可能</p>
<p>第一种:  拆成2个数的情况  i * j  也就是  dp[i] = i * (i-j)</p>
<p>第二种：拆成2个数以上的情况 : dp[i] = i * dp[i-j]</p>
<p> 这种可以用6来测试拆分</p>
<p>1 * 5</p>
<p>2 * 4</p>
<p>3 * 3</p>
<p>4 * 2</p>
<p>5 * 1</p>
<p>上面我们可以只拆分j,  我们有必要拆分i吗，其实是没必要的， 我的理解是2 * 4 中， 2已经被 1 * 5 中的5包含了，</p>
<p>那么5 拆成<code> 2 *1 * 1 * 1</code> 就包括了 2的情况，不知道我的理解对不对。</p>
<p>第三种 : 就是 i本身。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">integerBreak</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>  <span class="comment">// 1+1</span></span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">3.</span>.n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until i) &#123;</span><br><span class="line"><span class="comment">//                println(&quot;i $i    j $j &quot;)</span></span><br><span class="line">                <span class="keyword">val</span> a = j * (i - j)</span><br><span class="line">                <span class="keyword">val</span> b = j * dp[i - j]</span><br><span class="line"><span class="comment">//                maxNum = max(a, b, i)</span></span><br><span class="line">                println(<span class="string">&quot;j * (i - j)  <span class="variable">$j</span> * (<span class="variable">$i</span> - <span class="variable">$j</span>)  a =<span class="variable">$a</span>  dp[i - j] <span class="subst">$&#123;dp[i - j]&#125;</span>  b= <span class="variable">$b</span> &quot;</span>)</span><br><span class="line"><span class="comment">//                maxNum = max(a, b,dp[i])</span></span><br><span class="line"><span class="comment">//                maxNum= max(a,b)</span></span><br><span class="line"><span class="comment">//                val abMax = max(a, b)</span></span><br><span class="line"><span class="comment">//                println(&quot;abMax $abMax dp[$i] $&#123;dp[i]&#125; &quot;)</span></span><br><span class="line">                dp[i] = max(a, b, dp[i]) <span class="comment">// dp[i] 初始值是0，所以得出的值还是从a,b中拿到最大值</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            println(&quot;dp[$i]     $&#123;dp[i]&#125;&quot;)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">max</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>, c: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> max = a</span><br><span class="line">    <span class="keyword">if</span> (b &gt; max) &#123;</span><br><span class="line">        max = b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c &gt; max) &#123;</span><br><span class="line">        max = c</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h4><p>​      </p>
<p>   上面是i==3的情况，</p>
<p>   <img src="https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg"></p>
<p>   root node =1的时候， left tree 0 , right tree 2种情况 , 右子树和 root node =2的树的结构是一样的。</p>
<p>   root node =2的时候， left tree 1 , right tree 1种情况,  左，右子树和 root node =1的树的结构是一样的。</p>
<p>   root node =3的时候， left tree 2 , right tree 0种情况. 左子树和 root node =2的树的结构是一样的。</p>
<p>   所以 dp[3] =  (root node ==1 +dp[2]) +  (root node ==2 +dp[1]) +   (root node ==3 +dp[2]) </p>
<p>   dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量</p>
<p>   元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量</p>
<p>   元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量</p>
<p>   元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量</p>
<p>   有2个元素的搜索树数量就是dp[2]。</p>
<p>   有1个元素的搜索树数量就是dp[1]。</p>
<p>   有0个元素的搜索树数量就是dp[0]。</p>
<p>   所以dp[3] = dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]</p>
<p>   <img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210107093226241.png" alt="96.不同的二叉搜索树2"></p>
<p>   这个图更直观</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义目前可以根据下面推导来，确认dp数组的含义。dp[1] =1dp[2]= 2dp[3] =5</li>
<li>确定递推公式这个没推导出来，i j没搞清楚。把随想录的拿过来<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在上面的分析中，其实已经看出其递推关系， dp[i] +&#x3D; dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]</span><br><span class="line"></span><br><span class="line">j相当于是头结点的元素，从1遍历到i为止。</span><br><span class="line"></span><br><span class="line">所以递推公式：dp[i] +&#x3D; dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量</span><br></pre></td></tr></table></figure></li>
<li>dp数组如何初始化</li>
<li>确定遍历顺序</li>
<li>举例推导dp数组</li>
</ol>
   <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">numTrees</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 确定dp数组（dp table）以及下标的含义</span></span><br><span class="line">        <span class="keyword">val</span> dp = IntArray(n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="comment">//3. dp数组如何初始化</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.确定遍历顺序</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2</span> ..n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> ..i) &#123; <span class="comment">// 注意这里边界，一开始都 没加==</span></span><br><span class="line"><span class="comment">//                println(&quot; dp[$i] $&#123;dp[i]&#125; += (dp[j - 1] $&#123;dp[j - 1]&#125;  * dp[i - j]) $&#123;dp[i - j]&#125;  j = $j&quot;)</span></span><br><span class="line">                dp[i] += (dp[j - <span class="number">1</span>] * dp[i - j]) <span class="comment">//2.确定递推公式</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>












        
        
          <blockquote id="copyright">
              <p>Original link: <a href="https://noteforme.github.io/page/6/index.html">https://noteforme.github.io/page/6/index.html</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LEETCODE/" rel="tag">LEETCODE</a></li></ul>

          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-RecyclerView-padding" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/10/RecyclerView-padding/">RecyclerView-padding</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2023-01-10T07:16:04.000Z" itemprop="datePublished">2023年01月10日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/ANDROID/">ANDROID</a>
  </div>

      
      
<a href="/2023/01/10/RecyclerView-padding/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>修改Display scaling属性后，即使设置字体是dp也会导致，也会出现Text内容的有变化。</p>
<p>计算转账页面的padding,5个TextView平分屏幕宽度，之前nexus5没问题，因为是刚好2倍，我的手机就是有问题，原来是dp转px有损耗。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@get:JvmName</span>(<span class="string">&quot;dp2px&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> <span class="built_in">Float</span>.dp: <span class="built_in">Float</span></span><br><span class="line">    <span class="keyword">get</span>() = convert(<span class="keyword">this</span>, TypedValue.COMPLEX_UNIT_DIP)</span><br><span class="line"></span><br><span class="line"><span class="meta">@get:JvmName</span>(<span class="string">&quot;dp2px&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> <span class="built_in">Int</span>.dp: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">get</span>() = convert(<span class="keyword">this</span>.toFloat(), TypedValue.COMPLEX_UNIT_DIP).toInt()</span><br></pre></td></tr></table></figure>



<p>然后用 2f.dp这样就能避免dp转px的损耗。</p>
<p>其实选择上面这个方法就能解决这个问题。</p>
<p>字体测量方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getTextLength</span><span class="params">(typeface: <span class="type">Typeface</span>, txt: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> paint = Paint()</span><br><span class="line">    paint.typeface = typeface</span><br><span class="line">    paint.textSize = <span class="number">12f</span>.dp.toFloat()</span><br><span class="line">    <span class="keyword">val</span> textWidth = paint.measureText(txt)</span><br><span class="line">    <span class="keyword">return</span> textWidth.toInt()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>文字宽度</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dasusu/p/6602710.html">https://www.cnblogs.com/dasusu/p/6602710.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9fc07c3311c1">https://www.jianshu.com/p/9fc07c3311c1</a></p>
<p><a target="_blank" rel="noopener" href="https://www.laoyuyu.me/2020/08/03/android/text_measure_wh/">https://www.laoyuyu.me/2020/08/03/android/text_measure_wh/</a></p>

        
        
          <blockquote id="copyright">
              <p>Original link: <a href="https://noteforme.github.io/page/6/index.html">https://noteforme.github.io/page/6/index.html</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RecyclerView/" rel="tag">RecyclerView</a></li></ul>

          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-LC-GREEDY" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/02/LC-GREEDY/">LC-GREEDY</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2023-01-02T14:42:03.000Z" itemprop="datePublished">2023年01月02日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/DataStructure/">DataStructure</a>
  </div>

      
      
<a href="/2023/01/02/LC-GREEDY/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1sA4y1S7Sp">https://www.bilibili.com/video/BV1sA4y1S7Sp</a></p>
<p>这个视频讲到暴力 对数器可以验证答案，有意思。</p>
<p>有同学问了如何验证可不可以用贪心算法呢？</p>
<p><strong>刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心</strong>。</p>
<p>贪心算法一般分为如下四步：</p>
<ul>
<li>将问题分解为若干个子问题</li>
<li>找出适合的贪心策略</li>
<li>求解每一个子问题的最优解</li>
<li>将局部最优解堆叠成全局最优解</li>
</ul>
<p>这个四步其实过于理论化了，我们平时在做贪心类的题目 很难去按照这四步去思考，真是有点“鸡肋”。</p>
<p>做题的时候，只要想清楚 局部最优 是什么，如果推导出全局最优，其实就够了。</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1XY411A766">https://www.bilibili.com/video/BV1XY411A766</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Hz4y117CP/">https://www.bilibili.com/video/BV1Hz4y117CP/</a></p>
<h4 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455.分发饼干"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/assign-cookies/">455.分发饼干</a></h4><h5 id="分解题目"><a href="#分解题目" class="headerlink" title="分解题目"></a>分解题目</h5><ol>
<li>每个孩子最多只能给一块饼干。</li>
<li>每个孩子 <code>i</code>，都有一个胃口值 <code>g[i]</code>，每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code>。</li>
</ol>
<h5 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g &#x3D; [1,3], s &#x3D; [1,2,4]</span><br></pre></td></tr></table></figure>

<ol>
<li><p>对孩子的胃口值和， 饼干的大小进行排序，得到两行数组。</p>
</li>
<li><p>如上面示例，s中的s[0]=1饼干大小，满足g[0]=1 孩子的胃口值,那么同时向右移动.s[1]=2 不满足g[1],s指针向右移动，s[2]满足g[1].</p>
<p>这样所有孩子都满足了。</p>
</li>
</ol>
<p>上面思路和随想录的不一样，随想录的是大饼干喂 胃口值大的孩子，不过觉得我这个更好理解。</p>
<h5 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findContentChildren</span><span class="params">(g: <span class="type">IntArray</span>, s: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.isEmpty()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    Arrays.sort(g)  <span class="comment">// 写了s.isEmpty()， 一开始忘了加这个排序</span></span><br><span class="line">    Arrays.sort(s)</span><br><span class="line">    <span class="keyword">var</span> pg = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> ps = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (pg &lt; g.size &amp;&amp; ps &lt; s.size) &#123; <span class="comment">// 控制边界</span></span><br><span class="line">        <span class="keyword">if</span> (s[ps] &gt;= g[pg]) &#123;       <span class="comment">//饼干满足孩子的胃口大小.</span></span><br><span class="line">            count++</span><br><span class="line">            pg++</span><br><span class="line">            ps++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ps++    <span class="comment">//饼干不满足孩子的胃口大小，饼干数组指针往右走.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="376摆动序列"><a href="#376摆动序列" class="headerlink" title="376摆动序列"></a>376摆动序列</h4><h5 id="Idea-1"><a href="#Idea-1" class="headerlink" title="Idea"></a>Idea</h5><p>摆动序列，其实求波峰 波谷的个数，所以有一个方向改变就算一个波动。</p>
<ol>
<li><p>根据图1可以看到</p>
<p>preDiff = 17-1 &gt;0 , curveDiff = 5 -10&lt;0 ，这个就是一个摆动序列。还有</p>
<p>preDiff = 5-10 &lt;0 , curveDiff = 16 -5&gt;0 的情况，这又是另一种情况的摆动序列。</p>
</li>
<li><p>根据图2可以看到</p>
<p>preDiff ==0  , curveDiff = 5 -2 &gt; 0,  </p>
<p>preDiff ==0  , curveDiff = 5 -8 &gt; 0,  题目说 两个不等元素的序列也视作摆动序列。所以这种情况也是摆动序列。 但是我感觉这个和前面的 “如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 <strong>摆动序列</strong>”,是有矛盾的。</p>
<p>根据 1.2,所以条件可以合并, preDiff  &gt;=0 , curveDiff &lt;=0 ,preDiff &lt;=0 , curveDiff &gt;=0</p>
</li>
<li><p>图3，只有2个摆动，但是根据根据1，2的总结代码在2,3节点处，红色pre的地方也有1个摆动，这种情况要去掉，因为他是同方向的摆动。所以pre应该停在绿色的地方，只有摆动发生她才需要改变，平波不用管。</p>
</li>
</ol>
<p><img src="/2023/01/02/LC-GREEDY/2023-01-18-9.11.23.png" alt="2023-01-18-9.11.23"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">wiggleMaxLength</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.size &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums.size</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> preDiff = <span class="number">0</span> <span class="comment">//前一对差值</span></span><br><span class="line">    <span class="keyword">var</span> curveDiff = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until nums.size) &#123; <span class="comment">// 第一个数已经计入摆动序列了，所以从1开始</span></span><br><span class="line">        curveDiff = nums[i] - nums[i - <span class="number">1</span>] <span class="comment">// 因为要给值给preDiff，所以从i开始，随想录c++解法是从0开始的。</span></span><br><span class="line">        <span class="keyword">if</span> ((preDiff &gt;= <span class="number">0</span> &amp;&amp; curveDiff &lt; <span class="number">0</span>) || (preDiff &lt;= <span class="number">0</span> &amp;&amp; curveDiff &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">            result++</span><br><span class="line">            preDiff = curveDiff</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53 最大子序和"></a>53 最大子序和</h4><p>  -2,    1,    -3,    4,    -1,    2,    1,    -5,    4</p>
<p>*Q *P </p>
<h5 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h5><ol>
<li>题意是找到最大和的连续子数组， 所以是不能对数组排序。</li>
<li>这题可以考虑用双指针解法，移动*p，从0开始 加上指针对应的计数。如果计数增加则是正数计入，如果减小则重置，移动 *q指针。</li>
</ol>
<p>上面这个思路是不行的，4,    -1,    2,    1这种就有问题。</p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.gif" alt="53.最大子序和"></p>
<p>间隔后新的黄色部分是重置数据。</p>
<p>根据随想录的思路</p>
<p>局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。</p>
<p>这句话看起来有问题，但是也拿不出反例.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">maxSubArray</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> maxResult = <span class="built_in">Int</span>.MIN_VALUE</span><br><span class="line">    <span class="keyword">for</span> (pIndex <span class="keyword">in</span> nums.indices) &#123;</span><br><span class="line">        result += nums[pIndex]</span><br><span class="line">        maxResult = maxResult.coerceAtLeast(result)</span><br><span class="line">        <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            result = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxResult</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122 买卖股票的最佳时机 II"></a>122 买卖股票的最佳时机 II</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7,	1,	5,	3,	6,	4</span><br><span class="line">	-6	4		-2	3		-2</span><br></pre></td></tr></table></figure>



<p>假如第0天买入，第3天卖出，那么利润为：prices[3] - prices[0]。</p>
<p>相当于(prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])。</p>
<p><strong>此时就是把利润分解为每天为单位的维度，而不是从0天到第3天整体去考虑！</strong></p>
<p>那么根据prices可以得到每天的利润序列：(prices[i] - prices[i - 1])…..(prices[1] - prices[0])。</p>
<p><img src="https://img-blog.csdnimg.cn/2020112917480858.png" alt="122.买卖股票的最佳时机II"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">maxProfit</span><span class="params">(prices: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> diffArray = IntArray(prices.size - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until prices.size) &#123;</span><br><span class="line">        println(i)</span><br><span class="line">        diffArray[i - <span class="number">1</span>] = prices[i] - prices[i - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> diffArray.indices) &#123;</span><br><span class="line">        <span class="keyword">if</span> (diffArray[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += diffArray[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55 跳跃游戏"></a>55 跳跃游戏</h4><p>[2,3,1,1,4]</p>
<h5 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h5><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度，比如在2的位置，可以跳一格到3的位置，也可以两格到1的位置。</p>
<p><img src="https://img-blog.csdnimg.cn/20201124154758229.png" alt="55.跳跃游戏"></p>
<p>上面第二幅图，第一条线应该有问题，应该覆盖到2 3 1</p>
<p>遍历每个位置，确定每个位置能覆盖的最大范围。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">canJump</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> coverArea = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span>.coverArea) &#123; <span class="comment">// 注意:这里是coverArea,需要确定能走多少步</span></span><br><span class="line">        coverArea = (i + nums[i]).coerceAtLeast(coverArea) <span class="comment">//新的范围和 之前的范围做比较</span></span><br><span class="line">        <span class="keyword">if</span> (coverArea &gt;= nums.size - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45 跳跃游戏 II"></a>45 跳跃游戏 II</h4><h5 id="Idea-2"><a href="#Idea-2" class="headerlink" title="Idea"></a>Idea</h5><p>题目意思 总是可以到达数组的最后一个位置</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">jump</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> maxCover = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span>.maxCover) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i + nums[i] &gt; maxCover) &#123;</span><br><span class="line">            maxCover = i + nums[i]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count++</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (maxCover &gt;= nums.size) &#123;</span><br><span class="line">            println(<span class="string">&quot;count <span class="variable">$count</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> count</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>找到能覆盖的最远距离，如果移动到了这个地方，那么就计算一次，直到  nums.size - 1- 1个节点，然后再count++就可以了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">jump</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nextCover = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> currentCover = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until nums.size - <span class="number">1</span>) &#123;</span><br><span class="line">        nextCover = Math.max(i + nums[i], nextCover)</span><br><span class="line">        <span class="keyword">if</span> (i == currentCover) &#123;</span><br><span class="line">            currentCover = nextCover</span><br><span class="line">            count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1005-K-次取反后最大化的数组和"><a href="#1005-K-次取反后最大化的数组和" class="headerlink" title="1005. K 次取反后最大化的数组和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/">1005. K 次取反后最大化的数组和</a></h4><ol>
<li>先对数组进行排序，把 &lt; 0的数按位取反 ,直到数组的数据都&gt;0,此时翻转了n次</li>
<li>对翻转后的数组重新进行排序，对最小的数 翻转 k-n 次</li>
</ol>
<p>My Idea</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largestSumAfterKNegations</span><span class="params">(nums: <span class="type">IntArray</span>, k: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    Arrays.sort(nums)</span><br><span class="line">    <span class="keyword">var</span> balanceK = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until k) &#123; <span class="comment">// kotlin用while 应该更好</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= nums.size || nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            balanceK = k - i</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        nums[i] = Math.abs(nums[i])</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(nums)</span><br><span class="line">    <span class="keyword">if</span> (balanceK &gt; <span class="number">0</span> &amp;&amp; (balanceK % <span class="number">2</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        nums[<span class="number">0</span>] = -nums[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (value <span class="keyword">in</span> nums) &#123;</span><br><span class="line">        sum += value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个也可以</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1iY411s7qB">https://www.bilibili.com/video/BV1iY411s7qB</a></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largestSumAfterKNegations</span><span class="params">(nums: <span class="type">IntArray</span>, k: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> typedArray = nums.toTypedArray() <span class="comment">// 转成数组</span></span><br><span class="line">    Arrays.sort(typedArray, Comparator.comparingInt(Math::abs)) <span class="comment">// 按照绝对值排序</span></span><br><span class="line">    <span class="keyword">var</span> k = k</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> typedArray.indices) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; typedArray[i] &lt; <span class="number">0</span>) &#123;  <span class="comment">// 碰到数组中&gt;0的数</span></span><br><span class="line">            typedArray[i] *= -<span class="number">1</span></span><br><span class="line">            k--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(typedArray)</span><br><span class="line">    <span class="keyword">if</span> (k % <span class="number">2</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        typedArray[<span class="number">0</span>] *= -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (value <span class="keyword">in</span> nums) &#123;</span><br><span class="line">        sum += value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 参考随想录，但是编译不通过</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV138411G7LY">https://www.bilibili.com/video/BV138411G7LY</a></p>
<h4 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134 加油站"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/gas-station/">134 加油站</a></h4><h5 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">canCompleteCircuit</span><span class="params">(gas: <span class="type">IntArray</span>, cost: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> gas.indices) &#123;</span><br><span class="line">        <span class="keyword">var</span> balance = gas[i] - cost[i]</span><br><span class="line">        <span class="keyword">var</span> index = (i + <span class="number">1</span>) % gas.size</span><br><span class="line">        <span class="keyword">while</span> (balance &gt; <span class="number">0</span> &amp;&amp; i != index) &#123;  <span class="comment">// 还有油的话，没走完一圈，继续走</span></span><br><span class="line">            balance += (gas[index] - cost[index])</span><br><span class="line">            index = (index + <span class="number">1</span>) % gas.size</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (balance &gt;= <span class="number">0</span> &amp;&amp; (index == i)) &#123;<span class="comment">//走完一圈，返回下标</span></span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="贪心解法"><a href="#贪心解法" class="headerlink" title="贪心解法"></a>贪心解法</h5><p>这里k不用看</p>
<p><img src="/2023/01/02/LC-GREEDY/20230211173204.jpg" alt="20230211173204"></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1DF411L7cz">https://www.bilibili.com/video/BV1DF411L7cz</a></p>
<p>j 到 j+1跑不到 , 从i 到 j +1 油量&lt;0</p>
<ol>
<li>因为 i 能开到j,从 i 出发到 i+1 油量 &gt;=0 ,  那么 i+1 到 j+1 油量一定 &lt;0.</li>
<li>如果起点在 i+1, 因为 i 到j+1&lt;0 ,因此 i 到  i+1&gt;=0 , i+1 到j+1一定&lt;0.</li>
</ol>
<p>总结来看,  i 到 j+1&lt;0 ,中间不用看，直接从 j+1开始即可。</p>
<p>LC134我的解法有问题，看到随想录的解法后感觉很妙</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">canCompleteCircuit</span><span class="params">(gas: <span class="type">IntArray</span>, cost: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> totalSum = <span class="number">0</span> <span class="comment">//  所有路程需要的油量</span></span><br><span class="line">    <span class="keyword">var</span> currentSum = <span class="number">0</span>  <span class="comment">// 当前位置开始所需要的油量</span></span><br><span class="line">    <span class="keyword">var</span> start = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> gas.indices) &#123;</span><br><span class="line">        totalSum += gas[i] - cost[i]</span><br><span class="line">        currentSum += gas[i] - cost[i]</span><br><span class="line">        <span class="keyword">if</span> (currentSum &lt; <span class="number">0</span>) &#123; <span class="comment">// 到i加油站需要油量 &lt;0, 如果接下来 gas[i+1] - cost[i+1]还是&lt;0,那么start ,currentSum 继续更新</span></span><br><span class="line">            start = i + <span class="number">1</span></span><br><span class="line">            currentSum = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (totalSum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li> 到i加油站需要油量 &lt;0, 如果接下来 gas[i+1] - cost[i+1]还是&lt;0,那么start ,currentSum 继续更新.</li>
<li> j ,j+1是负数节点,如果存在这样一个节点,满足条件，那么j+1开始后面一圈的一定都是&gt;0</li>
</ol>
<h4 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135 分发糖果"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/candy/">135 分发糖果</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1,2,2]</span><br><span class="line"> 1 2 1 &#x2F;&#x2F;为什么array[2] 糖果是1，因为题目意思只有评分高才有更多的糖果，相等的情况按照最少的1个糖果了。</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">5</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">左&lt;右</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">左&gt;右</td>
</tr>
</tbody></table>
<h5 id="Idea-3"><a href="#Idea-3" class="headerlink" title="Idea"></a>Idea</h5><p>需要一边一边考虑，否则顾此失彼</p>
<ol>
<li>先考虑  左边孩子粉丝的情况 &lt; 右边孩子分数  ，此时需要从左往右, 得到第三行的分数.</li>
<li>再考虑 左边孩子粉丝 &gt; 右边孩子分数的情况, 此时需要从右向左，因为这种情况需要依赖，右边的孩子。如果从左到右，得到第4行结果，此时  2 3 4 5都是错的。</li>
<li>然后从右往左的过程，还需要考虑之前 左边孩子&lt; 右边的情况，所以取最大值。</li>
</ol>
<h5 id="code"><a href="#code" class="headerlink" title="code"></a>code</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">candy</span><span class="params">(ratings: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> answer = IntArray(ratings.size)</span><br><span class="line">        answer[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        左边孩子粉丝的情况 &lt; 右边孩子分数  ，此时需要从左往右</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until ratings.size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                answer[i] = answer[i - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                answer[i] = <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        println()</span><br><span class="line">        answer.printIntArray()</span><br><span class="line">        <span class="comment">//左边孩子粉丝 &gt; 右边孩子分数的情况, 此时需要从右向左</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> ratings.size - <span class="number">1</span> downTo <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i - <span class="number">1</span>] &gt; ratings[i]) &#123;</span><br><span class="line">                answer[i - <span class="number">1</span>] = answer[i - <span class="number">1</span>].coerceAtLeast(answer[i] + <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        answer.printIntArray()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> answer) &#123;</span><br><span class="line">            sum += i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="860-柠檬水找零"><a href="#860-柠檬水找零" class="headerlink" title="860 柠檬水找零"></a>860 柠檬水找零</h4><h5 id="Idea-4"><a href="#Idea-4" class="headerlink" title="Idea"></a>Idea</h5><ol>
<li>一开始想到的是暴力解法， 用map 存 5 , 10两种金额的个数，20不用考虑</li>
<li>来了5存起来 map5 +1，来了10存起来 map10+1 , map5 -1 ,  来了20， map10-1, map5-1</li>
</ol>
<h5 id="code-暴力解法"><a href="#code-暴力解法" class="headerlink" title="code  暴力解法"></a>code  暴力解法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">fun lemonadeChange(bills: IntArray): Boolean &#123;</span><br><span class="line">    val map &#x3D; HashMap&lt;Int, Int&gt;()</span><br><span class="line">    for ((index, money) in bills.withIndex()) &#123;</span><br><span class="line">        if (money &#x3D;&#x3D; 5) &#123;</span><br><span class="line">            map[5] &#x3D; map.getOrDefault(5, 0).plus(1)</span><br><span class="line">        &#125; else if (money &#x3D;&#x3D; 10) &#123;</span><br><span class="line">            map[5] &#x3D; map.getOrDefault(5, 0) - 1</span><br><span class="line">            map[10] &#x3D; map.getOrDefault(10, 0).plus(1)</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F;for 20 rmb</span><br><span class="line">            if (map.getOrDefault(10, 0) &gt; 0 &amp;&amp; map.getOrDefault(5, 0) &gt; 0) &#123; &#x2F;&#x2F;at lease 10rmb 1  , 5rmb 1</span><br><span class="line">                map[10] &#x3D; map.getOrDefault(10, 0) - 1</span><br><span class="line">                map[5] &#x3D; map.getOrDefault(5, 0) - 1</span><br><span class="line">            &#125; else if (map.getOrDefault(5, 0) &gt; 2) &#123; &#x2F;&#x2F; at least 3 * 5 rmb</span><br><span class="line">                map[5] &#x3D; map.getOrDefault(5, 0) - 3</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        println(&quot; index $index    map5 $&#123;map[5]&#125; map10 $&#123;map[10]&#125; &quot;)</span><br><span class="line">        if (map.getOrDefault(5, 0) &lt; 0 || map.getOrDefault(10, 0) &lt; 0) &#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>看了随想录的解法，和我的解法类似，知识map中的值可以用变量来做.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> five = <span class="number">0</span>, ten = <span class="number">0</span>, twenty = <span class="number">0</span>;</span><br><span class="line">这样++,--更方便.</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0860.%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6.html#%E6%80%9D%E8%B7%AF">https://programmercarl.com/0860.%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6.html#%E6%80%9D%E8%B7%AF</a></p>
<h4 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406 根据身高重建队列"></a>406 根据身高重建队列</h4><h5 id="Idea-随想录"><a href="#Idea-随想录" class="headerlink" title="Idea 随想录"></a>Idea 随想录</h5><p>对于本题相信大家困惑的点是先确定k还是先确定h呢，也就是究竟先按h排序呢，还是先按照k排序呢？</p>
<p>如果按照k来从小到大排序，排完之后，会发现k的排列并不符合条件，身高也不符合条件，两个维度哪一个都没确定下来。</p>
<p>那么按照身高h来排序呢，身高一定是从大到小排（身高相同的话则k小的站前面），让高个子在前面。</p>
<p><strong>此时我们可以确定一个维度了，就是身高，前面的节点一定都比本节点高！</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fun reconstructQueue(people: Array&lt;IntArray&gt;): Array&lt;IntArray&gt; &#123;</span><br><span class="line">    Arrays.sort(people, object : Comparator&lt;IntArray&gt; &#123; </span><br><span class="line">        override fun compare(o1: IntArray, o2: IntArray): Int &#123;</span><br><span class="line">            if (o2[0] &#x3D;&#x3D; o1[0]) &#123;       &#x2F;&#x2F; 如果身高相同，k小的排在前面</span><br><span class="line">                return o1[1] - o2[1]</span><br><span class="line">            &#125;</span><br><span class="line">            return o2[0] - o1[0]        &#x2F;&#x2F; 对数组先按照身高来排序</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    val linkedList &#x3D; LinkedList&lt;IntArray&gt;()</span><br><span class="line"></span><br><span class="line">    for (value in people)&#123;</span><br><span class="line">        val index &#x3D; value[1]</span><br><span class="line">        linkedList.add(index,value) &#x2F;&#x2F; 按照k插入对应的位置, 这里插入时很容易越界。</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return linkedList.toTypedArray()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452. 用最少数量的箭引爆气球"></a>452. 用最少数量的箭引爆气球</h4><p>IDEA</p>
<ol>
<li>先对数组按照左边界大小进行排序。</li>
<li>如果当前i数组右边的值 &gt;  或者前面数组重叠区域的最小右边界， 此时没有重叠（和之前的共有区域），数量+1</li>
<li>否则有重叠，取最小右边界值。</li>
</ol>
<p>一开始看题解，没理解特别是 points[i][1]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">points[i][<span class="number">1</span>] = <span class="built_in">min</span>(points[i - <span class="number">1</span>][<span class="number">1</span>], points[i][<span class="number">1</span>]); <span class="comment">// 更新重叠气球最小右边界</span></span><br></pre></td></tr></table></figure>



<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findMinArrowShots1</span><span class="params">(points: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line"><span class="comment">//        Arrays.sort(points)&#123;o1,o2 -&gt; o1[0] - o2[0]&#125; 这个回报越界错 [[-2147483646,-2147483645],[2147483646,2147483647]]</span></span><br><span class="line">        points.sortBy&#123;it[<span class="number">0</span>]&#125;</span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until points.size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (points[i][<span class="number">0</span>] &gt; points[i - <span class="number">1</span>][<span class="number">1</span>]) &#123; <span class="comment">// 如果当前气球的左边界 &gt; 公共右边界</span></span><br><span class="line">                count++</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有大于公共右边界</span></span><br><span class="line">                <span class="comment">//points[i][1] = points[i][1].minus(points[i - 1][1]) // 用minus是有问题的</span></span><br><span class="line">                points[i][<span class="number">1</span>] = points[i][<span class="number">1</span>].coerceAtMost(points[i - <span class="number">1</span>][<span class="number">1</span>]) <span class="comment">// 更新重叠气球最小右边界</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        points.printDimensionalArray()</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>1       6</p>
<p>​    2            8</p>
<p>​             7                12</p>
<p>​                        10         16</p>
<h5 id="使用chatGPT的算法，更好"><a href="#使用chatGPT的算法，更好" class="headerlink" title="使用chatGPT的算法，更好"></a>使用chatGPT的算法，更好</h5><p>确定右边界, 如果新的左边界&gt;之前的右边界+1 , 使用新的数据，并且确定右边界。</p>
<p>The solution sorts the balloons by their end positions in ascending order, and then uses a greedy algorithm to shoot the balloons. We start with the first balloon and set <code>end</code> to its end position. Then, we iterate through the rest of the balloons and compare their start positions to <code>end</code>. If the start position of a balloon is greater than <code>end</code>, we shoot another arrow and update <code>end</code> to the end position of the current balloon.</p>
<p>At the end, the function returns the number of arrows shot.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findMinArrowShots</span><span class="params">(points: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (points.isEmpty()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    points.sortBy &#123; it[<span class="number">1</span>] &#125;</span><br><span class="line">    <span class="keyword">var</span> arrows = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> end = points[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until points.size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (points[i][<span class="number">0</span>]&gt;end) &#123;</span><br><span class="line">            arrows++</span><br><span class="line">            end = points[i][<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arrows</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/non-overlapping-intervals/">435. 无重叠区间</a></h4><p>[1,2] [3,6] [7,12] [4,8] [10,16]</p>
<p>1     2</p>
<p>​            3       6</p>
<p>​                 4                  8</p>
<p>​                          7                      12</p>
<p>​                                            10                16</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1A14y1c7E1">https://www.bilibili.com/video/BV1A14y1c7E1</a></p>
<h5 id="左边数组进行排序。"><a href="#左边数组进行排序。" class="headerlink" title="左边数组进行排序。"></a>左边数组进行排序。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. if [i][0] &lt; [i-1][1] 说明会有重合，那么求出 [i][1] [i-1][1]中的最小值，作为右边界，更新数量</span><br><span class="line">否则就没重合更新右边界限。</span><br><span class="line">2. 否则，没有重合直接更新  end。</span><br></pre></td></tr></table></figure>



<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">eraseOverlapIntervals</span><span class="params">(intervals: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.isEmpty()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">        Arrays.sort(intervals) &#123; a, b -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>] &#125; <span class="comment">// 按照左边数组进行排序</span></span><br><span class="line">        <span class="keyword">var</span> end = intervals[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until intervals.size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt; end) &#123;    <span class="comment">//重合的情况</span></span><br><span class="line">                count++</span><br><span class="line">                end = end.coerceAtMost(intervals[i][<span class="number">1</span>]) <span class="comment">// 确定最小重合的 右边界, 这里一开始弄错了</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                end = intervals[i][<span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        intervals.printDimensionalArray()</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h5 id="右边数组排序"><a href="#右边数组排序" class="headerlink" title="右边数组排序"></a>右边数组排序</h5><p><strong>这种解法不理解.</strong></p>
<p>根据随想录的思路，总的个数 - 非交叉个数 = 交叉个数。</p>
<p>这里的难点是要知道交叉后的右边界的</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230201164134.png" alt="img"></p>
<p>如果3在 1,2 右边最小值的左边，所以3条线还会有交叉，如果在1，2最小值的右边那么 2去掉就可以了，还是去掉1。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">eraseOverlapIntervals</span><span class="params">(intervals: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.isEmpty()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">1</span> <span class="comment">//非交叉区间个数</span></span><br><span class="line">        Arrays.sort(intervals) &#123; a, b -&gt; a[<span class="number">1</span>] - b[<span class="number">1</span>] &#125; <span class="comment">// 按照左边数组进行排序</span></span><br><span class="line">        <span class="keyword">var</span> end = intervals[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until intervals.size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &gt;= end) &#123;</span><br><span class="line">                count ++</span><br><span class="line">                end = intervals[i][<span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            else&#123;</span></span><br><span class="line"><span class="comment">//                end = intervals[i][1].coerceAtMost(end) // 这个不需要</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        intervals.printDimensionalArray()</span></span><br><span class="line">        <span class="keyword">return</span> intervals.size - count</span><br><span class="line">    &#125;	</span><br></pre></td></tr></table></figure>



<p>12</p>
<h4 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763 划分字母区间"></a>763 划分字母区间</h4><h5 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h5><ol>
<li><p>遍历出每个字母的最远距离，出现的座标。</p>
<p>根据字母的hash值得到当前的座标，后面如果有重复的hash,会覆盖前面的。</p>
</li>
<li><p>遍历后序列找 当前字母hash值 == i , right = i 拿到当前 right + 1 - left, 就是片段的长度。</p>
<p>然后更新left值.</p>
</li>
</ol>
<p>​        </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">partitionLabels</span><span class="params">(s: <span class="type">String</span>)</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> result = arrayListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">val</span> hash = IntArray(<span class="number">26</span>)</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> s.indices) &#123;</span><br><span class="line">            hash[s[i] - <span class="string">&#x27;a&#x27;</span>] = i</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> right = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> s.indices) &#123;</span><br><span class="line">            right = hash[s[i] - <span class="string">&#x27;a&#x27;</span>].coerceAtLeast(right) <span class="comment">// 要找到当前hash值的最大值</span></span><br><span class="line">            <span class="keyword">if</span> (right == i) &#123;   <span class="comment">//如果 hash值的最大值 和座标相等，就用到了分割点</span></span><br><span class="line">                result.add(right + <span class="number">1</span> - left)</span><br><span class="line">                left = i + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        hash.printIntArray()</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56 合并区间"></a>56 合并区间</h4><h5 id="Idea-My"><a href="#Idea-My" class="headerlink" title="Idea My"></a>Idea My</h5><p>初始化 left. right</p>
<ol>
<li>按照左边数组 排序。</li>
<li>如果没重合直接[left,right]把前面数组加入区间 。</li>
<li>如果重合，那么确定 right右边界，判断<code> [i][0]</code>和right,确定右边界，把right放入右边界。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">merge</span><span class="params">(intervals: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: Array&lt;IntArray&gt; &#123;</span><br><span class="line">    Arrays.sort(intervals) &#123; a, b -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>] &#125;</span><br><span class="line">    <span class="keyword">var</span> left = intervals[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> right = intervals[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">val</span> arrayOf = arrayListOf&lt;IntArray&gt;()</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until intervals.size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt;= right) &#123;</span><br><span class="line">            right = right.coerceAtLeast(intervals[i][<span class="number">1</span>])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arrayOf.add(intArrayOf(left, right))</span><br><span class="line">            left = intervals[i][<span class="number">0</span>]</span><br><span class="line">            right = intervals[i][<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arrayOf.add(intArrayOf(left, right))</span><br><span class="line">    <span class="keyword">return</span> arrayOf.toTypedArray()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="Idea-2"><a href="#Idea-2" class="headerlink" title="Idea 2"></a>Idea 2</h5><p>看了随想录的题解，觉得比我上面的更好，只需要更新右边界。</p>
<p>1     3</p>
<p>​    2         6       8     10         15        18</p>
<p>​                    </p>
<ol>
<li>还是按照数组左边界排好序。</li>
<li>把第一组数组放入结果数组中，然后取出来，用它的右边界和第二组数组的左边界比较大小.</li>
<li>如果新的数组的左边界 &lt; 结果数组的右边界，说明有重合，更新结果数组的右边界。</li>
<li>如果新的数组的左边界 &gt; 结果数组的右边界,没有重合，新数组直接添加到结果数组集中。</li>
</ol>
<h4 id="738-单调递增的数字"><a href="#738-单调递增的数字" class="headerlink" title="738 单调递增的数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/monotone-increasing-digits/">738 单调递增的数字</a></h4><h5 id="Idea-5"><a href="#Idea-5" class="headerlink" title="Idea"></a>Idea</h5><p>看了随想录的题解</p>
<p>那么拿一个两位的数字来举例。</p>
<p>例如：98，一旦出现strNum[i - 1] &gt; strNum[i]的情况（非单调递增），首先想让strNum[i - 1]–，然后strNum[i]给为9，这样这个整数就是89，即小于98的最大的单调递增整数。</p>
<p>此时是从前向后遍历还是从后向前遍历呢？</p>
<p>这么说有点抽象，举个例子，数字：332，从前向后遍历的话，那么就把变成了329，此时2又小于了第一位的3了，真正的结果应该是299。</p>
<p>那么从后向前遍历，就可以重复利用上次比较得出的结果了，从后向前遍历332的数值变化为：332 -&gt; 329 -&gt; 299</p>
<p>确定了遍历顺序之后，那么此时局部最优就可以推出全局，找不出反例，试试贪心。</p>
<h5 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h5><p>初始的想法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> arrStr = n.toString().toCharArray()</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> arrStr.size - <span class="number">1</span> downTo <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arrStr[i - <span class="number">1</span>] &gt; arrStr[i]) &#123;</span><br><span class="line">            arrStr[i] = <span class="string">&#x27;9&#x27;</span></span><br><span class="line">            arrStr[i - <span class="number">1</span>] = arrStr[i - <span class="number">1</span>].toInt().minus(<span class="number">1</span>).toChar() </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> String(arrStr).toInt()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>100 跑完后变成90,其实后面所有位都要变成 ‘9’,只有当前位减1</p>
<p>找到 minus 1 的位置，后面的位都变成9</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> arrStr = n.toString().toCharArray()</span><br><span class="line">    <span class="keyword">var</span> position = arrStr.size <span class="comment">//初始位置不能是  arrStr.size - 1 ，否则最后一位都会变成 &#x27;9&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> arrStr.size - <span class="number">1</span> downTo <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arrStr[i - <span class="number">1</span>] &gt; arrStr[i]) &#123;</span><br><span class="line">            arrStr[i - <span class="number">1</span>] = arrStr[i - <span class="number">1</span>].toInt().minus(<span class="number">1</span>).toChar() <span class="comment">// digitToInt leetcode跑不了</span></span><br><span class="line">            position = i <span class="comment">// 找到-1 的位置，后面的位都变成9</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> position until arrStr.size) &#123;</span><br><span class="line">        arrStr[i] = <span class="string">&#x27;9&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> String(arrStr).toInt()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="968-监控二叉树"><a href="#968-监控二叉树" class="headerlink" title="968 监控二叉树"></a>968 监控二叉树</h4><p>这题比较难，暂时没必要写。</p>

        
        
          <blockquote id="copyright">
              <p>Original link: <a href="https://noteforme.github.io/page/6/index.html">https://noteforme.github.io/page/6/index.html</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LEETCODE/" rel="tag">LEETCODE</a></li></ul>

          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-Activity_Stack" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2023-01-02T03:31:38.914Z" itemprop="datePublished">2023年01月02日</time>
</span>
      
      
      
<a href="/2023/01/02/Activity_Stack/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h4><p>An activity is a single, focused thing that the user can do. Almost all activities interact with the user, so the Activity class takes care of creating a window for you in which you can place your UI with setContentView(View).<br>Acitivty和用户交互，所以也是用的最多的</p>
<p><img src="https://developer.android.google.cn/images/activity_lifecycle.png"> </p>
<h5 id="lifecycle"><a href="#lifecycle" class="headerlink" title="lifecycle"></a>lifecycle</h5><ol>
<li>onCreate():  Activity创建的时候调用，绑定数据。</li>
<li>onStart() : 当Activity对用户变得可见的时候调用.</li>
<li>onResume() : activity开始和用户交互的时候调用，这时候activity处于栈顶，伴随着用户的输入.</li>
<li>onPause() : 当activity失去前台状态，开始进入stopped&#x2F;hidden or destroyed状态，不能再获取焦点，此时activity对用户可见，但是更新的UI的操作要快。</li>
<li>onStop()  :  当activity不再可见，可能是新的activity来到栈顶，或者当前activity正在被destroy.</li>
<li>onDestory(): 当前activity正在离开。</li>
</ol>
<h5 id="想到一个问题-界面A到界面B，是A的onStop-先执行-还是B的onResume-先走"><a href="#想到一个问题-界面A到界面B，是A的onStop-先执行-还是B的onResume-先走" class="headerlink" title="想到一个问题:界面Ａ到界面Ｂ，是Ａ的onStop()先执行　还是Ｂ的onResume()先走"></a>想到一个问题:界面Ａ到界面Ｂ，是Ａ的onStop()先执行　还是Ｂ的onResume()先走</h5><p>先用事实说话吧</p>
<pre><code> I/BaseActivity: MainActivity -- onCreate() -- 
 I/BaseActivity: MainActivity -- onStart() -- 
 I/BaseActivity: MainActivity -- onResume() -- 
 I/BaseActivity: MainActivity -- onPause() -- 
 I/BaseActivity: StopResumeActivity -- onCreate() -- 
 I/BaseActivity: StopResumeActivity -- onStart() -- 
 I/BaseActivity: StopResumeActivity -- onResume() -- 
 I/BaseActivity: MainActivity -- onStop() -- 
</code></pre>
<p>从打印结果可以看到StopResumeActivity.onResume()先执行,然后是MainActivity的onStop</p>
<p>onStop() :<br>大概知道原因，但是还是不够说服力，因为onStart()方法已经对用户可见了，为什么MainActivity – onStop()不在 StopResumeActivity – onStart()后面呢？</p>
<p>可能是onResume()调用后，新activity位于栈顶，之前的再onStop()</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/c6E5UlI1N/article/details/119549972">https://blog.csdn.net/c6E5UlI1N/article/details/119549972</a></p>
<h4 id="OnNewIntent"><a href="#OnNewIntent" class="headerlink" title="OnNewIntent()"></a>OnNewIntent()</h4><p>onNewIntent</p>
<p>added in <a target="_blank" rel="noopener" href="https://developer.android.com/guide/topics/manifest/uses-sdk-element.html#ApiLevels">API level 1</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void onNewIntent (Intent intent)</span><br></pre></td></tr></table></figure>

<p>if the Activity was already created and a new Intent is being delivered to <code>onNewIntent(android.content.Intent)</code></p>
<p>This is called for activities that set launchMode to “singleTop” in their package, or if a client used the <code>FLAG_ACTIVITY_SINGLE_TOP</code> flag when calling <code>startActivity(Intent)</code>. In either case, when the activity is re-launched while at the top of the activity stack instead of a new instance of the activity being started, onNewIntent() will be called on the existing instance with the Intent that was used to re-launch it.</p>
<p>An activity will always be paused before receiving a new intent, so you can count on <code>onResume()</code> being called after this method.</p>
<p>Note that <code>getIntent()</code> still returns the original Intent. You can use <code>setIntent(Intent)</code> to update it to this new Intent.</p>
<table>
<thead>
<tr>
<th>Parameters</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>intent</code></td>
<td><code>Intent</code>: The new intent that was started for the activity.</td>
</tr>
</tbody></table>
<p>这个方法用于singleTop  singleTask两种启动模式</p>
<p>先看看  singleTask方式：FirstActivity  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=&quot;.launchmode.FirstActivity&quot;</span><br><span class="line">            android:launchMode=&quot;singleTask&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>​        </p>
<p>   从 FirstActivity  –&gt; LaunchActivity –&gt; FirstActivity 生命周期方法</p>
<blockquote>
<p> 04-24 11:49:14.602 26674-26674&#x2F;com.jonzhou.mineutils D&#x2F;FirstActivity LaunchMode: onCreate()<br> 04-24 11:49:14.672 26674-26674&#x2F;com.jonzhou.mineutils D&#x2F;FirstActivity LaunchMode: onStart()<br> 04-24 11:49:14.679 26674-26674&#x2F;com.jonzhou.mineutils D&#x2F;FirstActivity LaunchMode: onResume()<br> 04-24 11:49:32.085 26674-26674&#x2F;com.jonzhou.mineutils D&#x2F;FirstActivity LaunchMode: onPause()<br> 04-24 11:49:32.099 26674-26674&#x2F;com.jonzhou.mineutils D&#x2F;LaunchActivity LaunchMode: onCreate()<br> 04-24 11:49:32.127 26674-26674&#x2F;com.jonzhou.mineutils D&#x2F;LaunchActivity LaunchMode: onStart()<br> 04-24 11:49:32.132 26674-26674&#x2F;com.jonzhou.mineutils D&#x2F;LaunchActivity LaunchMode: onResume()<br> 04-24 11:49:32.462 26674-26674&#x2F;com.jonzhou.mineutils D&#x2F;FirstActivity LaunchMode: onStop()<br> 04-24 11:49:53.681 26674-26674&#x2F;com.jonzhou.mineutils D&#x2F;LaunchActivity LaunchMode: onPause()<br> 04-24 11:49:53.701 26674-26674&#x2F;com.jonzhou.mineutils D&#x2F;FirstActivity LaunchMode:  onNewIntent(Intent intent)<br> 04-24 11:49:53.702 26674-26674&#x2F;com.jonzhou.mineutils D&#x2F;FirstActivity LaunchMode: onStart()<br> 04-24 11:49:53.703 26674-26674&#x2F;com.jonzhou.mineutils D&#x2F;FirstActivity LaunchMode: onResume()<br> 04-24 11:49:54.049 26674-26674&#x2F;com.jonzhou.mineutils D&#x2F;LaunchActivity LaunchMode: onStop()<br> 04-24 11:49:54.049 26674-26674&#x2F;com.jonzhou.mineutils D&#x2F;LaunchActivity LaunchMode: onDestroy()</p>
</blockquote>
<p>然后可以通过 onNewIntent(Intent intent);获取传回来的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String data1 = intent.getStringExtra(newIntent);</span><br><span class="line">String data2 = getIntent().getStringExtra(newIntent);  //这种方式获取不到</span><br><span class="line">setIntent(intent);                                     //通过这种设置获取</span><br><span class="line">String data3 = getIntent().getStringExtra(newIntent);</span><br><span class="line">Timber.d(&quot;onNewIntent  &quot; + data3);</span><br></pre></td></tr></table></figure>

<p>为什么要设置 setIntent(intent)</p>
<blockquote>
<p>我们在多次启动同一个栈唯一模式下的activity时，在onNewIntent()里面的getIntent()得到的intent感觉都是第一次的那个数据。对，这里就是这个陷阱。因为它就是会返回第一个intent的数据</p>
</blockquote>
<h4 id="ActivityStack"><a href="#ActivityStack" class="headerlink" title="ActivityStack"></a>ActivityStack</h4><p>TaskRecord不同的应用就不同的 任务栈</p>
<p>安卓系统管理着不同模式下的多个ActivityStack（比如在home launcher界面需要有一个ActivityStack，画中画模式，分屏模式等），一个ActivityStack可以包含很多个TaskRecord，一个TaskRecord又可以包含很多个ActivityRecord。</p>
<p>每一个ActivityRecord都会有一个Activity与之对应，一个Activity可能会有多个ActivityRecord，因为Activity可以被多次实例化，取决于其launchmode。一系列相关的ActivityRecord组成了一个TaskRecord，TaskRecord是存在于ActivityStack中，ActivityStackSupervisor是用来管理这些ActivityStack的。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c193e7342fb1015f2f18269b27382f06.png"></p>
<h4 id="taskAffinity"><a href="#taskAffinity" class="headerlink" title="taskAffinity"></a>taskAffinity</h4><p>清单文件中Application和Activity标签都可以使用android:taskAffinity，值为String类型。</p>
<p>它代表这个Activity所希望归属的Task，在默认情况下，同一个app中的所有Activity拥有共同的Affinity，即manifest中定义的package。</p>
<p>另外task的affinity取决于它的根部Activity。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/732fa07cf455afaf801593830285e9e9.png"></p>
<p>如果使用SingleInstance模式启动的Activity，如果没有指定affinity的话，创建的新task的affinity还是app的包名。</p>
<h5 id="FLAG-ACTIVITY-NEW-TASK"><a href="#FLAG-ACTIVITY-NEW-TASK" class="headerlink" title="FLAG_ACTIVITY_NEW_TASK"></a>FLAG_ACTIVITY_NEW_TASK</h5><p>在默认情况下，目标Activity将与startActivity的调用者处于同一task中。但如果用户特别指定了FLAG_ACTIVITY_NEW_TASK，表明它希望为Activity重新开设一个Task。这时就有两种情况：</p>
<ol>
<li>假如当前已经有一个Task，它的affinity与新Activity是一样的，那么系统会直接用此Task来完成操作，而不是另外创建一个Task；</li>
<li>否则系统需要创建一个Task。</li>
</ol>
<h4 id="allowTaskReparenting-什么意思"><a href="#allowTaskReparenting-什么意思" class="headerlink" title="allowTaskReparenting 什么意思"></a>allowTaskReparenting 什么意思</h4><h4 id="Activity-launch-mode"><a href="#Activity-launch-mode" class="headerlink" title="Activity launch mode"></a>Activity launch mode</h4><p>启动模式</p>
<ol>
<li><p>Androidmanifest 设置 launch mode是对目标Activity而言</p>
</li>
<li><p>Intent flag比 Androidmanifest的优先级更高</p>
</li>
</ol>
<h5 id="4种启动模式"><a href="#4种启动模式" class="headerlink" title="4种启动模式"></a>4种启动模式</h5><p>我理解的启动模式，针对的是被启动的Activity</p>
<ul>
<li><p>standard </p>
<p>在不同的Task中打开同一个Activity，Activity会被创建多个实例。分别放进打开它的Task中。</p>
<p>例如: 点开短信中的电话号码， 新的 打电话的Activity会存在于   短信Task中。</p>
</li>
<li><p>singleTop</p>
</li>
<li><p>singleTask</p>
<blockquote>
<p>The system creates a new task and instantiates the activity at the root of the new task. However, if an instance of the activity already exists in a separate task, the system routes the intent to the existing instance through a call to its <code>onNewIntent()</code> method, rather than creating a new instance. Only one instance of the activity can exist at a time.</p>
<p>只会在一个Task出现,这个Task里只有一个这个Activity，全局唯一</p>
</blockquote>
</li>
<li><p>singleInstance </p>
<blockquote>
<p>Same as <code>&quot;singleTask&quot;</code>, except that the system doesn’t launch any other activities into the task holding the instance. The activity is always the single and only member of its task; any activities started by this one open in a separate task.</p>
<p>除了全局唯一，还会独占一个Task</p>
</blockquote>
</li>
</ul>
<h4 id="taskAffinity-1"><a href="#taskAffinity-1" class="headerlink" title="taskAffinity"></a>taskAffinity</h4><p>每个Activity都有一个taskAffinity，默认取自Activity所在的Application的taskAffinity,而后者又默认取自app包名.</p>
<p>每个Task也有它自己的taskAffinity，它取自栈底的Activity的taskAffinity</p>
<p>默认情况下，Activity会直接进入当前的Task</p>
<p>但对于设置了  launchMode &#x3D; “singleTask”的Activity,系统会先比对Activity和当前Task的taskAffinity是否相同</p>
<ul>
<li><p>如果相同，依然正常入栈.</p>
</li>
<li><p>如果不同，新Activity会去寻找和它 taskAffinity相同的Task后入栈。</p>
<p>如果找不到，系统就为它创建一个新的Task,或者创建一个新的Task.</p>
</li>
</ul>
<p>MainActivity启动FirstActivity</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.component.launchmode.FirstActivity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:taskAffinity</span>=<span class="string">&quot;com.comm.mytask&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<pre><code>   TaskRecord&#123;dff3f0b #4947 A=com.comm.util U=0 StackId=1 sz=2&#125;
         Run #4: ActivityRecord&#123;e52ebf7 u0 com.comm.util/.component.launchmode.FirstActivity t4947&#125;
         Run #3: ActivityRecord&#123;cd6b037 u0 com.comm.util/.MainActivity t4947&#125;
</code></pre>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.component.launchmode.FirstActivity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:launchMode</span>=<span class="string">&quot;singleTask&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:taskAffinity</span>=<span class="string">&quot;com.comm.mytask&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TaskRecord&#123;3713c1e #4946 A=com.comm.mytask U=0 StackId=1 sz=1&#125;</span><br><span class="line">   Run #4: ActivityRecord&#123;3d3bd58 u0 com.comm.util/.component.launchmode.FirstActivity t4946&#125;</span><br><span class="line"> TaskRecord&#123;273cacc #4945 A=com.comm.util U=0 StackId=1 sz=1&#125;</span><br><span class="line">   Run #3: ActivityRecord&#123;77277e0 u0 com.comm.util/.MainActivity t4945&#125;</span><br></pre></td></tr></table></figure>

<p> 添加完   <code>android:launchMode=&quot;singleTask&quot;</code>后 多了个task     com.comm.mytask</p>
<h5 id="TaskAffinity和最近任务列表"><a href="#TaskAffinity和最近任务列表" class="headerlink" title="TaskAffinity和最近任务列表"></a>TaskAffinity和最近任务列表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys activity activities | sed -En -e &#x27;/Running activities/,/Run #0/p&#x27;</span><br></pre></td></tr></table></figure>

<h5 id="SingleInstance-不设置taskAffinity"><a href="#SingleInstance-不设置taskAffinity" class="headerlink" title="SingleInstance 不设置taskAffinity"></a>SingleInstance 不设置taskAffinity</h5><p>SingleInstance会创建一个新的任务栈</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.component.launchmode.FirstActivity&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.component.launchmode.SecondActivity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:launchMode</span>=<span class="string">&quot;singleInstance&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.component.launchmode.ThirdActivity&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">D/FirstActivity LaunchModeActivity: onCreate() taskId  86</span><br><span class="line">D/FirstActivity LaunchModeActivity: onStart()</span><br><span class="line">D/FirstActivity LaunchModeActivity: onResume()</span><br><span class="line">D/FirstActivity LaunchModeActivity: onPause()</span><br><span class="line">D/SecondActivity LaunchModeActivity: onCreate() taskId  85</span><br><span class="line">D/SecondActivity LaunchModeActivity: onStart()</span><br><span class="line">D/SecondActivity LaunchModeActivity: onRestoreInstanceState()</span><br><span class="line">D/SecondActivity LaunchModeActivity:  onNewIntent(Intent intent)</span><br><span class="line">D/SecondActivity LaunchModeActivity: onResume()</span><br><span class="line">D/FirstActivity LaunchModeActivity: onSaveInstanceState()</span><br><span class="line">D/FirstActivity LaunchModeActivity: onStop()</span><br><span class="line">D/SecondActivity LaunchModeActivity: onPause()</span><br><span class="line">D/ThirdActivity LaunchModeActivity: onCreate() taskId  86</span><br><span class="line">D/ThirdActivity LaunchModeActivity: onStart()</span><br><span class="line">D/ThirdActivity LaunchModeActivity: onResume()</span><br><span class="line">D/SecondActivity LaunchModeActivity: onSaveInstanceState()</span><br><span class="line">D/SecondActivity LaunchModeActivity: onStop()</span><br></pre></td></tr></table></figure>

<p>可以看到 FirstActivity 、ThirdActivity在同一个栈中，SecondActivity单独在一个栈中</p>
<p>所以按返回键盘，先到 FirstActivity，然后到SecondActivity .</p>
<h5 id="栈内Activity查看，设置taskAffinity"><a href="#栈内Activity查看，设置taskAffinity" class="headerlink" title="栈内Activity查看，设置taskAffinity"></a>栈内Activity查看，设置taskAffinity</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.component.launchmode.SerachActivity&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:name</span>=<span class="string">&quot;.component.onactivityresult.SecondActivity&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:launchMode</span>=<span class="string">&quot;singleTask&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:taskAffinity</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:name</span>=<span class="string">&quot;.component.launchmode.FirstActivity&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:configChanges</span>=<span class="string">&quot;orientation&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:launchMode</span>=<span class="string">&quot;singleTask&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">           <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>adb shell dumpsys activity</p>
</blockquote>
<p><img src="/2023/01/02/Activity_Stack//2021-01-23_3.31.08.png"></p>
<ul>
<li>taskAffinity属性的值为字符串，且中间必须含有分隔符”.”</li>
<li>standard模式，taskAffinity继承自Application的taskAffinity，而Application默认taskAffinity为包名，所以MainActivity的taskAffinity为包名。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://developer.android.com/guide/components/activities/tasks-and-back-stack">https://developer.android.com/guide/components/activities/tasks-and-back-stack</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhangjg_blog/article/details/10923643">https://blog.csdn.net/zhangjg_blog/article/details/10923643</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/javazejian/article/details/52072131">https://blog.csdn.net/javazejian/article/details/52072131</a></p>
<p>生命周期视图</p>
<p><a target="_blank" rel="noopener" href="http://yhz61010.iteye.com/blog/2389877">http://yhz61010.iteye.com/blog/2389877</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_16628781/article/details/51539715">https://blog.csdn.net/qq_16628781/article/details/51539715</a></p>
<h4 id="然而-ANDROID-4-4-启动模式会出现问题"><a href="#然而-ANDROID-4-4-启动模式会出现问题" class="headerlink" title="然而 ANDROID 4.4 启动模式会出现问题"></a>然而 ANDROID 4.4 启动模式会出现问题</h4><p><a target="_blank" rel="noopener" href="http://www.jianshu.com/p/2a9fcf3c11e4">http://www.jianshu.com/p/2a9fcf3c11e4</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/mynameishuangshuai/article/details/51491074">http://blog.csdn.net/mynameishuangshuai/article/details/51491074</a></p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=r4T9zkhpmII">https://www.youtube.com/watch?v=r4T9zkhpmII</a></p>
<h5 id="任务栈一"><a href="#任务栈一" class="headerlink" title="任务栈一"></a>任务栈一</h5><p> 从图中我们看出前台任务栈分别为AB两个Activity，后台任务栈分别为CD两个任务栈，而且其启动模式均为singleTask，此时我们先启动CD，然后再启动AB，再有B启动D，此时后台任务栈便会被切换到前台，而且这个时候整个后退列表就变成了ABCD，请注意我们这里强调的是后退列表，而非栈合并。因此当用户点击back键时，列表中的Activity会依次按DCBA顺序出栈，如下图所示：</p>
<p>前面我们在分析singleTask模式时，提到过singleTask模式有些比较特殊的场景，现在我们就来了解了解它们。<br>特殊情景一:现在我们假设有如下两个Task栈,分别为前台任务栈和后台任务栈</p>
<p>  从图中我们看出前台任务栈分别为AB两个Activity，后台任务栈分别为CD两个任务栈，而且其启动模式均为singleTask，此时我们先启动CD，然后再启动AB，再有B启动D，此时后台任务栈便会被切换到前台，而且这个时候整个后退列表就变成了ABCD，请注意我们这里强调的是后退列表，而非栈合并。因此当用户点击back键时，列表中的Activity会依次按DCBA顺序出栈，如下图所示：</p>
<p>  这里我们通过两个应用ActivityTask和ActivityTask2来测试重现这个现象。因为两个是不同的应用所以启动时所在的栈也是不同。我们先启动ActivityTask2的应用，其ActivityC和ActivityD都是singleTask模式，然后再启动应用ActivityTask，此时ActivityC和ActivityD所在任务栈会被退居后台，而打开的ActivityA和ActivityB会在前台，而且都是默认模式。我们通过 adb shell dumpsys activity activities 命令查看此时栈的情况：</p>
<p>  我们可以看到由两个栈，分别为id&#x3D;222且栈名为“com.cmcm.activitytask”的任务栈其包含ActivityA和ActivityB（下面简称AB，栈名一般默认和包名相同），另外一个任务栈，id&#x3D;221，栈名为“com.cmcm.activitytask2”，其包含ActivityC和ActivityD（下面检测CD）。现在我们通过ActivityB去启动ActivityD，然后按back键回退</p>
<p>  我们可以看到包含CD的任务栈被提前的，虽然CD隔开了，但是我们从id和栈名可以发现他们是同一个栈，而AB所在的栈则在CD所在栈的后面，所以此时我们按back回退时，退出顺序是这样的D-&gt;C-&gt;B-&gt;A，动态图如下：</p>
<img src="/2023/01/02/Activity_Stack//play.gif" alt="play" style="zoom:20%;">

<p> 到此我们对SingleTask模式又有了更深入的理解，但是我们发现上面的例子使用的是两个应用，所以才会有不同的任务栈，那么我们能不能在一个应用中存在多个不同的任务栈呢（暂时不考虑singleInstance 模式）？答案当然是肯定的啦，这就需要通过taskAffinity属性来设置不同的任务栈名称，不过这点将放在下篇来记录，本篇就先到这里告一段落哈。</p>
<h5 id="任务栈二"><a href="#任务栈二" class="headerlink" title="任务栈二"></a>任务栈二</h5><h5 id="任务栈二-1"><a href="#任务栈二-1" class="headerlink" title="任务栈二"></a>任务栈二</h5><p>这篇文章讲的很好</p>
<p>​        这个和allowTaskReparenting没关系</p>
<p>​        这个和allowTaskReparenting没关系</p>
<p>  假如现在有这么一个需求,我们的客户端app正处于后台运行，此时我们因为某些需要，让微信调用自己客户端app的某个页面，用户完成相关操作后，我们不做任何处理，按下回退或者当前Activity.finish()，页面都会停留在自己的客户端（此时我们的app回退栈不为空），这显然不符合逻辑的，用户体验也是相当出问题的。我们要求是，回退必须回到微信客户端,而且要保证不杀死自己的app.这时候我们的处理方案就是，设置当前被调起Activity的属性为：</p>
<p>LaunchMode&#x3D;””SingleTask” taskAffinity&#x3D;”com.tencent.mm”</p>
<p>其中com.tencent.mm是借助于工具找到的微信包名，就是把自己的Activity放到微信默认的Task栈里面，这样回退时就会遵循“Task只要有Activity一定从本Task剩余Activity回退”的原则，不会回到自己的客户端；而且也不会影响自己客户端本来的Activity和Task逻辑。</p>
<ol start="2">
<li>TaskAffinity与allowTaskReparenting应用场景<br>  一个e-mail应用消息包含一个网页链接，点击这个链接将出发一个activity来显示这个页面，虽然这个activity是浏览器应用定义的，但是activity由于e-mail应用程序加载的，所以在这个时候该activity也属于e-mail这个task。如果e-mail应用切换到后台，浏览器在下次打开时由于allowTaskReparenting值为true，此时浏览器就会显示该activity而不显示浏览器主界面，同时actvity也将从e-mail的任务栈迁移到浏览器的任务栈，下次打开e-买了时并不会再显示该activity<br>     到此TaskAffinity就全部介绍完了，最后我们再来了解几个跟任务栈相关的属性参数；</li>
</ol>

        
        
          <blockquote id="copyright">
              <p>Original link: <a href="https://noteforme.github.io/page/6/index.html">https://noteforme.github.io/page/6/index.html</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-viewBinding" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/12/27/viewBinding/">viewBinding</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2022-12-27T13:04:33.000Z" itemprop="datePublished">2022年12月27日</time>
</span>
      
      
      
<a href="/2022/12/27/viewBinding/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/pengxurui/p/16669380.html">https://www.cnblogs.com/pengxurui/p/16669380.html</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6958346113552220173">https://juejin.cn/post/6958346113552220173</a></p>
<h5 id="编译生成的目录"><a href="#编译生成的目录" class="headerlink" title="编译生成的目录"></a>编译生成的目录</h5><p>build/generated/data_binding_base_class_source_out/</p>
<p>ActivityCBinding.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityCBinding</span> <span class="keyword">implements</span> <span class="title">ViewBinding</span> </span>&#123;</span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> LinearLayout rootView;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> Button btC;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> Button btD;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">ActivityCBinding</span><span class="params">(<span class="meta">@NonNull</span> LinearLayout rootView, <span class="meta">@NonNull</span> Button btC,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@NonNull</span> Button btD)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.rootView = rootView;</span><br><span class="line">    <span class="keyword">this</span>.btC = btC;</span><br><span class="line">    <span class="keyword">this</span>.btD = btD;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> LinearLayout <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rootView;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ActivityCBinding <span class="title">inflate</span><span class="params">(<span class="meta">@NonNull</span> LayoutInflater inflater)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> inflate(inflater, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ActivityCBinding <span class="title">inflate</span><span class="params">(<span class="meta">@NonNull</span> LayoutInflater inflater,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@Nullable</span> ViewGroup parent, <span class="keyword">boolean</span> attachToParent)</span> </span>&#123;</span><br><span class="line">    View root = inflater.inflate(R.layout.activity_c, parent, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (attachToParent) &#123;</span><br><span class="line">      parent.addView(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bind(root);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ActivityCBinding <span class="title">bind</span><span class="params">(<span class="meta">@NonNull</span> View rootView)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The body of this method is generated in a way you would not otherwise write.</span></span><br><span class="line">    <span class="comment">// This is done to optimize the compiled bytecode for size and performance.</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    missingId: &#123;</span><br><span class="line">      id = R.id.bt_c;</span><br><span class="line">      Button btC = ViewBindings.findChildViewById(rootView, id);</span><br><span class="line">      <span class="keyword">if</span> (btC == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span> missingId;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      id = R.id.bt_D;</span><br><span class="line">      Button btD = ViewBindings.findChildViewById(rootView, id);</span><br><span class="line">      <span class="keyword">if</span> (btD == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span> missingId;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ActivityCBinding((LinearLayout) rootView, btC, btD);</span><br><span class="line">    &#125;</span><br><span class="line">    String missingId = rootView.getResources().getResourceName(id);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;Missing required view with ID: &quot;</span>.concat(missingId));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>从控件  Button btC;  Button btD;可以很容易看到。id都是findbyid生成的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FragmentViewBinding</span>&lt;<span class="type">T : ViewBinding</span>&gt;</span>(classes: Class&lt;T&gt;, fragment: Fragment) :</span><br><span class="line">    FragmentDelegate&lt;T&gt;(fragment) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> TAG = <span class="string">&quot;TAG&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> layoutInflater = classes.inflateMethod()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> bindView = classes.bindMethod()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用getValue属于属性代理,访问viewbiding属性调用getVaule方法</span></span><br><span class="line">    <span class="meta">@Suppress(<span class="meta-string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Fragment</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T = viewBinding ?: let &#123;</span><br><span class="line"></span><br><span class="line">        Log.i(TAG, <span class="string">&quot;getValue: <span class="variable">$layoutInflater</span>  <span class="variable">$bindView</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> bind: T = (<span class="keyword">if</span> (thisRef.view == <span class="literal">null</span>) &#123;</span><br><span class="line">            layoutInflater.invoke(<span class="literal">null</span>, thisRef.layoutInflater) <span class="comment">// 表示 ActivityCBinding.inflate()</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            bindView.invoke(<span class="literal">null</span>, thisRef.view) <span class="comment">//表示 ActivityCBinding.bind()</span></span><br><span class="line">        &#125;) <span class="keyword">as</span> T</span><br><span class="line">        viewBinding = bind</span><br><span class="line">        bind</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
        
          <blockquote id="copyright">
              <p>Original link: <a href="https://noteforme.github.io/page/6/index.html">https://noteforme.github.io/page/6/index.html</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ANDROID/" rel="tag">ANDROID</a></li></ul>

          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-LC-backtrack-combination" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/10/30/LC-backtrack-combination/">LC-backtrack-combination</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2022-10-30T02:27:10.000Z" itemprop="datePublished">2022年10月30日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/DataStructure/">DataStructure</a>
  </div>

      
      
<a href="/2022/10/30/LC-backtrack-combination/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>组合</p>
<p>组合的元素是无序的[1,2]  , [2,1]是一个组合</p>
<p>组合的元素是不能重复的 </p>
<img src="https://img-blog.csdnimg.cn/20201123195242899.png" alt="77.组合1" style="zoom: 67%;">







<h4 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combinations/">77. 组合</a></h4><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ti4y1L7cv">https://www.bilibili.com/video/BV1ti4y1L7cv</a> </p>
<ol>
<li>拿到第一个元素.</li>
<li>用上面的图很形象,在剩余的元素中取数据，和 二叉树路径很像,递归加回溯的过程.</li>
</ol>
<p>这里一开始用的是 startIndex+1,不理解，这里回溯后,最第一次的for (i in startIndex..n)如果i ==2,或者3，或者4, 递归到底层，再回溯到第一次循环的时候，startIndex都是第一次的2,这样就导致剩余的元素不对</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">combine</span><span class="params">(n: <span class="type">Int</span>, k: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    backTracking(n, k, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTracking</span><span class="params">(n: <span class="type">Int</span>, k: <span class="type">Int</span>, startIndex: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.size == k) &#123;</span><br><span class="line">        result.add(path.toMutableList())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex..n) &#123;</span><br><span class="line">        path.add(i)</span><br><span class="line">        backTracking(n, k, i + <span class="number">1</span>) <span class="comment">// 这里一开始用的是 startIndex+1</span></span><br><span class="line">        path.remove(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="组合剪枝"><a href="#组合剪枝" class="headerlink" title="组合剪枝"></a>组合剪枝</h5><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1wi4y157er/">https://www.bilibili.com/video/BV1wi4y157er/</a></p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html#%E5%89%AA%E6%9E%9D%E4%BC%98%E5%8C%96">https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html#%E5%89%AA%E6%9E%9D%E4%BC%98%E5%8C%96</a></p>
<p>来举一个例子，n = 4，k = 4的话，那么第一层for循环的时候，从元素2开始的遍历都没有意义了。 在第二层for循环，从元素3开始的遍历都没有意义了。</p>
<p><img src="https://img-blog.csdnimg.cn/20210130194335207.png" alt="77.组合4"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> startIndex..n) &#123; <span class="comment">// 这里对应模拟就是,取1,取2 ,取3,取4 ,几个子孩子的操作.</span></span><br><span class="line">         path.add(i)</span><br><span class="line">         backTracking(n, k, i + <span class="number">1</span>) <span class="comment">// 这里一开始用的是 startIndex+1</span></span><br><span class="line">         path.remove(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>剪枝就是 i&lt; n这个范围里面做操作。</p>
<p>接下来看一下优化过程如下：</p>
<ol>
<li>已经选择的元素个数：path.size();</li>
<li>还需要的元素个数为: k - path.size();</li>
<li>在集合n中至多要从该起始位置 : n - (k - path.size()) + 1，开始遍历</li>
</ol>
<p>为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。</p>
<p>举个例子，n = 4，k = 3， 目前已经选取的元素为0（path.size为0），n - (k - 0) + 1 即 4 - ( 3 - 0) + 1 = 2。</p>
<p>从2开始搜索都是合理的，可以是组合[2, 3, 4]。</p>
<p>这里大家想不懂的话，建议也举一个例子，就知道是不是要+1了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> path = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="keyword">val</span> result = ArrayList&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">combine</span><span class="params">(n: <span class="type">Int</span>, k: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    backTracking1(n, k, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//剪枝操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTracking1</span><span class="params">(n: <span class="type">Int</span>, k: <span class="type">Int</span>, startIndex: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.size == k) &#123;</span><br><span class="line">        result.add(path.toMutableList())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex..(n - (k - path.size) + <span class="number">1</span>)) &#123;</span><br><span class="line">        path.add(i)</span><br><span class="line">        backTracking1(n, k, i + <span class="number">1</span>) <span class="comment">// 这里一开始用的是 startIndex+1</span></span><br><span class="line">        path.remove(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III</a></h4><ul>
<li>只使用数字1到9 .</li>
<li>每个数字 <strong>最多使用一次</strong> .</li>
</ul>
<ol>
<li><p>从1开始选取，每次循环往后选取，如果往前选数字入[1,2], [2,1]的情况，就重复了.</p>
</li>
<li><p>选取元素综合==n ,  并且是k个，装入数组。</p>
</li>
</ol>
<p>我的解法if (sum == n &amp;&amp; pathList.size == k)放一起不好 ，pathList.size到了k 个数，后面的就不用加了，达到竖向剪枝的目的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> result = ArrayList&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> sum: <span class="built_in">Int</span> = <span class="number">0</span> <span class="comment">//集合的和</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> pathList = ArrayList&lt;<span class="built_in">Int</span>&gt;() <span class="comment">// 集合</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">combinationSum3</span><span class="params">(k: <span class="type">Int</span>, n: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    blockTracking(k, n, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">blockTracking</span><span class="params">(k: <span class="type">Int</span>, n: <span class="type">Int</span>, startIndex: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sum == n &amp;&amp; pathList.size == k) &#123; <span class="comment">// 相加之和为 n 的 k 个数的组合</span></span><br><span class="line">        result.add(pathList.toMutableList())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex.<span class="number">.9</span>) &#123;</span><br><span class="line">        sum += i</span><br><span class="line">        pathList.add(i)</span><br><span class="line">        blockTracking(k, n, i + <span class="number">1</span>)</span><br><span class="line">        sum -= i</span><br><span class="line">        pathList.remove(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h5><p>还没想好</p>
<p><img src="https://img-blog.csdnimg.cn/2020112319580476.png" alt="216.组合总和III1"></p>
<ol>
<li><p>pathList.size到了k 个数，后面的就不用加了，达到竖向剪枝的目的。</p>
</li>
<li><p>(9 - (k - pathList.size) + 1) 分析 </p>
<p>k - pathList.size :  从1开始选取,还差多少个元素</p>
<p>9 - (k - pathList.size)  : 如果从1…9选取，为了避免重复，一直往大的数选取,第1次选到了8,如果k==2,那么过了8就没意义了，第一次的9就不需要选取了.</p>
<p>(9 - (k - pathList.size) + 1) 处理下标值。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> result = ArrayList&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> sum: <span class="built_in">Int</span> = <span class="number">0</span> <span class="comment">//集合的和</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> pathList = ArrayList&lt;<span class="built_in">Int</span>&gt;() <span class="comment">// 集合</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">combinationSum3</span><span class="params">(k: <span class="type">Int</span>, n: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    blockTracking(k, n, <span class="number">1</span>)</span><br><span class="line">    println(result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">blockTracking</span><span class="params">(k: <span class="type">Int</span>, n: <span class="type">Int</span>, startIndex: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pathList.size == k) &#123; <span class="comment">//shuxiang</span></span><br><span class="line">        <span class="keyword">if</span> (sum == n) &#123;</span><br><span class="line">            result.add(pathList.toMutableList())</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex..(<span class="number">9</span> - (k - pathList.size) + <span class="number">1</span>)) &#123; <span class="comment">// 横向剪枝</span></span><br><span class="line">        <span class="keyword">if</span> (sum &gt; n) &#123; <span class="comment">//剪枝</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        sum += i</span><br><span class="line">        pathList.add(i)</span><br><span class="line">        blockTracking(k, n, i + <span class="number">1</span>)</span><br><span class="line">        sum -= i</span><br><span class="line">        pathList.remove(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">blockTracking</span><span class="params">(k: <span class="type">Int</span>, n: <span class="type">Int</span>, startIndex: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; n) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">//sum &gt; n 直接返回，随想录的解法，这样更好.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pathList.size == k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == n) &#123;</span><br><span class="line">            result.add(pathList.toMutableList())</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex..(<span class="number">9</span> - (k - pathList.size) + <span class="number">1</span>)) &#123;</span><br><span class="line">        sum += i</span><br><span class="line">        pathList.add(i)</span><br><span class="line">        blockTracking(k, n, i + <span class="number">1</span>)</span><br><span class="line">        sum -= i</span><br><span class="line">        pathList.remove(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17.电话号码的字母组合"></a>17.电话号码的字母组合</h4><p>前面的题目都是在一个数组里面取，看到这个问题，这个问题是在数组里面，再取里面的数组。</p>
<p>问题是，如果输入”235”,那么他们内部数组的索引startIndex怎么求出来.</p>
<h5 id="String中的数字转int"><a href="#String中的数字转int" class="headerlink" title="String中的数字转int"></a>String中的数字转int</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> digits = <span class="string">&quot;23&quot;</span></span><br><span class="line"><span class="keyword">val</span> c = digits[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span> <span class="comment">// 50 - 48</span></span><br><span class="line">println(digits[<span class="number">0</span>].code) <span class="comment">// ASCII是 50</span></span><br><span class="line">println(<span class="string">&#x27;0&#x27;</span>.code)       <span class="comment">//ASCII是 48</span></span><br></pre></td></tr></table></figure>



<h4 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39.组合总和"></a>39.组合总和</h4><p>这题目和前面的区别是，可以选取重复的元素.</p>
<p>选了2后，第二列选5这时候不能选2了，否则就会重复了。</p>
<p><img src="/2022/10/30/LC-backtrack-combination/20221120103956.jpg"></p>
<p>看了随想录分析视频，在分析代码前，根据上面的图了解到的思路.</p>
<ol>
<li>整体回溯架构和前面的都是一样的,选了2后，后面还是可以继续253, 选了5后只有53了，否则就有重复的。</li>
<li>一开始我的解法是backTrack(candidates.toList(), target,i),传入for循环中的i，这样会导致有漏掉前面的情况。要知道for循环的部分就是树的宽度。</li>
<li>后面的剪枝应该也是针对这部分。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> path = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> result = ArrayList&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">combinationSum</span><span class="params">(candidates: <span class="type">IntArray</span>, target: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    backTrack(candidates.toList(), target)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(candidates: <span class="type">List</span>&lt;<span class="type">Int</span>&gt;, target: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; target) &#123;  <span class="comment">// 节点和</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum == target) &#123; </span><br><span class="line">        result.add(path.toList())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ((i, item) <span class="keyword">in</span> candidates.withIndex()) &#123;</span><br><span class="line">        path.add(item)</span><br><span class="line">        sum += item</span><br><span class="line">        backTrack(candidates.toMutableList().subList(i, candidates.size), target) <span class="comment">// 只需要传入后面能选取的数组部分</span></span><br><span class="line">        path.remove(item)</span><br><span class="line">        sum -= item</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>看了随想录的部分解法视频后，感觉这种更好，根据startIndex来取数组位置。传入startIndex后，后面的智能从startIndex后面取，和分割数组是一样的道理，感觉效率会更好。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> path = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> result = ArrayList&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">combinationSum</span><span class="params">(candidates: <span class="type">IntArray</span>, target: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    backTrack(candidates.toList(), target, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(candidates: <span class="type">List</span>&lt;<span class="type">Int</span>&gt;, target: <span class="type">Int</span>, startIndex: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">        result.add(path.toList())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex until candidates.size) &#123;</span><br><span class="line">        path.add(candidates[i])</span><br><span class="line">        sum += candidates[i]</span><br><span class="line">        backTrack(candidates, target, i) <span class="comment">// i后分割元素，一开始写的是startIndex，这样for循环后面的就没过滤到了,只有startIndex过滤到了。</span></span><br><span class="line">        path.remove(candidates[i])</span><br><span class="line">        sum -= candidates[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="剪枝-1"><a href="#剪枝-1" class="headerlink" title="剪枝"></a>剪枝</h5><p><img src="/2022/10/30/LC-backtrack-combination/20221120103956.jpg"></p>
<p>如果target ==4</p>
<p>可以看这张图，如果经过排序左边的 235,取了2,3已经 &gt;=4了，那么后面的5就不用去取了.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> path = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> result = ArrayList&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">combinationSum</span><span class="params">(candidates: <span class="type">IntArray</span>, target: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line"><span class="comment">//        backTrack1(candidates.toList(), target)</span></span><br><span class="line">        Arrays.sort(candidates) <span class="comment">//剪枝前需要排序</span></span><br><span class="line">        backTrack(candidates.toList(), target, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(candidates: <span class="type">List</span>&lt;<span class="type">Int</span>&gt;, target: <span class="type">Int</span>, startIndex: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            result.add(path.toList())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex until candidates.size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum + candidates[i] &gt; target) &#123; <span class="comment">//  剪枝操作</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            path.add(candidates[i])</span><br><span class="line">            sum += candidates[i]</span><br><span class="line">            backTrack(candidates, target, i)</span><br><span class="line">            path.remove(candidates[i])</span><br><span class="line">            sum -= candidates[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack1</span><span class="params">(candidates: <span class="type">IntArray</span>, target: <span class="type">Int</span>, startIndex: <span class="type">Int</span>, used: <span class="type">BooleanArray</span>, layer: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">        result.add(path.toList())</span><br><span class="line">        println(path)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex until candidates.size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum + candidates[i] &gt; target) &#123; <span class="comment">// 这样判断更好，因为是生序的数组，右边的枝没必要</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;layer<span class="variable">$layer</span> i: <span class="variable">$i</span> candidates[i]: <span class="subst">$&#123;candidates[i]&#125;</span>   used: <span class="subst">$&#123;used[i]&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            println(<span class="string">&quot;continue <span class="subst">$&#123;candidates[i]&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        path.add(candidates[i])</span><br><span class="line">        sum += candidates[i]</span><br><span class="line">        used[i] = <span class="literal">true</span></span><br><span class="line">        println(<span class="string">&quot;path <span class="variable">$path</span>&quot;</span>)</span><br><span class="line">        backTrack1(candidates, target, i + <span class="number">1</span>, used, layer + <span class="number">1</span>) <span class="comment">// 经过日志排查后, i + 1之前写的是 startIndex +1, 第二层报错</span></span><br><span class="line">        path.remove(candidates[i])</span><br><span class="line">        println(<span class="string">&quot;path backTrack <span class="variable">$path</span>&quot;</span>)</span><br><span class="line">        sum -= candidates[i]</span><br><span class="line">        used[i] = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40.组合总和 II"></a>40.组合总和 II</h4><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV12V4y1V73A/">https://www.bilibili.com/video/BV12V4y1V73A/</a></p>
<p> 这一题的 [10,1,2,7,6,1,5]，有两个1，可能都和7组成了[1,7]就重复了，这里就是要去掉这种重复。</p>
<p>一开始想不到去重的思路 。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20221021163812.png" alt="img"></p>
<ol>
<li>看了视频，对应这个图. 重复的原因在于树宽 第二次取1的地方，因为第1次取1，已经包括了第二次取1的所有树枝。所以把第二次取1的树枝剪掉既可。</li>
<li>剪枝条件1：candidates[i] == candidates[i - 1] </li>
<li>剪枝条件2: 通过设置used数组，只有used[i - 1] 是false才有意义, used[i - 1]= false ,说明数组的第一个1没有取，取的是第二个1，结果是[1,2]，所以可以舍弃掉，否则导致和第一次的取第一个1和下一层取2,结果是[1,2]重复了。这样判断就可以把 第二次取1的这个枝干给剪掉。 也叫 树层去重。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">val</span> path = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="keyword">val</span> result = ArrayList&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">combinationSum2</span><span class="params">(candidates: <span class="type">IntArray</span>, target: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    Arrays.sort(candidates)</span><br><span class="line">    println(candidates.joinToString())</span><br><span class="line">    <span class="keyword">val</span> used = BooleanArray(candidates.size)</span><br><span class="line">    backTrack(candidates, target, <span class="number">0</span>, used, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(candidates: <span class="type">IntArray</span>, target: <span class="type">Int</span>, startIndex: <span class="type">Int</span>, used: <span class="type">BooleanArray</span>, layer: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">        result.add(path.toList())</span><br><span class="line">        println(path)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex until candidates.size) &#123;</span><br><span class="line">        println(<span class="string">&quot;layer<span class="variable">$layer</span> i: <span class="variable">$i</span> candidates[i]: <span class="subst">$&#123;candidates[i]&#125;</span>   used: <span class="subst">$&#123;used[i]&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            println(<span class="string">&quot;continue <span class="subst">$&#123;candidates[i]&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        path.add(candidates[i])</span><br><span class="line">        sum += candidates[i]</span><br><span class="line">        used[i] = <span class="literal">true</span></span><br><span class="line">        println(<span class="string">&quot;path <span class="variable">$path</span>&quot;</span>)</span><br><span class="line">        backTrack(candidates, target, i + <span class="number">1</span>, used, layer + <span class="number">1</span>) <span class="comment">// 经过日志排查后, i + 1之前写的是 startIndex +1, 第二层报错</span></span><br><span class="line">        path.remove(candidates[i])</span><br><span class="line">        println(<span class="string">&quot;path backTrack <span class="variable">$path</span>&quot;</span>)</span><br><span class="line">        sum -= candidates[i]</span><br><span class="line">        used[i] = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131.分割回文串"></a>131.分割回文串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;aab&quot;</span><br><span class="line">输出：[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]</span><br></pre></td></tr></table></figure>

<p>没想明白 [[“a”,”a”,”b”],[“aa”,”b”]] 这个数组是怎么弄出来的。</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1c54y1e7k6">https://www.bilibili.com/video/BV1c54y1e7k6</a></p>
<p>这题是边看答案变做出来的。</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg" alt="131.分割回文串"></p>
<p>根据上图可以这样理解 ，</p>
<ol>
<li>DFS递归是 纵向切割， a|ab 取[a],  a|a|b 取 [a,a] , a|a|b| 最终到叶子节点取 [a,a,b]，到终点。</li>
<li>for循环是横向切割 。</li>
<li>  val str = s.substring(startIndex,i+1) // 这个也很关键，startIndex作为分割的起点</li>
</ol>
<p>这题类似于树中符合条件的所有的路径，一旦纵向路径中，有一个不符合条件[a,ab] ab不符合，就直接回溯去其他路径.所以放if里判断递归会更好。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = ArrayList&lt;List&lt;String&gt;&gt;()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> path = ArrayList&lt;String&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">partition</span><span class="params">(s: <span class="type">String</span>)</span></span>: List&lt;List&lt;String&gt;&gt; &#123;</span><br><span class="line">    backTrack(s, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(s: <span class="type">String</span>, startIndex: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (startIndex &gt;= s.length) &#123; <span class="comment">// 纵向到叶子节点，就网上回溯</span></span><br><span class="line">        result.add(path.toList())</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">//可以用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex until s.length) &#123;  <span class="comment">//for循环是 横向切割</span></span><br><span class="line">        <span class="keyword">if</span> (isPalindromeNum(s,startIndex,i+<span class="number">1</span>))&#123; <span class="comment">// 判断startIndex,到 i+1是否是回文串</span></span><br><span class="line">            <span class="keyword">val</span> str = s.substring(startIndex,i+<span class="number">1</span>) <span class="comment">// 这个也很关键，startIndex作为分割的起点</span></span><br><span class="line">            path.add(str)</span><br><span class="line">          </span><br><span class="line">       <span class="comment">// backTrack(s, i + 1)    //递归是 纵向切割，也没有循环。这个放if里面可能更好.</span></span><br><span class="line">       <span class="comment">// path.removeAt(path.size-1)</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">continue</span> <span class="comment">// 如ab不是回文串，也不用继续了 </span></span><br><span class="line">        &#125;</span><br><span class="line">        backTrack(s, i + <span class="number">1</span>)    <span class="comment">//递归是 纵向切割，也没有循环。这个放if里面可能更好.</span></span><br><span class="line">        path.removeAt(path.size-<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isPalindromeNum</span><span class="params">(str: <span class="type">String</span>,start:<span class="type">Int</span>,end:<span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> charArray = str.substring(start,end)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until charArray.length / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (charArray[i] != charArray[charArray.length - <span class="number">1</span> - i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="优化解法"><a href="#优化解法" class="headerlink" title="优化解法"></a>优化解法</h5><p>对判断是否回文串的优化.</p>
<h4 id="93-复原-IP-地址"><a href="#93-复原-IP-地址" class="headerlink" title="93.复原 IP 地址"></a>93.复原 IP 地址</h4><p>我的分析</p>
<p>这题和上面131类似，可以通过切割方式解决。</p>
<ol>
<li>ip地址都有四位，需要切割4次，所以树的深度是4。也是回溯终止条件之一，startIndex是切割线。(应该是i+1是切割线，否则只能分割一个字母)</li>
<li>选取有效的ip, 前导不为0，只能是数字。</li>
<li>&lt;255 , 可以限制树的宽度。</li>
</ol>
<p>我写完代码后，切割成这样 2.5.5.2， 不是全部的数字，没想到什么方式能切割所有的数字。</p>
<p>s.substring(startIndex, s.length) 先分割前三个，然后判断最后一个字符串，这样就能分割所有的字母。</p>
<p>startIndex解释，下面这张图更清楚，第一层取 元素2.</p>
<p><img src="https://img-blog.csdnimg.cn/202011232041348.png" alt="78.子集"></p>
<p><img src="https://img-blog.csdnimg.cn/20201123203735933.png" alt="93.复原IP地址"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = ArrayList&lt;String&gt;()</span><br><span class="line"><span class="keyword">val</span> path = ArrayList&lt;String&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">restoreIpAddresses</span><span class="params">(s: <span class="type">String</span>)</span></span>: List&lt;String&gt; &#123;</span><br><span class="line">    backTrack(s, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(s: <span class="type">String</span>, startIndex: <span class="type">Int</span>, layer: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 看了随想录解法，这里加上终止条件会更好。</span></span><br><span class="line">    <span class="keyword">if</span> (layer == <span class="number">3</span>) &#123;   <span class="comment">// 第三个分割线</span></span><br><span class="line">        <span class="keyword">val</span> substring = s.substring(startIndex, s.length) <span class="comment">// 这里的方式就解决了，分割所有子串的问题，最后一次分割，直接到字符串的终点。</span></span><br><span class="line">        <span class="keyword">if</span> (isValid(substring)) &#123;</span><br><span class="line">            path.add(substring)</span><br><span class="line">            result.add(path.toList().joinToString(separator = <span class="string">&quot;.&quot;</span>))</span><br><span class="line">            path.removeAt(path.size-<span class="number">1</span>) <span class="comment">// 最后的字符串回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex until s.length) &#123;</span><br><span class="line">        <span class="keyword">val</span> substring = s.substring(startIndex, i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (isValid(substring)) &#123;</span><br><span class="line">            path.add(substring)</span><br><span class="line">            backTrack(s, i + <span class="number">1</span>, layer + <span class="number">1</span>) <span class="comment">// 注意我这里经常传错用 startIndex,如果第一次已经分割到了超过第2个位置，那么就应该传这个位置，</span></span><br><span class="line">            path.removeAt(path.size-<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断字符串s在左闭又闭区间[start, end]所组成的数字是否合法</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isValid</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> start = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> end = s.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s[start] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; start != end) &#123; <span class="comment">// 0开头的数字不合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> start..end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt; <span class="string">&#x27;9&#x27;</span> || s[i] &lt; <span class="string">&#x27;0&#x27;</span>) &#123; <span class="comment">// 遇到非数字字符不合法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num = num * <span class="number">10</span> + (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (num &gt; <span class="number">255</span>) &#123; <span class="comment">// 如果大于255了不合法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/">78. 子集</a></h4><p><img src="https://img-blog.csdnimg.cn/202011232041348.png" alt="78.子集"></p>
<p>这题把上图画出来后，还是比较简单的。只要把所有步数情况添加就可以了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = ArrayList&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line"><span class="keyword">val</span> path = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">subsets</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    backTrack(nums, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(nums: <span class="type">IntArray</span>, startIndex: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    result.add(path.toList()) <span class="comment">// 这棵树所有的步长，都添加</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex until nums.size) &#123;</span><br><span class="line">        path.add(nums[i])</span><br><span class="line">        backTrack(nums, i + <span class="number">1</span>) <span class="comment">// 注意</span></span><br><span class="line">        path.remove(nums[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90.子集 II"></a>90.<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets-ii/description/">子集 II</a></h4><p><img src="https://img-blog.csdnimg.cn/20201124195411977.png" alt="90.子集II"></p>
<p>第一层 第二列取元素2的时候，此时子集就有2了，第三列再取就重复了。</p>
<p>从图中可以看出，同一树层上重复取2 就要过滤掉，同一树枝上就可以重复取2，因为同一树枝上元素的集合才是唯一子集！</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> result = ArrayList&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> path = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">subsetsWithDup</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">        Arrays.sort(nums)</span><br><span class="line">        <span class="keyword">val</span> used = BooleanArray(nums.size)</span><br><span class="line">        backTrack(nums, used, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(nums: <span class="type">IntArray</span>, used: <span class="type">BooleanArray</span>, startIndex: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        result.add(path.toList())</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex until nums.size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            used[i] = <span class="literal">true</span></span><br><span class="line">            path.add(nums[i])</span><br><span class="line">            backTrack(nums,used,i+<span class="number">1</span>)</span><br><span class="line">            path.remove(nums[i])</span><br><span class="line">            used[i] = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>!used[i - 1] 这个条件是判断树层的条件，否则会把树枝给剪掉了。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>本题也可以不使用used数组来去重，因为递归的时候下一个startIndex是i+1而不是0。</p>
<p>随想录这句没理解。</p>
<h4 id="491-递增子序列"><a href="#491-递增子序列" class="headerlink" title="491.递增子序列"></a>491.递增子序列</h4><ol>
<li><p>不能排序,所以子集中used解法不行</p>
</li>
<li><p>树枝中小心判断大小。</p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1EG4y1h78v/">https://www.bilibili.com/video/BV1EG4y1h78v/</a></p>
<p>一开始按照下面子集的解法做的,但是存在问题，子集是经过排序后的，然后nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]这样的条件判断，这题不能排序的，所以情况不一样。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(nums: <span class="type">IntArray</span>, used: <span class="type">BooleanArray</span>, startIndex: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.size &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        result.add(path.toList())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex until nums.size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt; nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        path.add(nums[i])</span><br><span class="line">        used[i] = <span class="literal">true</span></span><br><span class="line">        backTrack(nums,used,i+<span class="number">1</span>)</span><br><span class="line">        path.remove(nums[i])</span><br><span class="line">        used[i] = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://img-blog.csdnimg.cn/20201124200229824.png" alt="491. 递增子序列1"></p>
<p>上图可以看到，树层中是不能重复的，因为签名的 7包含后面7的所有情况。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> result = ArrayList&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> path = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findSubsequences</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">        backTrack(nums, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(nums: <span class="type">IntArray</span>, startIndex: <span class="type">Int</span>, layer: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size &gt; <span class="number">1</span>) &#123;                      <span class="comment">//  至少有两个元素</span></span><br><span class="line">            result.add(path.toList())</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">set</span> = mutableSetOf&lt;<span class="built_in">Int</span>&gt;()             <span class="comment">// 树层中是否包含 相同的元素。</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex until nums.size) &#123;</span><br><span class="line"><span class="comment">//            println(&quot;startIndex $startIndex set $set&quot;)</span></span><br><span class="line">            <span class="keyword">if</span> (layer == <span class="number">0</span>) &#123;</span><br><span class="line">                println(<span class="string">&quot;layer  set <span class="variable">$set</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((path.isNotEmpty() &amp;&amp; nums[i] &lt; path.last()) || <span class="keyword">set</span>.contains(nums[i])) &#123; <span class="comment">// 小于上一个元素，这个分支以下不用走了， set树层中包含相同的与元素。</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">set</span>.add(nums[i])  <span class="comment">//因为是判断树层，而且是每一层都局部会new 一个set，所以这个没有回溯。</span></span><br><span class="line">            path.add(nums[i])</span><br><span class="line">            backTrack(nums, i + <span class="number">1</span>, layer + <span class="number">1</span>)</span><br><span class="line">            path.remove(nums[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(nums: <span class="type">IntArray</span>, startIndex: <span class="type">Int</span>, layer: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.size &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        result.add(path.toList())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> used = IntArray(<span class="number">201</span>) <span class="comment">// -100 &lt;= nums[i] &lt;= 100 ， 包括 0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> startIndex until nums.size) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((path.isNotEmpty() &amp;&amp; nums[i] &lt; path.last()) || used[nums[i] + <span class="number">100</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        used[nums[i] + <span class="number">100</span>] = <span class="number">1</span></span><br><span class="line">        path.add(nums[i])</span><br><span class="line">        backTrack(nums, i + <span class="number">1</span>, layer + <span class="number">1</span>)</span><br><span class="line">        path.remove(nums[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="46全排列"><a href="#46全排列" class="headerlink" title="46全排列"></a>46全排列</h4><p>[1,2,3] 选了2之后， 1，3 就不知道从哪里开始了，子集问题有个startIndex</p>
<h5 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> result = ArrayList&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> path = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">permute</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> size = nums.size</span><br><span class="line">    <span class="keyword">val</span> used = BooleanArray(size)</span><br><span class="line">    backTrack(nums, used)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(nums: <span class="type">IntArray</span>, used: <span class="type">BooleanArray</span>)</span></span> &#123;</span><br><span class="line">    println(path)</span><br><span class="line">  <span class="comment">//if (totalUsed(used)) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (totalUsed(used)) &#123;</span><br><span class="line">        result.add(path.toList())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ((index, value) <span class="keyword">in</span> nums.withIndex()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (used[index]) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        path.add(nums[index])</span><br><span class="line">        used[index] = <span class="literal">true</span></span><br><span class="line">        backTrack(nums, used)</span><br><span class="line">        path.remove(nums[index])</span><br><span class="line">        used[index] = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">totalUsed</span><span class="params">(used: <span class="type">BooleanArray</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> used.contains(<span class="literal">false</span>).not()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>先画图分析 </p>
<p><img src="https://img-blog.csdnimg.cn/20201209174225145.png" alt="46.全排列"></p>
<p>单测中把数据打印出来，能大概理清这种思路，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[]</span><br><span class="line">[1]</span><br><span class="line">[1, 2]</span><br><span class="line">[1, 2, 3]</span><br><span class="line">[1, 3]</span><br><span class="line">[1, 3, 2]</span><br><span class="line">[2]</span><br><span class="line">[2, 1]</span><br><span class="line">[2, 1, 3]</span><br><span class="line">[2, 3]</span><br><span class="line">[2, 3, 1]</span><br><span class="line">[3]</span><br><span class="line">[3, 1]</span><br><span class="line">[3, 1, 2]</span><br><span class="line">[3, 2]</span><br><span class="line">[3, 2, 1]</span><br><span class="line">[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]</span><br></pre></td></tr></table></figure>





<h4 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47.全排列 II"></a>47.全排列 II</h4><p>我的解法有一点点问题[2,2,1,1]这个跑步过去,path.removeAt(path.lastIndex),看了随想录的解法和我没区别，才发现这里的。</p>
<p>思路</p>
<ol>
<li>和组合去重没区别 ,(index &gt; 0 &amp;&amp; nums[index] == nums[index - 1] &amp;&amp; !used[index - 1])重复元素，树层去重</li>
<li>全排列使用过的元素。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> path = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> result = ArrayList&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">permuteUnique</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">        Arrays.sort(nums)</span><br><span class="line"><span class="comment">//        nums.printIntArray()</span></span><br><span class="line">        <span class="keyword">val</span> used = BooleanArray(nums.size)</span><br><span class="line">        backTrack(nums, used)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    private fun backTrack(nums: IntArray, used: BooleanArray) &#123;</span></span><br><span class="line"><span class="comment">//        println(path)</span></span><br><span class="line"><span class="comment">//        if (path.size == nums.size) &#123;</span></span><br><span class="line"><span class="comment">//            result.add(path.toList())</span></span><br><span class="line"><span class="comment">//            return</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        for ((index, value) in nums.withIndex()) &#123;</span></span><br><span class="line"><span class="comment">//            if (used[index] || (index &gt; 0 &amp;&amp; nums[index] == nums[index - 1] &amp;&amp; !used[index - 1])) &#123;</span></span><br><span class="line"><span class="comment">//                continue</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            used[index] = true</span></span><br><span class="line"><span class="comment">//            path.add(value)</span></span><br><span class="line"><span class="comment">//            backTrack(nums, used)</span></span><br><span class="line"><span class="comment">//            used[index] = false</span></span><br><span class="line"><span class="comment">//            path.remove(value)</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(nums: <span class="type">IntArray</span>, used: <span class="type">BooleanArray</span>)</span></span> &#123;</span><br><span class="line">        println(path)</span><br><span class="line">        <span class="keyword">if</span> (path.size == nums.size) &#123;</span><br><span class="line">            result.add(path.toList())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (index <span class="keyword">in</span> nums.indices) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((index &gt; <span class="number">0</span> &amp;&amp; nums[index] == nums[index - <span class="number">1</span>] &amp;&amp; !used[index - <span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (used[index]) &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            used[index] = <span class="literal">true</span></span><br><span class="line">            path.add(nums[index])</span><br><span class="line">            backTrack(nums, used)</span><br><span class="line">            path.removeAt(path.lastIndex) <span class="comment">// 用path.remove(value)是有问题的，会把所有的这个元素删除掉，46没问题是因为没有重复元素，leetcode removeLast() cannot build</span></span><br><span class="line">            used[index] = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="332-重新安排行程"><a href="#332-重新安排行程" class="headerlink" title="332.重新安排行程"></a>332.重新安排行程</h4><p>随想录解法那个数组处理没看明白</p>
<p>这里用到的回溯，就是目的地可能有多个。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reconstruct-itinerary/solutions/654811/java-bu-yong-ou-la-zhi-yong-hui-su-si-lu-4v83/">https://leetcode.cn/problems/reconstruct-itinerary/solutions/654811/java-bu-yong-ou-la-zhi-yong-hui-su-si-lu-4v83/</a></p>
<p>看了他的视频</p>
<ol>
<li>给定的tickets转成 from to 的结构,就可以知道出发点对应的，到达点和到达点的线路数。 // 这个数据处理也是有点麻烦的。</li>
<li>根据多个到达点回溯，找到最合适的路径</li>
<li>如果到达点的是线路是0，那么找下一题跳线路。</li>
<li> 遇到的机场个数path ==航班数量+</li>
</ol>
<p>putIfAbsent</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hbtj_1216/article/details/75093428">https://blog.csdn.net/hbtj_1216/article/details/75093428</a></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> path = ArrayList&lt;String&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findItinerary</span><span class="params">(tickets: <span class="type">List</span>&lt;<span class="type">List</span>&lt;<span class="type">String</span>&gt;&gt;)</span></span>: List&lt;String&gt; &#123;</span><br><span class="line">    <span class="comment">//1. list转成 from to 的结构</span></span><br><span class="line">    <span class="comment">//2. 回溯找到最合适的路径</span></span><br><span class="line">    <span class="comment">//3.  遇到的机场个数path ==航班数量+</span></span><br><span class="line">    <span class="keyword">val</span> hashMap = HashMap&lt;String, TreeMap&lt;String, <span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line">    tickets.stream().forEach &#123; ticket -&gt;</span><br><span class="line">        <span class="keyword">val</span> from = ticket[<span class="number">0</span>] <span class="comment">// 出发地</span></span><br><span class="line">        <span class="keyword">val</span> to = ticket[<span class="number">1</span>]  <span class="comment">//目的地</span></span><br><span class="line"></span><br><span class="line">        hashMap.putIfAbsent(from, TreeMap())</span><br><span class="line">        <span class="keyword">val</span> treeMap = hashMap[from] ?: TreeMap()  <span class="comment">//获取出发地对应的容器TreeMap,如果之前没用过的出发地key,那么新建一个容器TreeMap</span></span><br><span class="line">        treeMap[to] = treeMap.getOrDefault(to, <span class="number">0</span>) + <span class="number">1</span> <span class="comment">// 容器内，目的地的个数++,一开始这里写的有问题。</span></span><br><span class="line">    &#125;</span><br><span class="line">    path.add(<span class="string">&quot;JFK&quot;</span>) <span class="comment">// 所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。</span></span><br><span class="line">    backTrack(hashMap, tickets.size)</span><br><span class="line">    <span class="keyword">return</span> path</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(hashMap: <span class="type">HashMap</span>&lt;<span class="type">String</span>, TreeMap&lt;String, <span class="built_in">Int</span>&gt;&gt;, ticketSize: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.size == ticketSize + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.根据path找到出发点,从hashmap根据出发点找到对应的 可能多个到达点</span></span><br><span class="line">    <span class="comment">// 2. 多个可能的目的地进行回溯.</span></span><br><span class="line">    <span class="keyword">val</span> recentTo = path[path.size - <span class="number">1</span>] <span class="comment">//path.last() LeetCode build failed</span></span><br><span class="line">    <span class="keyword">val</span> toDestinations = hashMap[recentTo]</span><br><span class="line">    <span class="keyword">if</span> (toDestinations.isNullOrEmpty()) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> (to <span class="keyword">in</span> toDestinations) &#123;<span class="comment">// forEach也行, for习惯点</span></span><br><span class="line">        <span class="keyword">if</span> (to.value == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        path.add(to.key)</span><br><span class="line">        to.setValue(to.value - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (backTrack(hashMap, ticketSize)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        path.removeAt(path.size - <span class="number">1</span>)</span><br><span class="line">        to.setValue(to.value + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="51-N-皇后"><a href="#51-N-皇后" class="headerlink" title="51.N 皇后"></a>51.N 皇后</h4><img src="https://img-blog.csdnimg.cn/20210130182532303.jpg" alt="51.N皇后" style="zoom:50%;">



<p>这题思路不难，实现还是有难度，主要是皇后冲突代码不好理解，<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1bK4y1n7iq">https://www.bilibili.com/video/BV1bK4y1n7iq</a></p>
<p>大概11分钟，判断 皇后位置的冲突情况。</p>
<ol>
<li>这一题思路就是主要 首先行，然后列摆放皇后问题，然后回溯。</li>
<li>还一个就是将要放下皇后的位置之前，8个方向只用考虑3个,确定左上，正上方，右上方的皇后是否存在。当前行不用考了，因为每行一个，后面的更不看了，因为还没放皇后.</li>
<li>最后就是要注意边界的问题，二刷的时候尤其注意这个。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="comment">//1. 初始化棋盘放上.</span></span><br><span class="line">    <span class="keyword">char</span>[][] chessBoard = <span class="keyword">new</span> <span class="keyword">char</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span>[] c : chessBoard) &#123;</span><br><span class="line">        Arrays.fill(c, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 开始放Queue,首先从行开始，一行一行回溯的放， 然后每一行开始从第1列开始。</span></span><br><span class="line">    <span class="comment">// 3. 每次新的一行开始放Queue时，要考虑当前位置列的 前面的列有没有Queue,</span></span><br><span class="line">    <span class="comment">// 当前位置的左边45度和135度有没有Queue,对于当前行和后面的行和斜对角不用考虑，因为每一行只有一个Queue,后面的行更是没有。</span></span><br><span class="line">    <span class="comment">//4 。只有能放下，才会放后续的，然后进行回溯.</span></span><br><span class="line">    <span class="comment">//5. 当放下的Queue时最后一行n时，递归结束，开始收集结果。</span></span><br><span class="line">    backTrack(n, <span class="number">0</span>, chessBoard);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> row, <span class="keyword">char</span>[][] chessBoard)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == row) &#123;</span><br><span class="line">        result.add(Array2List(chessBoard));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; n; ++column) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isValid(row, column, chessBoard, n)) &#123; <span class="comment">// row,column待放入Queue的位置</span></span><br><span class="line">            chessBoard[row][column] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            backTrack(n, row + <span class="number">1</span>, chessBoard);</span><br><span class="line">            chessBoard[row][column] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> pRow, <span class="keyword">int</span> pColumn, <span class="keyword">char</span>[][] chessBoard, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pRow; ++i) &#123; <span class="comment">//列</span></span><br><span class="line">        <span class="keyword">if</span> (chessBoard[i][pColumn] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = pRow - <span class="number">1</span>, y = pColumn - <span class="number">1</span>; x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span>; x--, y--) &#123; <span class="comment">//左上角 首次==边界错了</span></span><br><span class="line">        <span class="keyword">if</span> (chessBoard[x][y] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = pRow - <span class="number">1</span>, y = pColumn + <span class="number">1</span>; x &gt;= <span class="number">0</span> &amp;&amp; y &lt;= n - <span class="number">1</span>; x--, y++) &#123;<span class="comment">//右上角  首次==,n-1边界错了 ,y &lt; n - 1一开始写成这样，找了半天</span></span><br><span class="line">        <span class="keyword">if</span> (chessBoard[x][y] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List <span class="title">Array2List</span><span class="params">(<span class="keyword">char</span>[][] chessboard)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span>[] c : chessboard) &#123;</span><br><span class="line">        list.add(String.copyValueOf(c));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这题for里面有x,y两个变量，kotlin不好弄，就用java了。</p>
<h4 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37.解数独"></a>37.解数独</h4><p>随想录讲解.</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1TW4y1471V/">https://www.bilibili.com/video/BV1TW4y1471V/</a></p>
<p><img src="/2022/10/30/LC-backtrack-combination/20230102104449.jpg" alt="20230102104449"></p>
<p><a target="_blank" rel="noopener" href="https://xiaochen1024.com/video?id=6285f1b6ede03c002e46b218">https://xiaochen1024.com/video?id=6285f1b6ede03c002e46b218</a></p>
<p>根据下面公式可以找到 3 *3的开始位置。</p>
<pre><code>val startRow = (row / 3) * 3    
val startColumn = (column / 3) * 3
</code></pre>
<p>把红方框代入进去， val 3 = (4 / 3) * 3    就是红色箭头的位置。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.先行 后列的顺序，找到字符位 &#x27;.&#x27;的空格，填入 1 - 9 的数字</span></span><br><span class="line"><span class="comment">// 2.填入后，开始回溯</span></span><br><span class="line"><span class="comment">// 3.填入空格的时候，如果没有返回true,if就返回false</span></span><br><span class="line"><span class="comment">// 4. 如果全部填满了都没返回true,此时说明已经到了叶子节点，直接返回true.</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">solveSudoku</span><span class="params">(board: <span class="type">Array</span>&lt;<span class="type">CharArray</span>&gt;)</span></span>: <span class="built_in">Unit</span> &#123;</span><br><span class="line">    backTrack(board)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(board: <span class="type">Array</span>&lt;<span class="type">CharArray</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> board.indices) &#123;   <span class="comment">// 遍历行</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> board[<span class="number">0</span>].indices) &#123;<span class="comment">// 遍历列</span></span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (k <span class="keyword">in</span> <span class="string">&#x27;1&#x27;</span>..<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isValid(i, j, k, board)) &#123;</span><br><span class="line">                        board[i][j] = k</span><br><span class="line">                        <span class="keyword">if</span> (backTrack(board)) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        board[i][j] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">//放上面一层，循环后直接返回false了,// 9个数都试完了，都不行，那么就返回false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isValid</span><span class="params">(row: <span class="type">Int</span>, column: <span class="type">Int</span>, k: <span class="type">Char</span>, board: <span class="type">Array</span>&lt;<span class="type">CharArray</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> board[<span class="number">0</span>].indices) &#123; <span class="comment">// 判断行里是否重复,一开始不理解很多解法包括，随想录用的是9,这样如果不是9*9就有问题了,原来题目给的就是9*9的方格</span></span><br><span class="line">        <span class="keyword">if</span> (board[row][i] == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> board.indices) &#123;  <span class="comment">// 判断列里是否重复</span></span><br><span class="line">        <span class="keyword">if</span> (board[i][column] == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> startRow = (row / <span class="number">3</span>) * <span class="number">3</span>    </span><br><span class="line">    <span class="keyword">val</span> startColumn = (column / <span class="number">3</span>) * <span class="number">3</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> startRow until (startRow + <span class="number">3</span>)) &#123;  <span class="comment">// 判断9方格里是否重复</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> startColumn until startColumn + <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == k) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
        
          <blockquote id="copyright">
              <p>Original link: <a href="https://noteforme.github.io/page/6/index.html">https://noteforme.github.io/page/6/index.html</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LEETCODE/" rel="tag">LEETCODE</a></li></ul>

          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-AppLink" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/10/17/AppLink/">AppLink</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2022-10-17T08:49:19.000Z" itemprop="datePublished">2022年10月17日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/ANDROID/">ANDROID</a>
  </div>

      
      
<a href="/2022/10/17/AppLink/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7031143982960902157">https://juejin.cn/post/7031143982960902157</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.android.com/studio/write/app-link-indexing">https://developer.android.com/studio/write/app-link-indexing</a></p>
<h3 id="唤醒App的几种方式"><a href="#唤醒App的几种方式" class="headerlink" title="唤醒App的几种方式"></a>唤醒App的几种方式</h3><h3 id="Deep-Link"><a href="#Deep-Link" class="headerlink" title="Deep Link"></a>Deep Link</h3><p><a target="_blank" rel="noopener" href="https://developer.android.com/training/app-links/deep-linking">https://developer.android.com/training/app-links/deep-linking</a></p>
<p>URL Scheme</p>
<p><strong>链接格式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[scheme]:&#x2F;&#x2F;[host][:port]&#x2F;[path]?[query]</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>属性名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>scheme</td>
<td>协议名（由开发人员定义）</td>
</tr>
<tr>
<td>host</td>
<td>网络域名</td>
</tr>
<tr>
<td>port</td>
<td>端口号</td>
</tr>
<tr>
<td>path</td>
<td>页面路径</td>
</tr>
<tr>
<td>query</td>
<td>请求参数</td>
</tr>
</tbody></table>
<h5 id="scheme-only"><a href="#scheme-only" class="headerlink" title="scheme only"></a>scheme only</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- for deep-link --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 必须加否否无法响应点击链接的 Intent--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.VIEW&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.BROWSABLE&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">&quot;ewallet&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在浏览器输入 ewallet:// 就能直接打开app</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ewallet:&#x2F;&#x2F;</span><br></pre></td></tr></table></figure>



<h5 id="scheme-host"><a href="#scheme-host" class="headerlink" title="scheme host"></a>scheme host</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;intent-filter&gt;</span><br><span class="line">    &lt;!-- 必须加否否无法响应点击链接的 Intent--&gt;</span><br><span class="line">    &lt;action android:name&#x3D;&quot;android.intent.action.VIEW&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;category android:name&#x3D;&quot;android.intent.category.DEFAULT&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;category android:name&#x3D;&quot;android.intent.category.BROWSABLE&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;data</span><br><span class="line">        android:host&#x3D;&quot;topic&quot;</span><br><span class="line">        android:scheme&#x3D;&quot;com.great.jon&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;intent-filter&gt;</span><br></pre></td></tr></table></figure>

<p>在浏览器输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.great.jon:&#x2F;&#x2F;topic</span><br><span class="line">com.great.jon:&#x2F;&#x2F;topic?id &#x3D;11</span><br></pre></td></tr></table></figure>

<p>id=11 这个可以不写</p>
<h5 id="ADB-TEST"><a href="#ADB-TEST" class="headerlink" title="ADB TEST"></a>ADB TEST</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -a android.intent.action.VIEW -d &quot;replace your link here&quot;</span><br></pre></td></tr></table></figure>





<h5 id="Android系统级-Schemes"><a href="#Android系统级-Schemes" class="headerlink" title="Android系统级 Schemes"></a>Android系统级 Schemes</h5><p>有一些已经定义了URL Schemes，比如短信是 sms:、通话是tel:、email是mailto:，在定义自己APP的URL Schemes的时候要避免跟系统应用名称一样</p>
<h5 id="各大平台"><a href="#各大平台" class="headerlink" title="各大平台"></a><strong>各大平台</strong></h5><p>简单查找了一下各大平台的 scheme，感兴趣的可以直接从手机浏览器中打开尝试一下。</p>
<blockquote>
<p>QQ：<code>qq://</code><br>微信：<code>weixin://</code><br>淘宝：<code>taobao://</code><br>微博：<code>sinaweibo://</code><br>百瓶：<code>billionbottle://</code></p>
</blockquote>
<p><strong>页面调用方式</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.location.href = schemeUrl;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>直接跳转链接即可，简单方便。</p>
<h5 id="负面情况"><a href="#负面情况" class="headerlink" title="负面情况"></a>负面情况</h5><ul>
<li>目前没有办法区分多个 App 都注册了相同 scheme 的情况；</li>
<li>不支持从其他 App 中的 WebView 直接跳转到目标 App；</li>
<li>Android 端微信，无法直接通过 scheme 唤起 App，可以通过引导或微信开放标签来解决；</li>
<li>只能通过 <code>hidden</code>、<code>blur</code> 等事件监听到是否安装 App；</li>
</ul>
<p>因此为了解决以上问题，iOS 和 Android 都有了自己的第二套解决方案，分别是 iOS 的 <strong>Universal Links</strong>，和 Android 的 <strong>App Links</strong>。</p>
<h3 id="App-Links"><a href="#App-Links" class="headerlink" title="App Links"></a>App Links</h3><p>在 2015 年的 Google I/O 大会上，Android M 宣布了一个新特性：<strong>App Links</strong>。它可以让用户在点击一个普通 Web 链接的时候可以打开指定 App 的对应页面，前提是这个 App 已经安装并且经过了验证，否则会显示一个打开确认选项的对话框，目前只支持 Android M 以上系统。</p>
<p><strong>App Links</strong> 的出现其实也是为了优化用户体验，在使用它唤醒 App 时会弹出一个对话框提示用户是否打开，缺点就是如果用户勾选了取消之后，可能之后就再也唤醒不了了。</p>
<p><strong>工作方式及流程</strong></p>
<ol>
<li><p>配置 AndroidManifest.xml；</p>
</li>
<li><p>配置 json 文件；</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">  <span class="attr">&quot;relation&quot;</span>: [<span class="string">&quot;delegate_permission/common.handle_all_urls&quot;</span>],</span><br><span class="line">  <span class="attr">&quot;target&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;namespace&quot;</span>: <span class="string">&quot;android_app&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;package_name&quot;</span>: <span class="string">&quot;包名&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;sha256_cert_fingerprints&quot;</span>: [<span class="string">&quot;签名&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></li>
<li><p>将 json 文件上传到指定域名的 .well-known 路径下，文件名定义为  assetlinks.json；</p>
</li>
<li><p>验证 <strong>App Links</strong>，可使用 AndroidStudio 里的 <strong>App Links Assistant</strong> 中的 <strong>Test App Links</strong> 进行测试或者在短信中输入链接点击测试，如果直接唤起 App 没有弹出对话框选择则说明 <strong>App Links</strong> 验证成功；</p>
</li>
</ol>
<p>总的来说与 <strong>Universal Links</strong> 的配置和验证很相似，差异不大。</p>
<p><a target="_blank" rel="noopener" href="https://developer.android.com/studio/write/app-link-indexing">https://developer.android.com/studio/write/app-link-indexing</a></p>
<p><a target="_blank" rel="noopener" href="http://www.androidchina.net/10135.html">http://www.androidchina.net/10135.html</a></p>
<h3 id="第三方服务"><a href="#第三方服务" class="headerlink" title="第三方服务"></a>第三方服务</h3><h5 id="微信相关的友情提示"><a href="#微信相关的友情提示" class="headerlink" title="微信相关的友情提示"></a>微信相关的友情提示</h5><p>微信已经成为大家日常必不可少的交流工具，用作推广 App 来说是再好不过的，但是微信内部通常是无法直接跳转至其他 App 的。那除了以上列出的技术方案，我们还可以如何去实现这个技术需求呢？</p>
<h5 id="应用宝"><a href="#应用宝" class="headerlink" title="应用宝"></a>应用宝</h5><p>如果你的页面需要能直接打开应用商店，可以把你的 App 上传到应用宝平台，因为应用宝和 AppStore 有合作，并且在内部实现了属于自己的一套流程，直接在微信中跳转应用宝的链接也是一个可选的方案。</p>
<h5 id="微信开放标签"><a href="#微信开放标签" class="headerlink" title="微信开放标签"></a>微信开放标签</h5><p>微信在 2020 年 5 月推出了微信开放标签功能，用于在微信浏览器内直接唤醒 App，也能通过携带参数直接进入 App 相应的页面，只要按照文档规定接入微信 SDK 就可直接使用该功能。</p>
<p>具体要求可以参考官方开放平台：<a href="https://link.juejin.cn/?target=https://developers.weixin.qq.com/doc/oplatform/Mobile_App/WeChat_H5_Launch_APP.html">微信官方文档</a>（ <a href="https://link.juejin.cn/?target=https://developers.weixin.qq.com/doc/oplatform/Mobile_App/WeChat_H5_Launch_APP.html">developers.weixin.qq.com/doc/oplatfo…</a> ）。</p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1652487">https://cloud.tencent.com/developer/article/1652487</a></p>
<p>deeplin VS AppLink</p>
<ul>
<li>Deep Links 是一种允许用户进入应用某个特定Activity的intent filter。点击这类链接时，系统可能会弹出一个选择列表，让用户在一堆能够处理这类链接的应用里(包括你的)选择一个来处理该链接。图一展示了这样一种情况：用户点击了一个地图相关的链接，系统弹出一个选择列表，让用户选择是要使用地图应用来处理，还是使用Chrome浏览器来处理。</li>
<li>App Links 是一种基于你的网站地址且验证通过的Deep Links。因此，点击一个这样的链接会直接打开你的应用(如果已经安装)，系统将不会弹出选择列表。当然，后续用户可以更改配好设置，来指定由哪个应用程序处理这类链接。</li>
</ul>
<table>
<thead>
<tr>
<th>item</th>
<th>Deep Links</th>
<th>App Links</th>
</tr>
</thead>
<tbody><tr>
<td>Intent URL Scheme</td>
<td>https, http，或者自定义</td>
<td>需为http或https</td>
</tr>
<tr>
<td>Intent Action</td>
<td>任意Action</td>
<td>需为<code>android.intent.action.VIEW</code></td>
</tr>
<tr>
<td>Intent Category</td>
<td>任意Category</td>
<td>需为<code>android.intent.category.BROWSABLE</code>和<code>android.intent.category.DEFAULT</code></td>
</tr>
<tr>
<td>链接验证</td>
<td>不需要</td>
<td>需要在网站上放置一个数字资产链接，并能够通过HTTPS访问</td>
</tr>
<tr>
<td>用户体验</td>
<td>可能会弹出一个选择列表给用户选择用哪个应用处理连接</td>
<td>没有弹框，系统直接打开你的应用处理网站连接</td>
</tr>
<tr>
<td>兼容性</td>
<td>所有Android版本</td>
<td>Android 6.0及以上</td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903954149539848">https://juejin.cn/post/6844903954149539848</a></p>
<p>由于大部分应用，如微博、微信、第三方浏览器(包括Chrome)，都不会将URL抛给系统处理(对scheme进行屏蔽)，因此App Links生效的情况就很有限了，比如只能从记事本应用、短信应用这些进行跳转。一般商用实现的是打开系统浏览器，通过系统浏览器打开应用的对应页面。</p>
<p>作者：JinBeen<br>链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903954149539848">https://juejin.cn/post/6844903954149539848</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>

        
        
          <blockquote id="copyright">
              <p>Original link: <a href="https://noteforme.github.io/page/6/index.html">https://noteforme.github.io/page/6/index.html</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-LC-Tree-Search-22" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/10/05/LC-Tree-Search-22/">LC-Tree-Search-22</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2022-10-05T14:00:07.000Z" itemprop="datePublished">2022年10月05日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/DataStructure/">DataStructure</a>
  </div>

      
      
<a href="/2022/10/05/LC-Tree-Search-22/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="二叉树搜索-BST"><a href="#二叉树搜索-BST" class="headerlink" title="二叉树搜索 BST"></a>二叉树搜索 BST</h3><p><strong>根节点比左子树所有节点的数值都大，比右子树所有节点的数值都小.</strong> </p>
<h4 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700. 二叉搜索树中的搜索"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></h4><p>My idea</p>
<h5 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h5><ol>
<li><p>先序遍历搜索，如果找到了直接返回当前节点。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">searchBST</span><span class="params">(root: <span class="type">TreeNode</span>?, `<span class="keyword">val</span>`: <span class="type">Int</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (root.`<span class="keyword">val</span>` == `<span class="keyword">val</span>`) &#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> nodeLeft = searchBST(root.left, `<span class="keyword">val</span>`)</span><br><span class="line">    <span class="keyword">if</span> (nodeLeft != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nodeLeft</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> nodeRight = searchBST(root.right, `<span class="keyword">val</span>`)</span><br><span class="line">    <span class="keyword">if</span> (nodeRight != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nodeRight</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>看了官方解法,利用二叉搜索树的特性 </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">searchBST1</span><span class="params">(root: <span class="type">TreeNode</span>?, `<span class="keyword">val</span>`: <span class="type">Int</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> node: TreeNode? = root.left</span><br><span class="line">    <span class="keyword">if</span> (root.`<span class="keyword">val</span>` == `<span class="keyword">val</span>`) &#123; <span class="comment">//一开始没有做出来，这个条件没写,导致一直往下递归</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.`<span class="keyword">val</span>` &lt; `<span class="keyword">val</span>`) &#123;</span><br><span class="line">        node = root.right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> searchBST1(node, `<span class="keyword">val</span>`)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h5><p>二叉搜索树的迭代法相对简单，暂时先不看了</p>
<h4 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h4><p>二叉搜索树是一个有序树：</p>
<ul>
<li>若它的左子树不空，则左子树上<strong>所有结点</strong>的值均小于它的根结点的值；  注意==都不行</li>
<li>若它的右子树不空，则右子树上<strong>所有结点</strong>的值均大于它的根结点的值；</li>
<li>它的左、右子树也分别为二叉搜索树</li>
</ul>
<p>这就决定了，二叉搜索树，递归遍历和迭代遍历和普通二叉树都不一样。</p>
<p>一开始理解错了，只比较根节点和左右子树，导致下面这个testcase没通过，应该是根节点和所有的左右子树的节点数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5, 4, 6, null, null, 3, 7</span><br></pre></td></tr></table></figure>



<h5 id="转数组"><a href="#转数组" class="headerlink" title="转数组"></a>转数组</h5><p>把中序遍历转成数组很好理解</p>
<ol>
<li><p> 中序遍历递归 得到list数组</p>
</li>
<li><p>比较数组的前后节点大大小,</p>
</li>
<li><p>如果前面节点值更大，那么直接返回false, ==也不行</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isValidBST3</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    dfsTraversal(root) <span class="comment">// 中序遍历递归 得到list数组</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until list.size - <span class="number">1</span>) &#123; <span class="comment">// 比较数组的前后节点大大小</span></span><br><span class="line">        <span class="keyword">if</span> (list[i] &gt;= list[i + <span class="number">1</span>]) &#123; <span class="comment">// 如果前面节点值更大，那么直接返回false, ==也不行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dfsTraversal</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">    dfsTraversal(root.left)</span><br><span class="line">    list.add(root.`<span class="keyword">val</span>`)</span><br><span class="line">    dfsTraversal(root.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h5><p>随想录的递归解法，一开始怎么也理解不了，其实和上面 中序转数组的类似，就是把根据中序遍历遍历的节点，后一个节点一定比前一个节点的数值高。</p>
<ol>
<li>中序遍历 后一个节点比前一个节点的值大，就可以了，所以存储前一个节点。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> preNode: TreeNode? = <span class="literal">null</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isValidBST4</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (!isValidBST4(root.left)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (preNode != <span class="literal">null</span> &amp;&amp; preNode!!.`<span class="keyword">val</span>` &gt;= root.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    preNode = root</span><br><span class="line">    <span class="keyword">if</span> (!isValidBST4(root.right)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>之前的题主要用到 后序和先序，二叉搜索这里开始用到了 中序遍历。</p>
<h4 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530. 二叉搜索树的最小绝对差"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差</a></h4><p>My idea </p>
<p>这一题和上一题 98 思路差不多，</p>
<p>中序遍历的节点之间的数组相差最小，所以找出节点间的间隔最小值就可以了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> preNode: TreeNode? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">var</span> miniNum = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getMinimumDifference</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line">    getMinimumDifference(root.left)</span><br><span class="line">    <span class="keyword">if</span> (preNode != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> gapNum = root.`<span class="keyword">val</span>` - preNode!!.`<span class="keyword">val</span>`<span class="comment">//这一步可以简化 Math.min()</span></span><br><span class="line">        <span class="keyword">if</span> (gapNum &lt; miniNum) &#123;</span><br><span class="line">            miniNum = gapNum</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    preNode = root</span><br><span class="line">    getMinimumDifference(root.right)</span><br><span class="line">    <span class="keyword">return</span> miniNum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>也可以先中序遍历转成数组，然后求数组元素间的差值就可以了。</p>
<h4 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501. 二叉搜索树中的众数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数</a></h4><p>My idea</p>
<p>我的想法和上面的类似。</p>
<ol>
<li>中序遍历相邻节点用map存下value和值的个数。</li>
<li>遍历map求得最大个事的数组。把map按照value个数进行数组排序</li>
<li> 然后取排序后的前面的元素</li>
</ol>
<p>。了。/其实上面这种方式，用先序 后序都可以，都不需要二叉搜索树。</p>
<p>其实上面我的想法也是 打算用二叉搜索树的特性，放到map中，然后把map排序,就不知道怎么处理更好。看了随想录的处理方式,理了下思路.</p>
<ol>
<li>根据中序遍历的前后节点，他们的值相同的是一起的，进行遍历。</li>
<li>对value值进行count计数，如果count == 最大个数，加入集合。</li>
<li>如果count&gt;最大个数，清空集合.</li>
</ol>
<p>一开始不知道放哪里, maxCount=count ，以为在前面if (preNode != null &amp;&amp; preNode!!.<code>val</code> == node.<code>val</code>) 前面的比较里面,还想着Math.max,但是都不合适。然后看了一半随想录是放在更新节点的位置，更好.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> array = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findMode</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: IntArray &#123;</span><br><span class="line">    inDFS(root)</span><br><span class="line">    <span class="keyword">return</span> array.toIntArray()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> preNode: TreeNode? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">var</span> maxCount = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">inDFS</span><span class="params">(node: <span class="type">TreeNode</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> printNode = node?.`<span class="keyword">val</span>`</span><br><span class="line">    println(<span class="string">&quot;printNode <span class="variable">$printNode</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    inDFS(node.left)</span><br><span class="line">    <span class="keyword">if</span> (preNode != <span class="literal">null</span> &amp;&amp; preNode!!.`<span class="keyword">val</span>` == node.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        count++</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count == maxCount) &#123;</span><br><span class="line">        array.add(node.`<span class="keyword">val</span>`)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; maxCount) &#123;</span><br><span class="line">        maxCount = count<span class="comment">//这一步一开始不知道放哪里,看了一眼随想录答案</span></span><br><span class="line">        array.clear() <span class="comment">// 有更大的值，清空之前的集合</span></span><br><span class="line">        array.add(node.`<span class="keyword">val</span>`)</span><br><span class="line">    &#125;</span><br><span class="line">    preNode = node</span><br><span class="line">    inDFS(node.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>官方还有 o(1)的处理，while循环</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/solution/er-cha-sou-suo-shu-zhong-de-zhong-shu-by-leetcode-/">https://leetcode.cn/problems/find-mode-in-binary-search-tree/solution/er-cha-sou-suo-shu-zhong-de-zhong-shu-by-leetcode-/</a></p>
<h4 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h4><p>这一题有两种想法</p>
<ol>
<li>之前做的环形链表 走对方的路</li>
<li>先序遍历每一个节点，只要下面的节点都走过，只要下一个节点没有走到，就返回上一个节点，但是先序遍历DFS 两个节点都走了不知道怎么返回。</li>
</ol>
<p>看了随想录视频思路后 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1jd4y1B7E2">https://www.bilibili.com/video/BV1jd4y1B7E2</a></p>
<ol>
<li>后序遍历如果碰到p或q,就返回他们的节点.</li>
<li>如果一个节点的左右子树都不为空说明当前节点是他们的最近公共祖先.</li>
<li>还一种情况，有一个节点p就是祖先节点</li>
</ol>
<p>debug调试，拼凑把代码写出来了</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">lowestCommonAncestor</span><span class="params">(root: <span class="type">TreeNode</span>?, p: <span class="type">TreeNode</span>?, q: <span class="type">TreeNode</span>?)</span></span>: TreeNode? &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">// 随想录这里改成 碰到节点判断，直接在这里返回</span></span><br><span class="line"><span class="comment">//        val printData = root.`val`</span></span><br><span class="line"><span class="comment">//        println(printData)</span></span><br><span class="line">        <span class="keyword">val</span> leftNode = lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        <span class="keyword">val</span> rightNode = lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> (leftNode != <span class="literal">null</span> &amp;&amp; rightNode != <span class="literal">null</span>) &#123; <span class="comment">// 如果左右子树都不为空，那么当前节点就是最近公共祖先节点</span></span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; root.`<span class="keyword">val</span>` == p.`<span class="keyword">val</span>`) &#123;   <span class="comment">//碰到了其中一个节点返回</span></span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (q != <span class="literal">null</span> &amp;&amp; root.`<span class="keyword">val</span>` == q.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">            <span class="keyword">return</span> root                             <span class="comment">//碰到了其中一个节点返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftNode != <span class="literal">null</span>) <span class="keyword">return</span> leftNode       <span class="comment">//回溯之前碰到的节点</span></span><br><span class="line">        <span class="keyword">if</span> (rightNode != <span class="literal">null</span>) <span class="keyword">return</span> rightNode</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h5 id="终止条件写法"><a href="#终止条件写法" class="headerlink" title="终止条件写法"></a>终止条件写法</h5><p> 随想录这里改成 碰到节点判断，直接在这里返回，下次可以改成在终止条件这里，更简单</p>
<h4 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></h4><p>My idea</p>
<p>可以根据二叉搜索树的特性， 祖先节点的值大小有两种情况</p>
<ol>
<li>在p和q之前,</li>
<li>如果p&lt;q, 祖先节点的值 等于p , 大于q</li>
<li>只要满足上述条件，用先序遍历或者后序遍历都可以，把节点返回</li>
</ol>
<p>官方和随想录解法都是给出了相反的条件 ，当前节点&lt;p , &gt;q,在外面的情况（其实这里没想清楚,不存在这样的&lt;2 &gt;4的节点）, 但是我这里ide testcase也没问题。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/solution/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-26/">https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/solution/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-26/</a></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 很奇怪，IDE可以跑这个testcase没问题</span></span><br><span class="line"><span class="comment"> *[2,1]</span></span><br><span class="line"><span class="comment"> * 2</span></span><br><span class="line"><span class="comment"> * 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lowestCommonAncestor</span><span class="params">(root: <span class="type">TreeNode</span>?, p: <span class="type">TreeNode</span>?, q: <span class="type">TreeNode</span>?)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (p!!.`<span class="keyword">val</span>` &gt; q!!.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        swap(p, q)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.`<span class="keyword">val</span>` &gt; p.`<span class="keyword">val</span>` &amp;&amp; root.`<span class="keyword">val</span>` &lt; q.`<span class="keyword">val</span>`) &#123; </span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.`<span class="keyword">val</span>` == p.`<span class="keyword">val</span>` &amp;&amp; root.`<span class="keyword">val</span>` &lt; q.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.`<span class="keyword">val</span>` == q.`<span class="keyword">val</span>` &amp;&amp; root.`<span class="keyword">val</span>` &gt; p.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> leftNode = lowestCommonAncestor(root.left, p, q)</span><br><span class="line">    <span class="keyword">if</span> (leftNode != <span class="literal">null</span>) <span class="keyword">return</span> leftNode</span><br><span class="line">    <span class="keyword">val</span> rightNode = lowestCommonAncestor(root.right, p, q)</span><br><span class="line">    <span class="keyword">if</span> (rightNode != <span class="literal">null</span>) <span class="keyword">return</span> rightNode</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">swap</span><span class="params">(p: <span class="type">TreeNode</span>, q: <span class="type">TreeNode</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> temp = p.`<span class="keyword">val</span>`</span><br><span class="line">    p.`<span class="keyword">val</span>` = q!!.`<span class="keyword">val</span>`</span><br><span class="line">    q.`<span class="keyword">val</span>` = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0235.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html">https://programmercarl.com/0235.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Zt4y1F7ww">https://www.bilibili.com/video/BV1Zt4y1F7ww</a></p>
<p>看了随想录视频，其实相反的就两种情况</p>
<ol>
<li>当前节点 &lt;p , &lt;q， 那么p,q一定在右子树上，就去右子树去找</li>
<li>当前节点 &gt; p , &gt;q ,那么p,q一定在左子树上，就去左子树去找</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lowestCommonAncestor</span><span class="params">(root: <span class="type">TreeNode</span>?, p: <span class="type">TreeNode</span>?, q: <span class="type">TreeNode</span>?)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (root.`<span class="keyword">val</span>` &lt; p!!.`<span class="keyword">val</span>` &amp;&amp; root.`<span class="keyword">val</span>` &lt; q!!.`<span class="keyword">val</span>`) &#123; <span class="comment">// 当前节点比p和q的值都小，那么一定p,q一定在右子树上，就往右边遍历</span></span><br><span class="line">        <span class="keyword">val</span> rightNode = lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> (rightNode != <span class="literal">null</span>) <span class="keyword">return</span> rightNode</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root.`<span class="keyword">val</span>` &gt; p.`<span class="keyword">val</span>` &amp;&amp; root.`<span class="keyword">val</span>` &gt; q!!.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        <span class="keyword">val</span> leftNode = lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        <span class="keyword">if</span> (leftNode != <span class="literal">null</span>) <span class="keyword">return</span> leftNode</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a></h4><h5 id="DFS-1"><a href="#DFS-1" class="headerlink" title="DFS"></a>DFS</h5><p>My idea</p>
<p>可以用后序遍历，按照二叉树的特性，走到叶子节点后，连接到叶子节点，然后回溯到根节点并返回</p>
<ol>
<li>后序遍历根据待插入值和当前节点比较，找到需要插入的位置。</li>
<li>如果需要插入的位置左或右节点刚好为空，就插入。</li>
</ol>
<p>随想录其中一个解法和我的这个类似，不过感觉比我这个更复杂点</p>
<p>自己的做的解法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">insertIntoBST</span><span class="params">(root: <span class="type">TreeNode</span>?, `<span class="keyword">val</span>`: <span class="type">Int</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> TreeNode(`<span class="keyword">val</span>`) <span class="comment">//有一个这个test case  [] 5 ,空树的话返回 [5]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (`<span class="keyword">val</span>` &lt; root.`<span class="keyword">val</span>`) &#123; <span class="comment">// 插入点小于当前节点，往左子树中插入</span></span><br><span class="line">        insertIntoBST(root.left, `<span class="keyword">val</span>`)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (`<span class="keyword">val</span>` &gt; root.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        insertIntoBST(root.right, `<span class="keyword">val</span>`)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一开始这个放前面导致添加了两个5的左节点，因为 insertIntoBST(root.left, `val`)又走了一次</span></span><br><span class="line">    <span class="keyword">val</span> treeNode = TreeNode(`<span class="keyword">val</span>`) <span class="comment">// 只有一次机会走这个</span></span><br><span class="line">    <span class="keyword">if</span> (root.right == <span class="literal">null</span> &amp;&amp; `<span class="keyword">val</span>` &gt; root.`<span class="keyword">val</span>`) &#123; <span class="comment">//  待插入点大于当前节点，所以要插入右子树中，此时右子树为空，那么直接插入</span></span><br><span class="line">        root.right = treeNode</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; `<span class="keyword">val</span>` &lt; root.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        root.left = treeNode</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>看了随想录的解法，其实还可以每一个都被父节点接住更简单,也是后序遍历的精髓 </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">insertIntoBST</span><span class="params">(root: <span class="type">TreeNode</span>?, `<span class="keyword">val</span>`: <span class="type">Int</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> TreeNode(`<span class="keyword">val</span>`)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (`<span class="keyword">val</span>` &lt; root.`<span class="keyword">val</span>`) &#123; <span class="comment">// 插入点小于当前节点，往左子树中插入</span></span><br><span class="line">        root.left = insertIntoBST1(root.left, `<span class="keyword">val</span>`)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (`<span class="keyword">val</span>` &gt; root.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        root.right = insertIntoBST1(root.right, `<span class="keyword">val</span>`)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="迭代法-1"><a href="#迭代法-1" class="headerlink" title="迭代法"></a>迭代法</h5><p>官方用迭代法 ,看起来也不难</p>
<p> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/solution/er-cha-sou-suo-shu-zhong-de-cha-ru-cao-zuo-by-le-3/">https://leetcode.cn/problems/insert-into-a-binary-search-tree/solution/er-cha-sou-suo-shu-zhong-de-cha-ru-cao-zuo-by-le-3/</a></p>
<h4 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></h4><p>My idea</p>
<p>和上面思路类似，用后序遍历的 父节点接住，当前要删除节点的左或者右节点，那么当前节点就删除了，然后左右节点再改变指向。</p>
<ol>
<li><p>后序遍历到要删除的节点.</p>
</li>
<li><p>当前节点的右节点指向它的左节点。被上一个节点回溯的父节点接住。</p>
</li>
<li><p>返回当前节点的左节点，</p>
</li>
</ol>
<p>[5,3,6,2,4,null,7]<br>5<br>优先还是需要右节点上去，否则就很麻烦，需要4上去</p>
<p>删除节点主要有这5种情况</p>
<ul>
<li>第一种情况：没找到删除的节点，遍历到空节点直接返回了</li>
<li>找到删除的节点<ul>
<li>第二种情况：删除的左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</li>
<li>第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点</li>
<li>第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</li>
<li>第五种情况：删除节点的左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。</li>
</ul>
</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbj3k596mg30dq0aigyz.gif" alt="450.删除二叉搜索树中的节点"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">deleteNode</span><span class="params">(root: <span class="type">TreeNode</span>?, key: <span class="type">Int</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">//情况一</span></span><br><span class="line">    <span class="keyword">if</span> (key &lt; root.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        root.left = deleteNode(root.left, key)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        root.right = deleteNode(root.right, key)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key == root.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.right == <span class="literal">null</span> &amp;&amp; root.left == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">// 情况2  [0] 0 因为这个testcase 会返回[0]和预期不一致</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.left != <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;            <span class="comment">//情况三 如果左节点不为空</span></span><br><span class="line">            <span class="keyword">val</span> node = root.left  <span class="comment">// 左节点 2 推到删除的节点位置</span></span><br><span class="line">            <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;               <span class="comment">//这两句可以去掉 ，直接返回节点</span></span><br><span class="line">                node.right = root.right         <span class="comment">//此时左节点2在在删除节点位置，它的右子树指向之前右节点4</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.right != <span class="literal">null</span> &amp;&amp; root.left == <span class="literal">null</span>) &#123;  <span class="comment">//情况四 如果右节点不为空</span></span><br><span class="line">            <span class="keyword">val</span> node = root.right <span class="comment">//右节点4 推到删除的节点位置</span></span><br><span class="line">            <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;                 <span class="comment">//这两句可以去掉</span></span><br><span class="line">                node.left = root.left           <span class="comment">// 此时左节点4在在删除节点位置，它的左子树指向之前右节点2</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> rightNode = root.right <span class="comment">//情况五</span></span><br><span class="line">            <span class="keyword">var</span> leftNode = rightNode?.left</span><br><span class="line">            <span class="keyword">while</span> (leftNode?.left!= <span class="literal">null</span>) &#123;</span><br><span class="line">                leftNode = leftNode.left</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (leftNode != <span class="literal">null</span>) &#123;</span><br><span class="line">                leftNode.left = root.left</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rightNode.left = root.left</span><br><span class="line">            &#125;</span><br><span class="line">            root.left = <span class="literal">null</span></span><br><span class="line">            <span class="keyword">return</span> rightNode <span class="comment">// 这里返回的节点，可以被上面的左右子树接住</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="普通二叉树的节点删除"><a href="#普通二叉树的节点删除" class="headerlink" title="普通二叉树的节点删除"></a>普通二叉树的节点删除</h5><p>通用二叉树节点删除</p>
<p><img src="/2022/10/05/LC-Tree-Search-22/20221012115615.jpg"></p>
<p>要加if (leftNode != null)，否则删除报错</p>
<p>这个题目的leetcode的测试用例有问题,单独跑报错.</p>
<h4 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h4><p>看了随想录的解答，从中取中间节点的位置就可以了，如果数字是偶数，中间节点的两个中的一个都可以，</p>
<p>但是问题来了，为什么取中间节点构造的二叉树就是高度平衡的二叉搜索树呢?</p>
<p>先按照这个思路，把代码写出来</p>
<ol>
<li>按照先序遍历思路，先找到根节点，构造出中间节点。</li>
<li>根据中间节点划定新的数组的范围，左边和右边，然后递归找到新的数组的中间节点继续划出范围.</li>
</ol>
<p>在这里 左闭右闭更合理</p>
<p>这题主要注意边界值,if (left &gt; right）这个要注意是&gt; 没有=,因为index-1和index+1了，所以最终一定会超过right</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sortedArrayToBST</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">return</span> buildSearchTree(nums, <span class="number">0</span>, nums.size - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">buildSearchTree</span><span class="params">(nums: <span class="type">IntArray</span>, left: <span class="type">Int</span>, right: <span class="type">Int</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> index = <span class="comment">/*(start + end) / 2*/</span> left + (right - left) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">val</span> node = TreeNode(nums[index])</span><br><span class="line">    <span class="comment">// println(&quot;node $&#123;node.`val`&#125; :  start $left end $right&quot;)</span></span><br><span class="line">    node.left = buildSearchTree(nums, left, index - <span class="number">1</span>)</span><br><span class="line">    node.right = buildSearchTree(nums, index + <span class="number">1</span>, right)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538. 把二叉搜索树转换为累加树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></h4><p>累加树: 按照中序遍历的到的 从小到大的数组 [1,2,3,4] ,累加树就是右到左的值相加 [10,9,7,4]</p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0538.%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91.html#%E9%80%92%E5%BD%92">https://programmercarl.com/0538.%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91.html#%E9%80%92%E5%BD%92</a></p>
<p>中序遍历的树 : 左 中 右 2 , 5, 13</p>
<p>反中序遍历的: 右 中 左 13 , 5 , 2</p>
<p>然后按照反中序遍历的到节点累加就可以了。</p>
<img src="https://img-blog.csdnimg.cn/20210204153440666.png" alt="538.把二叉搜索树转换为累加树" style="zoom:50%;">



<p>这一题一开始没想上面的思路，看了随想录的思路后,写出来的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">convertBST</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    convertBST(root.right)</span><br><span class="line">    sum += root.`<span class="keyword">val</span>`</span><br><span class="line">    root.`<span class="keyword">val</span>` = sum</span><br><span class="line">    convertBST(root.left)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>根据中序遍历的规则，写出反中序 右中左遍历节点。</li>
<li>拿到每次中序的到的节点累加，然后赋值给当前节点。</li>
</ol>
<pre><code>sum += root.`val`
root.`val` = sum
</code></pre>
<p>这一段可以改进，可以保存前一个节点值，然后加上当前节点就可以了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pre = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">convertBST1</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    convertBST(root.right)</span><br><span class="line">    root.`<span class="keyword">val</span>` += pre</span><br><span class="line">    pre = root.`<span class="keyword">val</span>`</span><br><span class="line">    convertBST(root.left)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
        
          <blockquote id="copyright">
              <p>Original link: <a href="https://noteforme.github.io/page/6/index.html">https://noteforme.github.io/page/6/index.html</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LEETCODE/" rel="tag">LEETCODE</a></li></ul>

          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-Fragment-StateLoss" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/09/15/Fragment-StateLoss/">Fragment_StateLoss</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2022-09-15T02:25:12.000Z" itemprop="datePublished">2022年09月15日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/ANDROID/">ANDROID</a>
  </div>

      
      
<a href="/2022/09/15/Fragment-StateLoss/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>问题 ，Activity恢复后 mStateSaved,是怎么恢复的？</p>
<p>就是onSavedInstanceState 的官方API文档2</p>
<p>这里问题的场景是Activity已经关闭了,rpc请求很久再回来,导致了这个问题,所以我觉得判断livedate激活状态就可以了</p>
<p>可是这个改动应该只能在resume吧？</p>
<p>LiveData started 和 resumed 都可以</p>
<p>Livedata 会感知activity生命周期</p>
<p>这个有可能 activity 也在 started / resumed 状态下发出吧？ 这样的话，showDialog 应该也还会崩溃，因为onSavedInstanceState 是在 paused 时候发生的，这个时候应该还是 started 状态。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">* 后续考虑做个技改把它加到[BaseDialogFragment]里面</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">showWithLifecycle</span><span class="hljs-params">(fragmentActivity: <span class="hljs-type">FragmentActivity</span>, tag: <span class="hljs-type">String</span>? = <span class="hljs-literal">null</span>)</span></span> &#123;<br><br>  <span class="hljs-keyword">val</span> liveData = showWithLifecycleLiveData ?: MutableLiveData&lt;<span class="hljs-built_in">Boolean</span>&gt;().also &#123;<br><br>    it.observe(fragmentActivity) &#123; <span class="hljs-keyword">this</span>.show(fragmentActivity.supportFragmentManager, tag) &#125;<br><br>    showWithLifecycleLiveData = it<br><br>  &#125;<br><br>  liveData.value = <span class="hljs-literal">true</span><br><br>&#125;<br></code></pre></td></tr></table></figure>







<p>onSaveInstanceState保存分析</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6995791487426363405">https://juejin.cn/post/6995791487426363405</a></p>
<p>状态恢复</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/58579627f70a">https://www.jianshu.com/p/58579627f70a</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7057564670567120903">https://juejin.cn/post/7057564670567120903</a></p>
<p> <strong>can not perform this action after onsaveinstancestate dialogfragment show</strong> </p>
<p>developer  -&gt; 不保留活动 </p>
<p>onSaveInstanceState以下5种情况被调用：</p>
<p>1、当用户按下手机home键的时候。</p>
<p>2、长按手机home键或者按下菜单键时。</p>
<p>3、手机息屏时。</p>
<p>4、FirstActivity启动SecondActivity，FirstActivity就会调用，也就是说打开新Activity时，原Activity就会调用。</p>
<p>5、默认情况下横竖屏切换时。</p>
<p>打开Activity -&gt; Home  -&gt; 再从后台拿出来</p>
<p><img src="/2022/09/15/Fragment-StateLoss//20220919212018.jpg" alt="20220919212018"></p>
<p>既然状态的保存与恢复都必须要把Fragment带上，那么一旦当Fragment的状态已保存过了，那么就不应该再改变Fragment的状态。因此FragmentManager的每一个操作前，都会调用一个方法来检查状态是否保存过了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkStateLoss</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (mStateSaved) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<br>                    <span class="hljs-string">&quot;Can not perform this action after onSaveInstanceState&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (mNoTransactionsBecause != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<br>                    <span class="hljs-string">&quot;Can not perform this action inside of &quot;</span> + mNoTransactionsBecause);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * This is the same as &#123;<span class="hljs-doctag">@link</span> #onSaveInstanceState&#125; but is called for activities</span><br><span class="hljs-comment"> * created with the attribute &#123;<span class="hljs-doctag">@link</span> android.R.attr#persistableMode&#125; set to</span><br><span class="hljs-comment"> * &lt;code&gt;persistAcrossReboots&lt;/code&gt;. The &#123;<span class="hljs-doctag">@link</span> android.os.PersistableBundle&#125; passed</span><br><span class="hljs-comment"> * in will be saved and presented in &#123;<span class="hljs-doctag">@link</span> #onCreate(Bundle, PersistableBundle)&#125;</span><br><span class="hljs-comment"> * the first time that this activity is restarted following the next device reboot.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> outState Bundle in which to place your saved state.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> outPersistentState State which will be saved across reboots.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #onSaveInstanceState(Bundle)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #onCreate</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #onRestoreInstanceState(Bundle, PersistableBundle)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #onPause</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSaveInstanceState</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Bundle outState,</span><br><span class="hljs-params">        <span class="hljs-meta">@NonNull</span> PersistableBundle outPersistentState)</span> &#123;<br>    onSaveInstanceState(outState);<br>&#125;<br></code></pre></td></tr></table></figure>



<p>为什么会有这个异常</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lzf_acraftsman/article/details/108831949">https://blog.csdn.net/lzf_acraftsman/article/details/108831949</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903458605105160">https://juejin.cn/post/6844903458605105160</a></p>
<p>fragment重叠原因</p>
<h4 id="Fragment懒加载"><a href="#Fragment懒加载" class="headerlink" title="Fragment懒加载"></a>Fragment懒加载</h4><p>Fragment和ViewPager一起使用会有个预加载机制，会把旁白的Fragment的生命周期方法<br>前半段先执行，然后执行自身的生命周期方法</p>
<p>在项目终从其他页面回到MainAcitivty的时候，三个页面的生命周期方法都跑了一遍</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs isbl">　  <span class="hljs-variable">D</span>/<span class="hljs-variable">FinanceFragment</span>         <span class="hljs-variable">Test</span>: <span class="hljs-function"><span class="hljs-title">onStart</span>()</span><br><span class="hljs-variable">D</span>/<span class="hljs-variable">WealthFragment</span>         <span class="hljs-variable">Test</span>: <span class="hljs-function"><span class="hljs-title">onStart</span>()</span><br><span class="hljs-variable">D</span>/<span class="hljs-variable">MineFragment</span>         <span class="hljs-variable">Test</span>: <span class="hljs-function"><span class="hljs-title">onStart</span>()</span><br><span class="hljs-variable">D</span>/<span class="hljs-variable">FinanceFragment</span>         <span class="hljs-variable">Test</span>: <span class="hljs-function"><span class="hljs-title">onResume</span>()</span><br><span class="hljs-variable">D</span>/<span class="hljs-variable">WealthFragment</span>         <span class="hljs-variable">Test</span>: <span class="hljs-function"><span class="hljs-title">onResume</span>()</span><br><span class="hljs-variable">D</span>/<span class="hljs-variable">MineFragment</span>         <span class="hljs-variable">Test</span>: <span class="hljs-function"><span class="hljs-title">onResume</span>()</span><br></code></pre></td></tr></table></figure>


<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs typescript">     <br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">boolean</span> isPrepared;  <span class="hljs-comment">//判断view是否加载完成,在视图未初始化的时候，在lazyLoad当中就使用的话，就会有空指针的异常</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">boolean</span> isVisible;  <span class="hljs-comment">//判断当前Fragment是否可见状态,标志已经初始化完成，因为setUserVisibleHint是在onCreateView之前调用的</span><br>	  <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onViewCreated</span>(<span class="hljs-params">View view, <span class="hljs-meta">@Nullable</span> Bundle savedInstanceState</span>) &#123;<br>        <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">onViewCreated</span>(view, savedInstanceState);<br>        isPrepared = <span class="hljs-literal">true</span>;<br>        <span class="hljs-title function_">lazyLoad</span>();<br>    &#125;<br><br><br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">View</span> <span class="hljs-title function_">onCreateView</span>(<span class="hljs-params">LayoutInflater inflater, <span class="hljs-meta">@Nullable</span> ViewGroup container, Bundle savedInstanceState</span>) &#123;<br><span class="hljs-comment">//        Log.d(TAG + &quot;         Test&quot;, &quot; onCreateView()&quot;);</span><br><br>        <span class="hljs-keyword">if</span> (rootView == <span class="hljs-literal">null</span>) &#123;<br>            int view = <span class="hljs-title function_">setLayoutId</span>();<br>            <span class="hljs-keyword">if</span> (view != <span class="hljs-number">0</span>) &#123;<br>                rootView = inflater.<span class="hljs-title function_">inflate</span>(view, container, <span class="hljs-literal">false</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-title class_">ViewGroup</span> parent = (<span class="hljs-title class_">ViewGroup</span>) rootView.<span class="hljs-title function_">getParent</span>();<br>            <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;<br>                parent.<span class="hljs-title function_">removeView</span>(rootView);<br>            &#125;<br>        &#125;<br>        <span class="hljs-title function_">initView</span>(rootView);<br>        <span class="hljs-keyword">return</span> rootView;<br>    &#125;<br><br>    <span class="hljs-comment">//  http://www.10tiao.com/html/565/201702/2247483988/1.html</span><br>    <span class="hljs-comment">// 标志位，标志已经初始化完成，因为setUserVisibleHint是在onCreateView之前调用的，</span><br>    <span class="hljs-comment">// 在视图未初始化的时候，在lazyLoad当中就使用的话，就会有空指针的异常</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">boolean</span> isPrepared;<br>    <span class="hljs-comment">//标志当前页面是否可见</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">boolean</span> isVisible;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setUserVisibleHint</span>(<span class="hljs-params"><span class="hljs-built_in">boolean</span> isVisibleToUser</span>) &#123;<br>        <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">setUserVisibleHint</span>(isVisibleToUser);<br><span class="hljs-comment">//        Log.d(TAG + &quot;         Test&quot;, &quot; setUserVisibleHint() is Visible : ?  &quot; + isVisibleToUser);</span><br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">getUserVisibleHint</span>()) &#123;<br>            isVisible = <span class="hljs-literal">true</span>;<br>            <span class="hljs-title function_">onVisible</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            isVisible = <span class="hljs-literal">false</span>;<br>            <span class="hljs-title function_">onInvisible</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onInvisible</span>(<span class="hljs-params"></span>) &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onVisible</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">lazyLoad</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">lazyLoad</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (!isVisible || !isPrepared) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-title function_">requestData</span>();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 请求数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">requestData</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">Log</span>.<span class="hljs-title function_">d</span>(<span class="hljs-variable constant_">TAG</span> + <span class="hljs-string">&quot;         Test&quot;</span>, <span class="hljs-string">&quot; requestData &quot;</span>);<br>    &#125;<br><br><br></code></pre></td></tr></table></figure>

<p> <a target="_blank" rel="noopener" href="http://www.10tiao.com/html/565/201702/2247483988/1.html">http://www.10tiao.com/html/565/201702/2247483988/1.html</a></p>
<h4 id="Activity-dialogFragment-的事件回调"><a href="#Activity-dialogFragment-的事件回调" class="headerlink" title="Activity  dialogFragment 的事件回调"></a>Activity  dialogFragment 的事件回调</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ISelectListener</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getItemPosition</span><span class="hljs-params">(position: <span class="hljs-type">Int</span>)</span></span><br>&#125;<br><br><span class="hljs-keyword">var</span> mListener: ISelectListener? = <span class="hljs-literal">null</span><br><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onAttach</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>)</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onAttach(context)<br>    <span class="hljs-keyword">if</span> (parentFragment <span class="hljs-keyword">is</span> ISelectListener)&#123;<br>        mListener = parentFragment  <span class="hljs-keyword">as</span> ISelectListener<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (context <span class="hljs-keyword">is</span> ISelectListener) &#123;<br>        mListener = context<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> RuntimeException(context!!.toString() + <span class="hljs-string">&quot; must implement ISelectListener&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://developer.android.com/guide/components/fragments.html">https://developer.android.com/guide/components/fragments.html</a></p>
<p>onHiddenChanged切换刷新</p>
<p>使用hide()/show()发现生命周期基本不执行，不过可以用到这个onHiddenChanged();</p>
<p>看下执行的生命周期;   从 SecondFragment 页面开始到 -&gt;FirstFragment </p>
<blockquote>
<p>07-18 15:53:25.128 7758-7758/com.mineutils D/SecondFragment: onAttach(Context context)<br>07-18 15:53:25.129 7758-7758/com.mineutils D/SecondFragment: onCreate()<br>07-18 15:53:25.142 7758-7758/com.mineutils D/SecondFragment: onCreateView()<br>07-18 15:53:25.148 7758-7758/com.mineutils D/SecondFragment:  onViewCreated<br>                                                              onActivityCreated()<br>                                                              onStart()<br>​                                                                  onResume()</p>
<p>07-18 15:53:34.200 7758-7758/com.mineutils D/SecondFragment: onHiddenChanged hidden   true<br>07-18 15:53:34.207 7758-7758/com.mineutils D/FirstFragment:    onCreateView()<br>07-18 15:53:34.208 7758-7758/com.mineutils D/FirstFragment:    onViewCreated<br>                                                            onActivityCreated()<br>​                                                           onStart()</p>
<p>07-18 15:53:53.968 7758-7758/com.mineutils D/FirstFragment: onHiddenChanged hidden   true<br>07-18 15:53:53.968 7758-7758/com.mineutils D/SecondFragment: onHiddenChanged hidden   false</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/cml_blog/article/details/41411451">https://blog.csdn.net/cml_blog/article/details/41411451</a></p>
<h4 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h4><p><a target="_blank" rel="noopener" href="https://wizardforcel.gitbooks.io/w3school-android/content/77.html">https://wizardforcel.gitbooks.io/w3school-android/content/77.html</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5901b564570c35005804424b">https://juejin.im/post/5901b564570c35005804424b</a></p>
<h4 id="Fragment-not-attached-to-a-context"><a href="#Fragment-not-attached-to-a-context" class="headerlink" title="Fragment not attached to a context"></a>Fragment not attached to a context</h4><p><a target="_blank" rel="noopener" href="https://weidianhuang.medium.com/android-fragment-not-attached-to-a-context-24d00fac4f3d">https://weidianhuang.medium.com/android-fragment-not-attached-to-a-context-24d00fac4f3d</a></p>

        
        
          <blockquote id="copyright">
              <p>Original link: <a href="https://noteforme.github.io/page/6/index.html">https://noteforme.github.io/page/6/index.html</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Fragment/" rel="tag">Fragment</a></li></ul>

          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>



    <nav id="page-nav">

<a class="extend prev" rel="prev" href="/page/5/">Previous</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" href="/page/7/">Next</a>
</nav>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-posts"></i> Recent</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/07/04/DesignPatterns-State/">DesignPatterns_State</a>
          </li>
        
          <li>
            <a href="/2024/07/03/glide/">glide</a>
          </li>
        
          <li>
            <a href="/2024/06/28/bitmap/">Bitmap</a>
          </li>
        
          <li>
            <a href="/2024/06/28/bits-and-bytes/">Bits and Bytes</a>
          </li>
        
          <li>
            <a href="/2024/06/26/lifecycle/">LifeCycle</a>
          </li>
        
      </ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-tag"></i> Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ANDROID/" style="font-size: 14px;">ANDROID</a> <a href="/tags/AOSP/" style="font-size: 16px;">AOSP</a> <a href="/tags/Activity/" style="font-size: 10px;">Activity</a> <a href="/tags/AndroidNewFeatures/" style="font-size: 10px;">AndroidNewFeatures</a> <a href="/tags/Assembly/" style="font-size: 10px;">Assembly</a> <a href="/tags/BLOG/" style="font-size: 10px;">BLOG</a> <a href="/tags/ConstraintLayout/" style="font-size: 10px;">ConstraintLayout</a> <a href="/tags/DB/" style="font-size: 12px;">DB</a> <a href="/tags/DesignPattern/" style="font-size: 10px;">DesignPattern</a> <a href="/tags/Drawer/" style="font-size: 10px;">Drawer</a> <a href="/tags/Fragment/" style="font-size: 12px;">Fragment</a> <a href="/tags/JVM/" style="font-size: 18px;">JVM</a> <a href="/tags/LEETCODE/" style="font-size: 20px;">LEETCODE</a> <a href="/tags/Library/" style="font-size: 10px;">Library</a> <a href="/tags/Operators/" style="font-size: 10px;">Operators</a> <a href="/tags/Performance/" style="font-size: 14px;">Performance</a> <a href="/tags/RecyclerView/" style="font-size: 12px;">RecyclerView</a> <a href="/tags/RxJava/" style="font-size: 14px;">RxJava</a> <a href="/tags/THINK/" style="font-size: 10px;">THINK</a> <a href="/tags/TOOL/" style="font-size: 10px;">TOOL</a> <a href="/tags/TabLayout/" style="font-size: 10px;">TabLayout</a> <a href="/tags/Test/" style="font-size: 14px;">Test</a> <a href="/tags/TouchEvent/" style="font-size: 12px;">TouchEvent</a> <a href="/tags/VIEW/" style="font-size: 14px;">VIEW</a> <a href="/tags/XML/" style="font-size: 10px;">XML</a> <a href="/tags/anim/" style="font-size: 10px;">anim</a> <a href="/tags/compose/" style="font-size: 10px;">compose</a> <a href="/tags/concurrency/" style="font-size: 14px;">concurrency</a> <a href="/tags/coroutie/" style="font-size: 16px;">coroutie</a> <a href="/tags/inter/" style="font-size: 12px;">inter</a> <a href="/tags/keyboard/" style="font-size: 10px;">keyboard</a> <a href="/tags/permission/" style="font-size: 10px;">permission</a> <a href="/tags/proguard/" style="font-size: 10px;">proguard</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-classify"></i> Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ANDROID/">ANDROID</a><span class="category-list-count">54</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Architecture/">Architecture</a><span class="category-list-count">3</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Architecture/DesignPattern/">DesignPattern</a><span class="category-list-count">3</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/BLE/">BLE</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/COROUTINE/">COROUTINE</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Computer-Composition-principles/">Computer Composition principles</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/DataStructure/">DataStructure</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/DesignPattern/">DesignPattern</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/DesignPatterns/">DesignPatterns</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ENGLISH/">ENGLISH</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/INTERVIEW/">INTERVIEW</a><span class="category-list-count">9</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/INTERVIEW/NETWORK/">NETWORK</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/">JAVA</a><span class="category-list-count">27</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JETPACK/">JETPACK</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Jetpack/">Jetpack</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kotlin/">Kotlin</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/LIFE/">LIFE</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/LINUX/">LINUX</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Library/">Library</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mathematics/">Mathematics</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/NETWORK/">NETWORK</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS/">OS</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Organization/">Organization</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SOURCE/">SOURCE</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/TEST/">TEST</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/TOOL/">TOOL</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/VIEW/">VIEW</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/anim/">anim</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/flutter/">flutter</a><span class="category-list-count">5</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-archive"></i> Archive</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/">2024年</a><span class="archive-list-count">47</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/">2023年</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022年</a><span class="archive-list-count">34</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021年</a><span class="archive-list-count">21</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020年</a><span class="archive-list-count">39</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019年</a><span class="archive-list-count">20</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/">2018年</a><span class="archive-list-count">26</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">2017年</a><span class="archive-list-count">49</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-tag"></i> Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ANDROID/" rel="tag">ANDROID</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AOSP/" rel="tag">AOSP</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Activity/" rel="tag">Activity</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AndroidNewFeatures/" rel="tag">AndroidNewFeatures</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Assembly/" rel="tag">Assembly</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BLOG/" rel="tag">BLOG</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ConstraintLayout/" rel="tag">ConstraintLayout</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DB/" rel="tag">DB</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DesignPattern/" rel="tag">DesignPattern</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Drawer/" rel="tag">Drawer</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fragment/" rel="tag">Fragment</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LEETCODE/" rel="tag">LEETCODE</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Library/" rel="tag">Library</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Operators/" rel="tag">Operators</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Performance/" rel="tag">Performance</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RecyclerView/" rel="tag">RecyclerView</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RxJava/" rel="tag">RxJava</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/THINK/" rel="tag">THINK</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TOOL/" rel="tag">TOOL</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TabLayout/" rel="tag">TabLayout</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Test/" rel="tag">Test</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TouchEvent/" rel="tag">TouchEvent</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VIEW/" rel="tag">VIEW</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XML/" rel="tag">XML</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/anim/" rel="tag">anim</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/compose/" rel="tag">compose</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/concurrency/" rel="tag">concurrency</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/coroutie/" rel="tag">coroutie</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/inter/" rel="tag">inter</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/keyboard/" rel="tag">keyboard</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/permission/" rel="tag">permission</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/proguard/" rel="tag">proguard</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-link"></i> Blogroll</h3>
    <div class="widget">
      <ul>
      
        <li>
          <a target="_blank" rel="noopener" href="http://www.example1.com/">site-name1</a>
        </li>
      
        <li>
          <a target="_blank" rel="noopener" href="http://www.example2.com/">site-name2</a>
        </li>
      
        <li>
          <a target="_blank" rel="noopener" href="http://www.example3.com/">site-name3</a>
        </li>
      
      </ul>
    </div>
  </div>


  
</aside>
        
      </div>
      <a id="totop" href="#top"></a>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      <p>
        <a href="/sitemap.xml">Site Map</a>
        <span> | </span><a href="/atom.xml">Subscribe to this site</a>
        <span> | </span><a href="/about/">Contact the blogger</a>
      </p>
      
        <p>
          <i class="fa fa-visitors"></i>
          <i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>
          ，
          <i class="fa fa-views"></i>
          <i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>
        </p>
      
      <p>
        <span>Copyright &copy; 2024 Jon.</span>
        <span>Theme by <a href="https://github.com/chaooo/hexo-theme-BlueLake/" target="_blank">BlueLake.</a></span>
        <span>Powered by <a href="https://hexo.io/" target="_blank">Hexo.</a></span>
      </p>
    </div>
  </div>
</footer>

    </div>
  </div>
  
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/search.json.js"></script>


  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>






  
<script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>








  



</body>
</html>