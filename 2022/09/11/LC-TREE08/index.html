<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>LC_TREE08 | Jon&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
  
  
    <link rel="alternate" href="/atom.xml" title="Jon's Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="/localshare/css/share.css">

  
  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Jon&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Cease to struggle and you cease to live. - Thomas Carlyle</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/."><i class="fa fa-home"></i> Home</a>
        
          <a class="main-nav-link" href="/archives/"><i class="fa fa-archive"></i> Archive</a>
        
          <a class="main-nav-link" href="/about/"><i class="fa fa-user"></i> About</a>
        
          <a class="main-nav-link" href="/atom.xml"><i class="fa fa-rss"></i> RSS</a>
        
      </nav>
    </div>
    <div id="search-form">
      <div id="result-mask" class="hide"></div>
      <label><input id="search-key" type="text" autocomplete="off" placeholder="search"></label>
      <div id="result-wrap" class="hide">
        <div id="search-result"></div>
      </div>
      <div class="hide">
        <template id="search-tpl">
          <div class="item">
            <a href="/{path}" title="{title}">
              <div class="title">{title}</div>
              <div class="time">{date}</div>
              <div class="tags">{tags}</div>
            </a>
          </div>
        </template>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-LC-TREE08" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      LC_TREE08
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2022-09-11T07:39:49.000Z" itemprop="datePublished">2022年09月11日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/DataStructure/">DataStructure</a>
  </div>

      
        <span class="article-views">
  <i class="fa fa-views"></i>
  <i id="busuanzi_container_page_pv">
      <i id="busuanzi_value_page_pv"></i>
  </i>
</span>

      
      
<a href="/2022/09/11/LC-TREE08/#comments" class="article-comment-link">
  
    
    
    
    
    
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></h4><h5 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h5><p>层序遍历是没法实现的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isSymmetric3</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.offer(root)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">            <span class="keyword">val</span> layerSize = queue.size</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until layerSize) &#123;</span><br><span class="line"><span class="comment">//                val lastIndex = layerSize - 1 - i // 这样不可以,poll取出元素后，就少了元素越界了</span></span><br><span class="line">                <span class="keyword">val</span> headNode = queue.poll()</span><br><span class="line"></span><br><span class="line">                <span class="keyword">val</span> lastNode = queue.lastOrNull()</span><br><span class="line">                <span class="keyword">if</span> (headNode.`<span class="keyword">val</span>` != lastNode?.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">                headNode.left?.let &#123; queue.offer(it) &#125;</span><br><span class="line">                headNode.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><p>// 不能判断true,判断true直接返回了，判断false返回没问题，true返回就不会往下走了</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">leftRightSymmetric</span><span class="params">(nodeLeft: <span class="type">TreeNode</span>?, nodeRight: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nodeLeft?.`<span class="keyword">val</span>` == nodeRight?.`<span class="keyword">val</span>`) &#123; <span class="comment">// 不能判断true,判断true直接返回了，判断false返回没问题，true返回就不会往下走了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeLeft == nodeRight) &#123; <span class="comment">// = null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    leftRightSymmetric(nodeLeft?.left, nodeRight?.right)</span><br><span class="line">    leftRightSymmetric(nodeLeft?.right, nodeRight?.left)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E9%80%92%E5%BD%92%E6%B3%95">https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E9%80%92%E5%BD%92%E6%B3%95</a></p>
<p>从根节点的左右子树开始，深度遍历比较</p>
<p><img src="https://img-blog.csdnimg.cn/20210203144624414.png"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isSymmetric</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> leftRightSymmetric(root?.left, root?.right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">leftRightSymmetric</span><span class="params">(nodeLeft: <span class="type">TreeNode</span>?, nodeRight: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nodeLeft == <span class="literal">null</span> &amp;&amp; nodeRight != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeLeft != <span class="literal">null</span> &amp;&amp; nodeRight == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeLeft?.`<span class="keyword">val</span>` != nodeRight?.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeLeft == <span class="literal">null</span> &amp;&amp; nodeRight == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">//这里需要，否则就递归 溢出了,如果根节点的左右节点为null,退出也是没问题的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> leftFlag = leftRightSymmetric(nodeLeft?.left, nodeRight?.right)</span><br><span class="line">    <span class="keyword">val</span> rightFlag = leftRightSymmetric(nodeLeft?.right, nodeRight?.left)</span><br><span class="line">    <span class="keyword">return</span> leftFlag &amp;&amp; rightFlag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnwcimlj8lg30hm0bqnpd.gif"></p>
<p>队列，一直向下按照对称的条件添加</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isSymmetric1</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123; </span><br><span class="line">        root.left?.let &#123; queue.offer(it) &#125; <span class="comment">// 官方解法中，根节点入队2次也可以</span></span><br><span class="line">        root.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> node1 = queue.poll()</span><br><span class="line">        <span class="keyword">val</span> node2 = queue.poll()</span><br><span class="line">        <span class="keyword">if</span>(node1==<span class="literal">null</span>&amp;&amp;node2==<span class="literal">null</span>)&#123; <span class="comment">// 一开始没写这个条件，提示超出时间限制</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node1?.`<span class="keyword">val</span>` != node2?.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        queue.offer(node1?.left) <span class="comment">// 两边的节点比较</span></span><br><span class="line">        queue.offer(node2?.right)</span><br><span class="line">        queue.offer(node1?.right) <span class="comment">//中间的节点比较</span></span><br><span class="line">        queue.offer(node2?.left)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>栈也是可以的，只要保证位置靠近</p>
<h4 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/same-tree/">100. 相同的树</a></h4><h5 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isSameTree</span><span class="params">(p: <span class="type">TreeNode</span>?, q: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span> &amp;&amp; q != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p?.`<span class="keyword">val</span>` == q?.`<span class="keyword">val</span>` &amp;&amp; isSameTree(p?.left, q?.left) &amp;&amp; isSameTree(p?.right, q?.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="队列-1"><a href="#队列-1" class="headerlink" title="队列"></a>队列</h5><img src="/2022/09/11/LC-TREE08/20220912130345.jpg" alt="20220912130345" style="zoom: 67%;">

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isSameTree1</span><span class="params">(p: <span class="type">TreeNode</span>?, q: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span> &amp;&amp; q != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    queue.offer(p)</span><br><span class="line">    queue.offer(q)</span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> node1 = queue.poll()</span><br><span class="line">        <span class="keyword">val</span> node2 = queue.poll()</span><br><span class="line">        <span class="keyword">if</span> (node1 == <span class="literal">null</span> &amp;&amp; node2 == <span class="literal">null</span>) &#123; <span class="comment">// continue后，因为null,就不会加入新的节点</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node1?.`<span class="keyword">val</span>` != node2?.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        queue.offer(node1?.left)</span><br><span class="line">        queue.offer(node2?.left)</span><br><span class="line">        queue.offer(node1?.right)</span><br><span class="line">        queue.offer(node2?.right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="572-另一棵树的子树"><a href="#572-另一棵树的子树" class="headerlink" title="572. 另一棵树的子树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subtree-of-another-tree/">572. 另一棵树的子树</a></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isSubtree</span><span class="params">(root: <span class="type">TreeNode</span>?, subRoot: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span> &amp;&amp; subRoot == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root == <span class="literal">null</span> &amp;&amp; subRoot != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root != <span class="literal">null</span> &amp;&amp; subRoot == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isSameTree(root, subRoot) || isSubtree(root?.left, subRoot) || isSubtree(root?.right, subRoot) <span class="comment">//subRoot和root相同,subRoot和root左子树相同，subRoot和右子树相同</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isSameTree</span><span class="params">(node1: <span class="type">TreeNode</span>?, node2: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node1 == <span class="literal">null</span> &amp;&amp; node2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node1 == <span class="literal">null</span> &amp;&amp; node2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node1 != <span class="literal">null</span> &amp;&amp; node2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node1?.`<span class="keyword">val</span>` == node2?.`<span class="keyword">val</span>` &amp;&amp; isSameTree(node1?.left, node2?.left) &amp;&amp; isSameTree(</span><br><span class="line">        node1?.right,</span><br><span class="line">        node2?.right</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h4><h5 id="DFS-普通二叉树解法"><a href="#DFS-普通二叉树解法" class="headerlink" title="DFS 普通二叉树解法"></a>DFS 普通二叉树解法</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countNodes</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> leftCount = countNodes(root.left)</span><br><span class="line">    <span class="keyword">val</span> rightCount = countNodes(root.right)</span><br><span class="line">    <span class="keyword">return</span> leftCount + rightCount + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countNodes1</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.offer(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> size = queue.size</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until size) &#123;</span><br><span class="line">            <span class="keyword">val</span> treeNode = queue.poll()</span><br><span class="line">            count++</span><br><span class="line">            treeNode.left?.let &#123; queue.offer(it) &#125;</span><br><span class="line">            treeNode.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="DFS-完全二叉树特性"><a href="#DFS-完全二叉树特性" class="headerlink" title="DFS 完全二叉树特性"></a>DFS 完全二叉树特性</h5><p>一开始打算用先序遍历，但是这样不行,</p>
<p>如果一颗树 是平衡的，永远是得到 1,  想了一下，这种也不属于 先序遍历</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countNodes</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> depth = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> postTraversal(root, depth)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">postTraversal</span><span class="params">(root: <span class="type">TreeNode</span>?, depth: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isBalanced(root)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> shl (depth - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> leftNums = postTraversal(root?.left, depth + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> rightNums = postTraversal(root?.right, depth + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> leftNums + rightNums + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countNodes</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> leftNode = root.left</span><br><span class="line">    <span class="keyword">var</span> depthLeft = <span class="number">0</span> <span class="comment">//左子树深度</span></span><br><span class="line">    <span class="keyword">while</span> (leftNode != <span class="literal">null</span>) &#123;</span><br><span class="line">        leftNode = leftNode.left</span><br><span class="line">        depthLeft++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> rightNode = root.right</span><br><span class="line">    <span class="keyword">var</span> depthRight = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (rightNode != <span class="literal">null</span>) &#123;</span><br><span class="line">        rightNode = rightNode.right</span><br><span class="line">        depthRight++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (depthLeft == depthRight) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">2</span> shl depthLeft) - <span class="number">1</span> <span class="comment">// 节点数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> leftNums = countNodes(root.left)</span><br><span class="line">    <span class="keyword">val</span> rightNums = countNodes(root.right)</span><br><span class="line">    <span class="keyword">return</span> leftNums + rightNums + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countNodes3</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> leftNode = root.left</span><br><span class="line">    <span class="keyword">var</span> depthLeft = <span class="number">0</span> <span class="comment">//左子树深度</span></span><br><span class="line">    <span class="keyword">while</span> (leftNode != <span class="literal">null</span>) &#123;</span><br><span class="line">        leftNode = leftNode.left</span><br><span class="line">        depthLeft++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> rightNode = root.right</span><br><span class="line">    <span class="keyword">var</span> depthRight = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (rightNode != <span class="literal">null</span>) &#123;</span><br><span class="line">        rightNode = rightNode.right</span><br><span class="line">        depthRight++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> leftNums = countNodes(root.left)</span><br><span class="line">    <span class="keyword">val</span> rightNums = countNodes(root.right)</span><br><span class="line">    <span class="keyword">if</span> (depthLeft == depthRight) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">2</span> shl depthLeft) - <span class="number">1</span> <span class="comment">// 节点数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> leftNums + rightNums + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树</a></h4><p>一开始错误的解答是这样的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isBalanced</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> postTraversal(root) != -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">postTraversal</span><span class="params">(node: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> leftDepth = postTraversal(node.left)</span><br><span class="line">        <span class="keyword">val</span> rightDepth = postTraversal(node.right)</span><br><span class="line">        <span class="keyword">val</span> isBalance = Math.abs(leftDepth - rightDepth) &lt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (isBalance) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(leftDepth, rightDepth) + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里问题是   return -1，作为父节点的深度返回给了 depth，然后继续计算 Math.abs(leftDepth - rightDepth) &lt;= 1，出现了问题</p>
<p>改进解法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isBalanced</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> postTraversal(root) != -<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">postTraversal</span><span class="params">(node: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> leftDepth = postTraversal(node.left)</span><br><span class="line">    <span class="keyword">val</span> rightDepth = postTraversal(node.right)</span><br><span class="line">    <span class="keyword">if</span> (leftDepth == -<span class="number">1</span> || rightDepth == -<span class="number">1</span>) &#123; <span class="comment">// 子节点已经有不是平衡的节点 直接返回，来判断</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> isBalance = Math.abs(leftDepth - rightDepth) &lt;= <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (isBalance) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftDepth, rightDepth) + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>随想录迭代遍历，看起来很复杂，看起来是统一解法.</p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E9%A2%98%E5%A4%96%E8%AF%9D">https://programmercarl.com/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E9%A2%98%E5%A4%96%E8%AF%9D</a></p>
<h4 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-paths/">257. 二叉树的所有路径</a></h4><h5 id="隐藏回溯过程"><a href="#隐藏回溯过程" class="headerlink" title="隐藏回溯过程"></a>隐藏回溯过程</h5><p>这一题 没理解透字符串怎么形成的和回溯的, 用到了先序遍历，</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ZG411G7Dh">https://www.bilibili.com/video/BV1ZG411G7Dh</a> 视频包含了回溯过程</p>
<p> 可以看下随想录回溯过程</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">binaryTreePaths</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: List&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> result = LinkedList&lt;String&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    dfs(root, result, root.`<span class="keyword">val</span>`.toString())</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://www.youtube.com/watch?v=swG70SQBJ-A</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. String不能用 StringBuilder,存在引用传递问题，会输出</span></span><br><span class="line"><span class="comment"> *    [&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;2-&gt;5-&gt;3&quot;]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. 在先序位置 val存到path也有问题,头节点会存在重复的情况 [&quot;1-&gt;1-&gt;2-&gt;5&quot;,&quot;1-&gt;1-&gt;2-&gt;5-&gt;3&quot;]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(node: <span class="type">TreeNode</span>?, result: <span class="type">LinkedList</span>&lt;<span class="type">String</span>&gt;, path: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        result.add(path)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        dfs(node.left, result, <span class="string">&quot;<span class="variable">$path</span>-&gt;<span class="subst">$&#123;node.left.`val`&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        dfs(node.right, result, <span class="string">&quot;<span class="variable">$path</span>-&gt;<span class="subst">$&#123;node.right.`val`&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面2的情况演示</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(node: <span class="type">TreeNode</span>?, result: <span class="type">LinkedList</span>&lt;<span class="type">String</span>&gt;, path: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">val</span> mPath = <span class="string">&quot;<span class="variable">$path</span>-&gt; <span class="subst">$&#123;node.`val`&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        result.add(mPath)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        dfs(node.left, result, mPath)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        dfs(node.right, result, mPath)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面两种写法，回溯隐藏在参数里面.</p>
<h5 id="显示回溯"><a href="#显示回溯" class="headerlink" title="显示回溯"></a>显示回溯</h5><p>这是随想录的代码，二刷可以自己写, </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">binaryTreePaths</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: List&lt;String&gt;? &#123;</span><br><span class="line">    <span class="keyword">val</span> res: MutableList&lt;String&gt; = ArrayList()</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> paths: MutableList&lt;<span class="built_in">Int</span>&gt; = ArrayList()</span><br><span class="line">    traversal(root, paths, res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">traversal</span><span class="params">(root: <span class="type">TreeNode</span>, paths: <span class="type">MutableList</span>&lt;<span class="type">Int</span>&gt;, res: <span class="type">MutableList</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    paths.add(root.`<span class="keyword">val</span>`)</span><br><span class="line">    <span class="comment">// 叶子结点</span></span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123; <span class="comment">// 碰到叶子节点，开始把path遍历放进string中 </span></span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        <span class="keyword">val</span> sb = StringBuilder()</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until paths.size - <span class="number">1</span>) &#123;</span><br><span class="line">            sb.append(paths[i]).append(<span class="string">&quot;-&gt;&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(paths[paths.size - <span class="number">1</span>]) <span class="comment">//也可以放到上面一起再把&quot;-&gt;&quot; 删除</span></span><br><span class="line">        res.add(sb.toString()) </span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        traversal(root.left, paths, res)</span><br><span class="line">        paths.removeAt(paths.size - <span class="number">1</span>) <span class="comment">// 回溯  </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        traversal(root.right, paths, res)</span><br><span class="line">        paths.removeAt(paths.size - <span class="number">1</span>) <span class="comment">// 回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paths.removeAt(paths.size - 1) 最初这里没理解，都删除了，为什么,上面还能遍历所有节点，其实递归是一致先走的，碰到叶子节点的时候，遍历path, 最后才开始 paths.removeAt(paths.size - 1) 回溯 到上面. </span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html">https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ZG411G7Dh">https://www.bilibili.com/video/BV1ZG411G7Dh</a></p>
<p>迭代法 后面再说吧</p>
<h4 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404. 左叶子之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-left-leaves/">404. 左叶子之和</a></h4><p>这一题和【 222 完全二叉树的节点个数】很像，这里是普通的二叉树，所以我的想法就前两种做法</p>
<ol>
<li>后序遍历</li>
<li>层序遍历</li>
</ol>
<p>把根节点换成左子树的节点</p>
<p>看错了题目，其实是左子树叶子值的和</p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C.html#%E6%80%9D%E8%B7%AF">https://programmercarl.com/0404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C.html#%E6%80%9D%E8%B7%AF</a></p>
<p>只看了随想录题解，自己这样写的代码</p>
<h5 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sumOfLeftLeaves</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> dfsLeaves(root, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> direction 0 右子树， 1：左子树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dfsLeaves</span><span class="params">(node: <span class="type">TreeNode</span>?, direction: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span> &amp;&amp; direction == <span class="number">1</span>) &#123; <span class="comment">// 左右子树为空，根据父亲节点的传入，判断它是左子树</span></span><br><span class="line">        <span class="keyword">return</span> node.`<span class="keyword">val</span>` <span class="comment">//这种情况返回值，根据后序规则，上层节点叠加</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> leftCount = dfsLeaves(node.left, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> rightCount = dfsLeaves(node.right, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> leftCount + rightCount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>看了随想录解法，可以直接看更下一层节点，就不用再传入方向了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">          leftValue = root-&gt;left-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>迭代法</p>
<p>随想录统一迭代法</p>
<h4 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513. 找树左下角的值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513. 找树左下角的值</a></h4><p>想了下</p>
<ol>
<li>层序遍历可以解决</li>
<li>递归法还没想道，到了最底层，没想到如何判断 哪个是最左边的。</li>
</ol>
<h5 id="BFS-1"><a href="#BFS-1" class="headerlink" title="BFS"></a>BFS</h5><p>先存下来每一层的第一个节点，知道queue为空，那么最后一层的头节点就是要返回的.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findBottomLeftValue1</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.offer(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> leftNodeVal = root?.`<span class="keyword">val</span>`</span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> size = queue.size</span><br><span class="line">        leftNodeVal = queue.peek().`<span class="keyword">val</span>` <span class="comment">//每一层的第一个节点</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until size) &#123;</span><br><span class="line">            <span class="keyword">val</span> node = queue.poll()</span><br><span class="line">            node?.left?.let &#123; queue.offer(it) &#125;</span><br><span class="line">            node?.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> leftNodeVal!! <span class="comment">// queue为empty的时候退出，此时上一层存的节点就是最左边的节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h5><p>My idea</p>
<ol>
<li><p>一开始以为树的层级里，树的左边的值小于右边，来得出结果，但是这是二叉树，不是平衡形的，即使平衡这种思路也不一定对.</p>
</li>
<li><p>然后又看了树结构,想了下可以用 inorder traversal ,中序遍历, 层数最深，然后最先得到的数据就是要拿到的结果. </p>
<p>想下面8肯定是后面遍历到的</p>
</li>
</ol>
<p><img src="/2022/09/11/LC-TREE08/20220924155016.jpg" alt="20220924155016"></p>
<ol>
<li>一开始不知道leetcode可以用全局变量，用对象返回还很麻烦，删掉了</li>
<li>判断层级，如果大于之前的深度，那么就更新深度和值</li>
<li>中序和后序肯定没问题，但是先序不确定（随想录说是可以的）而且随想录 depth + 1 展开了用回溯</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mDepth = <span class="number">0</span> <span class="comment">//一开始不知道leetcode可以用全局变量，用对象返回还很麻烦，删掉了</span></span><br><span class="line"><span class="keyword">var</span> result = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findBottomLeftValue</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    inOrderTraversal(root, mDepth)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最左边的节点最先访问到</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">inOrderTraversal</span><span class="params">(node: <span class="type">TreeNode</span>?, depth: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">    inOrderTraversal(node.left, depth + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> (depth + <span class="number">1</span> &gt; mDepth) &#123; <span class="comment">// 判断层级，如果大于之前的深度，那么就更新深度和值</span></span><br><span class="line">        mDepth = depth + <span class="number">1</span></span><br><span class="line">        result = node.`<span class="keyword">val</span>`</span><br><span class="line">    &#125;</span><br><span class="line">    inOrderTraversal(node.right, depth + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum/">112. 路径总和</a></h4><p>解决所有二叉树路径的问题文章</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-ii/solution/yi-pian-wen-zhang-jie-jue-suo-you-er-cha-oo63/">https://leetcode.cn/problems/path-sum-ii/solution/yi-pian-wen-zhang-jie-jue-suo-you-er-cha-oo63/</a></p>
<p>这一题和  [112. 路径总和]  类似</p>
<p>使用回溯写法，因为添加和删除，回溯的规则，那么感觉用栈比较合适.</p>
<ol>
<li>终止条件就是 到达了叶子节点，此时开始计算当前路径和 是否满足条件</li>
<li>手写判断是否有左子树，有的话继续判断，又继续preOrderTraversal, 这里用的是先序遍历,方法查看条件</li>
<li>遍历完叶子节点后判断，此时这条路径完成，开始回溯，回退上一层preOrderTraversal，继续判断右子树</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">hasPathSum</span><span class="params">(root: <span class="type">TreeNode</span>?, targetSum: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> pathStack = Stack&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        pathStack.push(root.`<span class="keyword">val</span>`) <span class="comment">// root需要放在遍历外面，否则会push多次</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">//按照前面的规则 root==null ,0 应该是对的,但是题目说false,就单独加一句</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> preOrderTraversal(root, targetSum, pathStack) <span class="comment">// pathstack必须传进去，否则每次都new</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">preOrderTraversal</span><span class="params">(root: <span class="type">TreeNode</span>?, targetSum: <span class="type">Int</span>, pathStack: <span class="type">Stack</span>&lt;<span class="type">Int</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root?.left == <span class="literal">null</span> &amp;&amp; root?.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> pathSum = <span class="number">0</span></span><br><span class="line">        pathStack.forEach &#123;</span><br><span class="line">            pathSum += it</span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;pathSum <span class="variable">$pathSum</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (pathSum == targetSum) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root?.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        pathStack.push(root.left.`<span class="keyword">val</span>`) <span class="comment">// 有左节点，加入当前路径</span></span><br><span class="line">        <span class="keyword">if</span> (preOrderTraversal(root.left, targetSum, pathStack)) &#123; <span class="comment">//有路径是和 == targetSum 直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        pathStack.pop()  <span class="comment">// 不会直接把上面的回退了，需要上一句遍历执行完回退后，才把自己回退了，此时已经到了叶子判断了 root?.left == null &amp;&amp; root?.right == null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root?.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        pathStack.push(root.right.`<span class="keyword">val</span>`)</span><br><span class="line">        <span class="keyword">if</span> (preOrderTraversal(root.right, targetSum, pathStack)) &#123; <span class="comment">//有路径是和 == targetSum 直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        pathStack.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">hasPathSum1</span><span class="params">(root: <span class="type">TreeNode</span>?, targetSum: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">//按照前面的规则 root==null ,0 应该是对的,但是题目说false,就单独加一句</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> pathSum = root.`<span class="keyword">val</span>`</span><br><span class="line">    <span class="keyword">return</span> preOrderDFS(root, pathSum, targetSum) <span class="comment">// pathstack必须传进去，否则每次都new</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">preOrderDFS</span><span class="params">(node: <span class="type">TreeNode</span>, pathSum: <span class="type">Int</span>, targetSum: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> nodeValue = node.`<span class="keyword">val</span>`</span><br><span class="line">    println(<span class="string">&quot;nodeValue <span class="variable">$nodeValue</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span> &amp;&amp; targetSum == pathSum) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">if</span> (preOrderDFS(node.left, pathSum + node.left.`<span class="keyword">val</span>`, targetSum)) &#123; <span class="comment">// 这个直接放回，容易忘了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">if</span> (preOrderDFS(node.right, pathSum + node.right.`<span class="keyword">val</span>`, targetSum)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II</a></h4><p>如果是找路径和等于给定target的路径的，那么可以不用新增一个临时变量cursum来判断当前路径和，<br>只需要用给定和target减去节点值，最终结束条件判断target==0即可</p>
<h5 id="DFS-1"><a href="#DFS-1" class="headerlink" title="DFS"></a>DFS</h5><p>这一题的思路和前面的差不多，就是他要求返回所有符合条件的集合，所以直接添加值觉得不合适，除非多加一个参数，不加一个参数就不好弄。</p>
<p>//这种解法要注意 值引用问题，即使最初加入到resultList的pathList是正确的，后序的回退也会把值给修改了.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> resultList = LinkedList&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">pathSum</span><span class="params">(root: <span class="type">TreeNode</span>?, targetSum: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> resultList</span><br><span class="line">    <span class="keyword">val</span> stackList = Stack&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    stackList.add(root.`<span class="keyword">val</span>`)</span><br><span class="line">    preDFS(root, stackList, targetSum)</span><br><span class="line">    <span class="keyword">return</span> resultList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">preDFS</span><span class="params">(node: <span class="type">TreeNode</span>, pathList: <span class="type">Stack</span>&lt;<span class="type">Int</span>&gt;, targetSum: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = node.`<span class="keyword">val</span>`</span><br><span class="line">    println(<span class="keyword">data</span>)</span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span> &amp;&amp; pathSum(pathList) == targetSum) &#123;</span><br><span class="line">        resultList.add(pathList.toMutableList().toList()) <span class="comment">// 注意引用传递</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        pathList.push(node.left.`<span class="keyword">val</span>`)</span><br><span class="line">        preDFS(node.left, pathList, targetSum)</span><br><span class="line">        pathList.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        pathList.push(node.right.`<span class="keyword">val</span>`)</span><br><span class="line">        preDFS(node.right, pathList, targetSum)</span><br><span class="line">        pathList.pop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">pathSum</span><span class="params">(pathList: <span class="type">Stack</span>&lt;<span class="type">Int</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    pathList.forEach &#123;</span><br><span class="line">        sum += it</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这一题的官方DFS解法没看懂，感觉不好理解.</p>
<p>这是看完官方写法自己写的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> pathList = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">pathSum1</span><span class="params">(root: <span class="type">TreeNode</span>?, targetSum: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> resultList</span><br><span class="line">    <span class="keyword">val</span> stackList = Stack&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    stackList.add(root.`<span class="keyword">val</span>`)</span><br><span class="line">    preTraversal(root, targetSum - root.`<span class="keyword">val</span>`)</span><br><span class="line">    <span class="keyword">return</span> resultList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">preTraversal</span><span class="params">(node: <span class="type">TreeNode</span>?, targetSum: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = node.`<span class="keyword">val</span>`</span><br><span class="line">    println(<span class="keyword">data</span>)</span><br><span class="line">    pathList.offer(node.`<span class="keyword">val</span>`)</span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span> &amp;&amp; targetSum == <span class="number">0</span>) &#123;</span><br><span class="line">        resultList.add(pathList.toMutableList())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="literal">null</span>)</span><br><span class="line">        preTraversal(node.left, targetSum - node.left.`<span class="keyword">val</span>`)</span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="literal">null</span>)</span><br><span class="line">        preTraversal(node.right, targetSum - node.right.`<span class="keyword">val</span>`)</span><br><span class="line">    pathList.pop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这是官方解法，也很棒</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">pathSum2</span><span class="params">(root: <span class="type">TreeNode</span>?, targetSum: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> resultList</span><br><span class="line">    <span class="keyword">val</span> stackList = Stack&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    stackList.add(root.`<span class="keyword">val</span>`)</span><br><span class="line">    preDFSTraversal(root, targetSum)</span><br><span class="line">    <span class="keyword">return</span> resultList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">preDFSTraversal</span><span class="params">(node: <span class="type">TreeNode</span>?, targetSum: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = node.`<span class="keyword">val</span>`</span><br><span class="line">    println(<span class="keyword">data</span>)</span><br><span class="line">    <span class="keyword">val</span> targetSum = targetSum - node.`<span class="keyword">val</span>`</span><br><span class="line">    pathList.offer(node.`<span class="keyword">val</span>`)</span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span> &amp;&amp; targetSum == <span class="number">0</span>) &#123;</span><br><span class="line">        resultList.add(pathList.toMutableList())</span><br><span class="line">    &#125;</span><br><span class="line">    preDFSTraversal(node.left, targetSum)</span><br><span class="line">    preDFSTraversal(node.right, targetSum)</span><br><span class="line">    pathList.pop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>官方BFS 就很不好理解</p>
<h3 id="构建树"><a href="#构建树" class="headerlink" title="构建树"></a>构建树</h3><p>先序，中序</p>
<p>后序，中序</p>
<p>inOrder         [L, 3 ,R ]</p>
<p>PostOrder     [L, R, 3] </p>
<p>PreOrder       [3,L ,R]<br>可以看到 只有PostOrder ,PreOrder左右是分不清的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> 			1    					1 </span><br><span class="line"> 		2									2</span><br><span class="line">  3											3</span><br><span class="line">  </span><br><span class="line">PreOrder  1,2,3				PreOrder  1,2,3</span><br><span class="line">PostOrder 3,2,1 			PostOrder 3,2,1</span><br></pre></td></tr></table></figure>



<h4 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h4><p>效率低，但是好理解的方法</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1pp4y1k75Q/">https://www.bilibili.com/video/BV1pp4y1k75Q/</a></p>
<p>为什么post右子树是从 , [i , n-1],因为他是后序遍历，所以从 i开始</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inorder &#x3D; 	[9,3,15,20,7]</span><br><span class="line">postorder &#x3D; [9,15,7,20,3]</span><br></pre></td></tr></table></figure>

<ol>
<li><p>根据后序postorder 得到root 3, 然后根据中序知道 left branch [9] , right branch [15 , 20 , 7]</p>
</li>
<li><p>根据 left branch 的9,可以把 postorder后序分成[9], [15 , 20 , 7]两部分</p>
</li>
<li><p>然后 inorder= [15 , 20 , 7] , postorder=[15 , 20 , 7] 继续进行遍历</p>
</li>
</ol>
<p>总的来说，就是这样</p>
<ol>
<li>确定终止条件</li>
<li>构造节点</li>
<li>构造左子树， 构造右子树</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">buildTree</span><span class="params">(inorder: <span class="type">IntArray</span>, postorder: <span class="type">IntArray</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (inorder.isEmpty() &amp;&amp; postorder.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> node = TreeNode(postorder[postorder.size - <span class="number">1</span>]) <span class="comment">//postorder.size用的地方多，可以提取出来</span></span><br><span class="line">    <span class="keyword">val</span> index = getIndex(node, inorder)</span><br><span class="line">    node.left = buildTree(inorder.copyOfRange(<span class="number">0</span>, index), postorder.copyOfRange(<span class="number">0</span>, index)) <span class="comment">// copyOfRange数组效率低</span></span><br><span class="line">    node.right = buildTree(</span><br><span class="line">        inorder.copyOfRange(index + <span class="number">1</span>, inorder.size), postorder.copyOfRange(index, postorder.size - <span class="number">1</span>)</span><br><span class="line">    ) <span class="comment">// 注意copyOfRange(0,2)获取的是index 0,1两个元素</span></span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getIndex</span><span class="params">(node: <span class="type">TreeNode</span>, inorder: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> inorder.indices) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.`<span class="keyword">val</span>` == inorder[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h5><p>写出来还有问题,先pass这题耗时太久了,边界不好掌握可以考虑用日志调试</p>
<p>还可以再看下随想录的视频讲解</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1vW4y1i7dn">https://www.bilibili.com/video/BV1vW4y1i7dn</a></p>
<p>随想录代码优化前的写法，和上面代码写法是一样的，只是用了C++语言</p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html">https://programmercarl.com/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html</a></p>
<p>最初错误的解法,上面的解法数组有变化所以 end位置就是数组的大小，但是这里不同，数组是没变化，就不能这样做</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 数组不变，只改变下标</span><br><span class="line">private fun buildDFSTree(</span><br><span class="line">    inorder: IntArray,</span><br><span class="line">    postorder: IntArray,</span><br><span class="line">    inStart: Int,</span><br><span class="line">    inEnd: Int,</span><br><span class="line">    postStart: Int,</span><br><span class="line">    postEnd: Int</span><br><span class="line">): TreeNode? &#123;</span><br><span class="line">    if (inStart &gt; inEnd || postStart &gt; postEnd || inEnd &lt; 0 || postEnd &lt; 0) &#123;</span><br><span class="line">        return null</span><br><span class="line">    &#125;</span><br><span class="line">    val node &#x3D; TreeNode(postorder[postEnd]) &#x2F;&#x2F;postorder.size用的地方多，可以提取出来</span><br><span class="line">    val index &#x3D; getIndex(node, inorder)</span><br><span class="line"></span><br><span class="line">    node.left &#x3D; buildDFSTree(inorder, postorder, inStart, index - 1, 0, index - 1)   &#x2F;&#x2F;[0,index) 左闭右开</span><br><span class="line">    node.right &#x3D; buildDFSTree(inorder, postorder, index + 1, inEnd, index + 1, postEnd)</span><br><span class="line">    return node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这一题花了不少时间，思路不难，主要是 切割后序的数组的时候，左右子树的边界值不好处理,</p>
<ol>
<li>map用来存储，中序value值和position的对应关系，这里value应该是唯一的.</li>
<li>采用的是左闭右闭的方案，所以inStart &gt; inEnd 不能用 &gt;=, 否则return了，叶子节点无法构造出来.</li>
<li>根据后序root节点，分割中序数组，拿到左子树后，再用左子树树的分割后序数组,因为左子树的长度是一样的。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> map = HashMap&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">buildTree1</span><span class="params">(inorder: <span class="type">IntArray</span>, postorder: <span class="type">IntArray</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (inorder.isEmpty() &amp;&amp; postorder.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> inStart = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> inEnd = inorder.size - <span class="number">1</span></span><br><span class="line">    <span class="keyword">val</span> postStart = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> postEnd = postorder.size - <span class="number">1</span></span><br><span class="line">    inorder.forEachIndexed &#123; position, item -&gt;</span><br><span class="line">        map[item] = position</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buildDFSTree(inStart, inEnd, postStart, postEnd, inorder, postorder)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组不变，只改变下标</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">buildDFSTree</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    inStart: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    inEnd: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    postStart: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    postEnd: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    inorderArr: <span class="type">IntArray</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    postorderArr: <span class="type">IntArray</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: TreeNode? &#123;</span><br><span class="line">    println(<span class="string">&quot; inStart <span class="variable">$inStart</span> inEnd <span class="variable">$inEnd</span>  postStart <span class="variable">$postStart</span> postEnd <span class="variable">$postEnd</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> (inStart &gt; inEnd || postStart &gt; postEnd) &#123; <span class="comment">// 因为是左闭右闭的方案，所以这里不能用 &gt;= ,否则叶子节点无法构造出来</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> node = TreeNode(postorderArr[postEnd]) <span class="comment">//postorder.size用的地方多，可以提取出来</span></span><br><span class="line">    <span class="keyword">val</span> index = map[postorderArr[postEnd]] ?: <span class="number">0</span> <span class="comment">// 这里要改</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切割左子树,这种坐标定义好更清晰</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> leftInBegin = inStart</span><br><span class="line">    <span class="keyword">val</span> leftInEnd = index - <span class="number">1</span> <span class="comment">// 左闭右闭</span></span><br><span class="line">    <span class="keyword">val</span> leftPostBegin = postStart</span><br><span class="line">    <span class="keyword">val</span> leftPostEnd = postStart + (index - inStart - <span class="number">1</span>) <span class="comment">//(index - inStart) 左子树的长度, 因为选择是左闭右闭的方案，所以自身也-1</span></span><br><span class="line"></span><br><span class="line">    node.left = buildDFSTree(</span><br><span class="line">        leftInBegin, leftInEnd, leftPostBegin, leftPostEnd,</span><br><span class="line">        inorderArr,</span><br><span class="line">        postorderArr</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切割右子树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> rightInBegin = index + <span class="number">1</span></span><br><span class="line">    <span class="keyword">val</span> rightInEnd = inEnd</span><br><span class="line">    <span class="keyword">val</span> rightPostBegin = postStart + index - inStart <span class="comment">//(index - inStart) 这里不用-1,因为左子树的右边就是右子树，所以右子树就是从这个位置开始的</span></span><br><span class="line">    <span class="keyword">val</span> rightPostEnd = postEnd - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    node.right = buildDFSTree(</span><br><span class="line">        rightInBegin, rightInEnd, rightPostBegin, rightPostEnd,</span><br><span class="line">        inorderArr,</span><br><span class="line">        postorderArr</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>官方</p>
<p>先构建右子树的想法好巧妙，要是先构建的是左子树还有个确定后序区间的步骤。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution/cong-zhong-xu-yu-hou-xu-bian-li-xu-lie-gou-zao-14/">https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution/cong-zhong-xu-yu-hou-xu-bian-li-xu-lie-gou-zao-14/</a></p>
<p>官方解法很妙，根据后序数组pop，post_idx–;先开始右子树,然后左子树,构造方法也很简单，这样不用找后序数组的 开始和结束位置在哪. 做了上面的解法，也就是这个后序的边界值最难搞. 这种方式直接给省去了。</p>
<p>不得不说太妙了</p>
<p><img src="https://assets.leetcode-cn.com/solution-static/106/6.png"></p>
<p>官方迭代法后面再看吧 。</p>
<h4 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654. 最大二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-binary-tree/">654. 最大二叉树</a></h4><p>输入：nums = [3,2,1,6,0,5]<br>输出：[6,3,5,null,2,0,null,null,1]<br>解释：递归调用如下所示：</p>
<p>[3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。</p>
<ul>
<li>[3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。 ,3的左边是[]没有节点, 右边是[0,5],所以树也是这样构造的.<ul>
<li>空数组，无子节点。</li>
<li>[2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。<ul>
<li>空数组，无子节点。</li>
<li>只有一个元素，所以子节点是一个值为 1 的节点。</li>
</ul>
</li>
</ul>
</li>
<li>[0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。<ul>
<li>只有一个元素，所以子节点是一个值为 0 的节点。</li>
<li>空数组，无子节点。</li>
</ul>
</li>
</ul>
<h5 id="preTraversal"><a href="#preTraversal" class="headerlink" title="preTraversal"></a>preTraversal</h5><p>思路 : </p>
<ol>
<li>因为需要构造中间节点，所以用先序遍历</li>
<li>先找到数组中最大值，然后切割成左右子树。</li>
<li>在切割后的左右子树中继续切割，直至无法切割为止</li>
</ol>
<p>自己写的，做法和随想录类似 </p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0654.%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html#java">https://programmercarl.com/0654.%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html#java</a></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">constructMaximumBinaryTree</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">return</span> buildTree(nums, <span class="number">0</span>, nums.size - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">buildTree</span><span class="params">(nums: <span class="type">IntArray</span>, start: <span class="type">Int</span>, end: <span class="type">Int</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    println(<span class="string">&quot;buildTree start <span class="variable">$start</span> end <span class="variable">$end</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="literal">null</span>            <span class="comment">//分割的左右下标越界就退出 ,不能加==，否则叶子节点构造不到.</span></span><br><span class="line">    <span class="keyword">val</span> maxIndex = getMaxIndex(nums, start, end)</span><br><span class="line">    <span class="keyword">val</span> node = TreeNode(nums[maxIndex])     <span class="comment">// 构造先序的父节点</span></span><br><span class="line">    node.left = buildTree(nums, start, maxIndex - <span class="number">1</span>) <span class="comment">// 构造左节点</span></span><br><span class="line">    node.right = buildTree(nums, maxIndex + <span class="number">1</span>, end)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getMaxIndex</span><span class="params">(nums: <span class="type">IntArray</span>, start: <span class="type">Int</span>, end: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> maxIndex = start</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> start..end) &#123;  <span class="comment">// 在对应的数组范围内，找到最大值</span></span><br><span class="line">        <span class="keyword">if</span> (nums[maxIndex] &lt; nums[i]) &#123;</span><br><span class="line">            maxIndex = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxIndex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h5><p>官方还有一种单调栈的写法，后面再看吧</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-binary-tree/solution/zui-da-er-cha-shu-by-leetcode-solution-lbeo/">https://leetcode.cn/problems/maximum-binary-tree/solution/zui-da-er-cha-shu-by-leetcode-solution-lbeo/</a></p>
<h4 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h4><p>Idea</p>
<h5 id="只分割中序数组"><a href="#只分割中序数组" class="headerlink" title="只分割中序数组"></a>只分割中序数组</h5><p>按照上面106官方很妙的思路，下面解法</p>
<ol>
<li>根据中序遍历。value和index构造hash map,方便后面获取中序位置</li>
<li>根据先序遍历数组从 左子树到右子树构造节点, 这样就不用分割先序数组，也是很麻烦的</li>
<li>根据先序数组的节点的位置，分割中序遍历数组，拿到左右子树</li>
<li>然后是递归分割.</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> map = HashMap&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="keyword">var</span> preNodeIndex = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">buildTree</span><span class="params">(preorder: <span class="type">IntArray</span>, inorder: <span class="type">IntArray</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    inorder.forEachIndexed &#123; position, item -&gt; <span class="comment">//</span></span><br><span class="line">        map[item] = position</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buildDFS(preorder, inorder, <span class="number">0</span>, inorder.size - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">buildDFS</span><span class="params">(preorder: <span class="type">IntArray</span>, inorder: <span class="type">IntArray</span>, inBegin: <span class="type">Int</span>, inEnd: <span class="type">Int</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (inBegin &gt; inEnd) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> node = TreeNode(preorder[preNodeIndex])  <span class="comment">// 根据先序遍历数组从 左子树到右子树构造节点</span></span><br><span class="line">    <span class="keyword">val</span> inIndex = map[preorder[preNodeIndex]]!! <span class="comment">// 根据先序数组的节点的位置，分割中序遍历数组，拿到左右子树</span></span><br><span class="line">    println(<span class="string">&quot;<span class="subst">$&#123;preorder[preNodeIndex]&#125;</span> inBegin <span class="variable">$inBegin</span> inEnd <span class="variable">$inEnd</span>&quot;</span>)</span><br><span class="line">    preNodeIndex++</span><br><span class="line">    node.left = buildDFS(preorder, inorder, inBegin, inIndex - <span class="number">1</span>)</span><br><span class="line">    node.right = buildDFS(preorder, inorder, inIndex + <span class="number">1</span>, inEnd)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="分割先序-中序数组"><a href="#分割先序-中序数组" class="headerlink" title="分割先序 中序数组"></a>分割先序 中序数组</h5><ol>
<li>根据中序数组构造，位置和值的hashmap 。</li>
<li>根据先序数组的中节点位置，分割中序数组，得到左右子树。</li>
<li>根据中序数组得到的左子树的长度，分割 先序数组的左右子树.</li>
<li>构造左右子树.</li>
</ol>
<p>左闭右闭的情况</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> map = HashMap&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="keyword">var</span> preNodeIndex = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">buildTree1</span><span class="params">(preorder: <span class="type">IntArray</span>, inorder: <span class="type">IntArray</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    inorder.forEachIndexed &#123; position, item -&gt;</span><br><span class="line">        map[item] = position  <span class="comment">// 获得 中序 value和index hash</span></span><br><span class="line">        map.put(item,position)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> splitPreInOrder(preorder, <span class="number">0</span>, preorder.size - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.size - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">splitPreInOrder</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    preorderArr: <span class="type">IntArray</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    preStart: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    preEnd: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    inorderArr: <span class="type">IntArray</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    inStart: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    inEnd: <span class="type">Int</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: TreeNode? &#123;</span><br><span class="line">    println(<span class="string">&quot; preStart <span class="variable">$preStart</span> preEnd <span class="variable">$preEnd</span> inStart <span class="variable">$inStart</span> inEnd <span class="variable">$inEnd</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (preStart &gt; preEnd || inStart &gt; inEnd) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">val</span> inIndex = map[preorderArr[preStart]]!!  <span class="comment">// 分割中序数组</span></span><br><span class="line">    <span class="keyword">val</span> node = TreeNode(preorderArr[preStart])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> leftInBegin = inStart <span class="comment">//左闭</span></span><br><span class="line">    <span class="keyword">val</span> leftInEnd = inIndex-<span class="number">1</span>    <span class="comment">// 右闭</span></span><br><span class="line">    <span class="keyword">val</span> leftPreBegin = preStart + <span class="number">1</span> <span class="comment">// 先序中节点的后一个位置，就是左子树的开始位置</span></span><br><span class="line">    <span class="keyword">val</span> leftPreEnd = preStart + (inIndex - inStart) <span class="comment">// 其实位置 + 中序中左子树的长度</span></span><br><span class="line"></span><br><span class="line">    node.left = splitPreInOrder(preorderArr, leftPreBegin, leftPreEnd, inorderArr, leftInBegin, leftInEnd)</span><br><span class="line">    <span class="keyword">val</span> rightInBegin = inIndex + <span class="number">1</span> <span class="comment">// 分割点的后一个位置</span></span><br><span class="line">    <span class="keyword">val</span> rightInEnd = inEnd</span><br><span class="line">    <span class="keyword">val</span> rightPreBegin = preStart + (inIndex - inStart) + <span class="number">1</span> <span class="comment">// 先序数组 左子树位置+1 后一个位置</span></span><br><span class="line">    <span class="keyword">val</span> rightPreEnd = preEnd</span><br><span class="line">    node.right = splitPreInOrder(preorderArr, rightPreBegin, rightPreEnd, inorderArr, rightInBegin, rightInEnd)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>感觉还是左闭右闭好点，右开的情况容易越界.</p>
<h4 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-binary-trees/">617. 合并二叉树</a></h4><h5 id="DFS-2"><a href="#DFS-2" class="headerlink" title="DFS"></a>DFS</h5><ol>
<li>合并二叉树，通过先序遍历，先构造根节点</li>
<li>然后再分别构造左右子树</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">mergeTrees</span><span class="params">(root1: <span class="type">TreeNode</span>?, root2: <span class="type">TreeNode</span>?)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="literal">null</span> &amp;&amp; root2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">//这里还可以优化, 看官方解法和随想录的优化一样的</span></span><br><span class="line">    <span class="keyword">val</span> node = TreeNode((root1?.`<span class="keyword">val</span>` ?: <span class="number">0</span>) + (root2?.`<span class="keyword">val</span>` ?: <span class="number">0</span>))</span><br><span class="line">    node.left = mergeTrees(root1?.left, root2?.left)</span><br><span class="line">    node.right = mergeTrees(root1?.right, root2?.right)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>BFS</p>
<p>这题官方有一种BFS的解法,感觉有点麻烦，后面继续</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-binary-trees/solution/he-bing-er-cha-shu-by-leetcode-solution/">https://leetcode.cn/problems/merge-two-binary-trees/solution/he-bing-er-cha-shu-by-leetcode-solution/</a></p>

        
            <div id="toc-article">
                
  <div class="widget-wrap" id="toc-wrap">
    <h3 class="widget-title"><i class="fa fa-toc"></i> Contents</h3>
    <div class="widget">
      <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">101. 对称二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">层序遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-text">递归</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-text">队列</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91"><span class="toc-text">100. 相同的树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%92%E5%BD%92-1"><span class="toc-text">递归</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%98%9F%E5%88%97-1"><span class="toc-text">队列</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#572-%E5%8F%A6%E4%B8%80%E6%A3%B5%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91"><span class="toc-text">572. 另一棵树的子树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0"><span class="toc-text">222. 完全二叉树的节点个数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#DFS-%E6%99%AE%E9%80%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E8%A7%A3%E6%B3%95"><span class="toc-text">DFS 普通二叉树解法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#BFS"><span class="toc-text">BFS</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DFS-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%89%B9%E6%80%A7"><span class="toc-text">DFS 完全二叉树特性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">先序遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">后序遍历</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">110. 平衡二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84"><span class="toc-text">257. 二叉树的所有路径</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E5%9B%9E%E6%BA%AF%E8%BF%87%E7%A8%8B"><span class="toc-text">隐藏回溯过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E5%9B%9E%E6%BA%AF"><span class="toc-text">显示回溯</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#404-%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C"><span class="toc-text">404. 左叶子之和</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%B3%95"><span class="toc-text">递归法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#513-%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC"><span class="toc-text">513. 找树左下角的值</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#BFS-1"><span class="toc-text">BFS</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DFS"><span class="toc-text">DFS</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C"><span class="toc-text">112. 路径总和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-II"><span class="toc-text">113. 路径总和 II</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#DFS-1"><span class="toc-text">DFS</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E6%A0%91"><span class="toc-text">构建树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">106. 从中序与后序遍历序列构造二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-text">优化方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">654. 最大二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#preTraversal"><span class="toc-text">preTraversal</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88"><span class="toc-text">单调栈</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">105. 从前序与中序遍历序列构造二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AA%E5%88%86%E5%89%B2%E4%B8%AD%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-text">只分割中序数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E5%85%88%E5%BA%8F-%E4%B8%AD%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-text">分割先序 中序数组</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">617. 合并二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#DFS-2"><span class="toc-text">DFS</span></a></li></ol></li></ol>
    </div>
  </div>


            </div>
        
        
          <blockquote id="copyright">
              <p>Original link: <a href="https://noteforme.github.io/2022/09/11/LC-TREE08/">https://noteforme.github.io/2022/09/11/LC-TREE08/</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LEETCODE/" rel="tag">LEETCODE</a></li></ul>

          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
        
<nav id="article-nav">
  
    <a href="/2022/09/15/Fragment-StateLoss/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">newer</strong>
      <div class="article-nav-title">
        
          Fragment_StateLoss
        
      </div>
    </a>
  
  
    <a href="/2022/08/27/view-custom/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">older</strong>
      <div class="article-nav-title">view_custom</div>
    </a>
  
</nav>

      
      
        







      
    </footer>
  </div>
</article>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-posts"></i> Recent</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/09/03/Android-itnerview-algorithm/">Android_itnerview_algorithm</a>
          </li>
        
          <li>
            <a href="/2023/09/03/Android_interview%20organize/">Android_itnerview_organize</a>
          </li>
        
          <li>
            <a href="/2023/08/20/compose-layout/">compose_layout</a>
          </li>
        
          <li>
            <a href="/2023/08/19/compose/">compose</a>
          </li>
        
          <li>
            <a href="/2023/08/09/LC-DP-BAG/">LC_DP_BAG</a>
          </li>
        
      </ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-tag"></i> Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ANDROID/" style="font-size: 13.33px;">ANDROID</a> <a href="/tags/AOSP/" style="font-size: 16.67px;">AOSP</a> <a href="/tags/Activity/" style="font-size: 10px;">Activity</a> <a href="/tags/AndroidNewFeatures/" style="font-size: 10px;">AndroidNewFeatures</a> <a href="/tags/Assembly/" style="font-size: 10px;">Assembly</a> <a href="/tags/BLOG/" style="font-size: 10px;">BLOG</a> <a href="/tags/ConstraintLayout/" style="font-size: 10px;">ConstraintLayout</a> <a href="/tags/DB/" style="font-size: 11.67px;">DB</a> <a href="/tags/Drawer/" style="font-size: 10px;">Drawer</a> <a href="/tags/Fragment/" style="font-size: 11.67px;">Fragment</a> <a href="/tags/Git/" style="font-size: 11.67px;">Git</a> <a href="/tags/JVM/" style="font-size: 18.33px;">JVM</a> <a href="/tags/LEETCODE/" style="font-size: 20px;">LEETCODE</a> <a href="/tags/Operators/" style="font-size: 10px;">Operators</a> <a href="/tags/Performance/" style="font-size: 15px;">Performance</a> <a href="/tags/RecyclerView/" style="font-size: 11.67px;">RecyclerView</a> <a href="/tags/RxJava/" style="font-size: 15px;">RxJava</a> <a href="/tags/THINK/" style="font-size: 10px;">THINK</a> <a href="/tags/TOOL/" style="font-size: 11.67px;">TOOL</a> <a href="/tags/TabLayout/" style="font-size: 10px;">TabLayout</a> <a href="/tags/Test/" style="font-size: 15px;">Test</a> <a href="/tags/TouchEvent/" style="font-size: 13.33px;">TouchEvent</a> <a href="/tags/VIEW/" style="font-size: 11.67px;">VIEW</a> <a href="/tags/XML/" style="font-size: 10px;">XML</a> <a href="/tags/anim/" style="font-size: 10px;">anim</a> <a href="/tags/compose/" style="font-size: 11.67px;">compose</a> <a href="/tags/concurrency/" style="font-size: 15px;">concurrency</a> <a href="/tags/coroutie/" style="font-size: 16.67px;">coroutie</a> <a href="/tags/inter/" style="font-size: 18.33px;">inter</a> <a href="/tags/keyboard/" style="font-size: 10px;">keyboard</a> <a href="/tags/proguard/" style="font-size: 10px;">proguard</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-classify"></i> Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ANDROID/">ANDROID</a><span class="category-list-count">59</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/BLE/">BLE</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/DataStructure/">DataStructure</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/DesignPatterns/">DesignPatterns</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ENGLISH/">ENGLISH</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/">JAVA</a><span class="category-list-count">27</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Jetpack/">Jetpack</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kotlin/">Kotlin</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/LINUX/">LINUX</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mathematics/">Mathematics</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS/">OS</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Organization/">Organization</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SOURCE/">SOURCE</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/TEST/">TEST</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/TOOL/">TOOL</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/VIEW/">VIEW</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/anim/">anim</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/flutter/">flutter</a><span class="category-list-count">5</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-archive"></i> Archive</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/">2023年09月</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022年12月</a><span class="archive-list-count">33</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021年12月</a><span class="archive-list-count">23</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020年12月</a><span class="archive-list-count">46</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019年12月</a><span class="archive-list-count">21</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/">2018年11月</a><span class="archive-list-count">32</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">2017年12月</a><span class="archive-list-count">57</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-tag"></i> Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ANDROID/" rel="tag">ANDROID</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AOSP/" rel="tag">AOSP</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Activity/" rel="tag">Activity</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AndroidNewFeatures/" rel="tag">AndroidNewFeatures</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Assembly/" rel="tag">Assembly</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BLOG/" rel="tag">BLOG</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ConstraintLayout/" rel="tag">ConstraintLayout</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DB/" rel="tag">DB</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Drawer/" rel="tag">Drawer</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fragment/" rel="tag">Fragment</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LEETCODE/" rel="tag">LEETCODE</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Operators/" rel="tag">Operators</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Performance/" rel="tag">Performance</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RecyclerView/" rel="tag">RecyclerView</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RxJava/" rel="tag">RxJava</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/THINK/" rel="tag">THINK</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TOOL/" rel="tag">TOOL</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TabLayout/" rel="tag">TabLayout</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Test/" rel="tag">Test</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TouchEvent/" rel="tag">TouchEvent</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VIEW/" rel="tag">VIEW</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XML/" rel="tag">XML</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/anim/" rel="tag">anim</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/compose/" rel="tag">compose</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/concurrency/" rel="tag">concurrency</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/coroutie/" rel="tag">coroutie</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/inter/" rel="tag">inter</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/keyboard/" rel="tag">keyboard</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/proguard/" rel="tag">proguard</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-link"></i> Blogroll</h3>
    <div class="widget">
      <ul>
      
        <li>
          <a target="_blank" rel="noopener" href="http://www.example1.com/">site-name1</a>
        </li>
      
        <li>
          <a target="_blank" rel="noopener" href="http://www.example2.com/">site-name2</a>
        </li>
      
        <li>
          <a target="_blank" rel="noopener" href="http://www.example3.com/">site-name3</a>
        </li>
      
      </ul>
    </div>
  </div>


  
</aside>
        
      </div>
      <a id="totop" href="#top"></a>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      <p>
        <a href="/sitemap.xml">Site Map</a>
        <span> | </span><a href="/atom.xml">Subscribe to this site</a>
        <span> | </span><a href="/about/">Contact the blogger</a>
      </p>
      
        <p>
          <i class="fa fa-visitors"></i>
          <i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>
          ，
          <i class="fa fa-views"></i>
          <i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>
        </p>
      
      <p>
        <span>Copyright &copy; 2023 Jon.</span>
        <span>Theme by <a href="https://github.com/chaooo/hexo-theme-BlueLake/" target="_blank">BlueLake.</a></span>
        
            <span>Count by <a href="http://busuanzi.ibruce.info/" target="_blank">busuanzi.</a></span>
        
        <span>Powered by <a href="https://hexo.io/" target="_blank">Hexo.</a></span>
      </p>
    </div>
  </div>
</footer>

    </div>
    
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/search.json.js"></script>


  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>






  
<script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



  
<script src="/localshare/js/social-share.js"></script>

  
<script src="/localshare/js/qrcode.js"></script>




















  </div>
</body>
</html>