<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>Page 2 | Jon&#39;s Blog</title>
  <meta name="author" content="Jon">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Jon&#39;s Blog"/>

  
    <meta property="og:image" content=""/>
  

  
    <link rel="alternative" href="/atom.xml" title="Jon&#39;s Blog" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/prism.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-70812759-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-70812759-1');
</script>






<meta name="generator" content="Hexo 6.3.0"></head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">Jon&#39;s Blog</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class=""></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class=""></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class=""></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class=""></i>About
			</a>
		  </li>
		  
		  <li>
			<a href="/atom.xml" title="Subscribe me.">
			  <i class=""></i>RSS
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 <div class="page-header logo">
  <h1>Cease to struggle and you cease to live. - Thomas Carlyle<span class="blink-fast">|</span></h1>
</div>

<div class="row page">

	
	<div class="col-md-9">
	

		<div class="slogan">


		<i class="fa fa-heart blink-slow"></i>

		wubba lubba dub dub.

</div>    

		<div id="top_search"></div>
		<div class="mypage">
		
		<!-- title and entry -->
		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/10/17/AppLink/" >AppLink</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-10-17  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7031143982960902157">https://juejin.cn/post/7031143982960902157</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.android.com/studio/write/app-link-indexing">https://developer.android.com/studio/write/app-link-indexing</a></p>
<h3 id="唤醒App的几种方式"><a href="#唤醒App的几种方式" class="headerlink" title="唤醒App的几种方式"></a>唤醒App的几种方式</h3><h3 id="Deep-Link"><a href="#Deep-Link" class="headerlink" title="Deep Link"></a>Deep Link</h3><p><a target="_blank" rel="noopener" href="https://developer.android.com/training/app-links/deep-linking">https://developer.android.com/training/app-links/deep-linking</a></p>
<p>URL Scheme</p>
<p><strong>链接格式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[scheme]:&#x2F;&#x2F;[host][:port]&#x2F;[path]?[query]</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>属性名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>scheme</td>
<td>协议名（由开发人员定义）</td>
</tr>
<tr>
<td>host</td>
<td>网络域名</td>
</tr>
<tr>
<td>port</td>
<td>端口号</td>
</tr>
<tr>
<td>path</td>
<td>页面路径</td>
</tr>
<tr>
<td>query</td>
<td>请求参数</td>
</tr>
</tbody></table>
<h5 id="scheme-only"><a href="#scheme-only" class="headerlink" title="scheme only"></a>scheme only</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- for deep-link --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 必须加否否无法响应点击链接的 Intent--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.VIEW&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.BROWSABLE&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">&quot;ewallet&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在浏览器输入 ewallet:// 就能直接打开app</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ewallet:&#x2F;&#x2F;</span><br></pre></td></tr></table></figure>



<h5 id="scheme-host"><a href="#scheme-host" class="headerlink" title="scheme host"></a>scheme host</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;intent-filter&gt;</span><br><span class="line">    &lt;!-- 必须加否否无法响应点击链接的 Intent--&gt;</span><br><span class="line">    &lt;action android:name&#x3D;&quot;android.intent.action.VIEW&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;category android:name&#x3D;&quot;android.intent.category.DEFAULT&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;category android:name&#x3D;&quot;android.intent.category.BROWSABLE&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;data</span><br><span class="line">        android:host&#x3D;&quot;topic&quot;</span><br><span class="line">        android:scheme&#x3D;&quot;com.great.jon&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;intent-filter&gt;</span><br></pre></td></tr></table></figure>

<p>在浏览器输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.great.jon:&#x2F;&#x2F;topic</span><br><span class="line">com.great.jon:&#x2F;&#x2F;topic?id &#x3D;11</span><br></pre></td></tr></table></figure>

<p>id=11 这个可以不写</p>
<h5 id="ADB-TEST"><a href="#ADB-TEST" class="headerlink" title="ADB TEST"></a>ADB TEST</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -a android.intent.action.VIEW -d &quot;replace your link here&quot;</span><br></pre></td></tr></table></figure>





<h5 id="Android系统级-Schemes"><a href="#Android系统级-Schemes" class="headerlink" title="Android系统级 Schemes"></a>Android系统级 Schemes</h5><p>有一些已经定义了URL Schemes，比如短信是 sms:、通话是tel:、email是mailto:，在定义自己APP的URL Schemes的时候要避免跟系统应用名称一样</p>
<h5 id="各大平台"><a href="#各大平台" class="headerlink" title="各大平台"></a><strong>各大平台</strong></h5><p>简单查找了一下各大平台的 scheme，感兴趣的可以直接从手机浏览器中打开尝试一下。</p>
<blockquote>
<p>QQ：<code>qq://</code><br>微信：<code>weixin://</code><br>淘宝：<code>taobao://</code><br>微博：<code>sinaweibo://</code><br>百瓶：<code>billionbottle://</code></p>
</blockquote>
<p><strong>页面调用方式</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.location.href = schemeUrl;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>直接跳转链接即可，简单方便。</p>
<h5 id="负面情况"><a href="#负面情况" class="headerlink" title="负面情况"></a>负面情况</h5><ul>
<li>目前没有办法区分多个 App 都注册了相同 scheme 的情况；</li>
<li>不支持从其他 App 中的 WebView 直接跳转到目标 App；</li>
<li>Android 端微信，无法直接通过 scheme 唤起 App，可以通过引导或微信开放标签来解决；</li>
<li>只能通过 <code>hidden</code>、<code>blur</code> 等事件监听到是否安装 App；</li>
</ul>
<p>因此为了解决以上问题，iOS 和 Android 都有了自己的第二套解决方案，分别是 iOS 的 <strong>Universal Links</strong>，和 Android 的 <strong>App Links</strong>。</p>
<h3 id="App-Links"><a href="#App-Links" class="headerlink" title="App Links"></a>App Links</h3><p>在 2015 年的 Google I/O 大会上，Android M 宣布了一个新特性：<strong>App Links</strong>。它可以让用户在点击一个普通 Web 链接的时候可以打开指定 App 的对应页面，前提是这个 App 已经安装并且经过了验证，否则会显示一个打开确认选项的对话框，目前只支持 Android M 以上系统。</p>
<p><strong>App Links</strong> 的出现其实也是为了优化用户体验，在使用它唤醒 App 时会弹出一个对话框提示用户是否打开，缺点就是如果用户勾选了取消之后，可能之后就再也唤醒不了了。</p>
<p><strong>工作方式及流程</strong></p>
<ol>
<li><p>配置 AndroidManifest.xml；</p>
</li>
<li><p>配置 json 文件；</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">  <span class="attr">&quot;relation&quot;</span>: [<span class="string">&quot;delegate_permission/common.handle_all_urls&quot;</span>],</span><br><span class="line">  <span class="attr">&quot;target&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;namespace&quot;</span>: <span class="string">&quot;android_app&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;package_name&quot;</span>: <span class="string">&quot;包名&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;sha256_cert_fingerprints&quot;</span>: [<span class="string">&quot;签名&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></li>
<li><p>将 json 文件上传到指定域名的 .well-known 路径下，文件名定义为  assetlinks.json；</p>
</li>
<li><p>验证 <strong>App Links</strong>，可使用 AndroidStudio 里的 <strong>App Links Assistant</strong> 中的 <strong>Test App Links</strong> 进行测试或者在短信中输入链接点击测试，如果直接唤起 App 没有弹出对话框选择则说明 <strong>App Links</strong> 验证成功；</p>
</li>
</ol>
<p>总的来说与 <strong>Universal Links</strong> 的配置和验证很相似，差异不大。</p>
<p><a target="_blank" rel="noopener" href="https://developer.android.com/studio/write/app-link-indexing">https://developer.android.com/studio/write/app-link-indexing</a></p>
<p><a target="_blank" rel="noopener" href="http://www.androidchina.net/10135.html">http://www.androidchina.net/10135.html</a></p>
<h3 id="第三方服务"><a href="#第三方服务" class="headerlink" title="第三方服务"></a>第三方服务</h3><h5 id="微信相关的友情提示"><a href="#微信相关的友情提示" class="headerlink" title="微信相关的友情提示"></a>微信相关的友情提示</h5><p>微信已经成为大家日常必不可少的交流工具，用作推广 App 来说是再好不过的，但是微信内部通常是无法直接跳转至其他 App 的。那除了以上列出的技术方案，我们还可以如何去实现这个技术需求呢？</p>
<h5 id="应用宝"><a href="#应用宝" class="headerlink" title="应用宝"></a>应用宝</h5><p>如果你的页面需要能直接打开应用商店，可以把你的 App 上传到应用宝平台，因为应用宝和 AppStore 有合作，并且在内部实现了属于自己的一套流程，直接在微信中跳转应用宝的链接也是一个可选的方案。</p>
<h5 id="微信开放标签"><a href="#微信开放标签" class="headerlink" title="微信开放标签"></a>微信开放标签</h5><p>微信在 2020 年 5 月推出了微信开放标签功能，用于在微信浏览器内直接唤醒 App，也能通过携带参数直接进入 App 相应的页面，只要按照文档规定接入微信 SDK 就可直接使用该功能。</p>
<p>具体要求可以参考官方开放平台：<a href="https://link.juejin.cn/?target=https://developers.weixin.qq.com/doc/oplatform/Mobile_App/WeChat_H5_Launch_APP.html">微信官方文档</a>（ <a href="https://link.juejin.cn/?target=https://developers.weixin.qq.com/doc/oplatform/Mobile_App/WeChat_H5_Launch_APP.html">developers.weixin.qq.com/doc/oplatfo…</a> ）。</p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1652487">https://cloud.tencent.com/developer/article/1652487</a></p>
<p>deeplin VS AppLink</p>
<ul>
<li>Deep Links 是一种允许用户进入应用某个特定Activity的intent filter。点击这类链接时，系统可能会弹出一个选择列表，让用户在一堆能够处理这类链接的应用里(包括你的)选择一个来处理该链接。图一展示了这样一种情况：用户点击了一个地图相关的链接，系统弹出一个选择列表，让用户选择是要使用地图应用来处理，还是使用Chrome浏览器来处理。</li>
<li>App Links 是一种基于你的网站地址且验证通过的Deep Links。因此，点击一个这样的链接会直接打开你的应用(如果已经安装)，系统将不会弹出选择列表。当然，后续用户可以更改配好设置，来指定由哪个应用程序处理这类链接。</li>
</ul>
<table>
<thead>
<tr>
<th>item</th>
<th>Deep Links</th>
<th>App Links</th>
</tr>
</thead>
<tbody><tr>
<td>Intent URL Scheme</td>
<td>https, http，或者自定义</td>
<td>需为http或https</td>
</tr>
<tr>
<td>Intent Action</td>
<td>任意Action</td>
<td>需为<code>android.intent.action.VIEW</code></td>
</tr>
<tr>
<td>Intent Category</td>
<td>任意Category</td>
<td>需为<code>android.intent.category.BROWSABLE</code>和<code>android.intent.category.DEFAULT</code></td>
</tr>
<tr>
<td>链接验证</td>
<td>不需要</td>
<td>需要在网站上放置一个数字资产链接，并能够通过HTTPS访问</td>
</tr>
<tr>
<td>用户体验</td>
<td>可能会弹出一个选择列表给用户选择用哪个应用处理连接</td>
<td>没有弹框，系统直接打开你的应用处理网站连接</td>
</tr>
<tr>
<td>兼容性</td>
<td>所有Android版本</td>
<td>Android 6.0及以上</td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903954149539848">https://juejin.cn/post/6844903954149539848</a></p>
<p>由于大部分应用，如微博、微信、第三方浏览器(包括Chrome)，都不会将URL抛给系统处理(对scheme进行屏蔽)，因此App Links生效的情况就很有限了，比如只能从记事本应用、短信应用这些进行跳转。一般商用实现的是打开系统浏览器，通过系统浏览器打开应用的对应页面。</p>
<p>作者：JinBeen<br>链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903954149539848">https://juejin.cn/post/6844903954149539848</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>

	
	</div>
  <a type="button" href="/2022/10/17/AppLink/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/10/05/LC-Tree-Search-22/" >LC-Tree-Search-22</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-10-05  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h3 id="二叉树搜索-BST"><a href="#二叉树搜索-BST" class="headerlink" title="二叉树搜索 BST"></a>二叉树搜索 BST</h3><p><strong>根节点比左子树所有节点的数值都大，比右子树所有节点的数值都小.</strong> </p>
<h4 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700. 二叉搜索树中的搜索"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></h4><p>My idea</p>
<h5 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h5><ol>
<li><p>先序遍历搜索，如果找到了直接返回当前节点。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">searchBST</span><span class="params">(root: <span class="type">TreeNode</span>?, `<span class="keyword">val</span>`: <span class="type">Int</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (root.`<span class="keyword">val</span>` == `<span class="keyword">val</span>`) &#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> nodeLeft = searchBST(root.left, `<span class="keyword">val</span>`)</span><br><span class="line">    <span class="keyword">if</span> (nodeLeft != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nodeLeft</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> nodeRight = searchBST(root.right, `<span class="keyword">val</span>`)</span><br><span class="line">    <span class="keyword">if</span> (nodeRight != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nodeRight</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>看了官方解法,利用二叉搜索树的特性 </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">searchBST1</span><span class="params">(root: <span class="type">TreeNode</span>?, `<span class="keyword">val</span>`: <span class="type">Int</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> node: TreeNode? = root.left</span><br><span class="line">    <span class="keyword">if</span> (root.`<span class="keyword">val</span>` == `<span class="keyword">val</span>`) &#123; <span class="comment">//一开始没有做出来，这个条件没写,导致一直往下递归</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.`<span class="keyword">val</span>` &lt; `<span class="keyword">val</span>`) &#123;</span><br><span class="line">        node = root.right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> searchBST1(node, `<span class="keyword">val</span>`)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h5><p>二叉搜索树的迭代法相对简单，暂时先不看了</p>
<h4 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h4><p>二叉搜索树是一个有序树：</p>
<ul>
<li>若它的左子树不空，则左子树上<strong>所有结点</strong>的值均小于它的根结点的值；  注意==都不行</li>
<li>若它的右子树不空，则右子树上<strong>所有结点</strong>的值均大于它的根结点的值；</li>
<li>它的左、右子树也分别为二叉搜索树</li>
</ul>
<p>这就决定了，二叉搜索树，递归遍历和迭代遍历和普通二叉树都不一样。</p>
<p>一开始理解错了，只比较根节点和左右子树，导致下面这个testcase没通过，应该是根节点和所有的左右子树的节点数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5, 4, 6, null, null, 3, 7</span><br></pre></td></tr></table></figure>



<h5 id="转数组"><a href="#转数组" class="headerlink" title="转数组"></a>转数组</h5><p>把中序遍历转成数组很好理解</p>
<ol>
<li><p> 中序遍历递归 得到list数组</p>
</li>
<li><p>比较数组的前后节点大大小,</p>
</li>
<li><p>如果前面节点值更大，那么直接返回false, ==也不行</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isValidBST3</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    dfsTraversal(root) <span class="comment">// 中序遍历递归 得到list数组</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until list.size - <span class="number">1</span>) &#123; <span class="comment">// 比较数组的前后节点大大小</span></span><br><span class="line">        <span class="keyword">if</span> (list[i] &gt;= list[i + <span class="number">1</span>]) &#123; <span class="comment">// 如果前面节点值更大，那么直接返回false, ==也不行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dfsTraversal</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">    dfsTraversal(root.left)</span><br><span class="line">    list.add(root.`<span class="keyword">val</span>`)</span><br><span class="line">    dfsTraversal(root.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h5><p>随想录的递归解法，一开始怎么也理解不了，其实和上面 中序转数组的类似，就是把根据中序遍历遍历的节点，后一个节点一定比前一个节点的数值高。</p>
<ol>
<li>中序遍历 后一个节点比前一个节点的值大，就可以了，所以存储前一个节点。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> preNode: TreeNode? = <span class="literal">null</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isValidBST4</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (!isValidBST4(root.left)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (preNode != <span class="literal">null</span> &amp;&amp; preNode!!.`<span class="keyword">val</span>` &gt;= root.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    preNode = root</span><br><span class="line">    <span class="keyword">if</span> (!isValidBST4(root.right)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>之前的题主要用到 后序和先序，二叉搜索这里开始用到了 中序遍历。</p>
<h4 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530. 二叉搜索树的最小绝对差"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差</a></h4><p>My idea </p>
<p>这一题和上一题 98 思路差不多，</p>
<p>中序遍历的节点之间的数组相差最小，所以找出节点间的间隔最小值就可以了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> preNode: TreeNode? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">var</span> miniNum = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getMinimumDifference</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line">    getMinimumDifference(root.left)</span><br><span class="line">    <span class="keyword">if</span> (preNode != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> gapNum = root.`<span class="keyword">val</span>` - preNode!!.`<span class="keyword">val</span>`<span class="comment">//这一步可以简化 Math.min()</span></span><br><span class="line">        <span class="keyword">if</span> (gapNum &lt; miniNum) &#123;</span><br><span class="line">            miniNum = gapNum</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    preNode = root</span><br><span class="line">    getMinimumDifference(root.right)</span><br><span class="line">    <span class="keyword">return</span> miniNum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>也可以先中序遍历转成数组，然后求数组元素间的差值就可以了。</p>
<h4 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501. 二叉搜索树中的众数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数</a></h4><p>My idea</p>
<p>我的想法和上面的类似。</p>
<ol>
<li>中序遍历相邻节点用map存下value和值的个数。</li>
<li>遍历map求得最大个事的数组。把map按照value个数进行数组排序</li>
<li> 然后取排序后的前面的元素</li>
</ol>
<p>。了。/其实上面这种方式，用先序 后序都可以，都不需要二叉搜索树。</p>
<p>其实上面我的想法也是 打算用二叉搜索树的特性，放到map中，然后把map排序,就不知道怎么处理更好。看了随想录的处理方式,理了下思路.</p>
<ol>
<li>根据中序遍历的前后节点，他们的值相同的是一起的，进行遍历。</li>
<li>对value值进行count计数，如果count == 最大个数，加入集合。</li>
<li>如果count&gt;最大个数，清空集合.</li>
</ol>
<p>一开始不知道放哪里, maxCount=count ，以为在前面if (preNode != null &amp;&amp; preNode!!.<code>val</code> == node.<code>val</code>) 前面的比较里面,还想着Math.max,但是都不合适。然后看了一半随想录是放在更新节点的位置，更好.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> array = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findMode</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: IntArray &#123;</span><br><span class="line">    inDFS(root)</span><br><span class="line">    <span class="keyword">return</span> array.toIntArray()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> preNode: TreeNode? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">var</span> maxCount = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">inDFS</span><span class="params">(node: <span class="type">TreeNode</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> printNode = node?.`<span class="keyword">val</span>`</span><br><span class="line">    println(<span class="string">&quot;printNode <span class="variable">$printNode</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    inDFS(node.left)</span><br><span class="line">    <span class="keyword">if</span> (preNode != <span class="literal">null</span> &amp;&amp; preNode!!.`<span class="keyword">val</span>` == node.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        count++</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count == maxCount) &#123;</span><br><span class="line">        array.add(node.`<span class="keyword">val</span>`)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; maxCount) &#123;</span><br><span class="line">        maxCount = count<span class="comment">//这一步一开始不知道放哪里,看了一眼随想录答案</span></span><br><span class="line">        array.clear() <span class="comment">// 有更大的值，清空之前的集合</span></span><br><span class="line">        array.add(node.`<span class="keyword">val</span>`)</span><br><span class="line">    &#125;</span><br><span class="line">    preNode = node</span><br><span class="line">    inDFS(node.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>官方还有 o(1)的处理，while循环</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/solution/er-cha-sou-suo-shu-zhong-de-zhong-shu-by-leetcode-/">https://leetcode.cn/problems/find-mode-in-binary-search-tree/solution/er-cha-sou-suo-shu-zhong-de-zhong-shu-by-leetcode-/</a></p>
<h4 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h4><p>这一题有两种想法</p>
<ol>
<li>之前做的环形链表 走对方的路</li>
<li>先序遍历每一个节点，只要下面的节点都走过，只要下一个节点没有走到，就返回上一个节点，但是先序遍历DFS 两个节点都走了不知道怎么返回。</li>
</ol>
<p>看了随想录视频思路后 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1jd4y1B7E2">https://www.bilibili.com/video/BV1jd4y1B7E2</a></p>
<ol>
<li>后序遍历如果碰到p或q,就返回他们的节点.</li>
<li>如果一个节点的左右子树都不为空说明当前节点是他们的最近公共祖先.</li>
<li>还一种情况，有一个节点p就是祖先节点</li>
</ol>
<p>debug调试，拼凑把代码写出来了</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">lowestCommonAncestor</span><span class="params">(root: <span class="type">TreeNode</span>?, p: <span class="type">TreeNode</span>?, q: <span class="type">TreeNode</span>?)</span></span>: TreeNode? &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">// 随想录这里改成 碰到节点判断，直接在这里返回</span></span><br><span class="line"><span class="comment">//        val printData = root.`val`</span></span><br><span class="line"><span class="comment">//        println(printData)</span></span><br><span class="line">        <span class="keyword">val</span> leftNode = lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        <span class="keyword">val</span> rightNode = lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> (leftNode != <span class="literal">null</span> &amp;&amp; rightNode != <span class="literal">null</span>) &#123; <span class="comment">// 如果左右子树都不为空，那么当前节点就是最近公共祖先节点</span></span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; root.`<span class="keyword">val</span>` == p.`<span class="keyword">val</span>`) &#123;   <span class="comment">//碰到了其中一个节点返回</span></span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (q != <span class="literal">null</span> &amp;&amp; root.`<span class="keyword">val</span>` == q.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">            <span class="keyword">return</span> root                             <span class="comment">//碰到了其中一个节点返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftNode != <span class="literal">null</span>) <span class="keyword">return</span> leftNode       <span class="comment">//回溯之前碰到的节点</span></span><br><span class="line">        <span class="keyword">if</span> (rightNode != <span class="literal">null</span>) <span class="keyword">return</span> rightNode</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h5 id="终止条件写法"><a href="#终止条件写法" class="headerlink" title="终止条件写法"></a>终止条件写法</h5><p> 随想录这里改成 碰到节点判断，直接在这里返回，下次可以改成在终止条件这里，更简单</p>
<h4 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></h4><p>My idea</p>
<p>可以根据二叉搜索树的特性， 祖先节点的值大小有两种情况</p>
<ol>
<li>在p和q之前,</li>
<li>如果p&lt;q, 祖先节点的值 等于p , 大于q</li>
<li>只要满足上述条件，用先序遍历或者后序遍历都可以，把节点返回</li>
</ol>
<p>官方和随想录解法都是给出了相反的条件 ，当前节点&lt;p , &gt;q,在外面的情况（其实这里没想清楚,不存在这样的&lt;2 &gt;4的节点）, 但是我这里ide testcase也没问题。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/solution/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-26/">https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/solution/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-26/</a></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 很奇怪，IDE可以跑这个testcase没问题</span></span><br><span class="line"><span class="comment"> *[2,1]</span></span><br><span class="line"><span class="comment"> * 2</span></span><br><span class="line"><span class="comment"> * 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lowestCommonAncestor</span><span class="params">(root: <span class="type">TreeNode</span>?, p: <span class="type">TreeNode</span>?, q: <span class="type">TreeNode</span>?)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (p!!.`<span class="keyword">val</span>` &gt; q!!.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        swap(p, q)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.`<span class="keyword">val</span>` &gt; p.`<span class="keyword">val</span>` &amp;&amp; root.`<span class="keyword">val</span>` &lt; q.`<span class="keyword">val</span>`) &#123; </span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.`<span class="keyword">val</span>` == p.`<span class="keyword">val</span>` &amp;&amp; root.`<span class="keyword">val</span>` &lt; q.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.`<span class="keyword">val</span>` == q.`<span class="keyword">val</span>` &amp;&amp; root.`<span class="keyword">val</span>` &gt; p.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> leftNode = lowestCommonAncestor(root.left, p, q)</span><br><span class="line">    <span class="keyword">if</span> (leftNode != <span class="literal">null</span>) <span class="keyword">return</span> leftNode</span><br><span class="line">    <span class="keyword">val</span> rightNode = lowestCommonAncestor(root.right, p, q)</span><br><span class="line">    <span class="keyword">if</span> (rightNode != <span class="literal">null</span>) <span class="keyword">return</span> rightNode</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">swap</span><span class="params">(p: <span class="type">TreeNode</span>, q: <span class="type">TreeNode</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> temp = p.`<span class="keyword">val</span>`</span><br><span class="line">    p.`<span class="keyword">val</span>` = q!!.`<span class="keyword">val</span>`</span><br><span class="line">    q.`<span class="keyword">val</span>` = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0235.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html">https://programmercarl.com/0235.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Zt4y1F7ww">https://www.bilibili.com/video/BV1Zt4y1F7ww</a></p>
<p>看了随想录视频，其实相反的就两种情况</p>
<ol>
<li>当前节点 &lt;p , &lt;q， 那么p,q一定在右子树上，就去右子树去找</li>
<li>当前节点 &gt; p , &gt;q ,那么p,q一定在左子树上，就去左子树去找</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lowestCommonAncestor</span><span class="params">(root: <span class="type">TreeNode</span>?, p: <span class="type">TreeNode</span>?, q: <span class="type">TreeNode</span>?)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (root.`<span class="keyword">val</span>` &lt; p!!.`<span class="keyword">val</span>` &amp;&amp; root.`<span class="keyword">val</span>` &lt; q!!.`<span class="keyword">val</span>`) &#123; <span class="comment">// 当前节点比p和q的值都小，那么一定p,q一定在右子树上，就往右边遍历</span></span><br><span class="line">        <span class="keyword">val</span> rightNode = lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> (rightNode != <span class="literal">null</span>) <span class="keyword">return</span> rightNode</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root.`<span class="keyword">val</span>` &gt; p.`<span class="keyword">val</span>` &amp;&amp; root.`<span class="keyword">val</span>` &gt; q!!.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        <span class="keyword">val</span> leftNode = lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        <span class="keyword">if</span> (leftNode != <span class="literal">null</span>) <span class="keyword">return</span> leftNode</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a></h4><h5 id="DFS-1"><a href="#DFS-1" class="headerlink" title="DFS"></a>DFS</h5><p>My idea</p>
<p>可以用后序遍历，按照二叉树的特性，走到叶子节点后，连接到叶子节点，然后回溯到根节点并返回</p>
<ol>
<li>后序遍历根据待插入值和当前节点比较，找到需要插入的位置。</li>
<li>如果需要插入的位置左或右节点刚好为空，就插入。</li>
</ol>
<p>随想录其中一个解法和我的这个类似，不过感觉比我这个更复杂点</p>
<p>自己的做的解法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">insertIntoBST</span><span class="params">(root: <span class="type">TreeNode</span>?, `<span class="keyword">val</span>`: <span class="type">Int</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> TreeNode(`<span class="keyword">val</span>`) <span class="comment">//有一个这个test case  [] 5 ,空树的话返回 [5]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (`<span class="keyword">val</span>` &lt; root.`<span class="keyword">val</span>`) &#123; <span class="comment">// 插入点小于当前节点，往左子树中插入</span></span><br><span class="line">        insertIntoBST(root.left, `<span class="keyword">val</span>`)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (`<span class="keyword">val</span>` &gt; root.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        insertIntoBST(root.right, `<span class="keyword">val</span>`)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一开始这个放前面导致添加了两个5的左节点，因为 insertIntoBST(root.left, `val`)又走了一次</span></span><br><span class="line">    <span class="keyword">val</span> treeNode = TreeNode(`<span class="keyword">val</span>`) <span class="comment">// 只有一次机会走这个</span></span><br><span class="line">    <span class="keyword">if</span> (root.right == <span class="literal">null</span> &amp;&amp; `<span class="keyword">val</span>` &gt; root.`<span class="keyword">val</span>`) &#123; <span class="comment">//  待插入点大于当前节点，所以要插入右子树中，此时右子树为空，那么直接插入</span></span><br><span class="line">        root.right = treeNode</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; `<span class="keyword">val</span>` &lt; root.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        root.left = treeNode</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>看了随想录的解法，其实还可以每一个都被父节点接住更简单,也是后序遍历的精髓 </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">insertIntoBST</span><span class="params">(root: <span class="type">TreeNode</span>?, `<span class="keyword">val</span>`: <span class="type">Int</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> TreeNode(`<span class="keyword">val</span>`)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (`<span class="keyword">val</span>` &lt; root.`<span class="keyword">val</span>`) &#123; <span class="comment">// 插入点小于当前节点，往左子树中插入</span></span><br><span class="line">        root.left = insertIntoBST1(root.left, `<span class="keyword">val</span>`)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (`<span class="keyword">val</span>` &gt; root.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        root.right = insertIntoBST1(root.right, `<span class="keyword">val</span>`)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="迭代法-1"><a href="#迭代法-1" class="headerlink" title="迭代法"></a>迭代法</h5><p>官方用迭代法 ,看起来也不难</p>
<p> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/solution/er-cha-sou-suo-shu-zhong-de-cha-ru-cao-zuo-by-le-3/">https://leetcode.cn/problems/insert-into-a-binary-search-tree/solution/er-cha-sou-suo-shu-zhong-de-cha-ru-cao-zuo-by-le-3/</a></p>
<h4 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></h4><p>My idea</p>
<p>和上面思路类似，用后序遍历的 父节点接住，当前要删除节点的左或者右节点，那么当前节点就删除了，然后左右节点再改变指向。</p>
<ol>
<li><p>后序遍历到要删除的节点.</p>
</li>
<li><p>当前节点的右节点指向它的左节点。被上一个节点回溯的父节点接住。</p>
</li>
<li><p>返回当前节点的左节点，</p>
</li>
</ol>
<p>[5,3,6,2,4,null,7]<br>5<br>优先还是需要右节点上去，否则就很麻烦，需要4上去</p>
<p>删除节点主要有这5种情况</p>
<ul>
<li>第一种情况：没找到删除的节点，遍历到空节点直接返回了</li>
<li>找到删除的节点<ul>
<li>第二种情况：删除的左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</li>
<li>第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点</li>
<li>第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</li>
<li>第五种情况：删除节点的左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。</li>
</ul>
</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbj3k596mg30dq0aigyz.gif" alt="450.删除二叉搜索树中的节点"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">deleteNode</span><span class="params">(root: <span class="type">TreeNode</span>?, key: <span class="type">Int</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">//情况一</span></span><br><span class="line">    <span class="keyword">if</span> (key &lt; root.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        root.left = deleteNode(root.left, key)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        root.right = deleteNode(root.right, key)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key == root.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.right == <span class="literal">null</span> &amp;&amp; root.left == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">// 情况2  [0] 0 因为这个testcase 会返回[0]和预期不一致</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.left != <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;            <span class="comment">//情况三 如果左节点不为空</span></span><br><span class="line">            <span class="keyword">val</span> node = root.left  <span class="comment">// 左节点 2 推到删除的节点位置</span></span><br><span class="line">            <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;               <span class="comment">//这两句可以去掉 ，直接返回节点</span></span><br><span class="line">                node.right = root.right         <span class="comment">//此时左节点2在在删除节点位置，它的右子树指向之前右节点4</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.right != <span class="literal">null</span> &amp;&amp; root.left == <span class="literal">null</span>) &#123;  <span class="comment">//情况四 如果右节点不为空</span></span><br><span class="line">            <span class="keyword">val</span> node = root.right <span class="comment">//右节点4 推到删除的节点位置</span></span><br><span class="line">            <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;                 <span class="comment">//这两句可以去掉</span></span><br><span class="line">                node.left = root.left           <span class="comment">// 此时左节点4在在删除节点位置，它的左子树指向之前右节点2</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> rightNode = root.right <span class="comment">//情况五</span></span><br><span class="line">            <span class="keyword">var</span> leftNode = rightNode?.left</span><br><span class="line">            <span class="keyword">while</span> (leftNode?.left!= <span class="literal">null</span>) &#123;</span><br><span class="line">                leftNode = leftNode.left</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (leftNode != <span class="literal">null</span>) &#123;</span><br><span class="line">                leftNode.left = root.left</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rightNode.left = root.left</span><br><span class="line">            &#125;</span><br><span class="line">            root.left = <span class="literal">null</span></span><br><span class="line">            <span class="keyword">return</span> rightNode <span class="comment">// 这里返回的节点，可以被上面的左右子树接住</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="普通二叉树的节点删除"><a href="#普通二叉树的节点删除" class="headerlink" title="普通二叉树的节点删除"></a>普通二叉树的节点删除</h5><p>通用二叉树节点删除</p>
<p><img src="/2022/10/05/LC-Tree-Search-22/20221012115615.jpg"></p>
<p>要加if (leftNode != null)，否则删除报错</p>
<p>这个题目的leetcode的测试用例有问题,单独跑报错.</p>
<h4 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h4><p>看了随想录的解答，从中取中间节点的位置就可以了，如果数字是偶数，中间节点的两个中的一个都可以，</p>
<p>但是问题来了，为什么取中间节点构造的二叉树就是高度平衡的二叉搜索树呢?</p>
<p>先按照这个思路，把代码写出来</p>
<ol>
<li>按照先序遍历思路，先找到根节点，构造出中间节点。</li>
<li>根据中间节点划定新的数组的范围，左边和右边，然后递归找到新的数组的中间节点继续划出范围.</li>
</ol>
<p>在这里 左闭右闭更合理</p>
<p>这题主要注意边界值,if (left &gt; right）这个要注意是&gt; 没有=,因为index-1和index+1了，所以最终一定会超过right</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sortedArrayToBST</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">return</span> buildSearchTree(nums, <span class="number">0</span>, nums.size - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">buildSearchTree</span><span class="params">(nums: <span class="type">IntArray</span>, left: <span class="type">Int</span>, right: <span class="type">Int</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> index = <span class="comment">/*(start + end) / 2*/</span> left + (right - left) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">val</span> node = TreeNode(nums[index])</span><br><span class="line">    <span class="comment">// println(&quot;node $&#123;node.`val`&#125; :  start $left end $right&quot;)</span></span><br><span class="line">    node.left = buildSearchTree(nums, left, index - <span class="number">1</span>)</span><br><span class="line">    node.right = buildSearchTree(nums, index + <span class="number">1</span>, right)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538. 把二叉搜索树转换为累加树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></h4><p>累加树: 按照中序遍历的到的 从小到大的数组 [1,2,3,4] ,累加树就是右到左的值相加 [10,9,7,4]</p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0538.%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91.html#%E9%80%92%E5%BD%92">https://programmercarl.com/0538.%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91.html#%E9%80%92%E5%BD%92</a></p>
<p>中序遍历的树 : 左 中 右 2 , 5, 13</p>
<p>反中序遍历的: 右 中 左 13 , 5 , 2</p>
<p>然后按照反中序遍历的到节点累加就可以了。</p>
<img src="https://img-blog.csdnimg.cn/20210204153440666.png" alt="538.把二叉搜索树转换为累加树" style="zoom:50%;">



<p>这一题一开始没想上面的思路，看了随想录的思路后,写出来的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">convertBST</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    convertBST(root.right)</span><br><span class="line">    sum += root.`<span class="keyword">val</span>`</span><br><span class="line">    root.`<span class="keyword">val</span>` = sum</span><br><span class="line">    convertBST(root.left)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>根据中序遍历的规则，写出反中序 右中左遍历节点。</li>
<li>拿到每次中序的到的节点累加，然后赋值给当前节点。</li>
</ol>
<pre><code>sum += root.`val`
root.`val` = sum
</code></pre>
<p>这一段可以改进，可以保存前一个节点值，然后加上当前节点就可以了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pre = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">convertBST1</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    convertBST(root.right)</span><br><span class="line">    root.`<span class="keyword">val</span>` += pre</span><br><span class="line">    pre = root.`<span class="keyword">val</span>`</span><br><span class="line">    convertBST(root.left)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

	
	</div>
  <a type="button" href="/2022/10/05/LC-Tree-Search-22/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/09/15/Fragment-StateLoss/" >Fragment_StateLoss</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-09-15  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<p>问题 ，Activity恢复后 mStateSaved,是怎么恢复的？</p>
<p>就是onSavedInstanceState 的官方API文档2</p>
<p>这里问题的场景是Activity已经关闭了,rpc请求很久再回来,导致了这个问题,所以我觉得判断livedate激活状态就可以了</p>
<p>可是这个改动应该只能在resume吧？</p>
<p>LiveData started 和 resumed 都可以</p>
<p>Livedata 会感知activity生命周期</p>
<p>这个有可能 activity 也在 started / resumed 状态下发出吧？ 这样的话，showDialog 应该也还会崩溃，因为onSavedInstanceState 是在 paused 时候发生的，这个时候应该还是 started 状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"></span><br><span class="line">* 后续考虑做个技改把它加到[BaseDialogFragment]里面</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">fun showWithLifecycle(fragmentActivity: FragmentActivity, tag: String? &#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">  val liveData &#x3D; showWithLifecycleLiveData ?: MutableLiveData&lt;Boolean&gt;().also &#123;</span><br><span class="line"></span><br><span class="line">    it.observe(fragmentActivity) &#123; this.show(fragmentActivity.supportFragmentManager, tag) &#125;</span><br><span class="line"></span><br><span class="line">    showWithLifecycleLiveData &#x3D; it</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  liveData.value &#x3D; true</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p>onSaveInstanceState保存分析</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6995791487426363405">https://juejin.cn/post/6995791487426363405</a></p>
<p>状态恢复</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/58579627f70a">https://www.jianshu.com/p/58579627f70a</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7057564670567120903">https://juejin.cn/post/7057564670567120903</a></p>
<p> <strong>can not perform this action after onsaveinstancestate dialogfragment show</strong> </p>
<p>developer  -&gt; 不保留活动 </p>
<p>onSaveInstanceState以下5种情况被调用：</p>
<p>1、当用户按下手机home键的时候。</p>
<p>2、长按手机home键或者按下菜单键时。</p>
<p>3、手机息屏时。</p>
<p>4、FirstActivity启动SecondActivity，FirstActivity就会调用，也就是说打开新Activity时，原Activity就会调用。</p>
<p>5、默认情况下横竖屏切换时。</p>
<p>打开Activity -&gt; Home  -&gt; 再从后台拿出来</p>
<p><img src="/2022/09/15/Fragment-StateLoss/20220919212018.jpg" alt="20220919212018"></p>
<p>既然状态的保存与恢复都必须要把Fragment带上，那么一旦当Fragment的状态已保存过了，那么就不应该再改变Fragment的状态。因此FragmentManager的每一个操作前，都会调用一个方法来检查状态是否保存过了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkStateLoss</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mStateSaved) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    <span class="string">&quot;Can not perform this action after onSaveInstanceState&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mNoTransactionsBecause != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    <span class="string">&quot;Can not perform this action inside of &quot;</span> + mNoTransactionsBecause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This is the same as &#123;<span class="doctag">@link</span> #onSaveInstanceState&#125; but is called for activities</span></span><br><span class="line"><span class="comment"> * created with the attribute &#123;<span class="doctag">@link</span> android.R.attr#persistableMode&#125; set to</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;persistAcrossReboots&lt;/code&gt;. The &#123;<span class="doctag">@link</span> android.os.PersistableBundle&#125; passed</span></span><br><span class="line"><span class="comment"> * in will be saved and presented in &#123;<span class="doctag">@link</span> #onCreate(Bundle, PersistableBundle)&#125;</span></span><br><span class="line"><span class="comment"> * the first time that this activity is restarted following the next device reboot.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> outState Bundle in which to place your saved state.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> outPersistentState State which will be saved across reboots.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #onSaveInstanceState(Bundle)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #onCreate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #onRestoreInstanceState(Bundle, PersistableBundle)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #onPause</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(<span class="meta">@NonNull</span> Bundle outState,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@NonNull</span> PersistableBundle outPersistentState)</span> </span>&#123;</span><br><span class="line">    onSaveInstanceState(outState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>为什么会有这个异常</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lzf_acraftsman/article/details/108831949">https://blog.csdn.net/lzf_acraftsman/article/details/108831949</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903458605105160">https://juejin.cn/post/6844903458605105160</a></p>
<p>fragment重叠原因</p>
<h4 id="Fragment懒加载"><a href="#Fragment懒加载" class="headerlink" title="Fragment懒加载"></a>Fragment懒加载</h4><p>Fragment和ViewPager一起使用会有个预加载机制，会把旁白的Fragment的生命周期方法<br>前半段先执行，然后执行自身的生命周期方法</p>
<p>在项目终从其他页面回到MainAcitivty的时候，三个页面的生命周期方法都跑了一遍</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　  D&#x2F;FinanceFragment         Test: onStart()</span><br><span class="line">D&#x2F;WealthFragment         Test: onStart()</span><br><span class="line">D&#x2F;MineFragment         Test: onStart()</span><br><span class="line">D&#x2F;FinanceFragment         Test: onResume()</span><br><span class="line">D&#x2F;WealthFragment         Test: onResume()</span><br><span class="line">D&#x2F;MineFragment         Test: onResume()</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">     </span><br><span class="line">    private boolean isPrepared;  &#x2F;&#x2F;判断view是否加载完成,在视图未初始化的时候，在lazyLoad当中就使用的话，就会有空指针的异常</span><br><span class="line">    private boolean isVisible;  &#x2F;&#x2F;判断当前Fragment是否可见状态,标志已经初始化完成，因为setUserVisibleHint是在onCreateView之前调用的</span><br><span class="line">	  @Override</span><br><span class="line">    public void onViewCreated(View view, @Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onViewCreated(view, savedInstanceState);</span><br><span class="line">        isPrepared &#x3D; true;</span><br><span class="line">        lazyLoad();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    @Override</span><br><span class="line">    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) &#123;</span><br><span class="line">&#x2F;&#x2F;        Log.d(TAG + &quot;         Test&quot;, &quot; onCreateView()&quot;);</span><br><span class="line"></span><br><span class="line">        if (rootView &#x3D;&#x3D; null) &#123;</span><br><span class="line">            int view &#x3D; setLayoutId();</span><br><span class="line">            if (view !&#x3D; 0) &#123;</span><br><span class="line">                rootView &#x3D; inflater.inflate(view, container, false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ViewGroup parent &#x3D; (ViewGroup) rootView.getParent();</span><br><span class="line">            if (parent !&#x3D; null) &#123;</span><br><span class="line">                parent.removeView(rootView);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        initView(rootView);</span><br><span class="line">        return rootView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;  http:&#x2F;&#x2F;www.10tiao.com&#x2F;html&#x2F;565&#x2F;201702&#x2F;2247483988&#x2F;1.html</span><br><span class="line">    &#x2F;&#x2F; 标志位，标志已经初始化完成，因为setUserVisibleHint是在onCreateView之前调用的，</span><br><span class="line">    &#x2F;&#x2F; 在视图未初始化的时候，在lazyLoad当中就使用的话，就会有空指针的异常</span><br><span class="line">    private boolean isPrepared;</span><br><span class="line">    &#x2F;&#x2F;标志当前页面是否可见</span><br><span class="line">    private boolean isVisible;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setUserVisibleHint(boolean isVisibleToUser) &#123;</span><br><span class="line">        super.setUserVisibleHint(isVisibleToUser);</span><br><span class="line">&#x2F;&#x2F;        Log.d(TAG + &quot;         Test&quot;, &quot; setUserVisibleHint() is Visible : ?  &quot; + isVisibleToUser);</span><br><span class="line"></span><br><span class="line">        if (getUserVisibleHint()) &#123;</span><br><span class="line">            isVisible &#x3D; true;</span><br><span class="line">            onVisible();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            isVisible &#x3D; false;</span><br><span class="line">            onInvisible();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void onInvisible() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void onVisible() &#123;</span><br><span class="line">        lazyLoad();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void lazyLoad() &#123;</span><br><span class="line">        if (!isVisible || !isPrepared) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        requestData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 请求数据</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected void requestData() &#123;</span><br><span class="line">        Log.d(TAG + &quot;         Test&quot;, &quot; requestData &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> <a target="_blank" rel="noopener" href="http://www.10tiao.com/html/565/201702/2247483988/1.html">http://www.10tiao.com/html/565/201702/2247483988/1.html</a></p>
<h4 id="Activity-dialogFragment-的事件回调"><a href="#Activity-dialogFragment-的事件回调" class="headerlink" title="Activity  dialogFragment 的事件回调"></a>Activity  dialogFragment 的事件回调</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface ISelectListener &#123;</span><br><span class="line">    fun getItemPosition(position: Int)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var mListener: ISelectListener? &#x3D; null</span><br><span class="line"></span><br><span class="line">override fun onAttach(context: Context) &#123;</span><br><span class="line">    super.onAttach(context)</span><br><span class="line">    if (parentFragment is ISelectListener)&#123;</span><br><span class="line">        mListener &#x3D; parentFragment  as ISelectListener</span><br><span class="line">    &#125;else if (context is ISelectListener) &#123;</span><br><span class="line">        mListener &#x3D; context</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw RuntimeException(context!!.toString() + &quot; must implement ISelectListener&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://developer.android.com/guide/components/fragments.html">https://developer.android.com/guide/components/fragments.html</a></p>
<p>onHiddenChanged切换刷新</p>
<p>使用hide()/show()发现生命周期基本不执行，不过可以用到这个onHiddenChanged();</p>
<p>看下执行的生命周期;   从 SecondFragment 页面开始到 -&gt;FirstFragment </p>
<blockquote>
<p>07-18 15:53:25.128 7758-7758/com.mineutils D/SecondFragment: onAttach(Context context)<br>07-18 15:53:25.129 7758-7758/com.mineutils D/SecondFragment: onCreate()<br>07-18 15:53:25.142 7758-7758/com.mineutils D/SecondFragment: onCreateView()<br>07-18 15:53:25.148 7758-7758/com.mineutils D/SecondFragment:  onViewCreated<br>                                                              onActivityCreated()<br>                                                              onStart()<br>​                                                                  onResume()</p>
<p>07-18 15:53:34.200 7758-7758/com.mineutils D/SecondFragment: onHiddenChanged hidden   true<br>07-18 15:53:34.207 7758-7758/com.mineutils D/FirstFragment:    onCreateView()<br>07-18 15:53:34.208 7758-7758/com.mineutils D/FirstFragment:    onViewCreated<br>                                                            onActivityCreated()<br>​                                                           onStart()</p>
<p>07-18 15:53:53.968 7758-7758/com.mineutils D/FirstFragment: onHiddenChanged hidden   true<br>07-18 15:53:53.968 7758-7758/com.mineutils D/SecondFragment: onHiddenChanged hidden   false</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/cml_blog/article/details/41411451">https://blog.csdn.net/cml_blog/article/details/41411451</a></p>
<h4 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h4><p><a target="_blank" rel="noopener" href="https://wizardforcel.gitbooks.io/w3school-android/content/77.html">https://wizardforcel.gitbooks.io/w3school-android/content/77.html</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5901b564570c35005804424b">https://juejin.im/post/5901b564570c35005804424b</a></p>

	
	</div>
  <a type="button" href="/2022/09/15/Fragment-StateLoss/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/09/11/LC-TREE08/" >LC_TREE08</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-09-11  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h4 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></h4><h5 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h5><p>层序遍历是没法实现的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isSymmetric3</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.offer(root)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">            <span class="keyword">val</span> layerSize = queue.size</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until layerSize) &#123;</span><br><span class="line"><span class="comment">//                val lastIndex = layerSize - 1 - i // 这样不可以,poll取出元素后，就少了元素越界了</span></span><br><span class="line">                <span class="keyword">val</span> headNode = queue.poll()</span><br><span class="line"></span><br><span class="line">                <span class="keyword">val</span> lastNode = queue.lastOrNull()</span><br><span class="line">                <span class="keyword">if</span> (headNode.`<span class="keyword">val</span>` != lastNode?.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">                headNode.left?.let &#123; queue.offer(it) &#125;</span><br><span class="line">                headNode.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><p>// 不能判断true,判断true直接返回了，判断false返回没问题，true返回就不会往下走了</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">leftRightSymmetric</span><span class="params">(nodeLeft: <span class="type">TreeNode</span>?, nodeRight: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nodeLeft?.`<span class="keyword">val</span>` == nodeRight?.`<span class="keyword">val</span>`) &#123; <span class="comment">// 不能判断true,判断true直接返回了，判断false返回没问题，true返回就不会往下走了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeLeft == nodeRight) &#123; <span class="comment">// = null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    leftRightSymmetric(nodeLeft?.left, nodeRight?.right)</span><br><span class="line">    leftRightSymmetric(nodeLeft?.right, nodeRight?.left)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E9%80%92%E5%BD%92%E6%B3%95">https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E9%80%92%E5%BD%92%E6%B3%95</a></p>
<p>从根节点的左右子树开始，深度遍历比较</p>
<p><img src="https://img-blog.csdnimg.cn/20210203144624414.png"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isSymmetric</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> leftRightSymmetric(root?.left, root?.right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">leftRightSymmetric</span><span class="params">(nodeLeft: <span class="type">TreeNode</span>?, nodeRight: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nodeLeft == <span class="literal">null</span> &amp;&amp; nodeRight != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeLeft != <span class="literal">null</span> &amp;&amp; nodeRight == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeLeft?.`<span class="keyword">val</span>` != nodeRight?.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeLeft == <span class="literal">null</span> &amp;&amp; nodeRight == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">//这里需要，否则就递归 溢出了,如果根节点的左右节点为null,退出也是没问题的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> leftFlag = leftRightSymmetric(nodeLeft?.left, nodeRight?.right)</span><br><span class="line">    <span class="keyword">val</span> rightFlag = leftRightSymmetric(nodeLeft?.right, nodeRight?.left)</span><br><span class="line">    <span class="keyword">return</span> leftFlag &amp;&amp; rightFlag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnwcimlj8lg30hm0bqnpd.gif"></p>
<p>队列，一直向下按照对称的条件添加</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isSymmetric1</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123; </span><br><span class="line">        root.left?.let &#123; queue.offer(it) &#125; <span class="comment">// 官方解法中，根节点入队2次也可以</span></span><br><span class="line">        root.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> node1 = queue.poll()</span><br><span class="line">        <span class="keyword">val</span> node2 = queue.poll()</span><br><span class="line">        <span class="keyword">if</span>(node1==<span class="literal">null</span>&amp;&amp;node2==<span class="literal">null</span>)&#123; <span class="comment">// 一开始没写这个条件，提示超出时间限制</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node1?.`<span class="keyword">val</span>` != node2?.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        queue.offer(node1?.left) <span class="comment">// 两边的节点比较</span></span><br><span class="line">        queue.offer(node2?.right)</span><br><span class="line">        queue.offer(node1?.right) <span class="comment">//中间的节点比较</span></span><br><span class="line">        queue.offer(node2?.left)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>栈也是可以的，只要保证位置靠近</p>
<h4 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/same-tree/">100. 相同的树</a></h4><h5 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isSameTree</span><span class="params">(p: <span class="type">TreeNode</span>?, q: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span> &amp;&amp; q != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p?.`<span class="keyword">val</span>` == q?.`<span class="keyword">val</span>` &amp;&amp; isSameTree(p?.left, q?.left) &amp;&amp; isSameTree(p?.right, q?.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="队列-1"><a href="#队列-1" class="headerlink" title="队列"></a>队列</h5><img src="/2022/09/11/LC-TREE08/20220912130345.jpg" alt="20220912130345" style="zoom: 67%;">

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isSameTree1</span><span class="params">(p: <span class="type">TreeNode</span>?, q: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span> &amp;&amp; q != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    queue.offer(p)</span><br><span class="line">    queue.offer(q)</span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> node1 = queue.poll()</span><br><span class="line">        <span class="keyword">val</span> node2 = queue.poll()</span><br><span class="line">        <span class="keyword">if</span> (node1 == <span class="literal">null</span> &amp;&amp; node2 == <span class="literal">null</span>) &#123; <span class="comment">// continue后，因为null,就不会加入新的节点</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node1?.`<span class="keyword">val</span>` != node2?.`<span class="keyword">val</span>`) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        queue.offer(node1?.left)</span><br><span class="line">        queue.offer(node2?.left)</span><br><span class="line">        queue.offer(node1?.right)</span><br><span class="line">        queue.offer(node2?.right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="572-另一棵树的子树"><a href="#572-另一棵树的子树" class="headerlink" title="572. 另一棵树的子树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subtree-of-another-tree/">572. 另一棵树的子树</a></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isSubtree</span><span class="params">(root: <span class="type">TreeNode</span>?, subRoot: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span> &amp;&amp; subRoot == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root == <span class="literal">null</span> &amp;&amp; subRoot != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root != <span class="literal">null</span> &amp;&amp; subRoot == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isSameTree(root, subRoot) || isSubtree(root?.left, subRoot) || isSubtree(root?.right, subRoot) <span class="comment">//subRoot和root相同,subRoot和root左子树相同，subRoot和右子树相同</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isSameTree</span><span class="params">(node1: <span class="type">TreeNode</span>?, node2: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node1 == <span class="literal">null</span> &amp;&amp; node2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node1 == <span class="literal">null</span> &amp;&amp; node2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node1 != <span class="literal">null</span> &amp;&amp; node2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node1?.`<span class="keyword">val</span>` == node2?.`<span class="keyword">val</span>` &amp;&amp; isSameTree(node1?.left, node2?.left) &amp;&amp; isSameTree(</span><br><span class="line">        node1?.right,</span><br><span class="line">        node2?.right</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h4><h5 id="DFS-普通二叉树解法"><a href="#DFS-普通二叉树解法" class="headerlink" title="DFS 普通二叉树解法"></a>DFS 普通二叉树解法</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countNodes</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> leftCount = countNodes(root.left)</span><br><span class="line">    <span class="keyword">val</span> rightCount = countNodes(root.right)</span><br><span class="line">    <span class="keyword">return</span> leftCount + rightCount + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countNodes1</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.offer(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> size = queue.size</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until size) &#123;</span><br><span class="line">            <span class="keyword">val</span> treeNode = queue.poll()</span><br><span class="line">            count++</span><br><span class="line">            treeNode.left?.let &#123; queue.offer(it) &#125;</span><br><span class="line">            treeNode.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="DFS-完全二叉树特性"><a href="#DFS-完全二叉树特性" class="headerlink" title="DFS 完全二叉树特性"></a>DFS 完全二叉树特性</h5><p>一开始打算用先序遍历，但是这样不行,</p>
<p>如果一颗树 是平衡的，永远是得到 1,  想了一下，这种也不属于 先序遍历</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countNodes</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> depth = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> postTraversal(root, depth)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">postTraversal</span><span class="params">(root: <span class="type">TreeNode</span>?, depth: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isBalanced(root)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> shl (depth - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> leftNums = postTraversal(root?.left, depth + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> rightNums = postTraversal(root?.right, depth + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> leftNums + rightNums + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countNodes</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> leftNode = root.left</span><br><span class="line">    <span class="keyword">var</span> depthLeft = <span class="number">0</span> <span class="comment">//左子树深度</span></span><br><span class="line">    <span class="keyword">while</span> (leftNode != <span class="literal">null</span>) &#123;</span><br><span class="line">        leftNode = leftNode.left</span><br><span class="line">        depthLeft++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> rightNode = root.right</span><br><span class="line">    <span class="keyword">var</span> depthRight = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (rightNode != <span class="literal">null</span>) &#123;</span><br><span class="line">        rightNode = rightNode.right</span><br><span class="line">        depthRight++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (depthLeft == depthRight) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">2</span> shl depthLeft) - <span class="number">1</span> <span class="comment">// 节点数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> leftNums = countNodes(root.left)</span><br><span class="line">    <span class="keyword">val</span> rightNums = countNodes(root.right)</span><br><span class="line">    <span class="keyword">return</span> leftNums + rightNums + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countNodes3</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> leftNode = root.left</span><br><span class="line">    <span class="keyword">var</span> depthLeft = <span class="number">0</span> <span class="comment">//左子树深度</span></span><br><span class="line">    <span class="keyword">while</span> (leftNode != <span class="literal">null</span>) &#123;</span><br><span class="line">        leftNode = leftNode.left</span><br><span class="line">        depthLeft++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> rightNode = root.right</span><br><span class="line">    <span class="keyword">var</span> depthRight = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (rightNode != <span class="literal">null</span>) &#123;</span><br><span class="line">        rightNode = rightNode.right</span><br><span class="line">        depthRight++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> leftNums = countNodes(root.left)</span><br><span class="line">    <span class="keyword">val</span> rightNums = countNodes(root.right)</span><br><span class="line">    <span class="keyword">if</span> (depthLeft == depthRight) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">2</span> shl depthLeft) - <span class="number">1</span> <span class="comment">// 节点数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> leftNums + rightNums + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树</a></h4><p>一开始错误的解答是这样的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isBalanced</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> postTraversal(root) != -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">postTraversal</span><span class="params">(node: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> leftDepth = postTraversal(node.left)</span><br><span class="line">        <span class="keyword">val</span> rightDepth = postTraversal(node.right)</span><br><span class="line">        <span class="keyword">val</span> isBalance = Math.abs(leftDepth - rightDepth) &lt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (isBalance) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(leftDepth, rightDepth) + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里问题是   return -1，作为父节点的深度返回给了 depth，然后继续计算 Math.abs(leftDepth - rightDepth) &lt;= 1，出现了问题</p>
<p>改进解法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isBalanced</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> postTraversal(root) != -<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">postTraversal</span><span class="params">(node: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> leftDepth = postTraversal(node.left)</span><br><span class="line">    <span class="keyword">val</span> rightDepth = postTraversal(node.right)</span><br><span class="line">    <span class="keyword">if</span> (leftDepth == -<span class="number">1</span> || rightDepth == -<span class="number">1</span>) &#123; <span class="comment">// 子节点已经有不是平衡的节点 直接返回，来判断</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> isBalance = Math.abs(leftDepth - rightDepth) &lt;= <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (isBalance) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftDepth, rightDepth) + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>随想录迭代遍历，看起来很复杂，看起来是统一解法.</p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E9%A2%98%E5%A4%96%E8%AF%9D">https://programmercarl.com/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E9%A2%98%E5%A4%96%E8%AF%9D</a></p>
<h4 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-paths/">257. 二叉树的所有路径</a></h4><h5 id="隐藏回溯过程"><a href="#隐藏回溯过程" class="headerlink" title="隐藏回溯过程"></a>隐藏回溯过程</h5><p>这一题 没理解透字符串怎么形成的和回溯的, 用到了先序遍历，</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ZG411G7Dh">https://www.bilibili.com/video/BV1ZG411G7Dh</a> 视频包含了回溯过程</p>
<p> 可以看下随想录回溯过程</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">binaryTreePaths</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: List&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> result = LinkedList&lt;String&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    dfs(root, result, root.`<span class="keyword">val</span>`.toString())</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://www.youtube.com/watch?v=swG70SQBJ-A</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. String不能用 StringBuilder,存在引用传递问题，会输出</span></span><br><span class="line"><span class="comment"> *    [&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;2-&gt;5-&gt;3&quot;]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. 在先序位置 val存到path也有问题,头节点会存在重复的情况 [&quot;1-&gt;1-&gt;2-&gt;5&quot;,&quot;1-&gt;1-&gt;2-&gt;5-&gt;3&quot;]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(node: <span class="type">TreeNode</span>?, result: <span class="type">LinkedList</span>&lt;<span class="type">String</span>&gt;, path: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        result.add(path)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        dfs(node.left, result, <span class="string">&quot;<span class="variable">$path</span>-&gt;<span class="subst">$&#123;node.left.`val`&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        dfs(node.right, result, <span class="string">&quot;<span class="variable">$path</span>-&gt;<span class="subst">$&#123;node.right.`val`&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面2的情况演示</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(node: <span class="type">TreeNode</span>?, result: <span class="type">LinkedList</span>&lt;<span class="type">String</span>&gt;, path: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">val</span> mPath = <span class="string">&quot;<span class="variable">$path</span>-&gt; <span class="subst">$&#123;node.`val`&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        result.add(mPath)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        dfs(node.left, result, mPath)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        dfs(node.right, result, mPath)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面两种写法，回溯隐藏在参数里面.</p>
<h5 id="显示回溯"><a href="#显示回溯" class="headerlink" title="显示回溯"></a>显示回溯</h5><p>这是随想录的代码，二刷可以自己写, </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">binaryTreePaths</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: List&lt;String&gt;? &#123;</span><br><span class="line">    <span class="keyword">val</span> res: MutableList&lt;String&gt; = ArrayList()</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> paths: MutableList&lt;<span class="built_in">Int</span>&gt; = ArrayList()</span><br><span class="line">    traversal(root, paths, res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">traversal</span><span class="params">(root: <span class="type">TreeNode</span>, paths: <span class="type">MutableList</span>&lt;<span class="type">Int</span>&gt;, res: <span class="type">MutableList</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    paths.add(root.`<span class="keyword">val</span>`)</span><br><span class="line">    <span class="comment">// 叶子结点</span></span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123; <span class="comment">// 碰到叶子节点，开始把path遍历放进string中 </span></span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        <span class="keyword">val</span> sb = StringBuilder()</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until paths.size - <span class="number">1</span>) &#123;</span><br><span class="line">            sb.append(paths[i]).append(<span class="string">&quot;-&gt;&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(paths[paths.size - <span class="number">1</span>]) <span class="comment">//也可以放到上面一起再把&quot;-&gt;&quot; 删除</span></span><br><span class="line">        res.add(sb.toString()) </span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        traversal(root.left, paths, res)</span><br><span class="line">        paths.removeAt(paths.size - <span class="number">1</span>) <span class="comment">// 回溯  </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        traversal(root.right, paths, res)</span><br><span class="line">        paths.removeAt(paths.size - <span class="number">1</span>) <span class="comment">// 回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paths.removeAt(paths.size - 1) 最初这里没理解，都删除了，为什么,上面还能遍历所有节点，其实递归是一致先走的，碰到叶子节点的时候，遍历path, 最后才开始 paths.removeAt(paths.size - 1) 回溯 到上面. </span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html">https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ZG411G7Dh">https://www.bilibili.com/video/BV1ZG411G7Dh</a></p>
<p>迭代法 后面再说吧</p>
<h4 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404. 左叶子之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-left-leaves/">404. 左叶子之和</a></h4><p>这一题和【 222 完全二叉树的节点个数】很像，这里是普通的二叉树，所以我的想法就前两种做法</p>
<ol>
<li>后序遍历</li>
<li>层序遍历</li>
</ol>
<p>把根节点换成左子树的节点</p>
<p>看错了题目，其实是左子树叶子值的和</p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C.html#%E6%80%9D%E8%B7%AF">https://programmercarl.com/0404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C.html#%E6%80%9D%E8%B7%AF</a></p>
<p>只看了随想录题解，自己这样写的代码</p>
<h5 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sumOfLeftLeaves</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> dfsLeaves(root, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> direction 0 右子树， 1：左子树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dfsLeaves</span><span class="params">(node: <span class="type">TreeNode</span>?, direction: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span> &amp;&amp; direction == <span class="number">1</span>) &#123; <span class="comment">// 左右子树为空，根据父亲节点的传入，判断它是左子树</span></span><br><span class="line">        <span class="keyword">return</span> node.`<span class="keyword">val</span>` <span class="comment">//这种情况返回值，根据后序规则，上层节点叠加</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> leftCount = dfsLeaves(node.left, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> rightCount = dfsLeaves(node.right, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> leftCount + rightCount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>看了随想录解法，可以直接看更下一层节点，就不用再传入方向了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">          leftValue = root-&gt;left-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>迭代法</p>
<p>随想录统一迭代法</p>
<h4 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513. 找树左下角的值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513. 找树左下角的值</a></h4><p>想了下</p>
<ol>
<li>层序遍历可以解决</li>
<li>递归法还没想道，到了最底层，没想到如何判断 哪个是最左边的。</li>
</ol>
<h5 id="BFS-1"><a href="#BFS-1" class="headerlink" title="BFS"></a>BFS</h5><p>先存下来每一层的第一个节点，知道queue为空，那么最后一层的头节点就是要返回的.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findBottomLeftValue1</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.offer(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> leftNodeVal = root?.`<span class="keyword">val</span>`</span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> size = queue.size</span><br><span class="line">        leftNodeVal = queue.peek().`<span class="keyword">val</span>` <span class="comment">//每一层的第一个节点</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until size) &#123;</span><br><span class="line">            <span class="keyword">val</span> node = queue.poll()</span><br><span class="line">            node?.left?.let &#123; queue.offer(it) &#125;</span><br><span class="line">            node?.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> leftNodeVal!! <span class="comment">// queue为empty的时候退出，此时上一层存的节点就是最左边的节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h5><p>My idea</p>
<ol>
<li><p>一开始以为树的层级里，树的左边的值小于右边，来得出结果，但是这是二叉树，不是平衡形的，即使平衡这种思路也不一定对.</p>
</li>
<li><p>然后又看了树结构,想了下可以用 inorder traversal ,中序遍历, 层数最深，然后最先得到的数据就是要拿到的结果. </p>
<p>想下面8肯定是后面遍历到的</p>
</li>
</ol>
<p><img src="/2022/09/11/LC-TREE08/20220924155016.jpg" alt="20220924155016"></p>
<ol>
<li>一开始不知道leetcode可以用全局变量，用对象返回还很麻烦，删掉了</li>
<li>判断层级，如果大于之前的深度，那么就更新深度和值</li>
<li>中序和后序肯定没问题，但是先序不确定（随想录说是可以的）而且随想录 depth + 1 展开了用回溯</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mDepth = <span class="number">0</span> <span class="comment">//一开始不知道leetcode可以用全局变量，用对象返回还很麻烦，删掉了</span></span><br><span class="line"><span class="keyword">var</span> result = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findBottomLeftValue</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    inOrderTraversal(root, mDepth)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最左边的节点最先访问到</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">inOrderTraversal</span><span class="params">(node: <span class="type">TreeNode</span>?, depth: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">    inOrderTraversal(node.left, depth + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> (depth + <span class="number">1</span> &gt; mDepth) &#123; <span class="comment">// 判断层级，如果大于之前的深度，那么就更新深度和值</span></span><br><span class="line">        mDepth = depth + <span class="number">1</span></span><br><span class="line">        result = node.`<span class="keyword">val</span>`</span><br><span class="line">    &#125;</span><br><span class="line">    inOrderTraversal(node.right, depth + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum/">112. 路径总和</a></h4><p>解决所有二叉树路径的问题文章</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-ii/solution/yi-pian-wen-zhang-jie-jue-suo-you-er-cha-oo63/">https://leetcode.cn/problems/path-sum-ii/solution/yi-pian-wen-zhang-jie-jue-suo-you-er-cha-oo63/</a></p>
<p>这一题和  [112. 路径总和]  类似</p>
<p>使用回溯写法，因为添加和删除，回溯的规则，那么感觉用栈比较合适.</p>
<ol>
<li>终止条件就是 到达了叶子节点，此时开始计算当前路径和 是否满足条件</li>
<li>手写判断是否有左子树，有的话继续判断，又继续preOrderTraversal, 这里用的是先序遍历,方法查看条件</li>
<li>遍历完叶子节点后判断，此时这条路径完成，开始回溯，回退上一层preOrderTraversal，继续判断右子树</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">hasPathSum</span><span class="params">(root: <span class="type">TreeNode</span>?, targetSum: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> pathStack = Stack&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        pathStack.push(root.`<span class="keyword">val</span>`) <span class="comment">// root需要放在遍历外面，否则会push多次</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">//按照前面的规则 root==null ,0 应该是对的,但是题目说false,就单独加一句</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> preOrderTraversal(root, targetSum, pathStack) <span class="comment">// pathstack必须传进去，否则每次都new</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">preOrderTraversal</span><span class="params">(root: <span class="type">TreeNode</span>?, targetSum: <span class="type">Int</span>, pathStack: <span class="type">Stack</span>&lt;<span class="type">Int</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root?.left == <span class="literal">null</span> &amp;&amp; root?.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> pathSum = <span class="number">0</span></span><br><span class="line">        pathStack.forEach &#123;</span><br><span class="line">            pathSum += it</span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;pathSum <span class="variable">$pathSum</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (pathSum == targetSum) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root?.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        pathStack.push(root.left.`<span class="keyword">val</span>`) <span class="comment">// 有左节点，加入当前路径</span></span><br><span class="line">        <span class="keyword">if</span> (preOrderTraversal(root.left, targetSum, pathStack)) &#123; <span class="comment">//有路径是和 == targetSum 直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        pathStack.pop()  <span class="comment">// 不会直接把上面的回退了，需要上一句遍历执行完回退后，才把自己回退了，此时已经到了叶子判断了 root?.left == null &amp;&amp; root?.right == null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root?.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        pathStack.push(root.right.`<span class="keyword">val</span>`)</span><br><span class="line">        <span class="keyword">if</span> (preOrderTraversal(root.right, targetSum, pathStack)) &#123; <span class="comment">//有路径是和 == targetSum 直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        pathStack.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">hasPathSum1</span><span class="params">(root: <span class="type">TreeNode</span>?, targetSum: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">//按照前面的规则 root==null ,0 应该是对的,但是题目说false,就单独加一句</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> pathSum = root.`<span class="keyword">val</span>`</span><br><span class="line">    <span class="keyword">return</span> preOrderDFS(root, pathSum, targetSum) <span class="comment">// pathstack必须传进去，否则每次都new</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">preOrderDFS</span><span class="params">(node: <span class="type">TreeNode</span>, pathSum: <span class="type">Int</span>, targetSum: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> nodeValue = node.`<span class="keyword">val</span>`</span><br><span class="line">    println(<span class="string">&quot;nodeValue <span class="variable">$nodeValue</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span> &amp;&amp; targetSum == pathSum) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">if</span> (preOrderDFS(node.left, pathSum + node.left.`<span class="keyword">val</span>`, targetSum)) &#123; <span class="comment">// 这个直接放回，容易忘了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">if</span> (preOrderDFS(node.right, pathSum + node.right.`<span class="keyword">val</span>`, targetSum)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II</a></h4><p>如果是找路径和等于给定target的路径的，那么可以不用新增一个临时变量cursum来判断当前路径和，<br>只需要用给定和target减去节点值，最终结束条件判断target==0即可</p>
<h5 id="DFS-1"><a href="#DFS-1" class="headerlink" title="DFS"></a>DFS</h5><p>这一题的思路和前面的差不多，就是他要求返回所有符合条件的集合，所以直接添加值觉得不合适，除非多加一个参数，不加一个参数就不好弄。</p>
<p>//这种解法要注意 值引用问题，即使最初加入到resultList的pathList是正确的，后序的回退也会把值给修改了.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> resultList = LinkedList&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">pathSum</span><span class="params">(root: <span class="type">TreeNode</span>?, targetSum: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> resultList</span><br><span class="line">    <span class="keyword">val</span> stackList = Stack&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    stackList.add(root.`<span class="keyword">val</span>`)</span><br><span class="line">    preDFS(root, stackList, targetSum)</span><br><span class="line">    <span class="keyword">return</span> resultList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">preDFS</span><span class="params">(node: <span class="type">TreeNode</span>, pathList: <span class="type">Stack</span>&lt;<span class="type">Int</span>&gt;, targetSum: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = node.`<span class="keyword">val</span>`</span><br><span class="line">    println(<span class="keyword">data</span>)</span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span> &amp;&amp; pathSum(pathList) == targetSum) &#123;</span><br><span class="line">        resultList.add(pathList.toMutableList().toList()) <span class="comment">// 注意引用传递</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        pathList.push(node.left.`<span class="keyword">val</span>`)</span><br><span class="line">        preDFS(node.left, pathList, targetSum)</span><br><span class="line">        pathList.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        pathList.push(node.right.`<span class="keyword">val</span>`)</span><br><span class="line">        preDFS(node.right, pathList, targetSum)</span><br><span class="line">        pathList.pop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">pathSum</span><span class="params">(pathList: <span class="type">Stack</span>&lt;<span class="type">Int</span>&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    pathList.forEach &#123;</span><br><span class="line">        sum += it</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这一题的官方DFS解法没看懂，感觉不好理解.</p>
<p>这是看完官方写法自己写的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> pathList = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">pathSum1</span><span class="params">(root: <span class="type">TreeNode</span>?, targetSum: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> resultList</span><br><span class="line">    <span class="keyword">val</span> stackList = Stack&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    stackList.add(root.`<span class="keyword">val</span>`)</span><br><span class="line">    preTraversal(root, targetSum - root.`<span class="keyword">val</span>`)</span><br><span class="line">    <span class="keyword">return</span> resultList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">preTraversal</span><span class="params">(node: <span class="type">TreeNode</span>?, targetSum: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = node.`<span class="keyword">val</span>`</span><br><span class="line">    println(<span class="keyword">data</span>)</span><br><span class="line">    pathList.offer(node.`<span class="keyword">val</span>`)</span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span> &amp;&amp; targetSum == <span class="number">0</span>) &#123;</span><br><span class="line">        resultList.add(pathList.toMutableList())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="literal">null</span>)</span><br><span class="line">        preTraversal(node.left, targetSum - node.left.`<span class="keyword">val</span>`)</span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="literal">null</span>)</span><br><span class="line">        preTraversal(node.right, targetSum - node.right.`<span class="keyword">val</span>`)</span><br><span class="line">    pathList.pop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这是官方解法，也很棒</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">pathSum2</span><span class="params">(root: <span class="type">TreeNode</span>?, targetSum: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> resultList</span><br><span class="line">    <span class="keyword">val</span> stackList = Stack&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    stackList.add(root.`<span class="keyword">val</span>`)</span><br><span class="line">    preDFSTraversal(root, targetSum)</span><br><span class="line">    <span class="keyword">return</span> resultList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">preDFSTraversal</span><span class="params">(node: <span class="type">TreeNode</span>?, targetSum: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = node.`<span class="keyword">val</span>`</span><br><span class="line">    println(<span class="keyword">data</span>)</span><br><span class="line">    <span class="keyword">val</span> targetSum = targetSum - node.`<span class="keyword">val</span>`</span><br><span class="line">    pathList.offer(node.`<span class="keyword">val</span>`)</span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span> &amp;&amp; targetSum == <span class="number">0</span>) &#123;</span><br><span class="line">        resultList.add(pathList.toMutableList())</span><br><span class="line">    &#125;</span><br><span class="line">    preDFSTraversal(node.left, targetSum)</span><br><span class="line">    preDFSTraversal(node.right, targetSum)</span><br><span class="line">    pathList.pop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>官方BFS 就很不好理解</p>
<h3 id="构建树"><a href="#构建树" class="headerlink" title="构建树"></a>构建树</h3><p>先序，中序</p>
<p>后序，中序</p>
<p>inOrder         [L, 3 ,R ]</p>
<p>PostOrder     [L, R, 3] </p>
<p>PreOrder       [3,L ,R]<br>可以看到 只有PostOrder ,PreOrder左右是分不清的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> 			1    					1 </span><br><span class="line"> 		2									2</span><br><span class="line">  3											3</span><br><span class="line">  </span><br><span class="line">PreOrder  1,2,3				PreOrder  1,2,3</span><br><span class="line">PostOrder 3,2,1 			PostOrder 3,2,1</span><br></pre></td></tr></table></figure>



<h4 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h4><p>效率低，但是好理解的方法</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1pp4y1k75Q/">https://www.bilibili.com/video/BV1pp4y1k75Q/</a></p>
<p>为什么post右子树是从 , [i , n-1],因为他是后序遍历，所以从 i开始</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inorder &#x3D; 	[9,3,15,20,7]</span><br><span class="line">postorder &#x3D; [9,15,7,20,3]</span><br></pre></td></tr></table></figure>

<ol>
<li><p>根据后序postorder 得到root 3, 然后根据中序知道 left branch [9] , right branch [15 , 20 , 7]</p>
</li>
<li><p>根据 left branch 的9,可以把 postorder后序分成[9], [15 , 20 , 7]两部分</p>
</li>
<li><p>然后 inorder= [15 , 20 , 7] , postorder=[15 , 20 , 7] 继续进行遍历</p>
</li>
</ol>
<p>总的来说，就是这样</p>
<ol>
<li>确定终止条件</li>
<li>构造节点</li>
<li>构造左子树， 构造右子树</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">buildTree</span><span class="params">(inorder: <span class="type">IntArray</span>, postorder: <span class="type">IntArray</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (inorder.isEmpty() &amp;&amp; postorder.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> node = TreeNode(postorder[postorder.size - <span class="number">1</span>]) <span class="comment">//postorder.size用的地方多，可以提取出来</span></span><br><span class="line">    <span class="keyword">val</span> index = getIndex(node, inorder)</span><br><span class="line">    node.left = buildTree(inorder.copyOfRange(<span class="number">0</span>, index), postorder.copyOfRange(<span class="number">0</span>, index)) <span class="comment">// copyOfRange数组效率低</span></span><br><span class="line">    node.right = buildTree(</span><br><span class="line">        inorder.copyOfRange(index + <span class="number">1</span>, inorder.size), postorder.copyOfRange(index, postorder.size - <span class="number">1</span>)</span><br><span class="line">    ) <span class="comment">// 注意copyOfRange(0,2)获取的是index 0,1两个元素</span></span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getIndex</span><span class="params">(node: <span class="type">TreeNode</span>, inorder: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> inorder.indices) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.`<span class="keyword">val</span>` == inorder[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h5><p>写出来还有问题,先pass这题耗时太久了,边界不好掌握可以考虑用日志调试</p>
<p>还可以再看下随想录的视频讲解</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1vW4y1i7dn">https://www.bilibili.com/video/BV1vW4y1i7dn</a></p>
<p>随想录代码优化前的写法，和上面代码写法是一样的，只是用了C++语言</p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html">https://programmercarl.com/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html</a></p>
<p>最初错误的解法,上面的解法数组有变化所以 end位置就是数组的大小，但是这里不同，数组是没变化，就不能这样做</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 数组不变，只改变下标</span><br><span class="line">private fun buildDFSTree(</span><br><span class="line">    inorder: IntArray,</span><br><span class="line">    postorder: IntArray,</span><br><span class="line">    inStart: Int,</span><br><span class="line">    inEnd: Int,</span><br><span class="line">    postStart: Int,</span><br><span class="line">    postEnd: Int</span><br><span class="line">): TreeNode? &#123;</span><br><span class="line">    if (inStart &gt; inEnd || postStart &gt; postEnd || inEnd &lt; 0 || postEnd &lt; 0) &#123;</span><br><span class="line">        return null</span><br><span class="line">    &#125;</span><br><span class="line">    val node &#x3D; TreeNode(postorder[postEnd]) &#x2F;&#x2F;postorder.size用的地方多，可以提取出来</span><br><span class="line">    val index &#x3D; getIndex(node, inorder)</span><br><span class="line"></span><br><span class="line">    node.left &#x3D; buildDFSTree(inorder, postorder, inStart, index - 1, 0, index - 1)   &#x2F;&#x2F;[0,index) 左闭右开</span><br><span class="line">    node.right &#x3D; buildDFSTree(inorder, postorder, index + 1, inEnd, index + 1, postEnd)</span><br><span class="line">    return node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这一题花了不少时间，思路不难，主要是 切割后序的数组的时候，左右子树的边界值不好处理,</p>
<ol>
<li>map用来存储，中序value值和position的对应关系，这里value应该是唯一的.</li>
<li>采用的是左闭右闭的方案，所以inStart &gt; inEnd 不能用 &gt;=, 否则return了，叶子节点无法构造出来.</li>
<li>根据后序root节点，分割中序数组，拿到左子树后，再用左子树树的分割后序数组,因为左子树的长度是一样的。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> map = HashMap&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">buildTree1</span><span class="params">(inorder: <span class="type">IntArray</span>, postorder: <span class="type">IntArray</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (inorder.isEmpty() &amp;&amp; postorder.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> inStart = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> inEnd = inorder.size - <span class="number">1</span></span><br><span class="line">    <span class="keyword">val</span> postStart = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> postEnd = postorder.size - <span class="number">1</span></span><br><span class="line">    inorder.forEachIndexed &#123; position, item -&gt;</span><br><span class="line">        map[item] = position</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buildDFSTree(inStart, inEnd, postStart, postEnd, inorder, postorder)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组不变，只改变下标</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">buildDFSTree</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    inStart: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    inEnd: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    postStart: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    postEnd: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    inorderArr: <span class="type">IntArray</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    postorderArr: <span class="type">IntArray</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: TreeNode? &#123;</span><br><span class="line">    println(<span class="string">&quot; inStart <span class="variable">$inStart</span> inEnd <span class="variable">$inEnd</span>  postStart <span class="variable">$postStart</span> postEnd <span class="variable">$postEnd</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> (inStart &gt; inEnd || postStart &gt; postEnd) &#123; <span class="comment">// 因为是左闭右闭的方案，所以这里不能用 &gt;= ,否则叶子节点无法构造出来</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> node = TreeNode(postorderArr[postEnd]) <span class="comment">//postorder.size用的地方多，可以提取出来</span></span><br><span class="line">    <span class="keyword">val</span> index = map[postorderArr[postEnd]] ?: <span class="number">0</span> <span class="comment">// 这里要改</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切割左子树,这种坐标定义好更清晰</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> leftInBegin = inStart</span><br><span class="line">    <span class="keyword">val</span> leftInEnd = index - <span class="number">1</span> <span class="comment">// 左闭右闭</span></span><br><span class="line">    <span class="keyword">val</span> leftPostBegin = postStart</span><br><span class="line">    <span class="keyword">val</span> leftPostEnd = postStart + (index - inStart - <span class="number">1</span>) <span class="comment">//(index - inStart) 左子树的长度, 因为选择是左闭右闭的方案，所以自身也-1</span></span><br><span class="line"></span><br><span class="line">    node.left = buildDFSTree(</span><br><span class="line">        leftInBegin, leftInEnd, leftPostBegin, leftPostEnd,</span><br><span class="line">        inorderArr,</span><br><span class="line">        postorderArr</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切割右子树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> rightInBegin = index + <span class="number">1</span></span><br><span class="line">    <span class="keyword">val</span> rightInEnd = inEnd</span><br><span class="line">    <span class="keyword">val</span> rightPostBegin = postStart + index - inStart <span class="comment">//(index - inStart) 这里不用-1,因为左子树的右边就是右子树，所以右子树就是从这个位置开始的</span></span><br><span class="line">    <span class="keyword">val</span> rightPostEnd = postEnd - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    node.right = buildDFSTree(</span><br><span class="line">        rightInBegin, rightInEnd, rightPostBegin, rightPostEnd,</span><br><span class="line">        inorderArr,</span><br><span class="line">        postorderArr</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>官方</p>
<p>先构建右子树的想法好巧妙，要是先构建的是左子树还有个确定后序区间的步骤。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution/cong-zhong-xu-yu-hou-xu-bian-li-xu-lie-gou-zao-14/">https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution/cong-zhong-xu-yu-hou-xu-bian-li-xu-lie-gou-zao-14/</a></p>
<p>官方解法很妙，根据后序数组pop，post_idx–;先开始右子树,然后左子树,构造方法也很简单，这样不用找后序数组的 开始和结束位置在哪. 做了上面的解法，也就是这个后序的边界值最难搞. 这种方式直接给省去了。</p>
<p>不得不说太妙了</p>
<p><img src="https://assets.leetcode-cn.com/solution-static/106/6.png"></p>
<p>官方迭代法后面再看吧 。</p>
<h4 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654. 最大二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-binary-tree/">654. 最大二叉树</a></h4><p>输入：nums = [3,2,1,6,0,5]<br>输出：[6,3,5,null,2,0,null,null,1]<br>解释：递归调用如下所示：</p>
<p>[3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。</p>
<ul>
<li>[3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。 ,3的左边是[]没有节点, 右边是[0,5],所以树也是这样构造的.<ul>
<li>空数组，无子节点。</li>
<li>[2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。<ul>
<li>空数组，无子节点。</li>
<li>只有一个元素，所以子节点是一个值为 1 的节点。</li>
</ul>
</li>
</ul>
</li>
<li>[0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。<ul>
<li>只有一个元素，所以子节点是一个值为 0 的节点。</li>
<li>空数组，无子节点。</li>
</ul>
</li>
</ul>
<h5 id="preTraversal"><a href="#preTraversal" class="headerlink" title="preTraversal"></a>preTraversal</h5><p>思路 : </p>
<ol>
<li>因为需要构造中间节点，所以用先序遍历</li>
<li>先找到数组中最大值，然后切割成左右子树。</li>
<li>在切割后的左右子树中继续切割，直至无法切割为止</li>
</ol>
<p>自己写的，做法和随想录类似 </p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0654.%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html#java">https://programmercarl.com/0654.%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html#java</a></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">constructMaximumBinaryTree</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">return</span> buildTree(nums, <span class="number">0</span>, nums.size - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">buildTree</span><span class="params">(nums: <span class="type">IntArray</span>, start: <span class="type">Int</span>, end: <span class="type">Int</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    println(<span class="string">&quot;buildTree start <span class="variable">$start</span> end <span class="variable">$end</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="literal">null</span>            <span class="comment">//分割的左右下标越界就退出 ,不能加==，否则叶子节点构造不到.</span></span><br><span class="line">    <span class="keyword">val</span> maxIndex = getMaxIndex(nums, start, end)</span><br><span class="line">    <span class="keyword">val</span> node = TreeNode(nums[maxIndex])     <span class="comment">// 构造先序的父节点</span></span><br><span class="line">    node.left = buildTree(nums, start, maxIndex - <span class="number">1</span>) <span class="comment">// 构造左节点</span></span><br><span class="line">    node.right = buildTree(nums, maxIndex + <span class="number">1</span>, end)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getMaxIndex</span><span class="params">(nums: <span class="type">IntArray</span>, start: <span class="type">Int</span>, end: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> maxIndex = start</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> start..end) &#123;  <span class="comment">// 在对应的数组范围内，找到最大值</span></span><br><span class="line">        <span class="keyword">if</span> (nums[maxIndex] &lt; nums[i]) &#123;</span><br><span class="line">            maxIndex = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxIndex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h5><p>官方还有一种单调栈的写法，后面再看吧</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-binary-tree/solution/zui-da-er-cha-shu-by-leetcode-solution-lbeo/">https://leetcode.cn/problems/maximum-binary-tree/solution/zui-da-er-cha-shu-by-leetcode-solution-lbeo/</a></p>
<h4 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h4><p>Idea</p>
<h5 id="只分割中序数组"><a href="#只分割中序数组" class="headerlink" title="只分割中序数组"></a>只分割中序数组</h5><p>按照上面106官方很妙的思路，下面解法</p>
<ol>
<li>根据中序遍历。value和index构造hash map,方便后面获取中序位置</li>
<li>根据先序遍历数组从 左子树到右子树构造节点, 这样就不用分割先序数组，也是很麻烦的</li>
<li>根据先序数组的节点的位置，分割中序遍历数组，拿到左右子树</li>
<li>然后是递归分割.</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> map = HashMap&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="keyword">var</span> preNodeIndex = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">buildTree</span><span class="params">(preorder: <span class="type">IntArray</span>, inorder: <span class="type">IntArray</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    inorder.forEachIndexed &#123; position, item -&gt; <span class="comment">//</span></span><br><span class="line">        map[item] = position</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buildDFS(preorder, inorder, <span class="number">0</span>, inorder.size - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">buildDFS</span><span class="params">(preorder: <span class="type">IntArray</span>, inorder: <span class="type">IntArray</span>, inBegin: <span class="type">Int</span>, inEnd: <span class="type">Int</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (inBegin &gt; inEnd) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> node = TreeNode(preorder[preNodeIndex])  <span class="comment">// 根据先序遍历数组从 左子树到右子树构造节点</span></span><br><span class="line">    <span class="keyword">val</span> inIndex = map[preorder[preNodeIndex]]!! <span class="comment">// 根据先序数组的节点的位置，分割中序遍历数组，拿到左右子树</span></span><br><span class="line">    println(<span class="string">&quot;<span class="subst">$&#123;preorder[preNodeIndex]&#125;</span> inBegin <span class="variable">$inBegin</span> inEnd <span class="variable">$inEnd</span>&quot;</span>)</span><br><span class="line">    preNodeIndex++</span><br><span class="line">    node.left = buildDFS(preorder, inorder, inBegin, inIndex - <span class="number">1</span>)</span><br><span class="line">    node.right = buildDFS(preorder, inorder, inIndex + <span class="number">1</span>, inEnd)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="分割先序-中序数组"><a href="#分割先序-中序数组" class="headerlink" title="分割先序 中序数组"></a>分割先序 中序数组</h5><ol>
<li>根据中序数组构造，位置和值的hashmap 。</li>
<li>根据先序数组的中节点位置，分割中序数组，得到左右子树。</li>
<li>根据中序数组得到的左子树的长度，分割 先序数组的左右子树.</li>
<li>构造左右子树.</li>
</ol>
<p>左闭右闭的情况</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> map = HashMap&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="keyword">var</span> preNodeIndex = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">buildTree1</span><span class="params">(preorder: <span class="type">IntArray</span>, inorder: <span class="type">IntArray</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    inorder.forEachIndexed &#123; position, item -&gt;</span><br><span class="line">        map[item] = position  <span class="comment">// 获得 中序 value和index hash</span></span><br><span class="line">        map.put(item,position)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> splitPreInOrder(preorder, <span class="number">0</span>, preorder.size - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.size - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">splitPreInOrder</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    preorderArr: <span class="type">IntArray</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    preStart: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    preEnd: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    inorderArr: <span class="type">IntArray</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    inStart: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    inEnd: <span class="type">Int</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: TreeNode? &#123;</span><br><span class="line">    println(<span class="string">&quot; preStart <span class="variable">$preStart</span> preEnd <span class="variable">$preEnd</span> inStart <span class="variable">$inStart</span> inEnd <span class="variable">$inEnd</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (preStart &gt; preEnd || inStart &gt; inEnd) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">val</span> inIndex = map[preorderArr[preStart]]!!  <span class="comment">// 分割中序数组</span></span><br><span class="line">    <span class="keyword">val</span> node = TreeNode(preorderArr[preStart])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> leftInBegin = inStart <span class="comment">//左闭</span></span><br><span class="line">    <span class="keyword">val</span> leftInEnd = inIndex-<span class="number">1</span>    <span class="comment">// 右闭</span></span><br><span class="line">    <span class="keyword">val</span> leftPreBegin = preStart + <span class="number">1</span> <span class="comment">// 先序中节点的后一个位置，就是左子树的开始位置</span></span><br><span class="line">    <span class="keyword">val</span> leftPreEnd = preStart + (inIndex - inStart) <span class="comment">// 其实位置 + 中序中左子树的长度</span></span><br><span class="line"></span><br><span class="line">    node.left = splitPreInOrder(preorderArr, leftPreBegin, leftPreEnd, inorderArr, leftInBegin, leftInEnd)</span><br><span class="line">    <span class="keyword">val</span> rightInBegin = inIndex + <span class="number">1</span> <span class="comment">// 分割点的后一个位置</span></span><br><span class="line">    <span class="keyword">val</span> rightInEnd = inEnd</span><br><span class="line">    <span class="keyword">val</span> rightPreBegin = preStart + (inIndex - inStart) + <span class="number">1</span> <span class="comment">// 先序数组 左子树位置+1 后一个位置</span></span><br><span class="line">    <span class="keyword">val</span> rightPreEnd = preEnd</span><br><span class="line">    node.right = splitPreInOrder(preorderArr, rightPreBegin, rightPreEnd, inorderArr, rightInBegin, rightInEnd)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>感觉还是左闭右闭好点，右开的情况容易越界.</p>
<h4 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-binary-trees/">617. 合并二叉树</a></h4><h5 id="DFS-2"><a href="#DFS-2" class="headerlink" title="DFS"></a>DFS</h5><ol>
<li>合并二叉树，通过先序遍历，先构造根节点</li>
<li>然后再分别构造左右子树</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">mergeTrees</span><span class="params">(root1: <span class="type">TreeNode</span>?, root2: <span class="type">TreeNode</span>?)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="literal">null</span> &amp;&amp; root2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">//这里还可以优化, 看官方解法和随想录的优化一样的</span></span><br><span class="line">    <span class="keyword">val</span> node = TreeNode((root1?.`<span class="keyword">val</span>` ?: <span class="number">0</span>) + (root2?.`<span class="keyword">val</span>` ?: <span class="number">0</span>))</span><br><span class="line">    node.left = mergeTrees(root1?.left, root2?.left)</span><br><span class="line">    node.right = mergeTrees(root1?.right, root2?.right)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>BFS</p>
<p>这题官方有一种BFS的解法,感觉有点麻烦，后面继续</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-binary-trees/solution/he-bing-er-cha-shu-by-leetcode-solution/">https://leetcode.cn/problems/merge-two-binary-trees/solution/he-bing-er-cha-shu-by-leetcode-solution/</a></p>

	
	</div>
  <a type="button" href="/2022/09/11/LC-TREE08/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/08/27/view-custom/" >view_custom</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-08-27  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h5 id="自定义属性类别"><a href="#自定义属性类别" class="headerlink" title="自定义属性类别"></a>自定义属性类别</h5><blockquote>
<p>boolean     表示attr取值为true或者false<br>color         表示attr取值是颜色类型，例如#ff3344,或者是一个指向color的资源id，例如R.color.colorAccent.<br>dimension 表示 attr 取值是尺寸类型，例如例如取值16sp、16dp，也可以是一个指向dimen的资源id，例          如R.dimen.dp_16<br>float      表示attr取值是整形或者浮点型<br>fraction     表示 attr取值是百分数类型，只能以%结尾，例如30%<br>integer      表示attr取值是整型<br>string        表示attr取值是String类型，或者一个指向String的资源id，例如R.string.testString<br>reference   表示attr取值只能是一个指向资源的id。<br>enum     表示attr取值只能是枚举类型。</p>
</blockquote>
<p>CustomView.kt</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">&quot;CustomView&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;attr_boolean&quot;</span> <span class="attr">format</span>=<span class="string">&quot;boolean&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;attr_color&quot;</span> <span class="attr">format</span>=<span class="string">&quot;color&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;attr_dimension&quot;</span> <span class="attr">format</span>=<span class="string">&quot;dimension&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;attr_float&quot;</span> <span class="attr">format</span>=<span class="string">&quot;float&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;attr_fraction&quot;</span> <span class="attr">format</span>=<span class="string">&quot;fraction&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;attr_string&quot;</span> <span class="attr">format</span>=<span class="string">&quot;string&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;attr_reference&quot;</span> <span class="attr">format</span>=<span class="string">&quot;reference&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;attr_enum&quot;</span> <span class="attr">format</span>=<span class="string">&quot;enum&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">enum</span> <span class="attr">name</span>=<span class="string">&quot;left&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">enum</span> <span class="attr">name</span>=<span class="string">&quot;right&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">attr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = context.obtainStyledAttributes(attrs, R.styleable.CustomView, <span class="number">0</span>, defStyleAttr)</span><br><span class="line"><span class="keyword">val</span> boolean = a.getBoolean(R.styleable.CustomAttribute_customBoolean, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">val</span> color = a.getColor(R.styleable.CustomAttribute_customColorValue, R.color.colorPrimary)</span><br><span class="line"><span class="keyword">val</span> dimension = a.getDimension(R.styleable.CustomAttribute_customDimension, <span class="number">20F</span>)</span><br><span class="line"><span class="keyword">val</span> float = a.getFloat(R.styleable.CustomView_attr_float, <span class="number">20f</span>)</span><br><span class="line"><span class="keyword">val</span> fraction = a.getFraction(R.styleable.CustomView_attr_fraction, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0f</span>)</span><br><span class="line"><span class="keyword">val</span> integer = a.getInteger(R.styleable.CustomAttribute_customIntegerValue, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">val</span> string = a.getString(R.styleable.CustomView_attr_string)</span><br><span class="line">resourceId =</span><br><span class="line">    a.getResourceId(R.styleable.CustomAttribute_customReference, R.drawable.meitu13333)</span><br><span class="line"><span class="keyword">var</span> textPos = a.getInteger(R.styleable.CustomView_attr_enum, <span class="number">0</span>)</span><br><span class="line">a.recycle()</span><br></pre></td></tr></table></figure>



<p><strong>refrence , 表示attr取值只能是一个指向资源的id。</strong></p>
<p> <a target="_blank" rel="noopener" href="https://github.com/GcsSloop/AndroidNote/tree/master/CustomView">https://github.com/GcsSloop/AndroidNote/tree/master/CustomView</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000012253911">https://segmentfault.com/a/1190000012253911</a></p>
<h5 id="onDraw-dispatchDraw"><a href="#onDraw-dispatchDraw" class="headerlink" title="onDraw  dispatchDraw"></a>onDraw  dispatchDraw</h5><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/89efaf8bd3dd">https://www.jianshu.com/p/89efaf8bd3dd</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903997917102093">https://juejin.cn/post/6844903997917102093</a></p>

	
	</div>
  <a type="button" href="/2022/08/27/view-custom/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/08/18/ADB/" >ADB</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-08-18  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys window | grep mCurrentFocus		&#x2F;&#x2F;当前Activity</span><br><span class="line"></span><br><span class="line">adb shell dumpsys activity | grep com.john.kot</span><br><span class="line"></span><br><span class="line">adb shell dumpsys activity | grep com.comm.util</span><br></pre></td></tr></table></figure>




	
	</div>
  <a type="button" href="/2022/08/18/ADB/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/08/14/view-round-image/" >view_round_image</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-08-14  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaohanluo/article/details/52945791">https://blog.csdn.net/xiaohanluo/article/details/52945791</a></p>
<p><a target="_blank" rel="noopener" href="https://guides.codepath.com/android/Working-with-the-ImageView">https://guides.codepath.com/android/Working-with-the-ImageView</a></p>
<p><img src="https://images.thoughtbot.com/blog-vellum-image-uploads/wDbiaqGSQyyErtXGSh6w_scaletype.png"></p>
<p><a target="_blank" rel="noopener" href="https://guides.codepath.com/android/Working-with-the-ImageView">https://guides.codepath.com/android/Working-with-the-ImageView</a></p>
<h3 id="全圆角"><a href="#全圆角" class="headerlink" title="全圆角"></a>全圆角</h3><h4 id="OutLine"><a href="#OutLine" class="headerlink" title="OutLine"></a>OutLine</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ImageView</span><br><span class="line">    android:id=&quot;@+id/img_test&quot;</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:src=&quot;@drawable/music&quot; /&gt;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mImg = findViewById(R.id.img_test);</span><br><span class="line">ViewOutlineProvider viewOutlineProvider = <span class="keyword">new</span> ViewOutlineProvider() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getOutline</span><span class="params">(View view, Outline outline)</span> </span>&#123;</span><br><span class="line">       outline.setOval(<span class="number">0</span>,<span class="number">0</span>,mImg.getWidth(), mImg.getHeight());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">mImg.setOutlineProvider(viewOutlineProvider);</span><br><span class="line">mImg.setClipToOutline(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43499030/article/details/92799689">https://blog.csdn.net/weixin_43499030/article/details/92799689</a></p>
<h4 id="CardView"><a href="#CardView" class="headerlink" title="CardView"></a>CardView</h4><h3 id="部分圆角"><a href="#部分圆角" class="headerlink" title="部分圆角"></a>部分圆角</h3><h4 id="ShapeableImageView"><a href="#ShapeableImageView" class="headerlink" title="ShapeableImageView"></a>ShapeableImageView</h4><p>这种方式官方的无风险</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- layout.xml 就是在布局中定义--&gt;</span></span><br><span class="line">&lt;com.google.android.material.imageview.ShapeableImageView</span><br><span class="line">            android:layout_width=&quot;200dp&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:scaleType=&quot;fitXY&quot;</span><br><span class="line">            android:strokeWidth=&quot;10dp&quot;</span><br><span class="line">            android:strokeColor=&quot;@color/purple&quot;</span><br><span class="line">            android:src=&quot;@drawable/ic_launcher_background&quot;</span><br><span class="line">            app:shapeAppearance=&quot;@style/RoundAndCutImageStyle&quot; /&gt;</span><br></pre></td></tr></table></figure>



<p>需要通过设置 app:shapeAppearance 才有用</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  style.xml  可以单独给每个角设置属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;RoundAndCutImageStyle&quot;</span>&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;cornerFamilyTopLeft&quot;</span>&gt;</span>rounded<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;cornerFamilyBottomLeft&quot;</span>&gt;</span>rounded<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;cornerFamilyTopRight&quot;</span>&gt;</span>cut<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;cornerFamilyBottomRight&quot;</span>&gt;</span>cut<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;cornerSize&quot;</span>&gt;</span>50%<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;cornerSizeBottomLeft&quot;</span>&gt;</span>20dp<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;cornerSizeTopLeft&quot;</span>&gt;</span>20dp<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>左边是圆角，右边是“切角”</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f808689473d4938bf84d101b5908143~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6913083202387050509">https://juejin.cn/post/6913083202387050509</a></p>
<h4 id="BitmapShader"><a href="#BitmapShader" class="headerlink" title="BitmapShader"></a>BitmapShader</h4><p>setShader</p>
<p>setShader，顾名思义，设置着色器，我们知道在Canvas中，我们调用drawXXX可以绘制出各种各样的图形，如圆形、矩形、扇形等等，而Shader是给Paint设置的属性，决定paint绘制图形的时候如何给图形上色，比如绘制一个矩形，我想要矩形中铺满一张图片，那这些平铺的图片就相当于是给这个矩形上色了。好了，概念先说到这，Shader是一个基类，setShader中设置的都是Shader的子类<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/huxin1875/article/details/89133025">https://blog.csdn.net/huxin1875/article/details/89133025</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	 Call <span class="keyword">this</span> to create a <span class="keyword">new</span> shader that will draw with a bitmap.</span><br><span class="line">	 Params:</span><br><span class="line">	 bitmap – The bitmap to use inside the shader</span><br><span class="line">	 tileX – The tiling mode <span class="keyword">for</span> x to draw the bitmap in.</span><br><span class="line">	 tileY – The tiling mode <span class="keyword">for</span> y to draw the bitmap in.</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BitmapShader</span><span class="params">(<span class="meta">@NonNull</span> Bitmap bitmap, <span class="meta">@NonNull</span> TileMode tileX, <span class="meta">@NonNull</span> TileMode tileY)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(bitmap, tileX.nativeInt, tileY.nativeInt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BitmapShaderView</span> <span class="meta">@JvmOverloads</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    context: Context?, attrs: AttributeSet?,</span><br><span class="line">    defStyleAttr: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">) : View(context, attrs, defStyleAttr) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mWidth <span class="keyword">by</span> Delegates.notNull&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mHeight <span class="keyword">by</span> Delegates.notNull&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> bmpShader: BitmapShader</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mPaint: Paint</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> bmpRect: RectF</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSizeChanged</span><span class="params">(w: <span class="type">Int</span>, h: <span class="type">Int</span>, oldw: <span class="type">Int</span>, oldh: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh)</span><br><span class="line">        mWidth = w  <span class="comment">//屏幕宽</span></span><br><span class="line">        mHeight = h <span class="comment">//屏幕高</span></span><br><span class="line">        bmpRect = RectF(<span class="number">0f</span>, <span class="number">0f</span>, mWidth.toFloat(), mHeight.toFloat())</span><br><span class="line">        <span class="keyword">val</span> bitmap = BitmapFactory.decodeResource(resources, R.drawable.meitu122822234759011)</span><br><span class="line">        <span class="comment">//Shader.TileMode里有三种模式：CLAMP（拉伸）、MIRROR（镜像）、REPETA（重复）</span></span><br><span class="line">        bmpShader = BitmapShader(bitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP)</span><br><span class="line">        mPaint = Paint(Paint.ANTI_ALIAS_FLAG)</span><br><span class="line">        mPaint.shader = bmpShader</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDraw</span><span class="params">(canvas: <span class="type">Canvas</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas)</span><br><span class="line">        canvas?.drawRect(bmpRect, mPaint)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p> 先来看看BitmapShader属性的作用</p>
<p> bitmap 指的是要作为纹理的图片，</p>
<p> tileX 指的是在ｘ方向纹理的绘制模式</p>
<p> tileY 指的是Ｙ方向上的绘制模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">TileMode</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Replicate the edge color if the shader draws outside of its</span></span><br><span class="line"><span class="comment">     * original bounds.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CLAMP   (<span class="number">0</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Repeat the shader&#x27;s image horizontally and vertically.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    REPEAT  (<span class="number">1</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Repeat the shader&#x27;s image horizontally and vertically, alternating</span></span><br><span class="line"><span class="comment">     * mirror images so that adjacent images always seam.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MIRROR(<span class="number">2</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Render the shader&#x27;s image pixels only within its original bounds. If the shader</span></span><br><span class="line"><span class="comment">     * draws outside of its original bounds, transparent black is drawn instead.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DECAL(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    TileMode(<span class="keyword">int</span> nativeInt) &#123;</span><br><span class="line">        <span class="keyword">this</span>.nativeInt = nativeInt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> nativeInt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>*<strong>CLAMP 拉伸*</strong>:设置x , 横向的最后一个横行像素，不断的重复，设置y，那么纵项的那一列像素，不断的重复；<br>*<strong>REPEAT 重复*</strong>:就是横向、纵向不断重复这个bitmap<br>*<strong>MIRROR 镜像*</strong>:横向不断翻转重复，纵向不断翻转重复；</p>
<h5 id="CLAMP"><a href="#CLAMP" class="headerlink" title="CLAMP"></a>CLAMP</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BitmapShader(bitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP)</span><br></pre></td></tr></table></figure>

<img src="/2022/08/14/view-round-image/Screenshot_1660468780.png" alt="Screenshot_1660468780" style="zoom:20%;">







<p>REPEAT</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BitmapShader(bitmap, Shader.TileMode.REPEAT, Shader.TileMode.REPEAT)</span><br></pre></td></tr></table></figure>



<img src="/2022/08/14/view-round-image/Screenshot_1660469449.png" alt="Screenshot_1660469449" style="zoom:20%;">



<h5 id="MIRROR"><a href="#MIRROR" class="headerlink" title="MIRROR"></a>MIRROR</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BitmapShader(bitmap, Shader.TileMode.MIRROR, Shader.TileMode.MIRROR)</span><br></pre></td></tr></table></figure>



 <img src="/2022/08/14/view-round-image/Screenshot_1660469253.png" alt="Screenshot_1660469253" style="zoom:20%;">



<p>可以看到， x y 镜像映射</p>
<h5 id="DECAL"><a href="#DECAL" class="headerlink" title="DECAL"></a>DECAL</h5><p>最后这种就是正常显示的了</p>
<img src="/2022/08/14/view-round-image/Screenshot_1660469645.png" alt="Screenshot_1660469645" style="zoom:20%;">

<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903480809766920">https://juejin.cn/post/6844903480809766920</a></p>
<h5 id="全部圆角"><a href="#全部圆角" class="headerlink" title="全部圆角"></a>全部圆角</h5><p>有了scale，就可以设置给我们的matrix；</p>
<p>然后使用mBitmapShader.setLocalMatrix(mMatrix);</p>
<p>最后将bitmapShader设置给paint。</p>
<p>关于drawable转bitmap的代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.max(width / bmp.width.toFloat(), height / bmp.height.toFloat())</span><br></pre></td></tr></table></figure>

<p>View宽度 / 图片宽度 , View的高度/图片高度</p>
<p>他们取最大值，进行缩放，图片短的那一部分就会填满View,长的那一部分会被截掉,显示不全</p>
<p>计算scale</p>
<blockquote>
<p>比如：view的宽高为50 * 100；图片的宽高为5*100 ； 最终我们应该按照宽的比例放大，而不是按照高的比例缩小；因为我们需要让缩放后的图片，自定大于我们的view宽高，并保证原图比例。</p>
</blockquote>
<p>那么高度就被放大10倍到1000,值能显示到1/10</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoundImageShaderView</span> <span class="meta">@JvmOverloads</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    context: Context, attrs: AttributeSet?,</span><br><span class="line">    defStyleAttr: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">) : AppCompatImageView(context, attrs, defStyleAttr) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> TAG = <span class="string">&quot;RoundImageShaderView&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mRoundRect: RectF</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mBitmapShader: BitmapShader</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mMatrix = Matrix()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mBitmapPaint = Paint();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDraw</span><span class="params">(canvas: <span class="type">Canvas</span>?)</span></span> &#123;</span><br><span class="line">        canvas?.drawRoundRect(mRoundRect, <span class="number">20f</span>, <span class="number">20f</span>, mBitmapPaint)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSizeChanged</span><span class="params">(w: <span class="type">Int</span>, h: <span class="type">Int</span>, oldw: <span class="type">Int</span>, oldh: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh)</span><br><span class="line">        setUpShader()</span><br><span class="line">        mRoundRect = RectF(<span class="number">0f</span>, <span class="number">0f</span>, width.toFloat(), height.toFloat())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化BitmapShader</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">setUpShader</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> drawable: Drawable = drawable ?: <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">val</span> bmp = drawableToBitamp(drawable)</span><br><span class="line">        <span class="comment">// 将bmp作为着色器，就是在指定区域内绘制bmp</span></span><br><span class="line">        mBitmapShader = BitmapShader(bmp!!, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP)</span><br><span class="line">        <span class="comment">// 如果图片的宽或者高与view的宽高不匹配，计算出需要缩放的比例；缩放后的图片的宽高，一定要大于我们view的宽高；所以我们这里取大值；</span></span><br><span class="line">        <span class="keyword">val</span> scale = Math.max(width / bmp.width.toFloat(), height / bmp.height.toFloat())</span><br><span class="line">        <span class="comment">// shader的变换矩阵，我们这里主要用于放大或者缩小</span></span><br><span class="line">        mMatrix.setScale(scale, scale)</span><br><span class="line">        <span class="comment">// 设置变换矩阵</span></span><br><span class="line">        mBitmapShader.setLocalMatrix(mMatrix)</span><br><span class="line">        <span class="comment">// 设置shader</span></span><br><span class="line">        mBitmapPaint.shader = mBitmapShader</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * drawable转bitmap</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> drawable</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">drawableToBitamp</span><span class="params">(drawable: <span class="type">Drawable</span>)</span></span>: Bitmap? &#123;</span><br><span class="line">        <span class="keyword">if</span> (drawable <span class="keyword">is</span> BitmapDrawable) &#123;</span><br><span class="line">            <span class="keyword">val</span> bd: BitmapDrawable = drawable</span><br><span class="line">            <span class="keyword">return</span> bd.bitmap</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> w = drawable.intrinsicWidth</span><br><span class="line">        <span class="keyword">val</span> h = drawable.intrinsicHeight</span><br><span class="line">        <span class="keyword">return</span> Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.john.kot.view.RoundImageShaderView</span><br><span class="line">    android:id=&quot;@+id/iv_girl1&quot;</span><br><span class="line">    android:layout_width=&quot;200dp&quot;</span><br><span class="line">    android:layout_height=&quot;200dp&quot;</span><br><span class="line">    android:layout_marginStart=&quot;20dp&quot;</span><br><span class="line">    android:layout_marginTop=&quot;20dp&quot;</span><br><span class="line">    android:src=&quot;@drawable/meitu122822234759011&quot;</span><br><span class="line">    app:layout_constraintStart_toStartOf=&quot;parent&quot;</span><br><span class="line">    app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;com.john.kot.view.RoundImageShaderView</span><br><span class="line">    android:id=&quot;@+id/iv_girl2&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;200dp&quot;</span><br><span class="line">    android:layout_marginStart=&quot;20dp&quot;</span><br><span class="line">    android:layout_marginTop=&quot;20dp&quot;</span><br><span class="line">    android:src=&quot;@drawable/meitu122822234759011&quot;</span><br><span class="line">    app:layout_constraintStart_toStartOf=&quot;parent&quot;</span><br><span class="line">    app:layout_constraintTop_toBottomOf=&quot;@+id/iv_girl1&quot; /&gt;</span><br></pre></td></tr></table></figure>



<p><img src="/2022/08/14/view-round-image/20220814224524.jpg" alt="20220814224524"></p>
<p>可以看到，高度部分截取了</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lmj623565791/article/details/41967509">https://blog.csdn.net/lmj623565791/article/details/41967509</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/graphics/PorterDuff.Mode">https://developer.android.com/reference/android/graphics/PorterDuff.Mode</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000012253911">https://segmentfault.com/a/1190000012253911</a></p>
<h5 id="部分圆角-1"><a href="#部分圆角-1" class="headerlink" title="部分圆角"></a>部分圆角</h5><img src="/2022/08/14/view-round-image/20220828111337.jpg" alt="20220828111337" style="zoom: 50%;">

<p>第二张图就可以看到，这样做的原理</p>
<img src="/2022/08/14/view-round-image/20220828120522.jpg" alt="20220828120522" style="zoom:50%;">

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoundBottomBitmapShaderView</span> <span class="meta">@JvmOverloads</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    context: Context, attrs: AttributeSet?,</span><br><span class="line">    defStyleAttr: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">) : AppCompatImageView(context, attrs, defStyleAttr) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mBitmapShader: BitmapShader</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mMatrix = Matrix()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mBitmapPaint = Paint();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> radius = resources.getDimension(R.dimen.round_bitmap_radius)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> outHeight <span class="keyword">by</span> Delegates.notNull&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> outWidth <span class="keyword">by</span> Delegates.notNull&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSizeChanged</span><span class="params">(w: <span class="type">Int</span>, h: <span class="type">Int</span>, oldw: <span class="type">Int</span>, oldh: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh)</span><br><span class="line">        setUpShader()</span><br><span class="line">        outWidth = w</span><br><span class="line">        outHeight = h</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDraw</span><span class="params">(canvas: <span class="type">Canvas</span>?)</span></span> &#123;</span><br><span class="line"><span class="comment">//        super.onDraw(canvas) 要删除 super.onDraw(canvas)：否则Canvas又会在ImageView中重新绘制，将我们之前的操作都覆盖了</span></span><br><span class="line">        <span class="comment">//绘制圆角</span></span><br><span class="line">        canvas?.drawRoundRect(</span><br><span class="line">            RectF(</span><br><span class="line">                <span class="number">0f</span>,</span><br><span class="line">                (outHeight - <span class="number">2</span> * radius), outWidth.toFloat(), outHeight.toFloat()</span><br><span class="line">            ), radius, radius, mBitmapPaint</span><br><span class="line">        )</span><br><span class="line"><span class="comment">//         利用画笔绘制顶部上面直角部分</span></span><br><span class="line">        canvas?.drawRect(</span><br><span class="line">            RectF(</span><br><span class="line">                <span class="number">0f</span>, <span class="number">0f</span>, outWidth.toFloat(),</span><br><span class="line">                (outHeight - radius)</span><br><span class="line">            ), mBitmapPaint</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化BitmapShader</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">setUpShader</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> drawable: Drawable = drawable ?: <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">val</span> bmp = drawableToBitmap(drawable)</span><br><span class="line">        <span class="comment">// 将bmp作为着色器，就是在指定区域内绘制bmp</span></span><br><span class="line">        mBitmapShader = BitmapShader(bmp, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP)</span><br><span class="line">        <span class="comment">// 如果图片的宽或者高与view的宽高不匹配，计算出需要缩放的比例；缩放后的图片的宽高，一定要大于我们view的宽高；所以我们这里取大值；</span></span><br><span class="line">        <span class="keyword">val</span> scale = Math.max(width / bmp.width.toFloat(), height / bmp.height.toFloat())</span><br><span class="line">        <span class="comment">// shader的变换矩阵，我们这里主要用于放大或者缩小</span></span><br><span class="line">        mMatrix.setScale(scale, scale)</span><br><span class="line">        <span class="comment">// 设置变换矩阵</span></span><br><span class="line">        mBitmapShader.setLocalMatrix(mMatrix)</span><br><span class="line">        <span class="comment">// 设置shader</span></span><br><span class="line">        mBitmapPaint.shader = mBitmapShader</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * drawable转bitmap</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> drawable</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">drawableToBitmap</span><span class="params">(drawable: <span class="type">Drawable</span>)</span></span>: Bitmap &#123;</span><br><span class="line">        <span class="keyword">if</span> (drawable <span class="keyword">is</span> BitmapDrawable) &#123;</span><br><span class="line">            <span class="keyword">val</span> bd: BitmapDrawable = drawable</span><br><span class="line">            <span class="keyword">return</span> bd.bitmap</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> w = drawable.intrinsicWidth</span><br><span class="line">        <span class="keyword">val</span> h = drawable.intrinsicHeight</span><br><span class="line">        <span class="keyword">return</span> Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="一个脚"><a href="#一个脚" class="headerlink" title="一个脚"></a>一个脚</h5><p>前两步绘制的效果</p>
<img src="/2022/08/14/view-round-image/20220828183247.jpg" alt="20220828183247" style="zoom: 50%;">

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoundSingleBitmapShaderView</span> <span class="meta">@JvmOverloads</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    context: Context, attrs: AttributeSet?,</span><br><span class="line">    defStyleAttr: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">) : AppCompatImageView(context, attrs, defStyleAttr) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mBitmapShader: BitmapShader</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mMatrix = Matrix()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mBitmapPaint = Paint();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> mRadius = resources.getDimension(R.dimen.round_bitmap_radius)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> outHeight <span class="keyword">by</span> Delegates.notNull&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> outWidth <span class="keyword">by</span> Delegates.notNull&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSizeChanged</span><span class="params">(w: <span class="type">Int</span>, h: <span class="type">Int</span>, oldw: <span class="type">Int</span>, oldh: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh)</span><br><span class="line">        setUpShader()</span><br><span class="line">        outWidth = w</span><br><span class="line">        outHeight = h</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDraw</span><span class="params">(canvas: <span class="type">Canvas</span>?)</span></span> &#123;</span><br><span class="line"><span class="comment">//        super.onDraw(canvas)  //否则Canvas又会在ImageView中重新绘制，将我们之前的操作都覆盖了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//绘制圆</span></span><br><span class="line">        canvas?.drawRoundRect(</span><br><span class="line">            RectF(<span class="number">0f</span>, <span class="number">0f</span>, <span class="number">2</span> * mRadius, <span class="number">2</span> * mRadius),</span><br><span class="line">            mRadius,</span><br><span class="line">            mRadius,</span><br><span class="line">            mBitmapPaint</span><br><span class="line">        )</span><br><span class="line">        <span class="comment">//绘制矩形竖线</span></span><br><span class="line">        canvas?.drawRect(RectF(<span class="number">0f</span>, mRadius, mRadius, height.toFloat()), mBitmapPaint)</span><br><span class="line"></span><br><span class="line">      	<span class="comment">//绘制主要的图</span></span><br><span class="line">        canvas?.drawRect(</span><br><span class="line">            RectF(</span><br><span class="line">                mRadius, <span class="number">0f</span>, width.toFloat(),</span><br><span class="line">                height.toFloat()</span><br><span class="line">            ), mBitmapPaint</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化BitmapShader</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">setUpShader</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> drawable: Drawable = drawable ?: <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">val</span> bmp = drawableToBitmap(drawable)</span><br><span class="line">        <span class="comment">// 将bmp作为着色器，就是在指定区域内绘制bmp</span></span><br><span class="line">        mBitmapShader = BitmapShader(bmp, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP)</span><br><span class="line">        <span class="comment">// 如果图片的宽或者高与view的宽高不匹配，计算出需要缩放的比例；缩放后的图片的宽高，一定要大于我们view的宽高；所以我们这里取大值；</span></span><br><span class="line">        <span class="keyword">val</span> scale = Math.max(width / bmp.width.toFloat(), height / bmp.height.toFloat())</span><br><span class="line">        <span class="comment">// shader的变换矩阵，我们这里主要用于放大或者缩小</span></span><br><span class="line">        mMatrix.setScale(scale, scale)</span><br><span class="line">        <span class="comment">// 设置变换矩阵</span></span><br><span class="line">        mBitmapShader.setLocalMatrix(mMatrix)</span><br><span class="line">        <span class="comment">// 设置shader</span></span><br><span class="line">        mBitmapPaint.shader = mBitmapShader</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * drawable转bitmap</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> drawable</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">drawableToBitmap</span><span class="params">(drawable: <span class="type">Drawable</span>)</span></span>: Bitmap &#123;</span><br><span class="line">        <span class="keyword">if</span> (drawable <span class="keyword">is</span> BitmapDrawable) &#123;</span><br><span class="line">            <span class="keyword">val</span> bd: BitmapDrawable = drawable</span><br><span class="line">            <span class="keyword">return</span> bd.bitmap</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> w = drawable.intrinsicWidth</span><br><span class="line">        <span class="keyword">val</span> h = drawable.intrinsicHeight</span><br><span class="line">        <span class="keyword">return</span> Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="Xfermode绘制圆角"><a href="#Xfermode绘制圆角" class="headerlink" title="Xfermode绘制圆角"></a>Xfermode绘制圆角</h4><h5 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h5><p>先绘制 绘制黄色的圆</p>
<p>然后绘制蓝色正方形</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1930161-1b9736cdad4df3d8?imageMogr2/auto-orient/strip%7CimageView2/2/w/312/format/webp"></p>
<p>模式    说明<br>PorterDuff.Mode.CLEAR    所有绘制不会绘制到画布上<br>PorterDuff.Mode.SRC    显示上层绘制图形<br>PorterDuff.Mode.DST    显示下层绘制图形<br>PorterDuff.Mode.SRC_OVER    图形叠加，上层盖住下层<br>PorterDuff.Mode.DST_OVER    图形叠加，下层盖住上层<br>PorterDuff.Mode.SRC_IN    显示上层交集部分<br>PorterDuff.Mode.DST_IN    显示下层交集部分<br>PorterDuff.Mode.SRC_OUT    显示上层非交集部分<br>PorterDuff.Mode.DST_OUT    显示下层非交集部分<br>PorterDuff.Mode.SRC_ATOP    显示下层非交集部分和上层交集部分<br>PorterDuff.Mode.DST_ATOP    显示下层交集部分与上层非交集部分<br>PorterDuff.Mode.XOR    去除交集部分<br>PorterDuff.Mode.DARKEN    交集部分颜色加深<br>PorterDuff.Mode.LIGHTEN    交集部分颜色变亮<br>PorterDuff.Mode.MULTIPLY    显示交集部分，颜色混合叠加<br>PorterDuff.Mode.SCREEN    取两图层全部区域，交集部分变为透明色</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaohanluo/article/details/52945791">https://blog.csdn.net/xiaohanluo/article/details/52945791</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.android.google.cn/reference/android/graphics/PorterDuff.Mode">https://developer.android.google.cn/reference/android/graphics/PorterDuff.Mode</a></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleXfermodeView</span></span>(context: Context?) : View(context) &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> mSrcB: Bitmap</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> mDstB: Bitmap</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> mBG <span class="comment">// background checker-board pattern</span></span><br><span class="line">                : Shader</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> modeIndex = <span class="number">1</span> <span class="comment">// 模式</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDraw</span><span class="params">(canvas: <span class="type">Canvas</span>)</span></span> &#123;</span><br><span class="line">            canvas.drawColor(Color.WHITE)</span><br><span class="line">            <span class="keyword">val</span> labelP = Paint(Paint.ANTI_ALIAS_FLAG)</span><br><span class="line">            labelP.textAlign = Paint.Align.CENTER</span><br><span class="line">            <span class="keyword">val</span> paint = Paint()</span><br><span class="line">            paint.isFilterBitmap = <span class="literal">false</span></span><br><span class="line">            canvas.translate(<span class="number">15F</span>, <span class="number">35F</span>)</span><br><span class="line">            <span class="keyword">var</span> x = <span class="number">0f</span></span><br><span class="line">            <span class="keyword">var</span> y = <span class="number">0f</span></span><br><span class="line"><span class="comment">//            for (modeIndex in sModes.indices) &#123;</span></span><br><span class="line">            <span class="comment">// draw the border</span></span><br><span class="line">            paint.style = Paint.Style.STROKE</span><br><span class="line">            paint.shader = <span class="literal">null</span></span><br><span class="line">            canvas.drawRect(</span><br><span class="line">                x - <span class="number">0.5f</span>, y - <span class="number">0.5f</span>,</span><br><span class="line">                x + W + <span class="number">0.5f</span>, y + H + <span class="number">0.5f</span>, paint</span><br><span class="line">            ) <span class="comment">// 外层正方形黑色框框</span></span><br><span class="line">            <span class="comment">// draw the checker-board pattern</span></span><br><span class="line">            paint.style = Paint.Style.FILL</span><br><span class="line">            paint.shader = mBG</span><br><span class="line">            canvas.drawRect(x, y, x + W, y + H, paint) <span class="comment">// 正方形框框里的灰色小格子</span></span><br><span class="line">            <span class="comment">// draw the src/dst example into our offscreen bitmap</span></span><br><span class="line">            <span class="keyword">val</span> sc: <span class="built_in">Int</span> = canvas.saveLayer(</span><br><span class="line">                x, y, x + W, y + H, <span class="literal">null</span>,</span><br><span class="line">            ) <span class="comment">// 保存 图层</span></span><br><span class="line">            canvas.translate(x, y)</span><br><span class="line">            canvas.drawBitmap(mDstB, <span class="number">0f</span>, <span class="number">0f</span>, paint) <span class="comment">// 绘制黄色的圆</span></span><br><span class="line">            paint.xfermode = sModes[modeIndex]</span><br><span class="line">            canvas.drawBitmap(mSrcB, <span class="number">0f</span>, <span class="number">0f</span>, paint) <span class="comment">//绘制蓝色正方形</span></span><br><span class="line">            paint.xfermode = <span class="literal">null</span> <span class="comment">// 我猜否则下次循环会用到</span></span><br><span class="line">            canvas.restoreToCount(sc)</span><br><span class="line">            <span class="comment">// draw the label</span></span><br><span class="line">            canvas.drawText(</span><br><span class="line">                sLabels[modeIndex],</span><br><span class="line">                x + W / <span class="number">2</span>, y - labelP.textSize / <span class="number">2</span>, labelP</span><br><span class="line">            )</span><br><span class="line">            x += W + <span class="number">10</span></span><br><span class="line">            <span class="comment">// wrap around when we&#x27;ve drawn enough for one row</span></span><br><span class="line">            <span class="keyword">if</span> ((modeIndex % ROW_MAX) == ROW_MAX - <span class="number">1</span>) &#123;</span><br><span class="line">                    x = <span class="number">0f</span></span><br><span class="line">                    y += H + <span class="number">30</span></span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">val</span> W = <span class="number">200</span></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">val</span> H = <span class="number">200</span></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">val</span> ROW_MAX = <span class="number">4</span> <span class="comment">// number of samples per row</span></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">val</span> sModes: Array&lt;Xfermode&gt; = arrayOf&lt;Xfermode&gt;(</span><br><span class="line">                PorterDuffXfermode(PorterDuff.Mode.CLEAR),</span><br><span class="line">                PorterDuffXfermode(PorterDuff.Mode.SRC),</span><br><span class="line">                PorterDuffXfermode(PorterDuff.Mode.DST),</span><br><span class="line">                PorterDuffXfermode(PorterDuff.Mode.SRC_OVER),</span><br><span class="line">                PorterDuffXfermode(PorterDuff.Mode.DST_OVER),</span><br><span class="line">                PorterDuffXfermode(PorterDuff.Mode.SRC_IN),</span><br><span class="line">                PorterDuffXfermode(PorterDuff.Mode.DST_IN),</span><br><span class="line">                PorterDuffXfermode(PorterDuff.Mode.SRC_OUT),</span><br><span class="line">                PorterDuffXfermode(PorterDuff.Mode.DST_OUT),</span><br><span class="line">                PorterDuffXfermode(PorterDuff.Mode.SRC_ATOP),</span><br><span class="line">                PorterDuffXfermode(PorterDuff.Mode.DST_ATOP),</span><br><span class="line">                PorterDuffXfermode(PorterDuff.Mode.XOR),</span><br><span class="line">                PorterDuffXfermode(PorterDuff.Mode.DARKEN),</span><br><span class="line">                PorterDuffXfermode(PorterDuff.Mode.LIGHTEN),</span><br><span class="line">                PorterDuffXfermode(PorterDuff.Mode.MULTIPLY),</span><br><span class="line">                PorterDuffXfermode(PorterDuff.Mode.SCREEN)</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">val</span> sLabels = arrayOf(</span><br><span class="line">                <span class="string">&quot;Clear&quot;</span>, <span class="string">&quot;Src&quot;</span>, <span class="string">&quot;Dst&quot;</span>, <span class="string">&quot;SrcOver&quot;</span>,</span><br><span class="line">                <span class="string">&quot;DstOver&quot;</span>, <span class="string">&quot;SrcIn&quot;</span>, <span class="string">&quot;DstIn&quot;</span>, <span class="string">&quot;SrcOut&quot;</span>,</span><br><span class="line">                <span class="string">&quot;DstOut&quot;</span>, <span class="string">&quot;SrcATop&quot;</span>, <span class="string">&quot;DstATop&quot;</span>, <span class="string">&quot;Xor&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Darken&quot;</span>, <span class="string">&quot;Lighten&quot;</span>, <span class="string">&quot;Multiply&quot;</span>, <span class="string">&quot;Screen&quot;</span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">init</span> &#123;</span><br><span class="line">            mSrcB = makeSrc(W, H)</span><br><span class="line">            mDstB = makeDst(W, H)</span><br><span class="line">            <span class="comment">// make a ckeckerboard pattern</span></span><br><span class="line">            <span class="keyword">val</span> bm: Bitmap = Bitmap.createBitmap(</span><br><span class="line">                intArrayOf(</span><br><span class="line">                    -<span class="number">0x1</span>, -<span class="number">0x333334</span>,</span><br><span class="line">                    -<span class="number">0x333334</span>, -<span class="number">0x1</span></span><br><span class="line">                ), <span class="number">2</span>, <span class="number">2</span>,</span><br><span class="line">                Bitmap.Config.RGB_565</span><br><span class="line">            )</span><br><span class="line">            mBG = BitmapShader(</span><br><span class="line">                bm,</span><br><span class="line">                Shader.TileMode.REPEAT,</span><br><span class="line">                Shader.TileMode.REPEAT</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">val</span> m = Matrix()</span><br><span class="line">            m.setScale(<span class="number">6f</span>, <span class="number">6f</span>)</span><br><span class="line">            mBG.setLocalMatrix(m)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="comment">// create a bitmap with a circle, used for the &quot;dst&quot; image</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">makeDst</span><span class="params">(w: <span class="type">Int</span>, h: <span class="type">Int</span>)</span></span>: Bitmap &#123;</span><br><span class="line">            <span class="keyword">val</span> bm: Bitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888)</span><br><span class="line">            <span class="keyword">val</span> c = Canvas(bm)</span><br><span class="line">            <span class="keyword">val</span> p = Paint(Paint.ANTI_ALIAS_FLAG)</span><br><span class="line">            p.color = -<span class="number">0x33bc</span></span><br><span class="line">            c.drawOval(RectF(<span class="number">0f</span>, <span class="number">0f</span>, w * <span class="number">3f</span> / <span class="number">4</span>, h * <span class="number">3f</span> / <span class="number">4</span>), p)</span><br><span class="line">            <span class="keyword">return</span> bm</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create a bitmap with a rect, used for the &quot;src&quot; image</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">makeSrc</span><span class="params">(w: <span class="type">Int</span>, h: <span class="type">Int</span>)</span></span>: Bitmap &#123;</span><br><span class="line">            <span class="keyword">val</span> bm: Bitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888)</span><br><span class="line">            <span class="keyword">val</span> c = Canvas(bm)</span><br><span class="line">            <span class="keyword">val</span> p = Paint(Paint.ANTI_ALIAS_FLAG)</span><br><span class="line">            p.color = -<span class="number">0x995501</span></span><br><span class="line">            c.drawRect(w / <span class="number">3f</span>, h / <span class="number">3f</span>, w * <span class="number">19f</span> / <span class="number">20</span>, h * <span class="number">19f</span> / <span class="number">20</span>, p)</span><br><span class="line">            <span class="keyword">return</span> bm</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="圆角图片"><a href="#圆角图片" class="headerlink" title="圆角图片"></a>圆角图片</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TYPE_CIRCLE = <span class="number">0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TYPE_ROUND = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XfermodeView</span> <span class="meta">@JvmOverloads</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    context: Context?,</span><br><span class="line">    attrs: AttributeSet? = <span class="literal">null</span>,</span><br><span class="line">    defStyleAttr: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">) : View(context, attrs, defStyleAttr) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> src: Bitmap? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> <span class="keyword">out</span>: Bitmap? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mWidth = <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mHeight = <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> type = TYPE_ROUND  <span class="comment">//设置类型，是圆角图片还是圆角矩形</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="comment">// 禁止硬件加速，硬件加速会有一些问题，这里禁用掉</span></span><br><span class="line">        setLayerType(LAYER_TYPE_SOFTWARE, <span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onMeasure</span><span class="params">(widthMeasureSpec: <span class="type">Int</span>, heightMeasureSpec: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自己计算控件的宽高</span></span><br><span class="line">        <span class="keyword">val</span> widthSize = MeasureSpec.getSize(widthMeasureSpec)</span><br><span class="line">        <span class="keyword">val</span> widthMode = MeasureSpec.getMode(widthMeasureSpec)</span><br><span class="line">        <span class="keyword">val</span> heightSize = MeasureSpec.getSize(heightMeasureSpec)</span><br><span class="line">        <span class="keyword">val</span> heightMode = MeasureSpec.getMode(heightMeasureSpec)</span><br><span class="line">        mWidth = <span class="keyword">if</span> (widthMode == MeasureSpec.EXACTLY) &#123;</span><br><span class="line">            widthSize</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> imgWidth = (src!!.width + paddingLeft</span><br><span class="line">                    + paddingRight)</span><br><span class="line">            <span class="keyword">if</span> (widthMode == MeasureSpec.AT_MOST) &#123;</span><br><span class="line">                Math.min(widthSize, imgWidth)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                imgWidth</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mHeight = <span class="keyword">if</span> (heightMode == MeasureSpec.EXACTLY) &#123;</span><br><span class="line">            heightSize</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> imgHeight = (src!!.height + paddingTop</span><br><span class="line">                    + paddingBottom)</span><br><span class="line">            <span class="keyword">if</span> (heightMode == MeasureSpec.AT_MOST) &#123;</span><br><span class="line">                Math.min(heightSize, imgHeight)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                imgHeight</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">when</span> (type) &#123;</span><br><span class="line">            TYPE_CIRCLE -&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> min = Math.min(mWidth, mHeight)</span><br><span class="line">                setMeasuredDimension(min, min)</span><br><span class="line">            &#125;</span><br><span class="line">            TYPE_ROUND -&gt; setMeasuredDimension(mWidth, mHeight)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDraw</span><span class="params">(canvas: <span class="type">Canvas</span>)</span></span> &#123;</span><br><span class="line">        xmodeImage()</span><br><span class="line">        <span class="comment">//把画好画的画布放到自定义的画板上面</span></span><br><span class="line">        canvas.drawBitmap(<span class="keyword">out</span>!!, <span class="number">0f</span>, <span class="number">0f</span>, <span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">xmodeImage</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//根据原始的图片创建一个画布</span></span><br><span class="line">        <span class="keyword">out</span> = Bitmap.createBitmap(mWidth, mHeight, Bitmap.Config.ARGB_8888)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个画板，在画布的基础上</span></span><br><span class="line">        <span class="keyword">val</span> canvas = Canvas(<span class="keyword">out</span>!!)</span><br><span class="line">        <span class="comment">//创建一个画笔</span></span><br><span class="line">        <span class="keyword">val</span> paint = Paint(Paint.ANTI_ALIAS_FLAG)</span><br><span class="line">        <span class="keyword">when</span> (type) &#123;</span><br><span class="line">            TYPE_ROUND -&gt;            <span class="comment">//开始在有画板的画布上用画笔作画了，这里画了一个圆角矩形</span></span><br><span class="line">                canvas.drawRoundRect(</span><br><span class="line">                    RectF(<span class="number">0f</span>, <span class="number">0f</span>, mWidth.toFloat(), mHeight.toFloat()),</span><br><span class="line">                    <span class="number">60f</span>,</span><br><span class="line">                    <span class="number">60f</span>,</span><br><span class="line">                    paint</span><br><span class="line">                )</span><br><span class="line">            TYPE_CIRCLE -&gt; &#123;</span><br><span class="line">                <span class="comment">//画圆，取宽高的最小值作为圆的直径</span></span><br><span class="line">                <span class="keyword">val</span> min = Math.min(mWidth, mHeight)</span><br><span class="line">                <span class="comment">//开始画圆</span></span><br><span class="line">                canvas.drawCircle(</span><br><span class="line">                    (min / <span class="number">2</span>).toFloat(),</span><br><span class="line">                    (min / <span class="number">2</span>).toFloat(),</span><br><span class="line">                    (min / <span class="number">2</span>).toFloat(),</span><br><span class="line">                    paint</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        src = BitmapFactory.decodeResource(resources, R.drawable.meitu110468869)</span><br><span class="line">        <span class="comment">//设置Xfermode画笔模式为SRC_IN</span></span><br><span class="line">        paint.xfermode = PorterDuffXfermode(PorterDuff.Mode.SRC_IN)</span><br><span class="line">        <span class="comment">//然后有画了一个图片，最终实现两个图像的叠加</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> zoomImg = zoomImg(src!!, mWidth, mHeight)</span><br><span class="line">        canvas.drawBitmap(zoomImg!!, <span class="number">0f</span>, <span class="number">0f</span>, paint)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">zoomImg</span><span class="params">(bm: <span class="type">Bitmap</span>, newWidth: <span class="type">Int</span>, newHeight: <span class="type">Int</span>)</span></span>: Bitmap? &#123;</span><br><span class="line">        <span class="comment">// 获得图片的宽高</span></span><br><span class="line">        <span class="keyword">val</span> width = bm.width</span><br><span class="line">        <span class="keyword">val</span> height = bm.height</span><br><span class="line">        <span class="comment">// 计算缩放比例</span></span><br><span class="line">        <span class="keyword">val</span> scaleWidth = newWidth.toFloat() / width</span><br><span class="line">        <span class="keyword">val</span> scaleHeight = newHeight.toFloat() / height</span><br><span class="line">        <span class="comment">// 取得想要缩放的matrix参数</span></span><br><span class="line">        <span class="keyword">val</span> matrix = Matrix()</span><br><span class="line">        matrix.postScale(scaleWidth, scaleHeight)</span><br><span class="line">        <span class="comment">// 得到新的图片</span></span><br><span class="line">        <span class="keyword">return</span> Bitmap.createBitmap(bm, <span class="number">0</span>, <span class="number">0</span>, width, height, matrix, <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




	
	</div>
  <a type="button" href="/2022/08/14/view-round-image/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/07/26/Leetcode/" >leetcode</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-07-26  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h4 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-parentheses">20. 有效的括号</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//官方 HashMap 解法更好 更清晰</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Stack stack = <span class="keyword">new</span> Stack();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> ((c == <span class="string">&#x27;(&#x27;</span>) || c == <span class="string">&#x27;[&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            stack.push(c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> p1 = (c == <span class="string">&#x27;)&#x27;</span> &amp;&amp; (<span class="keyword">char</span>) stack.peek() == <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> p2 = (c == <span class="string">&#x27;]&#x27;</span> &amp;&amp; (<span class="keyword">char</span>) stack.peek() == <span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">            <span class="keyword">boolean</span> p3 = (c == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; (<span class="keyword">char</span>) stack.peek() == <span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (p1 || p2 || p3) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h4><h5 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;</span><br><span class="line">    ListNode prevHead &#x3D; new ListNode(-1);</span><br><span class="line">    ListNode  prev &#x3D; prevHead;</span><br><span class="line">    while (l1 !&#x3D; null &amp;&amp; l2 !&#x3D; null) &#123;</span><br><span class="line">        if (l1.val &lt; l2.val) &#123;</span><br><span class="line">            prev.next &#x3D; l1;</span><br><span class="line">            l1 &#x3D; l1.next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            prev.next &#x3D; l2;</span><br><span class="line">            l2 &#x3D; l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        prev &#x3D; prev.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (l1 &#x3D;&#x3D; null) &#123;</span><br><span class="line">        prev.next &#x3D; l2;</span><br><span class="line">    &#125;</span><br><span class="line">    if (l2 &#x3D;&#x3D; null) &#123;</span><br><span class="line">        prev.next &#x3D; l1;</span><br><span class="line">    &#125;</span><br><span class="line">    return prevHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="迭代解法"><a href="#迭代解法" class="headerlink" title="迭代解法"></a>迭代解法</h5><p>待学习</p>
<h4 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h4><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p>
<p>图示两个链表在节点 c1 开始相交：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution_160</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode la = headA;</span><br><span class="line">        ListNode lb = headB;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(la!=lb)&#123;</span><br><span class="line">            la = (la==<span class="keyword">null</span>) ? headB : la.next;</span><br><span class="line">            lb = (lb==<span class="keyword">null</span>) ? headA : lb.next ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> la;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>先走自己的路，再走对方的路，最终路程一样</strong></p>
<p>可以这么理解，a，b两个链表，变更为 a+b 和 b+a，长度就相等了，然后等步遍历判断是否相等就行了</p>
<p>原始的数据</p>
<p><img src="https://pic.leetcode-cn.com/1628662967-RLmciV-2.png"></p>
<p>修改后的数据示意图</p>
<p><img src="https://pic.leetcode-cn.com/1628662688-ZdSYRM-1.png" alt="1.png"></p>
<p>!(<img src="https://pic.leetcode-cn.com/e86e947c8b87ac723b9c858cd3834f9a93bcc6c5e884e41117ab803d205ef662-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8.png" alt="相交链表.png">)</p>
<h4 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a></h4><p>迭代法需要再写下 </p>

	
	</div>
  <a type="button" href="/2022/07/26/Leetcode/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/07/26/Gradle/" >Gradle</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-07-26  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<p>可以研究下 Project Api </p>
<h3 id="DEBUG"><a href="#DEBUG" class="headerlink" title="DEBUG"></a>DEBUG</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;gradlew &quot;-Dorg.gradle.daemon&#x3D;false&quot; &quot;-Dorg.gradle.debug&#x3D;true&quot; :tasks</span><br></pre></td></tr></table></figure>



<p>9:37</p>
<h3 id="Gradle-Lifecycle"><a href="#Gradle-Lifecycle" class="headerlink" title="Gradle Lifecycle"></a>Gradle Lifecycle</h3><p><a target="_blank" rel="noopener" href="https://docs.gradle.org/current/userguide/build_lifecycle.html">https://docs.gradle.org/current/userguide/build_lifecycle.html</a></p>
<ul>
<li><p>Initialization</p>
<p>Detects the <a target="_blank" rel="noopener" href="https://docs.gradle.org/current/userguide/organizing_gradle_projects.html#sec:settings_file">settings file</a>.Evaluates the settings file to determine which projects and included builds participate in the build.Creates a <a target="_blank" rel="noopener" href="https://docs.gradle.org/current/dsl/org.gradle.api.Project.html"><code>Project</code></a> instance for every project.</p>
</li>
<li><p>Configuration</p>
<p>Evaluates the build scripts of every project participating in the build.Creates a task graph for requested tasks.</p>
<p>本质上把build.gradle从上到下跑一遍。</p>
</li>
<li><p>Execution</p>
<p>Schedules and executes each of the selected tasks in the order of their dependencies.</p>
</li>
</ul>
<h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1m54y1L7vK/">https://www.bilibili.com/video/BV1m54y1L7vK/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1dK411K7Pg">https://www.bilibili.com/video/BV1dK411K7Pg</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1DE411Z7nt">https://www.bilibili.com/video/BV1DE411Z7nt</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1dp4y1e7W4">https://www.bilibili.com/video/BV1dp4y1e7W4</a></p>
<p>注意Android stuio默认关闭task 按钮</p>
<h5 id="静态任务"><a href="#静态任务" class="headerlink" title="静态任务"></a>静态任务</h5><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">&quot;gradle study&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">task(<span class="string">&quot;helloworld&quot;</span>,&#123;</span><br><span class="line">    println(<span class="string">&#x27;configure&#x27;</span>)</span><br><span class="line">    doLast &#123;&#123;</span><br><span class="line">        println(<span class="string">&quot;Executing task&quot;</span>)</span><br><span class="line">    &#125;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>./gradlew helloworld</p>
<h5 id="动态任务"><a href="#动态任务" class="headerlink" title="动态任务"></a>动态任务</h5><p><img src="/2022/07/26/Gradle/2023-07-16-gradle1.png" alt="2023-07-16-gradle1"></p>
<p>“configure” 在生命周期Configuration 阶段就执行。</p>
<p>dolast dofirst只是加入到任务中，只有指定具体执行的任务，才会执行，就像上面的 ./gradlew helloworld，指明helloworld任务。</p>
<p>闭包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">task testGrdele&#123;</span><br><span class="line">    println(&quot;testGrdele&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;闭包的概念, 像kotlin匿名函数</span><br><span class="line">task closure&#123;</span><br><span class="line">    mEach&#123;</span><br><span class="line">        println it</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mEachWithParams &#123; m, n -&gt;&#x2F;&#x2F;  -&gt; 将闭包的参数和主体分离开</span><br><span class="line">        println &quot;$&#123;m&#125; is $&#123;n&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">def mEach(closure)&#123;</span><br><span class="line">    for (int i in 1..5)&#123;</span><br><span class="line">        closure(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def mEachWithParams(closure)&#123;</span><br><span class="line">    def map &#x3D; [&#39;name&#39;:&#39;groovy&#39;,&#39;age&#39;:10]</span><br><span class="line">    map.each &#123;</span><br><span class="line">        closure(it.key,it.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h3><h4 id="Scrpit-Plugin"><a href="#Scrpit-Plugin" class="headerlink" title="Scrpit Plugin"></a>Scrpit Plugin</h4><h5 id="CustomGradlePlugin"><a href="#CustomGradlePlugin" class="headerlink" title="CustomGradlePlugin"></a>CustomGradlePlugin</h5><p> ./gradlew CustomGradlePlugin</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.脚本插件</span></span><br><span class="line"><span class="comment">//app模块下的build.gradle文件中定义的对象插件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomGradlePlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> apply(Project target) &#123;</span><br><span class="line">        target.task(<span class="string">&quot;showCustomPlugin&quot;</span>) &#123;</span><br><span class="line">            doLast &#123;</span><br><span class="line">                println(<span class="string">&quot;this is CustomGradlePlugin&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>./gradlew scriptPlugin</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply from: &quot;config.gradle&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">project.task(<span class="string">&quot;scriptPlugin&quot;</span>) &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println(<span class="string">&quot;$project.name:this is a scriptPlugin&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>ankotlin:this is a scriptPlugin</p>
<h5 id="MyAwesomePlugin"><a href="#MyAwesomePlugin" class="headerlink" title="MyAwesomePlugin"></a>MyAwesomePlugin</h5><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAwesomePlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt;&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> apply(Project project) &#123;</span><br><span class="line">        task(<span class="string">&quot;helloworld22&quot;</span>,&#123;</span><br><span class="line">            println(<span class="string">&#x27;configure&#x27;</span>)</span><br><span class="line">            doLast &#123;&#123;</span><br><span class="line">                println(<span class="string">&quot;Executing task&quot;</span>)</span><br><span class="line">            &#125;&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply <span class="attr">plugins :</span> MyAwesomePlugin</span><br></pre></td></tr></table></figure>





<p>buildscript 可以把java complile的classpath加入到build.gradle中</p>
<h4 id="Use-Plungin-in-build-gradle"><a href="#Use-Plungin-in-build-gradle" class="headerlink" title="Use Plungin in build.gradle"></a>Use Plungin in build.gradle</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath group: &#39;org.apache.commons&#39;, name: &#39;commons-lang3&#39;, version: &#39;3.5&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: &#39;java&#39;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation group: &#39;org.apache.commons&#39;, name: &#39;commons-lang3&#39;, version: &#39;3.5&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (StringUtils.isNoneEmpty())&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就能使用java的方法在build.gradle中。</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/60550107/gradle-share-repository-configuration-between-settings-gradle-kts-and-buildsrc">https://stackoverflow.com/questions/60550107/gradle-share-repository-configuration-between-settings-gradle-kts-and-buildsrc</a></p>

	
	</div>
  <a type="button" href="/2022/07/26/Gradle/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/07/24/kotlin-inline/" >kotlin-inline</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-07-24  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<p><img src="/2022/07/24/kotlin-inline/20220724115333.jpg" alt="20220724115333"></p>
<h4 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h4><p>4:00分钟 </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    hello &#123;</span><br><span class="line">        println(<span class="string">&quot;Bye&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="不加inline"><a href="#不加inline" class="headerlink" title="不加inline"></a>不加inline</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">(postAction: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line">    postAction()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际编译结果大致</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">val</span> post. = <span class="keyword">object</span>: Function0&lt;<span class="built_in">Unit</span>&gt;&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">nvoke</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> prinltn(<span class="string">&quot;Bye!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在for(i in 1.. 100) 就会创建很对个对象</p>
<h5 id="加-inline"><a href="#加-inline" class="headerlink" title="加 inline"></a>加 inline</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">(postAction: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line">    postAction()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不仅把函数内连过来,也会把它内部的函数的类型的参数 ，lambda表达式也内联过来.</p>
<p>//编译代码 类似</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  println(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">  println(<span class="string">&quot;Bye!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就不存在，对象的创建</p>
<p>noinline</p>
<p>crossinline</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1kz4y1f7sf">https://www.bilibili.com/video/BV1kz4y1f7sf</a></p>

	
	</div>
  <a type="button" href="/2022/07/24/kotlin-inline/#more" class="btn btn-default more">Read More</a>
</div>

		

		</div>

		<!-- pagination -->
		<div>
  		<center>
		<div class="pagination">

   
    
     <a href="/" type="button" class="btn btn-default"><i class="fa fa-arrow-circle-o-left"></i> Prev</a>
      

        <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
 
       <a href="/page/3/" type="button" class="btn btn-default ">Next<i class="fa fa-arrow-circle-o-right"></i></a>     
        

  
</div>

  		</center>
		</div>

		
		
	</div> <!-- col-md-9 -->

	
		<div class="col-md-3">
	<div id="sidebar">
	
			
  <div id="site_search">
   <div class="form-group">
    <input type="text" id="local-search-input" name="q" results="0" placeholder="Search" class="st-search-input st-default-search-input form-control"/>
   </div>  
  <div id="local-search-result"></div>
  </div>


		
			
	<div class="widget">
		<h4>Categories</h4>
		<ul class="tag_box inline list-unstyled">
		
			<li><a href="/categories/ANDROID/">ANDROID<span>58</span></a></li>
		
			<li><a href="/categories/BLE/">BLE<span>4</span></a></li>
		
			<li><a href="/categories/DataStructure/">DataStructure<span>16</span></a></li>
		
			<li><a href="/categories/DesignPatterns/">DesignPatterns<span>9</span></a></li>
		
			<li><a href="/categories/ENGLISH/">ENGLISH<span>1</span></a></li>
		
			<li><a href="/categories/JAVA/">JAVA<span>27</span></a></li>
		
			<li><a href="/categories/Jetpack/">Jetpack<span>5</span></a></li>
		
			<li><a href="/categories/Kotlin/">Kotlin<span>11</span></a></li>
		
			<li><a href="/categories/LINUX/">LINUX<span>5</span></a></li>
		
			<li><a href="/categories/Mathematics/">Mathematics<span>1</span></a></li>
		
			<li><a href="/categories/OS/">OS<span>2</span></a></li>
		
			<li><a href="/categories/Organization/">Organization<span>2</span></a></li>
		
			<li><a href="/categories/SOURCE/">SOURCE<span>1</span></a></li>
		
			<li><a href="/categories/TEST/">TEST<span>4</span></a></li>
		
			<li><a href="/categories/TOOL/">TOOL<span>11</span></a></li>
		
			<li><a href="/categories/VIEW/">VIEW<span>12</span></a></li>
		
			<li><a href="/categories/anim/">anim<span>4</span></a></li>
		
			<li><a href="/categories/flutter/">flutter<span>5</span></a></li>
		
		</ul>
	</div>

		
			
	<div class="widget">
		<h4>Tag Cloud</h4>
		<ul class="tag_box inline list-unstyled">		
		
			<li><a href="/tags/proguard/">proguard<span>1</span></a></li>
		
			<li><a href="/tags/BLOG/">BLOG<span>1</span></a></li>
		
			<li><a href="/tags/coroutie/">coroutie<span>7</span></a></li>
		
			<li><a href="/tags/THINK/">THINK<span>1</span></a></li>
		
			<li><a href="/tags/AOSP/">AOSP<span>7</span></a></li>
		
			<li><a href="/tags/Performance/">Performance<span>4</span></a></li>
		
			<li><a href="/tags/LEETCODE/">LEETCODE<span>12</span></a></li>
		
			<li><a href="/tags/ConstraintLayout/">ConstraintLayout<span>1</span></a></li>
		
			<li><a href="/tags/RecyclerView/">RecyclerView<span>2</span></a></li>
		
			<li><a href="/tags/concurrency/">concurrency<span>4</span></a></li>
		
			<li><a href="/tags/TOOL/">TOOL<span>2</span></a></li>
		
			<li><a href="/tags/AndroidNewFeatures/">AndroidNewFeatures<span>1</span></a></li>
		
			<li><a href="/tags/keyboard/">keyboard<span>1</span></a></li>
		
			<li><a href="/tags/Git/">Git<span>2</span></a></li>
		
			<li><a href="/tags/inter/">inter<span>8</span></a></li>
		
			<li><a href="/tags/anim/">anim<span>1</span></a></li>
		
			<li><a href="/tags/TouchEvent/">TouchEvent<span>3</span></a></li>
		
			<li><a href="/tags/VIEW/">VIEW<span>2</span></a></li>
		
			<li><a href="/tags/Activity/">Activity<span>1</span></a></li>
		
			<li><a href="/tags/Assembly/">Assembly<span>1</span></a></li>
		
		
		   <li><a href="/tags">...<span>31</span></a></li>
		 
		</ul>
	</div>


		
			
<div class="widget">
  <h4>Recent Posts</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/2023/09/04/Android_interview organize/" ><i class="fa fa-file-o"></i>Android_itnerview_organize</a>
      </li>
    
      <li>
        <a href="/2023/09/03/Android-itnerview-algorithm/" ><i class="fa fa-file-o"></i>Android_itnerview_algorithm</a>
      </li>
    
      <li>
        <a href="/2023/08/20/compose-layout/" ><i class="fa fa-file-o"></i>compose_layout</a>
      </li>
    
      <li>
        <a href="/2023/08/19/compose/" ><i class="fa fa-file-o"></i>compose</a>
      </li>
    
      <li>
        <a href="/2023/08/09/LC-DP-BAG/" ><i class="fa fa-file-o"></i>LC_DP_BAG</a>
      </li>
    
  </ul>
</div>

		
			
<div class="widget">
	<h4>Links</h4>
	<ul class="blogroll list-unstyled">
	
		<li><i class="false"></i><a href="https://github.com/Ares-X/hexo-theme-freemind.bithack" title="" target="_blank"]);">hexo-theme-bithack</a></li>
	
	</ul>
</div>


		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->

	
	
</div> <!-- row-fluid -->
	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  
  &copy; 2023 Jon's Blog
  
      powered by <a href="http://hexo.io/" target="_blank">Hexo</a>.Theme <a href="https://github.com/Ares-X/hexo-theme-freemind.bithack" target="_blank">freemind.bithack</a>  
</p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



</body>
   </html>
