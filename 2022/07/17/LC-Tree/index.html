<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>LC-Tree | Jon&#39;s Blog</title>
  <meta name="author" content="Jon">
  
  <meta name="description" content="二叉树算法思维
https://www.bilibili.com/video/BV1nG411x77H
TreeOperation.java打印树
Tree

https://www.bilibili.com/video/BV1JW411i731
完全二叉树数组存储方式

i 是数组下标
遍历
每个">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="LC-Tree"/>
  <meta property="og:site_name" content="Jon&#39;s Blog"/>

  
    <meta property="og:image" content=""/>
  

  
    <link rel="alternative" href="/atom.xml" title="Jon&#39;s Blog" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/prism.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-70812759-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-70812759-1');
</script>






<meta name="generator" content="Hexo 6.3.0"></head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">Jon&#39;s Blog</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class=""></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class=""></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class=""></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class=""></i>About
			</a>
		  </li>
		  
		  <li>
			<a href="/atom.xml" title="Subscribe me.">
			  <i class=""></i>RSS
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> LC-Tree</h1>
		</div>
	



<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  		

	  <p>二叉树算法思维</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1nG411x77H">https://www.bilibili.com/video/BV1nG411x77H</a></p>
<p>TreeOperation.java打印树</p>
<h4 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h4><p><img src="/2022/07/17/LC-Tree/20220723171518.jpg" alt="20220723171518"></p>
<p><img src="/2022/07/17/LC-Tree/20220723171848.jpg" alt="20220723171848"></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1JW411i731">https://www.bilibili.com/video/BV1JW411i731</a></p>
<h5 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h5><p>数组存储方式</p>
<p><img src="/2022/07/17/LC-Tree/20220723173810.jpg" alt="20220723173810"></p>
<p>i 是数组下标</p>
<h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p><img src="/2022/07/17/LC-Tree/20220723183845.jpg" alt="20220723183845"></p>
<p>每个Node都有3次访问机会，谁先出现就代表什么序.</p>
<p>中间节点  在哪,代表的遍历方式</p>
<ul>
<li>先序遍历  preorder traversal ：中左右</li>
<li>中序遍历 inorder traversal：左中右</li>
<li>后序遍历 postorder traversal：左右中</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/azl397985856/leetcode/blob/master/thinkings/tree.md">https://github.com/azl397985856/leetcode/blob/master/thinkings/tree.md</a></p>
<h5 id="preorder-traversal-递归"><a href="#preorder-traversal-递归" class="headerlink" title="preorder traversal 递归"></a>preorder traversal 递归</h5><p><img src="/2022/07/17/LC-Tree/20220724172053.jpg" alt="20220724172053"></p>
<p>二叉树的遍历动画</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1RR4y1j7kh">https://www.bilibili.com/video/BV1RR4y1j7kh</a></p>
<p>B的左边遍历完成后，开始遍历B的右子树</p>
<p>遍历过程</p>
<ol>
<li>访问根节点</li>
<li>先序遍历其左子树</li>
<li>先序遍历其右子树</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraversal</span><span class="params">(BinTree BT)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(BT)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, BT -&gt; Data);</span><br><span class="line">    PreOrderTraversal(BT-&gt;Left)</span><br><span class="line">    PreOrderTraversal(BT-&gt;Right)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1JW411i731?p=34&amp;vd_source=d4c5260002405798a57476b318eccac9">https://www.bilibili.com/video/BV1JW411i731?p=34&amp;vd_source=d4c5260002405798a57476b318eccac9</a></p>
<h5 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h5><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV15f4y1W7i2">https://www.bilibili.com/video/BV15f4y1W7i2</a></p>
<h5 id="构建和打印树"><a href="#构建和打印树" class="headerlink" title="构建和打印树"></a>构建和打印树</h5><p><a target="_blank" rel="noopener" href="https://blog.nowcoder.net/n/f3799d64ed764fd49c63947d617d4cd5">https://blog.nowcoder.net/n/f3799d64ed764fd49c63947d617d4cd5</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/playground/VDCGQ8Ds/">https://leetcode.cn/playground/VDCGQ8Ds/</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/vpcMyM/">https://leetcode.cn/circle/discuss/vpcMyM/</a></p>
<p>中序遍历</p>
<p><img src="/2022/07/17/LC-Tree/20220723183055.jpg" alt="20220723183055"></p>
<h5 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h5><p>也叫 广度优先遍历</p>
<p>用队列实现</p>
<p>while遍历纵向层数</p>
<p>for遍历横向</p>
<p><img src="https://labuladong.gitee.io/algo/images/dijkstra/1.jpeg"></p>
<p><img src="/2022/07/17/LC-Tree/20220723185012.jpg" alt="20220723185012"></p>
<h4 id="确定二叉树"><a href="#确定二叉树" class="headerlink" title="确定二叉树"></a>确定二叉树</h4><p>必须有中序遍历，和先 后 序遍历之一</p>
<p><img src="/2022/07/17/LC-Tree/20220723185911.jpg" alt="20220723185911"></p>
<p>二叉搜索树</p>
<p>BST. Binary Search Tree</p>
<p><img src="/2022/07/17/LC-Tree/20220723190752.jpg" alt="20220723190752"></p>
<h5 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h5><p>递归</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">preorderTraversal</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> linkedList = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    preTraversal(root, linkedList)</span><br><span class="line">    <span class="keyword">return</span> linkedList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">preTraversal</span><span class="params">(node: <span class="type">TreeNode</span>?, linkedList: <span class="type">LinkedList</span>&lt;<span class="type">Int</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="comment">// 这样的递归基更好</span></span><br><span class="line">    linkedList.add(node.`<span class="keyword">val</span>`)</span><br><span class="line">    preTraversal(node.left, linkedList)</span><br><span class="line">    preTraversal(node.right, linkedList)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>迭代</p>
<p>随想录</p>
<p>前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。</p>
<p>为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbmss7603g30eq0d4b2a.gif" alt="二叉树前序遍历（迭代法）"></p>
<p>5 4 1 2 6</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">preorderTraversal1</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> linkedList = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">val</span> stack = Stack&lt;TreeNode&gt;()</span><br><span class="line">    root?.let&#123;</span><br><span class="line">        stack.push(it)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> popNode = stack.pop()</span><br><span class="line">        popNode.`<span class="keyword">val</span>`.let&#123;</span><br><span class="line">            linkedList.add(it)</span><br><span class="line">        &#125;</span><br><span class="line">        popNode.right?.let &#123;</span><br><span class="line">            stack.push(it)</span><br><span class="line">        &#125;</span><br><span class="line">        popNode.left?.let &#123;</span><br><span class="line">            stack.push(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> linkedList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h5><p>递归</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">inorderTraversal</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> linkedList = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    orderRecursive(root, linkedList)</span><br><span class="line">    <span class="keyword">return</span> linkedList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">orderRecursive</span><span class="params">(node: <span class="type">TreeNode</span>?, linkedList: <span class="type">LinkedList</span>&lt;<span class="type">Int</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">    orderRecursive(node.left, linkedList)</span><br><span class="line">    linkedList.add(node.`<span class="keyword">val</span>`)</span><br><span class="line">    orderRecursive(node.right, linkedList)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>迭代法</p>
<p>随想录</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbmuj244bg30eq0d4kjm.gif" alt="二叉树中序遍历（迭代法）"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">inorderTraversal1</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> linkedList = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> linkedList</span><br><span class="line">    <span class="keyword">val</span> stack = Stack&lt;TreeNode&gt;()</span><br><span class="line">    <span class="keyword">var</span> node = root</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span> || !stack.empty()) &#123; <span class="comment">//node != null 第一次可以进来</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(node)</span><br><span class="line">            node = node.left</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> resultNode = stack.pop()</span><br><span class="line">            linkedList.add(resultNode.`<span class="keyword">val</span>`)</span><br><span class="line">            node = resultNode.right</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> linkedList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h5><p>递归</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//recurive</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">postorderTraversal</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> linkedList = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    recursiveTraversal(root, linkedList)</span><br><span class="line">    <span class="keyword">return</span> linkedList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">recursiveTraversal</span><span class="params">(node: <span class="type">TreeNode</span>?, linkedList: <span class="type">LinkedList</span>&lt;<span class="type">Int</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">    recursiveTraversal(node.left, linkedList)</span><br><span class="line">    recursiveTraversal(node.right, linkedList)</span><br><span class="line">    linkedList.add(node.`<span class="keyword">val</span>`)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>迭代法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">postorderTraversal</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">     <span class="keyword">var</span> mRoot = root</span><br><span class="line">     <span class="keyword">val</span> resultList = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">     <span class="keyword">val</span> stack = Stack&lt;TreeNode&gt;()</span><br><span class="line">     <span class="keyword">var</span> preNode: TreeNode? = <span class="literal">null</span></span><br><span class="line">     <span class="keyword">while</span> (mRoot != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">         <span class="keyword">while</span> (mRoot != <span class="literal">null</span>) &#123;</span><br><span class="line">             stack.push(mRoot)</span><br><span class="line">             mRoot = mRoot.left</span><br><span class="line">         &#125;</span><br><span class="line">         mRoot = stack.pop()</span><br><span class="line">         <span class="keyword">if</span> (mRoot?.right == <span class="literal">null</span> || mRoot.right == preNode) &#123; <span class="comment">// 一开始写成这样 mRoot == preNode,导致死循环</span></span><br><span class="line">             resultList.add(mRoot.`<span class="keyword">val</span>`)</span><br><span class="line">             preNode = mRoot</span><br><span class="line">             mRoot = <span class="literal">null</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             stack.push(mRoot)</span><br><span class="line">             mRoot = mRoot.right</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> resultList</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-postorder-traversal/solution/er-cha-shu-de-hou-xu-bian-li-by-leetcode-solution/">https://leetcode.cn/problems/binary-tree-postorder-traversal/solution/er-cha-shu-de-hou-xu-bian-li-by-leetcode-solution/</a> 动图</p>
<p>官方题解</p>
<p>迭代法统一写法</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/dai-ma-sui-xiang-lu-che-di-chi-tou-qian-xjof1/">https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/dai-ma-sui-xiang-lu-che-di-chi-tou-qian-xjof1/</a></p>
<p>这个统一法还没研究，先往后学吧，地铁上看了下，其实也不难</p>
<h4 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h4><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnad5itmk8g30iw0cqe83.gif"></p>
<p>按照顺序，下一层的放在后面.</p>
<h5 id="迭代写法"><a href="#迭代写法" class="headerlink" title="迭代写法"></a>迭代写法</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">levelOrder</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> layerList = LinkedList&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.offer(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> layerSize = queue.size <span class="comment">// queue大小，下面循环在不断变化，所以要先定义出来</span></span><br><span class="line">        <span class="keyword">val</span> linkedList = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until layerSize) &#123;</span><br><span class="line">            <span class="keyword">val</span> headNode = queue.poll()</span><br><span class="line">            linkedList.add(headNode.`<span class="keyword">val</span>`)</span><br><span class="line">            headNode.left?.let &#123; queue.offer(it) &#125;</span><br><span class="line">            headNode.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        layerList.add(linkedList)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> layerList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h5><p>递归解法一开始没理解，再看了下，思路很妙</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">levelOrder1</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> layerList = LinkedList&lt;LinkedList&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> layerList</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> depth = <span class="number">0</span> <span class="comment">// 层级</span></span><br><span class="line">    <span class="keyword">return</span> recursive(layerList, root, depth)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">recursive</span><span class="params">(layerList: <span class="type">LinkedList</span>&lt;<span class="type">LinkedList</span>&lt;<span class="type">Int</span>&gt;&gt;, node: <span class="type">TreeNode</span>?, depth: <span class="type">Int</span>)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (layerList.size &lt;= depth) &#123; <span class="comment">//二维数组长度不超过这个层级,随想录这里是用 ==,不过我觉得&lt;=更好</span></span><br><span class="line">        <span class="keyword">val</span> linkedList = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        layerList.add(linkedList)</span><br><span class="line">    &#125;</span><br><span class="line">    node?.`<span class="keyword">val</span>`?.let &#123; layerList[depth].add(it) &#125; <span class="comment">// 拿到当前层级节点的值</span></span><br><span class="line">    <span class="keyword">val</span> mDepth = depth + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (node?.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        recursive(layerList, node.left, mDepth)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node?.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        recursive(layerList, node.right, mDepth)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> layerList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/solution/er-cha-shu-de-ceng-xu-bian-li-by-leetcode-solution/">https://leetcode.cn/problems/binary-tree-level-order-traversal/solution/er-cha-shu-de-ceng-xu-bian-li-by-leetcode-solution/</a></p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html">https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html</a></p>
<h4 id="107-二叉树的层序遍历-II"><a href="#107-二叉树的层序遍历-II" class="headerlink" title="107. 二叉树的层序遍历 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层序遍历 II</a></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">levelOrderBottom</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> resultList = LinkedList&lt;ArrayList&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.offer(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> layerSize = queue.size <span class="comment">// queue循环中 不断的变化</span></span><br><span class="line">        <span class="keyword">val</span> arrayList = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until layerSize) &#123;</span><br><span class="line">            <span class="keyword">val</span> headNode = queue.poll()</span><br><span class="line">            <span class="keyword">if</span> (headNode != <span class="literal">null</span>) &#123;</span><br><span class="line">                arrayList.add(headNode.`<span class="keyword">val</span>`)</span><br><span class="line">                headNode.left?.let &#123; queue.offer(it) &#125;</span><br><span class="line">                headNode.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        resultList.addFirst(arrayList)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultList</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>



<h4 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h4><h5 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">rightSideView</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> resultList = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.add(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> layoutSize = queue.size</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until layoutSize) &#123;</span><br><span class="line">            <span class="keyword">val</span> headNode = queue.poll()</span><br><span class="line">            <span class="keyword">if</span> (i == layoutSize - <span class="number">1</span>) &#123;</span><br><span class="line">                resultList.add(headNode.`<span class="keyword">val</span>`)</span><br><span class="line">            &#125;</span><br><span class="line">            headNode?.left?.let &#123; queue.offer(it) &#125;</span><br><span class="line">            headNode?.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="DFS-深度优先遍历"><a href="#DFS-深度优先遍历" class="headerlink" title="DFS 深度优先遍历"></a>DFS 深度优先遍历</h5><p>这个DFS很妙，这次只是先理解,二刷的时候可以自己写写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solutions</span></span>&#123;</span><br><span class="line">	  List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">       dfs(root,<span class="number">0</span>)</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function">prvidate <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root ==<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(depth == res.size())&#123; <span class="comment">// 当前层级第一个右节点还没有，添加到结果中</span></span><br><span class="line">      res.add(root.val)</span><br><span class="line">    &#125;</span><br><span class="line">    depth++;</span><br><span class="line">    dfs(root.right,depth)</span><br><span class="line">    dfs(root.left,depth)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理解在官方视频中.</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/solution/er-cha-shu-de-you-shi-tu-by-leetcode-solution/">https://leetcode.cn/problems/binary-tree-right-side-view/solution/er-cha-shu-de-you-shi-tu-by-leetcode-solution/</a></p>
<h4 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637. 二叉树的层平均值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">637. 二叉树的层平均值</a></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">averageOfLevels</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: DoubleArray &#123;</span><br><span class="line">    <span class="keyword">val</span> resultList = ArrayList&lt;<span class="built_in">Double</span>&gt;()</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.offer(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> layoutSize = queue.size</span><br><span class="line">        <span class="keyword">var</span> layerSum = <span class="number">0.</span>toDouble()</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until layoutSize) &#123;</span><br><span class="line">            <span class="keyword">val</span> node = queue.poll()</span><br><span class="line">            layerSum += node.`<span class="keyword">val</span>`</span><br><span class="line">            node?.left?.let &#123; queue.offer(it) &#125;</span><br><span class="line">            node?.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> average = resultList.add(layerSum * <span class="number">1.00000</span> / layoutSize)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultList.toDoubleArray()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="429-N-叉树的层序遍历"><a href="#429-N-叉树的层序遍历" class="headerlink" title="429. N 叉树的层序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">429. N 叉树的层序遍历</a></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">levelOrder</span><span class="params">(root: <span class="type">Node</span>?)</span></span>: List&lt;List&lt;<span class="built_in">Int</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> result = LinkedList&lt;ArrayList&lt;<span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;Node&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.offer(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> layoutSize = queue.size <span class="comment">// 该层级的节点数</span></span><br><span class="line">        <span class="keyword">val</span> layerResult = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until layoutSize) &#123;</span><br><span class="line">            <span class="keyword">val</span> pollNode = queue.poll()</span><br><span class="line">            layerResult.add(pollNode.`<span class="keyword">val</span>`)</span><br><span class="line">            pollNode.children.forEach &#123; <span class="comment">// 只有这里有点不同</span></span><br><span class="line">                queue.offer(it)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(layerResult)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="515-在每个树行中找最大值"><a href="#515-在每个树行中找最大值" class="headerlink" title="515. 在每个树行中找最大值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">515. 在每个树行中找最大值</a></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largestValues</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> answer = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.offer(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> layerSize = queue.size</span><br><span class="line">        <span class="keyword">var</span> maxValue = <span class="built_in">Int</span>.MIN_VALUE <span class="comment">//最小值 , 每一层级都要初始化，否则拿到上一层级的值，就不是最小值，会有问题</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until layerSize) &#123;</span><br><span class="line">            <span class="keyword">val</span> pollNode = queue.poll()</span><br><span class="line">            maxValue = pollNode.`<span class="keyword">val</span>`.coerceAtLeast(maxValue) <span class="comment">// 比较取最大值</span></span><br><span class="line">            pollNode?.left?.let &#123; queue.offer(it) &#125;</span><br><span class="line">            pollNode?.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        answer.add(maxValue)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></p>
<p>一开始用这种方式，但是会提示 “超出内存限制”</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">connect</span><span class="params">(root: <span class="type">Node</span>?)</span></span>: Node? &#123;</span><br><span class="line"><span class="comment">//        val answerList = ArrayList&lt;String&gt;() //根据题意, 一开始以为要返回这个答案,其实只要连接后 返回root就好了</span></span><br><span class="line">        <span class="keyword">val</span> queue = LinkedList&lt;Node&gt;()</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.offer(root)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> preNode: Node?=<span class="literal">null</span></span><br><span class="line">        <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">            <span class="keyword">val</span> layerSize = queue.size</span><br><span class="line">            preNode = <span class="literal">null</span></span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until layerSize) &#123;</span><br><span class="line">                <span class="keyword">val</span> curNode = queue.poll()</span><br><span class="line">                preNode = curNode </span><br><span class="line">                <span class="keyword">if</span> (preNode != <span class="literal">null</span>) &#123;</span><br><span class="line">                    preNode.next = curNode</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//                answerList.add(curNode.`val`.toString())</span></span><br><span class="line">                <span class="keyword">if</span> (i == layerSize - <span class="number">1</span>) &#123;</span><br><span class="line">                    curNode.next = <span class="literal">null</span>  <span class="comment">// 最后个node 指向null</span></span><br><span class="line">                <span class="comment">//    answerList.add(&quot;#&quot;)</span></span><br><span class="line">                &#125;</span><br><span class="line">                curNode?.left?.let &#123; queue.offer(it) &#125;</span><br><span class="line">                curNode?.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>官方解法 还有另一种解法，二刷时可以研究研究</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">connect</span><span class="params">(root: <span class="type">Node</span>?)</span></span>: Node? &#123;</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;Node&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.offer(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> layerSize = queue.size</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until layerSize) &#123;</span><br><span class="line">            <span class="keyword">val</span> curNode = queue.poll()</span><br><span class="line">            <span class="keyword">if</span> (i &lt; layerSize - <span class="number">1</span>) &#123;</span><br><span class="line">                curNode.next = queue.peek()</span><br><span class="line">            &#125;</span><br><span class="line">            curNode?.left?.let &#123; queue.offer(it) &#125;</span><br><span class="line">            curNode?.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/solution/tian-chong-mei-ge-jie-dian-de-xia-yi-ge-you-ce-2-4/">https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/solution/tian-chong-mei-ge-jie-dian-de-xia-yi-ge-you-ce-2-4/</a></p>
<h4 id="117-填充每个节点的下一个右侧节点指针-II"><a href="#117-填充每个节点的下一个右侧节点指针-II" class="headerlink" title="117. 填充每个节点的下一个右侧节点指针 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">117. 填充每个节点的下一个右侧节点指针 II</a></h4><p>和116题唯一的区别，116是完美二叉树</p>
<h4 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h4><h5 id="广度优先-Breadth-First-Search"><a href="#广度优先-Breadth-First-Search" class="headerlink" title="广度优先 Breadth-First-Search"></a>广度优先 <strong>Breadth-First-Search</strong></h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">maxDepth</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    <span class="keyword">var</span> depth = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.offer(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> layerSize = queue.size</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until layerSize) &#123;</span><br><span class="line">            <span class="keyword">val</span> pollNode = queue.poll()</span><br><span class="line">            pollNode?.left?.let &#123; queue.add(it) &#125; </span><br><span class="line">            pollNode?.right?.let &#123; queue.add(it) &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == layerSize - <span class="number">1</span>) &#123;	</span><br><span class="line">                depth++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="递归-Depth-First-Search"><a href="#递归-Depth-First-Search" class="headerlink" title="递归 Depth First Search"></a>递归 Depth <strong>First Search</strong></h5><p>这题用一个方法就可以了，遍历左右子树取最大值后 再加 1</p>
<p>这个其实也是先序遍历,左右中</p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html#%E9%80%92%E5%BD%92%E6%B3%95">https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html#%E9%80%92%E5%BD%92%E6%B3%95</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> leftdepth = <span class="built_in">getdepth</span>(node-&gt;left);       <span class="comment">// 左</span></span><br><span class="line"><span class="keyword">int</span> rightdepth = <span class="built_in">getdepth</span>(node-&gt;right);     <span class="comment">// 右</span></span><br><span class="line"><span class="keyword">int</span> depth = <span class="number">1</span> + <span class="built_in">max</span>(leftdepth, rightdepth); <span class="comment">// 中</span></span><br><span class="line"><span class="keyword">return</span> depth;</span><br></pre></td></tr></table></figure>



<p><strong>可以看看随想录的解法，里面有回溯的过程，过程更详细</strong></p>
<p>下面解法做了简化</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">maxDepth</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> depth = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> depth</span><br><span class="line">    <span class="keyword">return</span> dfsDepth(root, depth)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dfsDepth</span><span class="params">(node: <span class="type">TreeNode</span>?, depth: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> depth</span><br><span class="line">    <span class="keyword">val</span> maxDepth = Math.max(dfsDepth(node.left, depth + <span class="number">1</span>), dfsDepth(node.right, depth + <span class="number">1</span>)) <span class="comment">// 用max函数更直观</span></span><br><span class="line">    <span class="keyword">return</span> maxDepth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/solution/er-cha-shu-de-zui-da-shen-du-by-leetcode-solution/">https://leetcode.cn/problems/maximum-depth-of-binary-tree/solution/er-cha-shu-de-zui-da-shen-du-by-leetcode-solution/</a></p>
<h4 id="559-N-叉树的最大深度"><a href="#559-N-叉树的最大深度" class="headerlink" title="559. N 叉树的最大深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/">559. N 叉树的最大深度</a></h4><p>DFS</p>
<p> 这个DFS解法 看了官方题解答案，自己再做一次</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/solution/n-cha-shu-de-zui-da-shen-du-by-leetcode-n7qtv/">https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/solution/n-cha-shu-de-zui-da-shen-du-by-leetcode-n7qtv/</a></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">maxDepth</span><span class="params">(root: <span class="type">Node</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> maxDepth = <span class="number">0</span></span><br><span class="line">    root.children.forEach &#123;</span><br><span class="line">        <span class="keyword">val</span> depth = maxDepth(it)</span><br><span class="line">        maxDepth = Math.max(maxDepth, depth)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxDepth +<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>BFS</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">maxDepth1</span><span class="params">(root: <span class="type">Node</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;Node&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.offer(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> maxDepth = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> layerSize = queue.size</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until layerSize) &#123;</span><br><span class="line">            <span class="keyword">val</span> pollNode = queue.poll()</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123; <span class="comment">// 这个条件可以去掉</span></span><br><span class="line">                maxDepth++</span><br><span class="line">            &#125;</span><br><span class="line">            pollNode.children.forEach &#123;</span><br><span class="line">                <span class="keyword">if</span> (it != <span class="literal">null</span>)</span><br><span class="line">                    queue.offer(it)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxDepth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">maxDepth1</span><span class="params">(root: <span class="type">Node</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;Node&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.offer(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> maxDepth = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> layerSize = queue.size</span><br><span class="line">        maxDepth++ <span class="comment">//拿到外面更好，不用判断i==1了,每次layerSize 遍历完就是一层了</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until layerSize) &#123;</span><br><span class="line">            <span class="keyword">val</span> pollNode = queue.poll()</span><br><span class="line">            pollNode.children.forEach &#123;</span><br><span class="line">                <span class="keyword">if</span> (it != <span class="literal">null</span>)</span><br><span class="line">                    queue.offer(it)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxDepth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h4><p>BFS</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">minDepth</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.offer(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> depth = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> layerSize = queue.size</span><br><span class="line">        depth++ <span class="comment">// 不用放下面判断，直接是一层新的</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until layerSize) &#123;</span><br><span class="line">            <span class="keyword">val</span> pollNode = queue.poll()</span><br><span class="line">            <span class="keyword">if</span> (pollNode.left == <span class="literal">null</span> &amp;&amp; pollNode.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> depth</span><br><span class="line">            &#125;</span><br><span class="line">            pollNode?.left?.let &#123; queue.offer(it) &#125;</span><br><span class="line">            pollNode?.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>官方题解看起来，更好</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/solution/er-cha-shu-de-zui-xiao-shen-du-by-leetcode-solutio/">https://leetcode.cn/problems/minimum-depth-of-binary-tree/solution/er-cha-shu-de-zui-xiao-shen-du-by-leetcode-solutio/</a></p>
<p>DFS</p>
<p><img src="https://img-blog.csdnimg.cn/20210203155800503.png"></p>
<p> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/solution/bfshe-dfsliang-chong-fang-shi-jie-jue-by-g4eh/">https://leetcode.cn/problems/minimum-depth-of-binary-tree/solution/bfshe-dfsliang-chong-fang-shi-jie-jue-by-g4eh/</a></p>
<p>用了这个视频的解法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">minDepth</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment">//左子节点和右子节点都不为空，然后取最小值才有意义，否则就是错的</span></span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="literal">null</span> &amp;&amp; root.right != <span class="literal">null</span>) &#123; <span class="comment">// 左右都不为空</span></span><br><span class="line">        <span class="keyword">return</span> Math.min(minDepth(root.left), minDepth(root.right)) + <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.left == <span class="literal">null</span>) &#123; <span class="comment">//左不为空</span></span><br><span class="line">        <span class="keyword">return</span> minDepth(root.right) + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minDepth(root.left) + <span class="number">1</span> <span class="comment">//右不为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>理解了这个解法，再看官方的DFS解法，也简单明了</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/solution/er-cha-shu-de-zui-xiao-shen-du-by-leetcode-solutio/">https://leetcode.cn/problems/minimum-depth-of-binary-tree/solution/er-cha-shu-de-zui-xiao-shen-du-by-leetcode-solutio/</a></p>
<h4 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></h4><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnakm26jtog30e409s4qp.gif"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">invertTree</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    swapNode(root) </span><br><span class="line">    invertTree(root.left)</span><br><span class="line">    invertTree(root.right)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">swapNode</span><span class="params">(node: <span class="type">TreeNode</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> temp = node?.left</span><br><span class="line">    node?.left = node?.right</span><br><span class="line">    node?.right = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    invertTree(root.left);<span class="comment">//注意这里是left</span></span><br><span class="line">    TreeNode temp = root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = temp;</span><br><span class="line">    invertTree(root.left);<span class="comment">//这里还是left</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>————————————————<br>版权声明：本文为CSDN博主「xsybg」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/xsybg/article/details/122687168">https://blog.csdn.net/xsybg/article/details/122687168</a></p>
<p>注意两个递归调用的参数都是root.left, 因为在第二步是交换root的左右孩子，所以在第三步要处理的右孩子其实已经变成了root的左孩子，是不是很有趣？<br>这个题目很简单，但是确实会稀里糊涂地通过，没搞清楚是树的哪一种遍历，看了代码随想录的解析感觉还挺惊喜的。<br>代码随想录的链接贴在这里：<br>————————————————<br>版权声明：本文为CSDN博主「xsybg」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/xsybg/article/details/122687168">https://blog.csdn.net/xsybg/article/details/122687168</a></p>
<p>根据下面打印</p>
<p>4的坐子树中的1,3交换了两次， 6,9一次都没交换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">      4      </span><br><span class="line">    &#x2F;   \    </span><br><span class="line">  2       7  </span><br><span class="line"> &#x2F; \     &#x2F; \ </span><br><span class="line">1   3   6   9</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> node 4</span><br><span class="line">      4      </span><br><span class="line">    &#x2F;   \    </span><br><span class="line">  2       7  </span><br><span class="line"> &#x2F; \     &#x2F; \ </span><br><span class="line">1   3   6   9</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> node 2</span><br><span class="line">      4      </span><br><span class="line">    &#x2F;   \    </span><br><span class="line">  2       7  </span><br><span class="line"> &#x2F; \     &#x2F; \ </span><br><span class="line">1   3   6   9</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> node 1</span><br><span class="line">      4      </span><br><span class="line">    &#x2F;   \    </span><br><span class="line">  2       7  </span><br><span class="line"> &#x2F; \     &#x2F; \ </span><br><span class="line">1   3   6   9</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> node 1</span><br><span class="line">      4      </span><br><span class="line">    &#x2F;   \    </span><br><span class="line">  2       7  </span><br><span class="line"> &#x2F; \     &#x2F; \ </span><br><span class="line">3   1   6   9</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> node 2</span><br><span class="line">      4      </span><br><span class="line">    &#x2F;   \    </span><br><span class="line">  7       2  </span><br><span class="line"> &#x2F; \     &#x2F; \ </span><br><span class="line">6   9   3   1</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> node 3</span><br><span class="line">      4      </span><br><span class="line">    &#x2F;   \    </span><br><span class="line">  7       2  </span><br><span class="line"> &#x2F; \     &#x2F; \ </span><br><span class="line">6   9   3   1</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> node 3</span><br><span class="line">      4      </span><br><span class="line">    &#x2F;   \    </span><br><span class="line">  7       2  </span><br><span class="line"> &#x2F; \     &#x2F; \ </span><br><span class="line">6   9   1   3</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="广度优先遍历-层序遍历"><a href="#广度优先遍历-层序遍历" class="headerlink" title="广度优先遍历(层序遍历)"></a>广度优先遍历(层序遍历)</h5><p>遍历左右节点就可以.然后交换就可以了</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">invertTree1</span><span class="params">(root: <span class="type">TreeNode</span>?)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedList&lt;TreeNode&gt;()</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.offer(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty())&#123;</span><br><span class="line">        <span class="keyword">val</span> layerSize = queue.size</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until layerSize)&#123;</span><br><span class="line">            <span class="keyword">val</span> pollNode = queue.poll()</span><br><span class="line">            swapNode(pollNode)</span><br><span class="line">            pollNode.left?.let &#123; queue.offer(it) &#125;</span><br><span class="line">            pollNode.right?.let &#123; queue.offer(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




	  <div class="article-footer-copyright">

    本博客采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议(CC BY-NC-SA 4.0) 发布.</a>
</div>

	</div>

	
	
	<div>
  	<center>

	<div class="pagination">

    
    
    <a href="/2022/07/24/kotlin-inline/" type="button" class="btn btn-default"><i
                class="fa fa-arrow-circle-o-left"></i> Prev</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a href="/2022/07/03/LC-stack-queue/" type="button" class="btn btn-default ">Next<i
                class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>


    </center>
	</div>
	
	<!-- comment -->
	<!--
<section id="comment">
    <h2 class="title">Comments</h2>

    
</section>

-->
	
	
	
	</div> <!-- col-md-9/col-md-12 -->


	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2022-07-17 
	</div>
	

	<!-- categories -->
    
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>	
    <ul id="categorys" class="tag_box list-unstyled collapse in">
          
  <li>
    <li><a href="/categories/DataStructure/">DataStructure<span>16</span></a></li>
  </li>

    </ul>
	</div>
	

	<!-- tags -->
	
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#tags"><i class="fa fa-tags"></i></a>		  
    <ul id="tags" class="tag_box list-unstyled collapse in">	  
	    
  <li><a href="/tags/LEETCODE/">LEETCODE<span>12</span></a></li>
    </ul>
	</div>
		

	<!-- toc -->
	<div class="meta-widget">
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

		

	</div>
	
		

</div><!-- row -->

<!--
 -->



	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  
  &copy; 2023 Jon's Blog
  
      powered by <a href="http://hexo.io/" target="_blank">Hexo</a>.Theme <a href="https://github.com/Ares-X/hexo-theme-freemind.bithack" target="_blank">freemind.bithack</a>  
</p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



</body>
   </html>
