

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Jon">
  <meta name="keywords" content="">
  
    <meta name="description" content="阿里面试题1.android事件分发机制，请详细说下整个流程 事件分发（面试）.png 2.android view绘制机制和加载过程，请详细说下整个流程 1.ViewRootImpl会调用performTraversals(),其内部会调用performMeasure()、performLayout、performDraw()。  2.performMeasure()会调用最外层的ViewGro">
<meta property="og:type" content="article">
<meta property="og:title" content="interview-answer">
<meta property="og:url" content="https://noteforme.github.io/2018/03/12/interview-answer/index.html">
<meta property="og:site_name" content="Jon&#39;s Blog">
<meta property="og:description" content="阿里面试题1.android事件分发机制，请详细说下整个流程 事件分发（面试）.png 2.android view绘制机制和加载过程，请详细说下整个流程 1.ViewRootImpl会调用performTraversals(),其内部会调用performMeasure()、performLayout、performDraw()。  2.performMeasure()会调用最外层的ViewGro">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2911038-5349d6ebb32372da?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp">
<meta property="article:published_time" content="2018-03-12T04:44:01.000Z">
<meta property="article:modified_time" content="2024-10-01T12:00:04.537Z">
<meta property="article:author" content="Jon">
<meta property="article:tag" content="inter">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/2911038-5349d6ebb32372da?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp">
  
  
  
  <title>interview-answer - Jon&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"noteforme.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="interview-answer"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2018-03-12 12:44" pubdate>
          March 12, 2018 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          15k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          125 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">interview-answer</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="阿里面试题"><a href="#阿里面试题" class="headerlink" title="阿里面试题"></a><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/cf5092fa2694">阿里面试题</a></h2><h2 id="1-android事件分发机制，请详细说下整个流程"><a href="#1-android事件分发机制，请详细说下整个流程" class="headerlink" title="1.android事件分发机制，请详细说下整个流程"></a>1.android事件分发机制，请详细说下整个流程</h2><p><img src="https://upload-images.jianshu.io/upload_images/2911038-5349d6ebb32372da?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>事件分发（面试）.png</p>
<h2 id="2-android-view绘制机制和加载过程，请详细说下整个流程"><a href="#2-android-view绘制机制和加载过程，请详细说下整个流程" class="headerlink" title="2.android view绘制机制和加载过程，请详细说下整个流程"></a>2.android view绘制机制和加载过程，请详细说下整个流程</h2><ul>
<li><p>1.ViewRootImpl会调用performTraversals(),其内部会调用performMeasure()、performLayout、performDraw()。</p>
</li>
<li><p>2.performMeasure()会调用最外层的ViewGroup的measure()–&gt;onMeasure(),ViewGroup的onMeasure()是抽象方法，但其提供了measureChildren()，这之中会遍历子View然后循环调用measureChild()这之中会用getChildMeasureSpec()+父View的MeasureSpec+子View的LayoutParam一起获取本View的MeasureSpec，然后调用子View的measure()到View的onMeasure()–&gt;setMeasureDimension(getDefaultSize(),getDefaultSize()),getDefaultSize()默认返回measureSpec的测量数值，所以继承View进行自定义的wrap_content需要重写。</p>
</li>
<li><p>3.performLayout()会调用最外层的ViewGroup的layout(l,t,r,b),本View在其中使用setFrame()设置本View的四个顶点位置。在onLayout(抽象方法)中确定子View的位置，如LinearLayout会遍历子View，循环调用setChildFrame()–&gt;子View.layout()。</p>
</li>
<li><p>4.performDraw()会调用最外层ViewGroup的draw():其中会先后调用background.draw()(绘制背景)、onDraw()(绘制自己)、dispatchDraw()(绘制子View)、onDrawScrollBars()(绘制装饰)。</p>
</li>
<li><p>5.MeasureSpec由2位SpecMode(UNSPECIFIED、EXACTLY(对应精确值和match_parent)、AT_MOST(对应warp_content))和30位SpecSize组成一个int,DecorView的MeasureSpec由窗口大小和其LayoutParams决定，其他View由父View的MeasureSpec和本View的LayoutParams决定。ViewGroup中有getChildMeasureSpec()来获取子View的MeasureSpec。</p>
</li>
<li><p>6.三种方式获取measure()后的宽高：</p>
<ul>
<li>1.Activity#onWindowFocusChange()中调用获取</li>
<li>2.view.post(Runnable)将获取的代码投递到消息队列的尾部。</li>
<li>3.ViewTreeObservable.</li>
</ul>
<p>自定义 View 的绘制顺序</p>
</li>
</ul>
<h2 id="3-android四大组件的加载过程，请详细介绍下"><a href="#3-android四大组件的加载过程，请详细介绍下" class="headerlink" title="3.android四大组件的加载过程，请详细介绍下"></a>3.android四大组件的加载过程，请详细介绍下</h2><ul>
<li>1.<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f499afd8d0ab">android四大组件的加载过程</a>:这是我总结的一篇博客</li>
</ul>
<h2 id="4-Activity的启动模式"><a href="#4-Activity的启动模式" class="headerlink" title="4.Activity的启动模式"></a>4.Activity的启动模式</h2><ul>
<li>1.standard:默认标准模式，每启动一个都会创建一个实例，</li>
<li>2.singleTop：栈顶复用，如果在栈顶就调用onNewIntent复用，从onResume()开始</li>
<li>3.singleTask：栈内复用，本栈内只要用该类型Activity就会将其顶部的activity出栈</li>
<li>4.singleInstance：单例模式，除了3中特性，系统会单独给该Activity创建一个栈，</li>
</ul>
<h2 id="5-A、B、C、D分别是四种Activity的启动模式，那么A-B-C-D-A-B-C-D分别启动，最后的activity栈是怎么样的"><a href="#5-A、B、C、D分别是四种Activity的启动模式，那么A-B-C-D-A-B-C-D分别启动，最后的activity栈是怎么样的" class="headerlink" title="5.A、B、C、D分别是四种Activity的启动模式，那么A-&gt;B-&gt;C-&gt;D-&gt;A-&gt;B-&gt;C-&gt;D分别启动，最后的activity栈是怎么样的"></a>5.A、B、C、D分别是四种Activity的启动模式，那么A-&gt;B-&gt;C-&gt;D-&gt;A-&gt;B-&gt;C-&gt;D分别启动，最后的activity栈是怎么样的</h2><ul>
<li>1.这个题目需要深入了解activity的启动模式</li>
<li>2.最后的答案是：两个栈，前台栈是只有D，后台栈从底至上是A、B、C</li>
</ul>
<h2 id="6-Activity缓存方法"><a href="#6-Activity缓存方法" class="headerlink" title="6.Activity缓存方法"></a>6.Activity缓存方法</h2><ul>
<li>1.配置改变导致Activity被杀死，横屏变竖屏：在onStop之前会调用onSaveInstanceState()保存数据在重建Activity之后，会在onStart()之后调用onRestoreInstanceState(),并把保存下来的Bundle传给onCreate()和它会默认重建Activity当前的视图，我们可以在onCreate()中，回复自己的数据。</li>
<li>2.内存不足杀掉Activity，优先级分别是：前台可见，可见非前台，后台。</li>
</ul>
<h2 id="7-Service的生命周期，两种启动方法，有什么区别"><a href="#7-Service的生命周期，两种启动方法，有什么区别" class="headerlink" title="7.Service的生命周期，两种启动方法，有什么区别"></a>7.Service的生命周期，两种启动方法，有什么区别</h2><ul>
<li>1.context.startService() -&gt;onCreate()- &gt;onStart()-&gt;Service running–&gt;(如果调用context.stopService() )-&gt;onDestroy() -&gt;Service shut down<ul>
<li>1.如果Service还没有运行，则调用onCreate()然后调用onStart()；</li>
<li>2.如果Service已经运行，则只调用onStart()，所以一个Service的onStart方法可能会重复调用多次。</li>
<li>3.调用stopService的时候直接onDestroy，</li>
<li>4.如果是调用者自己直接退出而没有调用stopService的话，Service会一直在后台运行。该Service的调用者再启动起来后可以通过stopService关闭Service。</li>
</ul>
</li>
<li>2.context.bindService()-&gt;onCreate()-&gt;onBind()-&gt;Service running–&gt;onUnbind() -&gt; onDestroy() -&gt;Service stop<ul>
<li>1.onBind将返回给客户端一个IBind接口实例，IBind允许客户端回调服务的方法，比如得到Service运行的状态或其他操作。</li>
<li>2.这个时候会把调用者和Service绑定在一起，Context退出了,Service就会调用onUnbind-&gt;onDestroy相应退出。</li>
<li>3.所以调用bindService的生命周期为：onCreate –&gt; onBind(只一次，不可多次绑定) –&gt; onUnbind –&gt; onDestory。</li>
</ul>
</li>
</ul>
<h2 id="8-怎么保证service不被杀死"><a href="#8-怎么保证service不被杀死" class="headerlink" title="8.怎么保证service不被杀死"></a>8.怎么保证service不被杀死</h2><ul>
<li>1.提升service优先级</li>
<li>2.提升service进程优先级</li>
<li>3.onDestroy方法里重启service</li>
</ul>
<h2 id="9-静态的Broadcast-和动态的有什么区别"><a href="#9-静态的Broadcast-和动态的有什么区别" class="headerlink" title="9.静态的Broadcast 和动态的有什么区别"></a>9.静态的Broadcast 和动态的有什么区别</h2><ul>
<li>1.动态的比静态的安全</li>
<li>2.静态在app启动的时候就初始化了 动态使用代码初始化</li>
<li>3.静态需要配置 动态不需要</li>
<li>4.生存期，静态广播的生存期可以比动态广播的长很多</li>
<li>5.优先级动态广播的优先级比静态广播高</li>
</ul>
<h2 id="10-Intent可以传递哪些数据类型"><a href="#10-Intent可以传递哪些数据类型" class="headerlink" title="10.Intent可以传递哪些数据类型"></a>10.Intent可以传递哪些数据类型</h2><ul>
<li>1.Serializable</li>
<li>2.charsequence: 主要用来传递String，char等</li>
<li>3.parcelable</li>
<li>4.Bundle</li>
</ul>
<h2 id="11-Json有什么优劣势、解析的原理"><a href="#11-Json有什么优劣势、解析的原理" class="headerlink" title="11.Json有什么优劣势、解析的原理"></a>11.Json有什么优劣势、解析的原理</h2><ul>
<li>1.JSON的速度要远远快于XML</li>
<li>2.JSON相对于XML来讲，数据的体积小</li>
<li>3.JSON对数据的描述性比XML较差</li>
<li>4.解析的基本原理是：词法分析</li>
</ul>
<h2 id="12-一个语言的编译过程"><a href="#12-一个语言的编译过程" class="headerlink" title="12.一个语言的编译过程"></a>12.一个语言的编译过程</h2><ul>
<li>1.词法分析：将一串文本按规则分割成最小的结构，关键字、标识符、运算符、界符和常量等。一般实现方法是自动机和正则表达式</li>
<li>2.语法分析：将一系列单词组合成语法树。一般实现方法有自顶向下和自底向上</li>
<li>3.语义分析：对结构上正确的源程序进行上下文有关性质的审查</li>
<li>4.目标代码生成</li>
<li>5.代码优化：优化生成的目标代码，</li>
</ul>
<h2 id="13-动画有哪几类，各有什么特点"><a href="#13-动画有哪几类，各有什么特点" class="headerlink" title="13.动画有哪几类，各有什么特点"></a>13.动画有哪几类，各有什么特点</h2><ul>
<li>1.动画的基本原理：其实就是利用插值器和估值器，来计算出各个时刻View的属性，然后通过改变View的属性来，实现View的动画效果。</li>
<li>2.View动画:只是影像变化，view的实际位置还在原来的地方。</li>
<li>3.帧动画是在xml中定义好一系列图片之后，使用AnimationDrawable来播放的动画。</li>
<li>4.View的属性动画：<ul>
<li>1.插值器：作用是根据时间的流逝的百分比来计算属性改变的百分比</li>
<li>2.估值器：在1的基础上由这个东西来计算出属性到底变化了多少数值的类</li>
</ul>
</li>
</ul>
<h2 id="14-Handler、Looper消息队列模型，各部分的作用"><a href="#14-Handler、Looper消息队列模型，各部分的作用" class="headerlink" title="14.Handler、Looper消息队列模型，各部分的作用"></a>14.Handler、Looper消息队列模型，各部分的作用</h2><ul>
<li>1.MessageQueue：读取会自动删除消息，单链表维护，在插入和删除上有优势。在其next()中会无限循环，不断判断是否有消息，有就返回这条消息并移除。</li>
<li>2.Looper：Looper创建的时候会创建一个MessageQueue，调用loop()方法的时候消息循环开始，loop()也是一个死循环，会不断调用messageQueue的next()，当有消息就处理，否则阻塞在messageQueue的next()中。当Looper的quit()被调用的时候会调用messageQueue的quit(),此时next()会返回null，然后loop()方法也跟着退出。</li>
<li>3.Handler：在主线程构造一个Handler，然后在其他线程调用sendMessage(),此时主线程的MessageQueue中会插入一条message，然后被Looper使用。</li>
<li>4.系统的主线程在ActivityThread的main()为入口开启主线程，其中定义了内部类Activity.H定义了一系列消息类型，包含四大组件的启动停止。</li>
<li>5.MessageQueue和Looper是一对一关系，Handler和Looper是多对一</li>
</ul>
<h2 id="15-怎样退出终止App"><a href="#15-怎样退出终止App" class="headerlink" title="15.怎样退出终止App"></a>15.怎样退出终止App</h2><ul>
<li>1.自己设置一个Activity的栈，然后一个个finish()</li>
</ul>
<h2 id="16-Android-IPC-Binder原理"><a href="#16-Android-IPC-Binder原理" class="headerlink" title="16.Android IPC:Binder原理"></a>16.Android IPC:Binder原理</h2><ul>
<li>1.在Activity和Service进行通讯的时候，用到了Binder。<ul>
<li>1.当属于同个进程我们可以继承Binder然后在Activity中对Service进行操作</li>
<li>2.当不属于同个进程，那么要用到AIDL让系统给我们创建一个Binder，然后在Activity中对远端的Service进行操作。</li>
</ul>
</li>
<li>2.系统给我们生成的Binder：<ul>
<li>1.Stub类中有:接口方法的id，有该Binder的标识，有asInterface(IBinder)(让我们在Activity中获取实现了Binder的接口，接口的实现在Service里，同进程时候返回Stub否则返回Proxy)，有onTransact()这个方法是在不同进程的时候让Proxy在Activity进行远端调用实现Activity操作Service</li>
<li>2.Proxy类是代理，在Activity端，其中有:IBinder mRemote(这就是远端的Binder)，两个接口的实现方法不过是代理最终还是要在远端的onTransact()中进行实际操作。</li>
</ul>
</li>
<li>3.哪一端的Binder是副本，该端就可以被另一端进行操作，因为Binder本体在定义的时候可以操作本端的东西。所以可以在Activity端传入本端的Binder，让Service端对其进行操作称为Listener，可以用RemoteCallbackList这个容器来装Listener，防止Listener因为经历过序列化而产生的问题。</li>
<li>4.当Activity端向远端进行调用的时候，当前线程会挂起，当方法处理完毕才会唤醒。</li>
<li>5.如果一个AIDL就用一个Service太奢侈，所以可以使用Binder池的方式，建立一个AIDL其中的方法是返回IBinder，然后根据方法中传入的参数返回具体的AIDL。</li>
<li>6.IPC的方式有：Bundle（在Intent启动的时候传入，不过是一次性的），文件共享(对于SharedPreference是特例，因为其在内存中会有缓存)，使用Messenger(其底层用的也是AIDL，同理要操作哪端，就在哪端定义Messenger)，AIDL，ContentProvider(在本进程中继承实现一个ContentProvider，在增删改查方法中调用本进程的SQLite，在其他进程中查询)，Socket</li>
</ul>
<h2 id="17-描述一次跨进程通讯"><a href="#17-描述一次跨进程通讯" class="headerlink" title="17.描述一次跨进程通讯"></a>17.描述一次跨进程通讯</h2><ul>
<li>1.client、proxy、serviceManager、BinderDriver、impl、service</li>
<li>2.client发起一个请求service信息的Binder请求到BinderDriver中，serviceManager发现BinderDiriver中有自己的请求 然后将clinet请求的service的数据返回给client这样完成了一次Binder通讯</li>
<li>3.clinet获取的service信息就是该service的proxy，此时调用proxy的方法，proxy将请求发送到BinderDriver中，此时service的 Binder线程池循环发现有自己的请求，然后用impl就处理这个请求最后返回，这样完成了第二次Binder通讯<br>4.中间client可挂起，也可以不挂起，有一个关键字oneway可以解决这个</li>
</ul>
<h2 id="18-android重要术语解释"><a href="#18-android重要术语解释" class="headerlink" title="18.android重要术语解释"></a>18.android重要术语解释</h2><ul>
<li>1.ActivityManagerServices，简称AMS，服务端对象，负责系统中所有Activity的生命周期</li>
<li>2.ActivityThread，App的真正入口。当开启App之后，会调用main()开始运行，开启消息循环队列，这就是传说中的UI线程或者叫主线程。与ActivityManagerServices配合，一起完成Activity的管理工作</li>
<li>3.ApplicationThread，用来实现ActivityManagerService与ActivityThread之间的交互。在ActivityManagerService需要管理相关Application中的Activity的生命周期时，通过ApplicationThread的代理对象与ActivityThread通讯。</li>
<li>4.ApplicationThreadProxy，是ApplicationThread在服务器端的代理，负责和客户端的ApplicationThread通讯。AMS就是通过该代理与ActivityThread进行通信的。</li>
<li>5.Instrumentation，每一个应用程序只有一个Instrumentation对象，每个Activity内都有一个对该对象的引用。Instrumentation可以理解为应用进程的管家，ActivityThread要创建或暂停某个Activity时，都需要通过Instrumentation来进行具体的操作。</li>
<li>6.ActivityStack，Activity在AMS的栈管理，用来记录已经启动的Activity的先后关系，状态信息等。通过ActivityStack决定是否需要启动新的进程。</li>
<li>7.ActivityRecord，ActivityStack的管理对象，每个Activity在AMS对应一个ActivityRecord，来记录Activity的状态以及其他的管理信息。其实就是服务器端的Activity对象的映像。</li>
<li>8.TaskRecord，AMS抽象出来的一个“任务”的概念，是记录ActivityRecord的栈，一个“Task”包含若干个ActivityRecord。AMS用TaskRecord确保Activity启动和退出的顺序。如果你清楚Activity的4种launchMode，那么对这个概念应该不陌生。</li>
</ul>
<h2 id="19-理解Window和WindowManager"><a href="#19-理解Window和WindowManager" class="headerlink" title="19.理解Window和WindowManager"></a>19.理解Window和WindowManager</h2><ul>
<li>1.Window用于显示View和接收各种事件，Window有三种类型：应用Window(每个Activity对应一个Window)、子Window(不能单独存在，附属于特定Window)、系统window(Toast和状态栏)</li>
<li>2.Window分层级，应用Window在1-99、子Window在1000-1999、系统Window在2000-2999.WindowManager提供了增删改View三个功能。</li>
<li>3.Window是个抽象概念：每一个Window对应着一个View和ViewRootImpl，Window通过ViewRootImpl来和View建立联系，View是Window存在的实体，只能通过WindowManager来访问Window。</li>
<li>4.WindowManager的实现是WindowManagerImpl其再委托给WindowManagerGlobal来对Window进行操作，其中有四个List分别储存对应的View、ViewRootImpl、WindowManger.LayoutParams和正在被删除的View</li>
<li>5.Window的实体是存在于远端的WindowMangerService中，所以增删改Window在本端是修改上面的几个List然后通过ViewRootImpl重绘View，通过WindowSession(每个应用一个)在远端修改Window。</li>
<li>6.Activity创建Window：Activity会在attach()中创建Window并设置其回调(onAttachedToWindow()、dispatchTouchEvent()),Activity的Window是由Policy类创建PhoneWindow实现的。然后通过Activity#setContentView()调用PhoneWindow的setContentView。</li>
</ul>
<h2 id="20-Bitmap的处理"><a href="#20-Bitmap的处理" class="headerlink" title="20.Bitmap的处理"></a>20.Bitmap的处理</h2><ul>
<li>1.当使用ImageView的时候，可能图片的像素大于ImageView，此时就可以通过BitmapFactory.Option来对图片进行压缩，inSampleSize表示缩小2^(inSampleSize-1)倍。</li>
<li>2.BitMap的缓存：<ul>
<li>1.使用LruCache进行内存缓存。</li>
<li>2.使用DiskLruCache进行硬盘缓存。</li>
<li>3.实现一个ImageLoader的流程：同步异步加载、图片压缩、内存硬盘缓存、网络拉取<ul>
<li>1.同步加载只创建一个线程然后按照顺序进行图片加载</li>
<li>2.异步加载使用线程池，让存在的加载任务都处于不同线程</li>
<li>3.为了不开启过多的异步任务，只在列表静止的时候开启图片加载</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="21-如何实现一个网络框架"><a href="#21-如何实现一个网络框架" class="headerlink" title="21.如何实现一个网络框架"></a>21.如何实现一个网络框架</h2><ul>
<li>1.缓存队列,以url为key缓存内容可以参考Bitmap的处理方式，这里单独开启一个线程。</li>
<li>2.网络请求队列，使用线程池进行请求。</li>
<li>3.提供各种不同类型的返回值的解析如String，Json，图片等等。</li>
</ul>
<h2 id="22-ClassLoader的基础知识"><a href="#22-ClassLoader的基础知识" class="headerlink" title="22.ClassLoader的基础知识"></a>22.ClassLoader的基础知识</h2><ul>
<li>1.双亲委托：一个ClassLoader类负责加载这个类所涉及的所有类，在加载的时候会判断该类是否已经被加载过，然后会递归去他父ClassLoader中找。</li>
<li>2.可以动态加载Jar通过URLClassLoader</li>
<li>3.ClassLoader 隔离问题 JVM识别一个类是由：ClassLoader id+PackageName+ClassName。</li>
<li>4.加载不同Jar包中的公共类：<ul>
<li>1.让父ClassLoader加载公共的Jar，子ClassLoader加载包含公共Jar的Jar，此时子ClassLoader在加载公共Jar的时候会先去父ClassLoader中找。(只适用Java)</li>
<li>2.重写加载包含公共Jar的Jar的ClassLoader，在loadClass中找到已经加载过公共Jar的ClassLoader，也就是把父ClassLoader替换掉。(只适用Java)</li>
<li>3.在生成包含公共Jar的Jar时候把公共Jar去掉。</li>
</ul>
</li>
</ul>
<h2 id="25-线程同步的问题，常用的线程同步"><a href="#25-线程同步的问题，常用的线程同步" class="headerlink" title="25.线程同步的问题，常用的线程同步"></a>25.线程同步的问题，常用的线程同步</h2><ul>
<li>1.sycn：保证了原子性、可见性、有序性</li>
<li>2.锁：保证了原子性、可见性、有序性<ul>
<li>1.自旋锁:可以使线程在没有取得锁的时候，不被挂起，而转去执行一个空循环。<ul>
<li>1.优点:线程被挂起的几率减少，线程执行的连贯性加强。用于对于锁竞争不是很激烈，锁占用时间很短的并发线程。</li>
<li>2.缺点:过多浪费CPU时间，有一个线程连续两次试图获得自旋锁引起死锁</li>
</ul>
</li>
<li>2.阻塞锁:没得到锁的线程等待或者挂起，Sycn、Lock</li>
<li>3.可重入锁:一个线程可多次获取该锁，Sycn、Lock</li>
<li>4.悲观锁:每次去拿数据的时候都认为别人会修改，所以会阻塞全部其他线程 Sycn、Lock</li>
<li>5.乐观锁:每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。cas</li>
<li>6.显示锁和内置锁:显示锁用Lock来定义、内置锁用synchronized。</li>
<li>7.读-写锁:为了提高性能，Java提供了读</li>
</ul>
</li>
<li>3.volatile<ul>
<li>1.只能保证可见性，不能保证原子性</li>
<li>2.自增操作有三步，此时多线程写会出现问题</li>
</ul>
</li>
<li>4.cas<ul>
<li>1.操作:内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做并返回false。</li>
<li>2.解释:本地副本为A，共享内存为V，线程A要把V修改成B。某个时刻线程A要把V修改成B，如果A和V不同那么就表示有其他线程在修改V，此时就表示修改失败，否则表示没有其他线程修改，那么把V改成B。</li>
<li>3.局限:如果V被修改成V1然后又被改成V，此时cas识别不出变化，还是认为没有其他线程在修改V，此时就会有问题</li>
<li>4.局限解决:将V带上版本。</li>
</ul>
</li>
<li>5.线程不安全到底是怎么回事：<ul>
<li>1.一个线程写，多个线程读的时候，会造成写了一半就去读</li>
<li>2.多线程写，会造成脏数据</li>
</ul>
</li>
</ul>
<h2 id="26-Asynctask和线程池，GC相关（怎么判断哪些内存该GC，GC算法）"><a href="#26-Asynctask和线程池，GC相关（怎么判断哪些内存该GC，GC算法）" class="headerlink" title="26.Asynctask和线程池，GC相关（怎么判断哪些内存该GC，GC算法）"></a>26.Asynctask和线程池，GC相关（怎么判断哪些内存该GC，GC算法）</h2><ul>
<li>1.Asynctask：异步任务类，单线程线程池+Handler</li>
<li>2.线程池：<ul>
<li>1.ThreadPoolExecutor：通过Executors可以构造单线程池、固定数目线程池、不固定数目线程池。</li>
<li>2.ScheduledThreadPoolExecutor：可以延时调用线程或者延时重复调度线程。</li>
</ul>
</li>
<li>3.GC相关：重要<ul>
<li>1.搜索算法：<ul>
<li>1.引用计数</li>
<li>2.图搜索，可达性分析</li>
</ul>
</li>
<li>2.回收算法：<ul>
<li>1.标记清除复制：用于青年代</li>
<li>2.标记整理：用于老年代</li>
</ul>
</li>
<li>3.堆分区：<ul>
<li>1.青年区eden 80%、survivor1 10%、survivor2 10%</li>
<li>2.老年区</li>
</ul>
</li>
<li>4.虚拟机栈分区：<ul>
<li>1.局部变量表</li>
<li>2.操作数栈</li>
<li>3.动态链接</li>
<li>4.方法返回地址</li>
</ul>
</li>
<li>5.GC Roots:<ul>
<li>1.虚拟机栈(栈桢中的本地变量表)中的引用的对象</li>
<li>2.方法区中的类静态属性引用的对象</li>
<li>3.方法区中的常量引用的对象</li>
<li>4.本地方法栈中JNI的引用的对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="28-数据库性能优化：索引和事务，需要找本专门的书大概了解一下"><a href="#28-数据库性能优化：索引和事务，需要找本专门的书大概了解一下" class="headerlink" title="28.数据库性能优化：索引和事务，需要找本专门的书大概了解一下"></a>28.数据库性能优化：索引和事务，需要找本专门的书大概了解一下</h2><h2 id="29-13-APK打包流程和其内容"><a href="#29-13-APK打包流程和其内容" class="headerlink" title="29.13.APK打包流程和其内容"></a>29.13.APK打包流程和其内容</h2><ul>
<li>1.流程<ul>
<li>1.aapt生成R文件<ul>
<li>2.aidl生成java文件</li>
<li>3.将全部java文件编译成class文件</li>
<li>4.将全部class文件和第三方包合并成dex文件</li>
<li>5.将资源、so文件、dex文件整合成apk</li>
<li>6.apk签名</li>
<li>7.apk字节对齐</li>
</ul>
</li>
</ul>
</li>
<li>2.内容：so、dex、asset、资源文件</li>
</ul>
<h2 id><a href="#" class="headerlink" title></a></h2><h2 id="31-java类加载过程："><a href="#31-java类加载过程：" class="headerlink" title="31.java类加载过程："></a>31.java类加载过程：</h2><ul>
<li>1.加载时机：创建实例、访问静态变量或方法、反射、加载子类之前</li>
<li>2.验证：验证文件格式、元数据、字节码、符号引用的正确性</li>
<li>3.加载：根据全类名获取文件字节流、将字节流转化为静态储存结构放入方法区、生成class对象</li>
<li>4.准备：在堆上为静态变量划分内存</li>
<li>5.解析：将常量池中的符号引用转换为直接引用</li>
<li>6.初始化：初始化静态变量</li>
<li>7.书籍推荐：<strong>深入理解java虚拟机</strong>，博客推荐：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/bc6d1770d92c">Java&#x2F;Android阿里面试JVM部分理解</a></li>
</ul>
<h2 id="32-retrofit的了解"><a href="#32-retrofit的了解" class="headerlink" title="32.retrofit的了解"></a>32.retrofit的了解</h2><ul>
<li>1.动态代理创建一个接口的代理类</li>
<li>2.通过反射解析每个接口的注解、入参构造http请求</li>
<li>3.获取到返回的http请求，使用Adapter解析成需要的返回值。</li>
</ul>
<h2 id="33-bundle的数据结构，如何存储"><a href="#33-bundle的数据结构，如何存储" class="headerlink" title="33.bundle的数据结构，如何存储"></a>33.bundle的数据结构，如何存储</h2><ul>
<li>1.键值对储存</li>
<li>2.传递的数据可以是boolean、byte、int、long、float、double、string等基本类型或它们对应的数组，也可以是对象或对象数组。</li>
<li>3.当Bundle传递的是对象或对象数组时，必须实现Serializable 或Parcelable接口</li>
</ul>
<h2 id="34-listview内点击buttom并移动的事件流完整拦截过程："><a href="#34-listview内点击buttom并移动的事件流完整拦截过程：" class="headerlink" title="34.listview内点击buttom并移动的事件流完整拦截过程："></a>34.listview内点击buttom并移动的事件流完整拦截过程：</h2><ul>
<li>1.点下按钮的时候：<ul>
<li>1.产生了一个down事件，activity–&gt;phoneWindow–&gt;ViewGroup–&gt;ListView–&gt;botton,中间如果有重写了拦截方法，则事件被该view拦截可能消耗。</li>
<li>2.没拦截，事件到达了button，这个过程中建立了一条事件传递的view链表</li>
<li>3.到button的dispatch方法–&gt;onTouch–&gt;view是否可用–&gt;Touch代理</li>
</ul>
</li>
<li>2.移动点击按钮的时候:<ul>
<li>1.产生move事件，listView中会对move事件做拦截</li>
<li>2.此时listView会将该滑动事件消费掉</li>
<li>3.后续的滑动事件都会被listView消费掉</li>
</ul>
</li>
<li>3.手指抬起来时候：前面建立了一个view链表，listView的父view在获取事件的时候，会直接取链表中的listView让其进行事件消耗。</li>
</ul>
<h2 id="35-service的意义：不需要界面，在后台执行的程序"><a href="#35-service的意义：不需要界面，在后台执行的程序" class="headerlink" title="35.service的意义：不需要界面，在后台执行的程序"></a>35.service的意义：不需要界面，在后台执行的程序</h2><h2 id="36-android的IPC通信方式，线程（进程间）通信机制有哪些"><a href="#36-android的IPC通信方式，线程（进程间）通信机制有哪些" class="headerlink" title="36.android的IPC通信方式，线程（进程间）通信机制有哪些"></a>36.android的IPC通信方式，线程（进程间）通信机制有哪些</h2><ul>
<li>1.ipc通信方式：binder、contentprovider、socket</li>
<li>2.操作系统进程通讯方式：共享内存、socket、管道</li>
</ul>
<h2 id="37-操作系统进程和线程的区别"><a href="#37-操作系统进程和线程的区别" class="headerlink" title="37.操作系统进程和线程的区别"></a>37.操作系统进程和线程的区别</h2><ul>
<li>1.简而言之,一个程序至少有一个进程,一个进程至少有一个线程.</li>
<li>2.线程的划分尺度小于进程，使得多线程程序的并发性高。</li>
<li>3.另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</li>
<li>4.多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配</li>
</ul>
<h2 id="38-HashMap的实现过程：Capacity就是buckets的数目，Load-factor就是buckets填满程度的最大比例。如果对迭代性能要求很高的话不要把capacity设置过大，也不要把load-factor设置过小。"><a href="#38-HashMap的实现过程：Capacity就是buckets的数目，Load-factor就是buckets填满程度的最大比例。如果对迭代性能要求很高的话不要把capacity设置过大，也不要把load-factor设置过小。" class="headerlink" title="38.HashMap的实现过程：Capacity就是buckets的数目，Load factor就是buckets填满程度的最大比例。如果对迭代性能要求很高的话不要把capacity设置过大，也不要把load factor设置过小。"></a>38.HashMap的实现过程：Capacity就是buckets的数目，Load factor就是buckets填满程度的最大比例。如果对迭代性能要求很高的话不要把capacity设置过大，也不要把load factor设置过小。</h2><ul>
<li>1.简单来说HashMap就是一个会自动扩容的<strong>数组链表</strong></li>
<li>2.put过程<ul>
<li>1.对key的hashCode()做hash，然后再计算index;</li>
<li>2.如果没碰撞直接放到bucket里；</li>
<li>3.如果碰撞了，以链表的形式存在buckets后；</li>
<li>4.如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树；</li>
<li>5.如果节点已经存在就替换old value(保证key的唯一性)</li>
<li>6.如果bucket满了(超过load factor*current capacity)，就要resize。</li>
</ul>
</li>
<li>3.resize：当put时，如果发现目前的bucket占用程度已经超过了Load Factor所希望的比例，那么就会发生resize。在resize的过程，简单的说就是把bucket扩充为2倍，之后重新计算index，把节点再放到新的bucket中</li>
<li>4.get过程<ul>
<li>1.根据key的hash算出数组下表</li>
<li>2.使用equals遍历链表进行比较</li>
</ul>
</li>
</ul>
<h2 id="39-mvc、mvp、mvvm："><a href="#39-mvc、mvp、mvvm：" class="headerlink" title="39.mvc、mvp、mvvm："></a>39.mvc、mvp、mvvm：</h2><ul>
<li>1.mvc:数据、View、Activity，View将操作反馈给Activity，Activitiy去获取数据，数据通过观察者模式刷新给View。循环依赖<ul>
<li>1.Activity重，很难单元测试</li>
<li>2.View和Model耦合严重</li>
</ul>
</li>
<li>2.mvp:数据、View、Presenter，View将操作给Presenter，Presenter去获取数据，数据获取好了返回给Presenter，Presenter去刷新View。PV，PM双向依赖<ul>
<li>1.接口爆炸</li>
<li>2.Presenter很重</li>
</ul>
</li>
<li>3.mvvm:数据、View、ViewModel，View将操作给ViewModel，ViewModel去获取数据，数据和界面绑定了，数据更新界面更新。<ul>
<li>1.viewModel的业务逻辑可以单独拿来测试</li>
<li>2.一个view 对应一个 viewModel 业务逻辑可以分离，不会出现全能类</li>
<li>3.数据和界面绑定了，不用写垃圾代码，但是复用起来不舒服</li>
</ul>
</li>
</ul>
<h2 id="40-java的线程如何实现"><a href="#40-java的线程如何实现" class="headerlink" title="40.java的线程如何实现"></a>40.java的线程如何实现</h2><ul>
<li>1.Thread继承</li>
<li>2.Runnale</li>
<li>3.Future</li>
<li>4.线程池</li>
</ul>
<h2 id="41-ArrayList-如何删除重复的元素或者指定的元素；"><a href="#41-ArrayList-如何删除重复的元素或者指定的元素；" class="headerlink" title="41.ArrayList 如何删除重复的元素或者指定的元素；"></a>41.ArrayList 如何删除重复的元素或者指定的元素；</h2><ul>
<li>1.删除重复：Set</li>
<li>2.删除指定：迭代器</li>
</ul>
<h2 id="42-如何设计在-UDP-上层保证-UDP-的可靠性传输；"><a href="#42-如何设计在-UDP-上层保证-UDP-的可靠性传输；" class="headerlink" title="42.如何设计在 UDP 上层保证 UDP 的可靠性传输；"></a>42.如何设计在 UDP 上层保证 UDP 的可靠性传输；</h2><ul>
<li>1.简单来讲，要使用UDP来构建可靠的面向连接的数据传输，就要实现类似于TCP协议的超时重传，有序接受，应答确认，滑动窗口流量控制等机制,等于说要在传输层的上一层（或者直接在应用层）实现TCP协议的可靠数据传输机制。</li>
<li>2.比如使用UDP数据包+序列号，UDP数据包+时间戳等方法，在服务器端进行应答确认机制，这样就会保证不可靠的UDP协议进行可靠的数据传输。</li>
<li>3.基于udp的可靠传输协议有：RUDP、RTP、UDT</li>
</ul>
<h2 id="43-Java-中内部类为什么可以访问外部类"><a href="#43-Java-中内部类为什么可以访问外部类" class="headerlink" title="43.Java 中内部类为什么可以访问外部类"></a>43.Java 中内部类为什么可以访问外部类</h2><ul>
<li>1.因为内部类创建的时候，需要外部类的对象，在内部类对象创建的时候会把外部类的引用传递进去</li>
</ul>
<h2 id="44-设计移动端的联系人存储与查询的功能，要求快速搜索联系人，可以用到哪些数据结构？数据库索引，平衡二叉树-B树、红黑树"><a href="#44-设计移动端的联系人存储与查询的功能，要求快速搜索联系人，可以用到哪些数据结构？数据库索引，平衡二叉树-B树、红黑树" class="headerlink" title="44.设计移动端的联系人存储与查询的功能，要求快速搜索联系人，可以用到哪些数据结构？数据库索引，平衡二叉树(B树、红黑树)"></a>44.设计移动端的联系人存储与查询的功能，要求快速搜索联系人，可以用到哪些数据结构？数据库索引，平衡二叉树(B树、红黑树)</h2><h2 id="45-红黑树特点"><a href="#45-红黑树特点" class="headerlink" title="45.红黑树特点"></a>45.红黑树特点</h2><ul>
<li>1.root节点和叶子节点是黑色</li>
<li>2.红色节点后必须为黑色节点</li>
<li>3.从root到叶子每条路径的黑节点数量相同</li>
</ul>
<h2 id="46-linux异步和同步i-o"><a href="#46-linux异步和同步i-o" class="headerlink" title="46.linux异步和同步i&#x2F;o:"></a>46.linux异步和同步i&#x2F;o:</h2><ul>
<li>1.同步：对于client，client一直等待，但是client不挂起：主线程调用</li>
<li>2.异步：对于client，client发起请求，service好了再回调client：其他线程调用，调用完成之后进行回调</li>
<li>3.阻塞：对于service，在准备io的时候会将service端挂起，直至准备完成然后唤醒service：bio</li>
<li>3.非阻塞：对于service，在准备io的时候不会将service端挂起，而是service一直去轮询判断io是否准备完成，准备完成了就进行操作：nio、linux的select、poll、epoll</li>
<li>4.多路复用io：非阻塞io的一种优化，java nio，用一个线程去轮询多个 io端口是否可用，如果一个可用就通知对应的io请求，这使用一个线程轮询可以大大增强性能。<ul>
<li>1.我可以采用 多线程+ 阻塞IO 达到类似的效果，但是由于在多线程 + 阻塞IO 中，每个socket对应一个线程，这样会造成很大的资源占用。</li>
<li>2.而在多路复用IO中，轮询每个socket状态是内核在进行的，这个效率要比用户线程要高的多。</li>
</ul>
</li>
<li>5.异步io：aio，用户线程完全不感知io的进行，所有操作都交给内核，io完成之后内核通知用户线程。<ul>
<li>1.这种io才是异步的，2、3、4都是同步io，因为内核进行数据拷贝的过程都会让用户线程阻塞。</li>
<li>2.异步IO是需要操作系统的底层支持，也就是内核支持，Java 7中，提供了Asynchronous IO</li>
</ul>
</li>
</ul>
<h2 id="47-ConcurrentHashMap内部实现，HashTable的实现被废弃的原因"><a href="#47-ConcurrentHashMap内部实现，HashTable的实现被废弃的原因" class="headerlink" title="47.ConcurrentHashMap内部实现，HashTable的实现被废弃的原因:"></a>47.ConcurrentHashMap内部实现，HashTable的实现被废弃的原因:</h2><ul>
<li>1.HashTable容器在竞争激烈的并发环境下表现出效率低下的原因，是因为所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</li>
<li>2.ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。</li>
</ul>
<h2 id="48-HandlerThread是什么"><a href="#48-HandlerThread是什么" class="headerlink" title="48.HandlerThread是什么"></a>48.HandlerThread是什么</h2><ul>
<li>1.MessageQueue + Looper + Handler</li>
</ul>
<h2 id="49-IntentService是什么"><a href="#49-IntentService是什么" class="headerlink" title="49.IntentService是什么"></a>49.IntentService是什么</h2><ul>
<li>1.含有HandlerThread的Service，可以多次startService()来多次在子线程中进行 onHandlerIntent()的调用。</li>
</ul>
<h2 id="50-class和dex"><a href="#50-class和dex" class="headerlink" title="50.class和dex"></a>50.class和dex</h2><ul>
<li>1.dvm执行的是dex格式文件，jvm执行的是class文件，android程序编译完之后生产class文件。然后dex工具会把class文件处理成dex文件，然后把资源文件和.dex文件等打包成apk文件。</li>
<li>2.dvm是基于寄存器的虚拟机，而jvm执行是基于虚拟栈的虚拟机。寄存器存取速度比栈快的多，dvm可以根据硬件实现最大的优化，比较适合移动设备。</li>
<li>3.class文件存在很多的冗余信息，dex工具会去除冗余信息，并把所有的class文件整合到dex文件中。减少了I&#x2F;O操作，提高了类的查找速度</li>
</ul>
<h2 id="51-内存泄漏"><a href="#51-内存泄漏" class="headerlink" title="51.内存泄漏"></a>51.内存泄漏</h2><ul>
<li>1.其他线程持有一个Listener，Listener操作activity。那么在线程么有完毕的时候，activity关闭了，原本是要被回收的但是，不能被回收。</li>
<li>2.例如Handler导致的内存泄漏，Handler就相当于Listener。</li>
<li>3.在activity关闭的时候注意停止线程，或者将Listener的注册取消</li>
<li>3.使用弱引用，这样即使Listener持有了activity，在GC的时候还是会被回收</li>
<li>4.工具:LeakCanary</li>
</ul>
<h2 id="52-过度绘制、卡顿优化"><a href="#52-过度绘制、卡顿优化" class="headerlink" title="52.过度绘制、卡顿优化:"></a>52.过度绘制、卡顿优化:</h2><ul>
<li>1.过度绘制：<ul>
<li>1.移除Window默认的Background：getWidow.setBackgroundDrawable(null);</li>
<li>2.移除XML布局文件中非必需的Background</li>
<li>3.减少布局嵌套(扁平化的一个体现，减少View数的深度，也就减少了View树的遍历时间，渲染的时候，前后期的工作，总是按View树结点来)</li>
<li>4.在引入布局文件里面，最外层可以用merge替代LinearLayout,RelativeLayout，这样把子UI元素直接衔接在include位置</li>
<li>5.工具：HierarchyViewer 查看视图层级</li>
</ul>
</li>
<li>2.卡顿优化：16ms数据更新</li>
</ul>
<h2 id="53-apk瘦身"><a href="#53-apk瘦身" class="headerlink" title="53.apk瘦身:"></a>53.apk瘦身:</h2><ul>
<li>1.classes.dex：通过代码混淆，删掉不必要的jar包和代码实现该文件的优化</li>
<li>2.资源文件：通过Lint工具扫描代码中没有使用到的静态资源</li>
<li>3.图片资源：使用tinypng和webP，下面详细介绍图片资源优化的方案,矢量图</li>
<li>4.SO文件将不用的去掉，目前主流app一般只放一个arm的so包</li>
</ul>
<h2 id="54-ANR的形成，各个组件上出现ARN的时间限制是多少"><a href="#54-ANR的形成，各个组件上出现ARN的时间限制是多少" class="headerlink" title="54.ANR的形成，各个组件上出现ARN的时间限制是多少"></a>54.ANR的形成，各个组件上出现ARN的时间限制是多少</h2><ul>
<li>1.只要是主线程耗时的操作就会ARN  如io</li>
<li>2.broadcast超时时间为10秒  按键无响应的超时时间为5秒 前台service无响应的超时时间为20秒，后台service为200秒</li>
</ul>
<h2 id="55-Serializable和Parcelable-的区别"><a href="#55-Serializable和Parcelable-的区别" class="headerlink" title="55.Serializable和Parcelable 的区别"></a>55.Serializable和Parcelable 的区别</h2><ul>
<li>1.P 消耗内存小</li>
<li>2.网络传输用S  程序内使用P</li>
<li>3.S将数据持久化方便</li>
<li>4.S使用了反射 容易触发垃圾回收 比较慢</li>
</ul>
<h2 id="56-Sharedpreferences源码简述"><a href="#56-Sharedpreferences源码简述" class="headerlink" title="56.Sharedpreferences源码简述"></a>56.Sharedpreferences源码简述</h2><ul>
<li>1.储存于硬盘上的xml键值对，数据多了会有性能问题</li>
<li>2.ContextImpl记录着SharedPreferences的重要数据，文件路径和实例的键值对</li>
<li>3.在xml文件全部内加载到内存中之前，读取操作是阻塞的，在xml文件全部内加载到内存中之后，是直接读取内存中的数据</li>
<li>4.apply因为是异步的没有返回值, commit是同步的有返回值能知道修改是否提交成功</li>
<li>5.多并发的提交commit时，需等待正在处理的commit数据更新到磁盘文件后才会继续往下执行，从而降低效率; 而apply只是原子更新到内存，后调用apply函数会直接覆盖前面内存数据，从一定程度上提高很多效率。 3.edit()每次都是创建新的EditorImpl对象.</li>
<li>6.博客推荐：**<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/102f25cf64e3">全面剖析SharedPreferences</a>**</li>
</ul>
<h2 id="57-操作系统如何管理内存的："><a href="#57-操作系统如何管理内存的：" class="headerlink" title="57.操作系统如何管理内存的："></a>57.操作系统如何管理内存的：</h2><ul>
<li>1.使用寄存器进行将进程地址和物理内存进行映射</li>
<li>2.虚拟内存进行内存映射到硬盘上增大内存</li>
<li>3.虚拟内存是进行内存分页管理</li>
<li>4.页表实现分页，就是 页+地址偏移。</li>
<li>5.如果程序的内存在硬盘上，那么就需要用页置换算法来将其调入内存中：先进先出、最近未使用最少等等</li>
<li>6.博客推荐：**<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/aecff59430fa">现代操作系统部分章节笔记</a>**</li>
</ul>
<h2 id="58-浏览器输入地址到返回结果发生了什么"><a href="#58-浏览器输入地址到返回结果发生了什么" class="headerlink" title="58.浏览器输入地址到返回结果发生了什么"></a>58.浏览器输入地址到返回结果发生了什么</h2><ul>
<li>1.DNS解析</li>
<li>2.TCP连接</li>
<li>3.发送HTTP请求</li>
<li>4.服务器处理请求并返回HTTP报文</li>
<li>5.浏览器解析渲染页面</li>
<li>6.连接结束</li>
</ul>
<h2 id="59-java泛型类型擦除发生在什么时候，通配符有什么需要注意的。"><a href="#59-java泛型类型擦除发生在什么时候，通配符有什么需要注意的。" class="headerlink" title="59.java泛型类型擦除发生在什么时候，通配符有什么需要注意的。"></a>59.java泛型类型擦除发生在什么时候，通配符有什么需要注意的。</h2><ul>
<li>1.发生在编译的时候</li>
<li>2.PECS，extends善于提供精确的对象 A是B的子集，Super善于插入精确的对象 A是B的超集</li>
<li>3.博客推荐：**<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4e4751b5bbbb">Effective Java笔记（不含反序列化、并发、注解和枚举）</a><strong>、</strong><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6006a3284f55">android阿里面试java基础锦集</a>**</li>
</ul>
<h2 id="60-activity的生命周期"><a href="#60-activity的生命周期" class="headerlink" title="60.activity的生命周期"></a>60.activity的生命周期</h2><ul>
<li>1.a启动b，后退键再到a的生命周期流程：a.create–&gt;a.start–&gt;a.resume–&gt;a.pause–&gt;b.create–&gt;b.start–&gt;b.resume–&gt;b界面绘制–&gt;a.stop–&gt;b.pause–&gt;b.stop–&gt;b.destroy–&gt;a.restart–&gt;a.start–&gt;a.resume</li>
<li>2.意外销毁会调用saveInstance，重新恢复的时候回调用restoreInstance。储存数据的时候使用了委托机制，从activity–&gt;window–&gt;viewGroup–&gt;view 会递归调用save来保持本view的数据，restore则是递归恢复本view数据。我们可以在里面做一些自己需要的数据操作。</li>
</ul>
<h2 id="61-面试常考的算法"><a href="#61-面试常考的算法" class="headerlink" title="61.面试常考的算法"></a>61.面试常考的算法</h2><ul>
<li>1.快排、堆排序为首的各种排序算法</li>
<li>2.链表的各种操作：判断成环、判断相交、合并链表、倒数K个节点、寻找成环节点</li>
<li>3.二叉树、红黑树、B树定义以及时间复杂度计算方式</li>
<li>4.动态规划、贪心算法、简单的图论</li>
<li>5.推荐书籍：<strong>算法导论</strong>，将图论之前的例子写一遍</li>
</ul>
<h2 id="62-Launcher进程启动另外一个进程的过程：启动一个app"><a href="#62-Launcher进程启动另外一个进程的过程：启动一个app" class="headerlink" title="62.Launcher进程启动另外一个进程的过程：启动一个app"></a>62.Launcher进程启动另外一个进程的过程：<a target="_blank" rel="noopener" href="http://www.cnblogs.com/tiantianbyconan/p/5017056.html">启动一个app</a></h2><h2 id="63-开源框架源码"><a href="#63-开源框架源码" class="headerlink" title="63.开源框架源码"></a>63.开源框架源码</h2><ul>
<li>1.Fresco<ul>
<li>1.mvc框架：<ul>
<li>1.Controller控制数据显示在Hierarchy中的Drawable的显隐</li>
<li>2.ImagePipeline在Controller中负责进行数据获取，返回的数据是CloseableImage</li>
<li>3.Drawee把除了初始化之外的操作全部交给Holder去做，Holder持有Controller和Hierarchy</li>
</ul>
</li>
<li>2.Drawable层次以及绘制：<ul>
<li>1.如果要绘制一次Drawable就调用invalidateSelf()来触发onDraw()</li>
<li>2.Drawable分为：容器类(保存一些Drawable)、自我绘制类(进度条)、图形变换类(scale、rotate、矩阵变换)、动画类(内部不断刷新，进行webp和gif的帧绘制)</li>
<li>3.ImagePipeline返回的CloseableImage是由一个个DrawableFactory解析成Drawable的</li>
<li>4.webp和gif动画是由jni代码解析的，然后其他静态图片是根据不同的android平台使用BitmapFactory来解析的</li>
</ul>
</li>
<li>3.职责链模式：producer不做操作标n，表示只是提供一个consumer。获取图片–》解码图片缓存Producer–》后台线程Producer–》client图片处理producer(n)–》解码producer(n)–》旋转或剪裁producer(n)–》编码图片内存缓存producer–》读硬盘缓存producer–》写硬盘缓存producer(n)–》网络producer提供CloseableImage《–解码图片缓存consumer《–client图片处理consumer《–解码consumer《–旋转或剪裁consumer《–编码图片内存缓存consumer《–写硬盘缓存consumer《–图片数据</li>
<li>4.内存缓存：<ul>
<li>1.一个CountingLruMap保存已经没有被引用的缓存条目，一个CountingLruMap保存所有的条目包括没有引用的条目。每当缓存策略改变和一定时间缓存配置的更新的时候，就会将 待销毁条目Map中的条目一个个移除，直到缓存大小符合配置。</li>
<li>2.这里的引用计数是用Fresco组件实现的引用计数器。</li>
<li>3.缓存有一个代理类，用来追踪缓存的存取。</li>
<li>4.CountingLruMap是使用LinkedHashMap来储存数据的。</li>
</ul>
</li>
<li>5.硬盘缓存：<ul>
<li>1.DefaultDiskStorage使用Lru策略。</li>
<li>2.为了不让所有的文件集中在一个文件中，创建很多命名不同的文件夹，然后使用hash算法把缓存文件分散</li>
<li>3.DiskStorageCache封装了DefaultDiskStorage，不仅进行缓存存取追踪，并且其在内存里面维持着一个 &lt;key,value&gt; 的键值对，因为文件修改频繁，所有只是定时刷新，因此如果在内存中找不到，还要去硬盘中找一次。</li>
<li>4.删除硬盘的缓存只出现在硬盘数据大小超限的时候，此时同时也会删除缓存中的key，所以不会出现内存中有key，但是硬盘上没有的情况。</li>
<li>5.在插入硬盘数据的时候，采用的是插入器的形式。返回一个Inserter，在Inserter.writeData()中传入一个CallBack(里面封装了客户端插入数据的逻辑和文件引用)，让内部实现调用CallBack的逻辑来插入文件数据，前面写的文件后缀是.temp,只有调用commit()之后才会修改后缀，让文件对客户端可见。</li>
<li>6.使用了java提供的FileTreeVisitor来遍历文件</li>
</ul>
</li>
<li>6.对象池：<ul>
<li>1.使用数组来存储一个桶，桶内部是一个Queue。数组下标是数据申请内存的byte大小，桶内部的Queue存的是内存块的。所以数组使用的是稀疏数组</li>
<li>2.申请内存的方式有两种 1.java堆上开辟的内存 2.ashme 的本地内存中开辟的内存</li>
</ul>
</li>
<li>7.设计模式：Builder、职责链、观察者、代理、组合、享元、适配器、装饰者、策略、生产者消费者、提供者</li>
<li>8.自定义计数引用：类似c++智能指针<ul>
<li>1.使用一个静态IdentityHashMap &lt;储存需要被计数引用的对象,其被引用的次数&gt;</li>
<li>2.用SharedReference分装需要被计数引用的对象，提供一个销毁资源的销毁器，提供一个静态工厂方法来复制自己，复制一个引用计数加一。提供一个方法销毁自己，表示自己需要变成无人引用的对象了，此时引用计数减一。</li>
<li>3.引用计数归零，销毁器将销毁资源，如bitmap的recycle或者是jni内存调用jni方法归还内存。</li>
</ul>
</li>
<li>9.博客推荐：**<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/dbe01f9994d0">Android Fresco源码文档翻译</a><strong>、</strong><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ab2124764438">从零开始撸一个Fresco之硬盘缓存</a><strong>、</strong><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/36663090b140">从零开始撸一个Fresco之gif和Webp动画</a><strong>、</strong><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ba0de15ce667">从零开始撸一个Fresco之内存缓存</a><strong>、</strong><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2dff47ae7666">从零开始撸一个Fresco之总结</a>**</li>
</ul>
</li>
<li>2.oKhttp：<ul>
<li>1.同步和异步：<ul>
<li>1.异步使用了Dispatcher来将存储在 Deque 中的请求分派给线程池中各个线程执行。</li>
<li>2.当任务执行完成后，无论是否有异常，finally代码段总会被执行，也就是会调用Dispatcher的finished函数，它将正在运行的任务Call从队列runningAsyncCalls中移除后，主动的把缓存队列向前走了一步。</li>
</ul>
</li>
<li>2.连接池：<ul>
<li>1.一个Connection封装了一个socket，ConnectionPool中储存s着所有的Connection，StreamAllocation是引用计数的一个单位</li>
<li>2.当一个请求获取一个Connection的时候要传入一个StreamAllocation，Connection中存着一个弱引用的StreamAllocation列表，每当上层应用引用一次Connection，StreamAllocation就会加一个。反之如果上层应用不使用了，就会删除一个。</li>
<li>3.ConnectionPool中会有一个后台任务定时清理StreamAllocation列表为空的Connection。5分钟时间，维持5个socket</li>
</ul>
</li>
<li>3.选择路线与建立连接<ul>
<li>1.选择路线有两种方式：<ul>
<li>1.无代理，那么在本地使用DNS查找到ip，注意结果是数组，即一个域名有多个IP，这就是自动重连的来源</li>
<li>2.有代理HTTP：设置socket的ip为代理地址的ip，设置socket的端口为代理地址的端口</li>
<li>3.代理好处：HTTP代理会帮你在远程服务器进行DNS查询，可以减少DNS劫持。</li>
</ul>
</li>
<li>2.建立连接<ul>
<li>1.连接池中已经存在连接，就从中取出(get)RealConnection，如果没有命中就进入下一步</li>
<li>2.根据选择的路线(Route)，调用Platform.get().connectSocket选择当前平台Runtime下最好的socket库进行握手</li>
<li>3.将建立成功的RealConnection放入(put)连接池缓存</li>
<li>4.如果存在TLS，就根据SSL版本与证书进行安全握手</li>
<li>5.构造HttpStream并维护刚刚的socket连接，管道建立完成</li>
</ul>
</li>
</ul>
</li>
<li>4.职责链模式：缓存、重试、建立连接等功能存在于拦截器中网络请求相关，主要是网络请求优化。网络请求的时候遇到的问题</li>
<li>5.博客推荐：**<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/60e5ebf0096a">Android数据层架构的实现 上篇</a><strong>、</strong><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5def7b42d223">Android数据层架构的实现 下篇</a>**</li>
</ul>
</li>
<li>3.okio<ul>
<li>1.简介；<ul>
<li>1.sink：自己–》别人</li>
<li>2.source：别人–》自己</li>
<li>3.BufferSink：有缓存区域的sink</li>
<li>4.BufferSource：有缓存区域的source</li>
<li>5.Buffer：实现了3、4的缓存区域，内部有Segment的双向链表，在在转移数据的时候，只需要将指针转移指向就行</li>
</ul>
</li>
<li>2.比java io的好处：<ul>
<li>1.减少内存申请和数据拷贝</li>
<li>2.类少，功能齐全，开发效率高</li>
</ul>
</li>
<li>3.内部实现：<ul>
<li>1.Buffer的Segment双向链表，减少数据拷贝</li>
<li>2.Segment的内部byte数组的共享，减少数据拷贝</li>
<li>3.SegmentPool的共享和回收Segment</li>
<li>4.sink和source中被实际操作的其实是Buffer，Buffer可以充当sink和source</li>
<li>5.最终okio只是对java io的封装，所有操作都是基于java io 的</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>写在最后:能看到这里的人,我挺佩服你的.这篇文章是我在<strong>头条</strong>面试之前整理的,最后**80%**的题目都命中了,所以祝你好运.</p>
</blockquote>
<p>不贩卖焦虑，也不标题党。分享一些这个世界上有意思的事情。题材包括且不限于：科幻、科学、科技、互联网、程序员、计算机编程。下面是我的微信公众号：<strong>世界上有意思的事</strong>，干货多多等你来看。</p>
<p>作者：何时夕<br>链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/cf5092fa2694">https://www.jianshu.com/p/cf5092fa2694</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h1 id="百度面试题"><a href="#百度面试题" class="headerlink" title="百度面试题"></a><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f0d2ed1254a9">百度面试题</a></h1><p>电话面试</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 安卓View绘制流程<br><span class="hljs-bullet">2.</span> 事件分发机制<br><span class="hljs-bullet">3.</span> JAVA基础思想<br><span class="hljs-bullet">4.</span> 多线程和安全问题<br><span class="hljs-bullet">5.</span> 安卓性能优化和兼容问题<br><span class="hljs-bullet">6.</span> 再问一下常规的组件相关问题<br></code></pre></td></tr></table></figure>

<p>现场笔试</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-number">1</span>  请描述安卓四大组建之间的关系，并说下安卓MVC的设计模式。<br><br><span class="hljs-number">2</span> 线程中sleep()和wait()有和却别，各有什么含义                   <br><br><span class="hljs-number">3</span>  <span class="hljs-keyword">abstract</span>和<span class="hljs-keyword">interface</span>的区别?<br><br><span class="hljs-number">4</span> array,arrayList, List ,三者有何区别？<br><br><span class="hljs-number">5</span> hashtable和hashmap的区别,并简述Hashmap的实现原理<br><br><span class="hljs-number">6</span> StringBuilder和],String ,subString方法的细微差别<br><br><span class="hljs-number">7</span> 请写出四种以上你知道的设计模式，并介绍下实现原理<br><br><span class="hljs-number">8</span> 安卓子线程是否能更新UI，如果能请说明具体细节。<br><br><span class="hljs-number">9</span> ANR产生的原因和解决步骤<br><br><span class="hljs-number">10</span> JavaGC机制的原理和内存泄露<br><br><span class="hljs-number">11</span>  安卓布局优化方案，          <br><br><span class="hljs-number">12</span>  请在<span class="hljs-number">100</span>个电话号码找出<span class="hljs-number">135</span>的电话号码   注意 不能用正则，（类似怎么最好的遍历LogGat日志）<br><span class="hljs-number">13</span>  Handler机制，请写出一种更新UI的方法和代码<br><br><span class="hljs-number">14</span>  请解释安卓为啥要加签名机制。<br><br><span class="hljs-number">15</span>   你觉得安卓开发最关键的技术在哪里？<br><span class="hljs-number">13</span>  Handler机制，请写出一种更新UI的方法和代码<br><br><span class="hljs-number">14</span>  请解释安卓为啥要加签名机制。<br><br><span class="hljs-number">15</span>   你觉得安卓开发最关键的技术在哪里？<br></code></pre></td></tr></table></figure>

<p>一轮面试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs undefined">1  ANR 具体产生的类型有哪些，具体说下其产生的最大超时时间。<br><br>2  多线程多点下载的过程<br><br>3 http协议的理解和用法<br><br>4 安卓解决线程并发问题<br><br>5 你知道的数据结构有哪些，说下具体实现机制<br><br>6 十六进制数据怎么和十进制和二进制之间转换<br><br>7 谈下对Java OOP中多态的理解<br><br>8  activty和Fragmengt之间怎么通信，Fragmengt和Fragmengt怎么通信<br><br>9 怎么让自己的进程不被第三方应用杀掉，系统杀掉之后怎么能启动起来。<br>10 说下平时开发中比较注意的一些问题，<br><br>答 ：可以熟说下svn和git的细节，和代码规范问题，和一些安全信息的问题等<br><br>11 自定义view效率高于xml定义吗？说明理由。<br><br>13 广播注册一般有几种，各有什么优缺点<br><br>14 服务启动一般有几种，服务和activty之间怎么通信，服务和服务之间怎么通信<br>15 布局优化主要哪些？具体优化？<br><br>16 数据库的知识，包括本地数据库优化点。<br></code></pre></td></tr></table></figure>

<p>二轮面试</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-number">1</span> 安卓事件分发机制，请详细说下整个流程<br><br><span class="hljs-number">2</span> 安卓view绘制机制和加载过程，请详细说下整个流程<br><br><span class="hljs-number">3</span> activty的加载过程 请详细介绍下（不是生命周期切记）<br><br><span class="hljs-number">4</span> 安卓采用自动垃圾回收机制，请说下安卓内存管理的原理<br><br><span class="hljs-number">5</span>  说下安卓虚拟机和java虚拟机的原理和不同点 <br><br><span class="hljs-number">6</span> 多线程中的安全队列一般通过什么实现？线程池原理？（java）<br><br><span class="hljs-number">7</span> 安卓权限管理，为何在清单中注册权限，安卓APP就可以使用，反之不可以（操作系统）<br><br><span class="hljs-number">8</span>  socket短线重连怎么实现，心跳机制又是怎样实现，四次握手步骤有哪些（网络通讯原理）<br><br><span class="hljs-number">9</span> http中TCP和UDP有啥区别，说下HTTP请求的IP报文结构（计算机网络）<br><span class="hljs-number">10</span> 你知道的安全加密有哪些？   （如果你说了一个加密，面试官就会接着跟进提问，所以之前你必须要会，不会的话背也要背下来）（安全加密）<br><span class="hljs-number">11</span>  你知道的数据存储结构？堆栈和链表内部机制。（数据结构）<br><br><span class="hljs-number">12</span> 说下Linux进程和线程的区别。进程调度优先级，和cpu调度进程关系。（操作系统）<br><br><span class="hljs-number">13</span> 请你详细说下你知道的一种设计模式，并解释下java的高内聚和低耦合。<br><br><span class="hljs-number">14</span>  spring 的反射和代理，在安卓中应用场景（插件和ROM数据框架）<br><br><span class="hljs-number">15</span> JNI 调用过程中 混淆问题<br><br><span class="hljs-number">16</span> 看过安卓源码吗，请说出一个你看过的API或者组建内部原理。<br><br><span class="hljs-number">17</span> android <span class="hljs-number">5.0</span> <span class="hljs-number">6.0</span> 以及<span class="hljs-number">7.0</span>预测新特性<br><br><span class="hljs-number">18</span> hybrid混合开发，响应式编程等<br><br><span class="hljs-number">17</span>为啥离职呢  对待加班看法<br><br><span class="hljs-number">18</span> 你擅长什么，做了那些东西。<br></code></pre></td></tr></table></figure>

<h1 id="名企面试题"><a href="#名企面试题" class="headerlink" title="名企面试题"></a><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/735be5ece9e8">名企面试题</a></h1><h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/tree/master/android">Android</a></h2><h5 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h5><ul>
<li>[Android 源码中的设计模式(你需要知道的设计模式全在这里)](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android</a> 源码中的设计模式(你需要知道的设计模式全在这里).md)</li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/%E5%85%A8%E9%9D%A2%E4%BA%86%E8%A7%A3Activity.md">全面了解Activity</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Service%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.md">Service全面总结</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/IntentService%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%E5%92%8C%E5%AE%9E%E4%BE%8B%E4%BB%8B%E7%BB%8D.md">IntentService使用详解和实例介绍</a></li>
<li>[Fragment 全解析](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Fragment">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Fragment</a> 全解析.md)</li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/ContentProvider%E5%AE%9E%E4%BE%8B%E8%AF%A6%E8%A7%A3.md">ContentProvider实例详解</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/BroadcastReceiver%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93.md">BroadcastReceiver使用总结</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E6%9C%BA%E5%88%B6%E4%B9%8BAsycTask.md">Android异步任务机制之AsycTask</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%9B%BE%E8%A7%A3.md">Android启动过程图解</a></li>
<li>[Android 自定义View入门](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android</a> 自定义View入门.md)</li>
<li>[Android 自定义ViewGroup入门实践](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android</a> 自定义ViewGroup入门实践.md)</li>
<li>[Android 缓存机制](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android</a> 缓存机制.md)</li>
<li>[Android 数据存储五种方式使用与总结](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android</a> 数据存储五种方式使用与总结.md)</li>
<li>[Android 异步消息处理机制源码解析](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android</a> 异步消息处理机制（Handler 、 Looper 、MessageQueue）源码解析.md)</li>
<li>[Android View事件分发机制源码分析](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android</a> View事件分发机制源码分析.md)</li>
<li>[Android SQLite的使用入门](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android</a> SQLite的使用入门.md)</li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/AIDL%E7%9A%84%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5%E5%92%8C%E5%AE%9E%E4%BE%8B%E4%BB%8B%E7%BB%8D.md">AIDL的使用情况和实例介绍</a></li>
<li>[Android 名企面试题及答案整理（一）](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android</a> 名企面试题及答案整理（一）.md)</li>
</ul>
<h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><ul>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android5.0%E3%80%816.0%E3%80%817.0%E6%96%B0%E7%89%B9%E6%80%A7.md">Android5.0、6.0、7.0新特性</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android%E4%B8%AD%E5%BC%B1%E5%BC%95%E7%94%A8%E4%B8%8E%E8%BD%AF%E5%BC%95%E7%94%A8%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF.md">Android中弱引用与软引用的应用场景</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Android%E9%95%BF%E8%BF%9E%E6%8E%A5%EF%BC%8C%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6.md">Android长连接，怎么处理心跳机制</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Asset%E7%9B%AE%E5%BD%95%E4%B8%8Eres%E7%9B%AE%E5%BD%95%E7%9A%84%E5%8C%BA%E5%88%AB.md">Asset目录与res目录的区别</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Binder%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0.md">Binder机制原理和底层实现</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/Json%E4%BC%98%E5%8A%A3%E5%8A%BF.md">Json优劣势</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/ListView%E4%BC%98%E5%8C%96.md">ListView优化</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/android%E4%B8%AD%E5%9B%BE%E7%89%87%E7%BC%93%E5%AD%98.md">android中图片缓存</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/%E4%B8%A4%E7%B1%BB%E5%8A%A8%E7%94%BB.md">两类动画</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/%E4%BA%94%E5%A4%A7%E5%B8%83%E5%B1%80%E6%98%93%E6%B7%B7%E6%B7%86%E7%9F%A5%E8%AF%86.md">五大布局易混淆知识</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/%E4%BF%9D%E8%AF%81service%E4%B8%8D%E8%A2%AB%E6%9D%80%E6%AD%BB.md">保证service不被杀死</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/%E5%8A%A0%E9%80%9F%E5%90%AF%E5%8A%A8activity.md">加速启动activity</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/%E6%80%8E%E6%A0%B7%E9%80%80%E5%87%BA%E7%BB%88%E6%AD%A2App.md">怎样退出终止App</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/android/activity%E5%88%87%E6%8D%A2%E5%8A%A8%E7%94%BB.md">activity切换动画</a></li>
</ul>
<h5 id="外链"><a href="#外链" class="headerlink" title="外链"></a>外链</h5><ul>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://www.trinea.cn/android/layout-performance/">布局性能优化(include, viewstub, merge)</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://www.cnblogs.com/xiaoluo501395377/p/3444744.html">DOM、SAX、Pull解析XML</a></li>
</ul>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/tree/master/java">Java</a></h2><h5 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h5><ul>
<li>[ArrayList、LinkedList、Vector的区别](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> ArrayList、LinkedList、Vector的区别.md)</li>
<li>[Collection包结构，与Collections的区别](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> Collection包结构，与Collections的区别.md)</li>
<li>[Excption与Error包结构,OOM和SOF](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> Excption与Error包结构%2COOM和SOF.md)</li>
<li>[HashMap和HashTable的区别](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> HashMap和HashTable的区别.md)</li>
<li>[HashMap源码分析](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> HashMap源码分析.md)</li>
<li>[Hashcode的作用](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> Hashcode的作用.md)</li>
<li>[Map、Set、List、Queue、Stack的特点与用法](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> Map、Set、List、Queue、Stack的特点与用法.md)</li>
<li>[Object有哪些公用方法？](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> Object有哪些公用方法？.md)</li>
<li>[Override和Overload的使用规则和区别](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> Override和Overload的使用规则和区别.md)</li>
<li>[Switch能否用string做参数？](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> Switch能否用string做参数？.md)</li>
<li>[ThreadLocal的使用规则和源码分析](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> ThreadLocal的使用规则和源码分析.md)</li>
<li>[ThreadPool用法与示例](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> ThreadPool用法与示例.md)</li>
<li>[equals与&#x3D;&#x3D;的区别](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> equals与%3D%3D的区别.md)</li>
<li>[try catch finally，try里有return，finally还执行么？](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> try catch finally，try里有return，finally还执行么？.md)</li>
<li>[九种基本数据类型的大小，以及他们的封装类](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> 九种基本数据类型的大小，以及他们的封装类.md)</li>
<li>[从源码分析String、StringBuffer与StringBuilder区别和联系](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> 从源码分析String、StringBuffer与StringBuilder区别和联系.md)</li>
<li>[多线程下生产者消费者问题的五种同步方法实现](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> 多线程下生产者消费者问题的五种同步方法实现.md)</li>
<li>[实现多线程的两种方法](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> 实现多线程的两种方法.md)</li>
<li>[接口（Interface）与 抽象类 （Abstract）使用规则和区别](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> 接口（Interface）与 抽象类 （Abstract）使用规则和区别.md)</li>
<li>[方法锁、对象锁和类锁的意义和区别](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> 方法锁、对象锁和类锁的意义和区别.md)</li>
<li>[四种引用，强弱软虚，用到的场景](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> 的四种引用，强弱软虚，用到的场景.md)</li>
<li>[线程同步的方法：sychronized、lock、reentrantLock分析](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> 线程同步的方法：sychronized、lock、reentrantLock分析.md)</li>
<li>[集合框架的层次结构和使用规则梳理](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> 集合框架的层次结构和使用规则梳理.md)</li>
<li>[面向对象的三个特征与含义](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5BJava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[Java]</a> 面向对象的三个特征与含义.md)</li>
<li>[static的作用和意义](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5Bjava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[java]</a> static的作用和意义.md)</li>
<li>[多态实现的JVM调用过程](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/%5Bjava%5D">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/java/[java]</a> 多态实现的JVM调用过程.md)</li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/wait()%E5%92%8Csleep()%E7%9A%84%E5%8C%BA%E5%88%AB.md">wait()和sleep()的区别</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/git%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8.md">git命令使用</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/java/Java%E4%B8%8EC++%E5%AF%B9%E6%AF%94.md">Java与C++对比</a></li>
</ul>
<h5 id="外链-1"><a href="#外链-1" class="headerlink" title="外链"></a>外链</h5><ul>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://762626559-qq-com.iteye.com/blog/395402">java反射</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://blog.csdn.net/xiaanming/article/details/8703708/">java回调</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://www.weixueyuan.net/view/6321.html">Java泛型</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://www.cnblogs.com/langtianya/p/3757993.html">java 新特性</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://www.iteye.com/topic/834447">Java IO与NIO</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://www.xuebuyuan.com/780786.html">foreach与正常for循环效率对比</a></li>
</ul>
<h2 id="数据结构-https-link-jianshu-com-t-https-github-com-helen-x-AndroidInterview-tree-master-data-structure"><a href="#数据结构-https-link-jianshu-com-t-https-github-com-helen-x-AndroidInterview-tree-master-data-structure" class="headerlink" title="[数据结构](https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/tree/master/data structure)"></a>[数据结构](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/tree/master/data">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/tree/master/data</a> structure)</h2><h5 id="基础-2"><a href="#基础-2" class="headerlink" title="基础"></a>基础</h5><ul>
<li>[九大基础排序总结与对比(排序算法一网打尽)](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/data">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data</a> structure&#x2F;[数据结构] 九大基础排序总结与对比.md)</li>
<li>[AVL树和AVL旋转、哈夫曼树和哈夫曼编码](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/data">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data</a> structure&#x2F;[数据结构] AVL树和AVL旋转、哈夫曼树和哈夫曼编码.md)</li>
<li>[B(B-)树、B+树、B树](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/data">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data</a> structure&#x2F;[数据结构] B(B-)树、B%2B树、B树.md)</li>
<li>[Hash表、Hash函数及冲突解决](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/data">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data</a> structure&#x2F;[数据结构] Hash表、Hash函数及冲突解决.md)</li>
<li>[KMP的一个简单解释](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/data">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data</a> structure&#x2F;[数据结构] KMP的一个简单解释.md)</li>
<li>[二分查找与变种二分查找](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/data">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data</a> structure&#x2F;[数据结构] 二分查找与变种二分查找.md)</li>
<li>[二叉树前中后、层次遍历算法](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/data">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data</a> structure&#x2F;[数据结构] 二叉树前中后、层次遍历算法.md)</li>
<li>[图的BFS、DFS、prim、Dijkstra算法](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/data">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data</a> structure&#x2F;[数据结构] 图的BFS、DFS、prim、Dijkstra算法.md)</li>
<li>[字符串操作](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/data">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data</a> structure&#x2F;[数据结构] 字符串操作.md)</li>
<li>[数组与链表的优缺点和区别](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/data">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data</a> structure&#x2F;[数据结构] 数组与链表的优缺点和区别.md)</li>
<li>[红黑树](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/data">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data</a> structure&#x2F;[数据结构] 红黑树.md)</li>
<li>[队列和栈](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/data">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/data</a> structure&#x2F;[数据结构] 队列和栈.md)</li>
</ul>
<h5 id="外链-2"><a href="#外链-2" class="headerlink" title="外链"></a>外链</h5><ul>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://blog.csdn.net/zyq522376829/article/details/47686867">海量数据处理 </a></li>
</ul>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/tree/master/algorithm">算法</a></h2><h5 id="基础-3"><a href="#基础-3" class="headerlink" title="基础"></a>基础</h5><ul>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.md">二叉搜索树与双向链表</a></li>
<li>[二叉树中 和为某值 的所有路径](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD">https://link.jianshu.com?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/二叉树中</a> 和为某值 的所有路径.md)</li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F.md">二叉树的镜像</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE.md">二维数组中的查找</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0.md">二进制中1的个数</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91.md">从上往下打印二叉树</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8.md">从尾到头打印链表</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97.md">判断二叉搜索树的后序遍历序列</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E5%88%A4%E6%96%AD%E6%A0%88%E7%9A%84%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97.md">判断栈的弹出序列</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E5%88%A4%E6%96%AD%E6%A0%91B%E6%98%AF%E4%B8%8D%E6%98%AF%E6%A0%91A%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84.md">判断树B是不是树A的子结构</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88.md">包含min函数的栈</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.md">反转链表</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6.md">变态跳台阶</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8.md">合并两个排序链表</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6.md">复杂链表的复制</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%A9%BA%E6%A0%BC%E6%9B%BF%E6%8D%A2.md">字符串中空格替换</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%85%A8%E6%8E%92%E5%88%97.md">字符串的顺序全排列</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97.md">数组中出现次数超过一半的数字</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97.md">斐波那契数列</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97.md">旋转数组的最小数字</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9.md">浮点数的整数次方</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.md">用两个栈实现队列</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96.md">矩形覆盖</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2.md">调整数组顺序使奇数位于偶数前面</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E8%B7%B3%E5%8F%B0%E9%98%B6.md">跳台阶</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91.md">重建二叉树</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9.md">链表中倒数第k个结点</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/helen-x/AndroidInterview/blob/master/algorithm/swordForOffer/%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5.md">顺时针打印矩阵</a></li>
</ul>
<h5 id="外链-3"><a href="#外链-3" class="headerlink" title="外链"></a>外链</h5><ul>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741370.html">分治算法</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741374.html">动态规划</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741375.html">贪心算法</a></li>
<li><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741378.html">分支限界法</a></li>
</ul>
<p>作者：菜刀文<br>链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/735be5ece9e8">https://www.jianshu.com/p/735be5ece9e8</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h1 id="面试和必备的技能"><a href="#面试和必备的技能" class="headerlink" title="面试和必备的技能"></a>面试和必备的技能</h1><p>这里只简单列举一些东西，可能不是特别全，但是却特别适用，也不一定按照下面的流程，有可能是穿插的，也有可能都有，根据公司的规模以及面试官的心情而定（哈哈哈 ，你们就自求多福吧）。建议大家还是要将下面的东西全部掌握，没事写写代码，练练手，在项目中能用到的地方一定要用，有可能会遇到很多坑，一定要自己想办法填坑，之后回忆起这段经历，肯定可以敢理直气壮的跟别人讨论。如果你说的头头是道，那么对方会先输一层，然后在心里对你佩服。</p>
<ol>
<li><p>一般情况下第一轮都是基础面试，需要扎实的基础</p>
<ul>
<li>最常用的Android 基础知识</li>
<li>Java 基础知识</li>
<li>了解一些 常用东西的原理，例如：handler， thread 等</li>
<li>项目中的技术点</li>
</ul>
</li>
<li><p>第二轮的时候需要了解更深层次的东西</p>
<ul>
<li>Android 事件分发机制原理</li>
<li>Android 绘图机制原理</li>
<li>WindowManager 的相关知识</li>
<li>进程间传输方式</li>
<li>Java 内存管理机制</li>
<li>一些常用的 list,map 原理，以及子类之间的差别</li>
</ul>
</li>
<li><p>能进入第三轮基本没什么问题，但是要注意以下问题</p>
<ul>
<li><p>该轮一般是 老大或者部门负责人，问的问题一般都看 深度与广度</p>
</li>
<li><p>当问及薪水的时候，要说一个合适的，小公司随意，大公司一定要慎重，当心里没底的时候，可以告诉对方，让对方给一个合理的薪资。一般都是在原工资基础之上增长，听猎头说一般涨幅都在15%-30%，超 NB 的可以要30%及以上，如果感觉自己还不错的，挺厉害的，建议最高20%，一般人就定在15% 左右最靠谱。公司内部一般有一套机制，根据公司情况而定。</p>
</li>
<li><p>我们的面试原则就是拿到合理薪资，得到 offer</p>
</li>
<li><p>个人发展情况，这个问题很难回答，如果和公司方向不符合，极有可能和公司无缘。建议多试探性的问问公司缺少什么，你能否给予公司对应的东西。当然对于有自我追求的人，那可以放心大胆的提。我的方向就是架构师，哈哈哈，挺极端的，别学我哦。我感觉选择都是双向的，因此我知道自己需要的是什么。</p>
</li>
<li><p>你最擅长什么UI 还是其他什么？这个问题更不好回答。你要说你擅长 UI，是不是意味着你其他能力就不行？虽然我不知道面试官的用意，但是我能感觉到，这个问题不是那么好回答，我会回答说自己都行，来什么业务接什么需求。可能回答不太好，总之和公司的职位吻合就行，这样总不至于出错吧。</p>
</li>
</ul>
</li>
</ol>
<h2 id="Android-高级面试题及答案"><a href="#Android-高级面试题及答案" class="headerlink" title="Android 高级面试题及答案"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html">Android 高级面试题及答案</a></h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label0">1.如何对 Android 应用进行性能分析</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label1">2.什么情况下会导致内存泄露</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label2">3.如何避免 OOM 异常</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label3">4.Android 中如何捕获未捕获的异常</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label4">5.ANR 是什么？怎样避免和解决 ANR（重要）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label5">6.Android 线程间通信有哪几种方式</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label6">7.Devik 进程，linux 进程，线程的区别</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label7">8.描述一下 android 的系统架构</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label8">9.android 应用对内存是如何限制的?我们应该如何合理使用内存？</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label9">10. 简述 android 应用程序结构是哪些</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label10">11.请解释下 Android 程序运行时权限与文件系统权限的区别</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label11">12.Framework 工作方式及原理，Activity 是如何生成一个 view 的，机制是什么</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label12">13.多线程间通信和多进程之间通信有什么不同，分别怎么实现</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label13">14.Android 屏幕适配</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label14">15.什么是 AIDL 以及如何使用</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label15">16.Handler 机制</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label16">17.事件分发机制</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label17">18.子线程发消息到主线程进行更新 UI，除了 handler 和 AsyncTask，还有什么</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label18">19.子线程中能不能 new handler？为什么</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label19">20.Android 中的动画有哪几类，它们的特点和区别是什么</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label20">21.如何修改 Activity 进入和退出动画</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label21">22.SurfaceView &amp; View 的区别</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label22">23.开发中都使用过哪些框架、平台</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label23">24.使用过那些自定义View</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label24">25.自定义控件：绘制圆环的实现过程</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label25">26.自定义控件：摩天轮的实现过程</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label27">28.流式布局的实现过程</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deman/p/5860976.html#_label28">29.第三方登陆</a></li>
<li>[30.第三方支付](</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/inter/" class="print-no-link">#inter</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>interview-answer</div>
      <div>https://noteforme.github.io/2018/03/12/interview-answer/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Jon</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>March 12, 2018</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2018/03/28/RxJava01/" title="RxJava01">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">RxJava01</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2018/03/04/TextView/" title="TextView">
                        <span class="hidden-mobile">TextView</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
